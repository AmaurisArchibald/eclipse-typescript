/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved. 
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0  
 
THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE, 
MERCHANTABLITY OR NON-INFRINGEMENT. 
 
See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

// <auto-generated />
/// <reference path="types.ts" />
var ts;
(function (ts) {
    ts.Diagnostics = {
        Unterminated_string_literal: { code: 1002, category: 1 /* Error */, key: "Unterminated string literal." },
        Identifier_expected: { code: 1003, category: 1 /* Error */, key: "Identifier expected." },
        _0_expected: { code: 1005, category: 1 /* Error */, key: "'{0}' expected." },
        Trailing_comma_not_allowed: { code: 1009, category: 1 /* Error */, key: "Trailing comma not allowed." },
        Asterisk_Slash_expected: { code: 1010, category: 1 /* Error */, key: "'*/' expected." },
        Unexpected_token: { code: 1012, category: 1 /* Error */, key: "Unexpected token." },
        Catch_clause_parameter_cannot_have_a_type_annotation: { code: 1013, category: 1 /* Error */, key: "Catch clause parameter cannot have a type annotation." },
        A_rest_parameter_must_be_last_in_a_parameter_list: { code: 1014, category: 1 /* Error */, key: "A rest parameter must be last in a parameter list." },
        Parameter_cannot_have_question_mark_and_initializer: { code: 1015, category: 1 /* Error */, key: "Parameter cannot have question mark and initializer." },
        A_required_parameter_cannot_follow_an_optional_parameter: { code: 1016, category: 1 /* Error */, key: "A required parameter cannot follow an optional parameter." },
        An_index_signature_cannot_have_a_rest_parameter: { code: 1017, category: 1 /* Error */, key: "An index signature cannot have a rest parameter." },
        An_index_signature_parameter_cannot_have_an_accessibility_modifier: { code: 1018, category: 1 /* Error */, key: "An index signature parameter cannot have an accessibility modifier." },
        An_index_signature_parameter_cannot_have_a_question_mark: { code: 1019, category: 1 /* Error */, key: "An index signature parameter cannot have a question mark." },
        An_index_signature_parameter_cannot_have_an_initializer: { code: 1020, category: 1 /* Error */, key: "An index signature parameter cannot have an initializer." },
        An_index_signature_must_have_a_type_annotation: { code: 1021, category: 1 /* Error */, key: "An index signature must have a type annotation." },
        An_index_signature_parameter_must_have_a_type_annotation: { code: 1022, category: 1 /* Error */, key: "An index signature parameter must have a type annotation." },
        An_index_signature_parameter_type_must_be_string_or_number: { code: 1023, category: 1 /* Error */, key: "An index signature parameter type must be 'string' or 'number'." },
        A_class_or_interface_declaration_can_only_have_one_extends_clause: { code: 1024, category: 1 /* Error */, key: "A class or interface declaration can only have one 'extends' clause." },
        An_extends_clause_must_precede_an_implements_clause: { code: 1025, category: 1 /* Error */, key: "An 'extends' clause must precede an 'implements' clause." },
        A_class_can_only_extend_a_single_class: { code: 1026, category: 1 /* Error */, key: "A class can only extend a single class." },
        A_class_declaration_can_only_have_one_implements_clause: { code: 1027, category: 1 /* Error */, key: "A class declaration can only have one 'implements' clause." },
        Accessibility_modifier_already_seen: { code: 1028, category: 1 /* Error */, key: "Accessibility modifier already seen." },
        _0_modifier_must_precede_1_modifier: { code: 1029, category: 1 /* Error */, key: "'{0}' modifier must precede '{1}' modifier." },
        _0_modifier_already_seen: { code: 1030, category: 1 /* Error */, key: "'{0}' modifier already seen." },
        _0_modifier_cannot_appear_on_a_class_element: { code: 1031, category: 1 /* Error */, key: "'{0}' modifier cannot appear on a class element." },
        An_interface_declaration_cannot_have_an_implements_clause: { code: 1032, category: 1 /* Error */, key: "An interface declaration cannot have an 'implements' clause." },
        super_must_be_followed_by_an_argument_list_or_member_access: { code: 1034, category: 1 /* Error */, key: "'super' must be followed by an argument list or member access." },
        Only_ambient_modules_can_use_quoted_names: { code: 1035, category: 1 /* Error */, key: "Only ambient modules can use quoted names." },
        Statements_are_not_allowed_in_ambient_contexts: { code: 1036, category: 1 /* Error */, key: "Statements are not allowed in ambient contexts." },
        A_function_implementation_cannot_be_declared_in_an_ambient_context: { code: 1037, category: 1 /* Error */, key: "A function implementation cannot be declared in an ambient context." },
        A_declare_modifier_cannot_be_used_in_an_already_ambient_context: { code: 1038, category: 1 /* Error */, key: "A 'declare' modifier cannot be used in an already ambient context." },
        Initializers_are_not_allowed_in_ambient_contexts: { code: 1039, category: 1 /* Error */, key: "Initializers are not allowed in ambient contexts." },
        _0_modifier_cannot_appear_on_a_module_element: { code: 1044, category: 1 /* Error */, key: "'{0}' modifier cannot appear on a module element." },
        A_declare_modifier_cannot_be_used_with_an_interface_declaration: { code: 1045, category: 1 /* Error */, key: "A 'declare' modifier cannot be used with an interface declaration." },
        A_declare_modifier_is_required_for_a_top_level_declaration_in_a_d_ts_file: { code: 1046, category: 1 /* Error */, key: "A 'declare' modifier is required for a top level declaration in a .d.ts file." },
        A_rest_parameter_cannot_be_optional: { code: 1047, category: 1 /* Error */, key: "A rest parameter cannot be optional." },
        A_rest_parameter_cannot_have_an_initializer: { code: 1048, category: 1 /* Error */, key: "A rest parameter cannot have an initializer." },
        A_set_accessor_must_have_exactly_one_parameter: { code: 1049, category: 1 /* Error */, key: "A 'set' accessor must have exactly one parameter." },
        A_set_accessor_cannot_have_an_optional_parameter: { code: 1051, category: 1 /* Error */, key: "A 'set' accessor cannot have an optional parameter." },
        A_set_accessor_parameter_cannot_have_an_initializer: { code: 1052, category: 1 /* Error */, key: "A 'set' accessor parameter cannot have an initializer." },
        A_set_accessor_cannot_have_rest_parameter: { code: 1053, category: 1 /* Error */, key: "A 'set' accessor cannot have rest parameter." },
        A_get_accessor_cannot_have_parameters: { code: 1054, category: 1 /* Error */, key: "A 'get' accessor cannot have parameters." },
        Accessors_are_only_available_when_targeting_ECMAScript_5_and_higher: { code: 1056, category: 1 /* Error */, key: "Accessors are only available when targeting ECMAScript 5 and higher." },
        Enum_member_must_have_initializer: { code: 1061, category: 1 /* Error */, key: "Enum member must have initializer." },
        An_export_assignment_cannot_be_used_in_an_internal_module: { code: 1063, category: 1 /* Error */, key: "An export assignment cannot be used in an internal module." },
        Ambient_enum_elements_can_only_have_integer_literal_initializers: { code: 1066, category: 1 /* Error */, key: "Ambient enum elements can only have integer literal initializers." },
        Unexpected_token_A_constructor_method_accessor_or_property_was_expected: { code: 1068, category: 1 /* Error */, key: "Unexpected token. A constructor, method, accessor, or property was expected." },
        A_declare_modifier_cannot_be_used_with_an_import_declaration: { code: 1079, category: 1 /* Error */, key: "A 'declare' modifier cannot be used with an import declaration." },
        Invalid_reference_directive_syntax: { code: 1084, category: 1 /* Error */, key: "Invalid 'reference' directive syntax." },
        Octal_literals_are_not_available_when_targeting_ECMAScript_5_and_higher: { code: 1085, category: 1 /* Error */, key: "Octal literals are not available when targeting ECMAScript 5 and higher." },
        An_accessor_cannot_be_declared_in_an_ambient_context: { code: 1086, category: 1 /* Error */, key: "An accessor cannot be declared in an ambient context." },
        _0_modifier_cannot_appear_on_a_constructor_declaration: { code: 1089, category: 1 /* Error */, key: "'{0}' modifier cannot appear on a constructor declaration." },
        _0_modifier_cannot_appear_on_a_parameter: { code: 1090, category: 1 /* Error */, key: "'{0}' modifier cannot appear on a parameter." },
        Only_a_single_variable_declaration_is_allowed_in_a_for_in_statement: { code: 1091, category: 1 /* Error */, key: "Only a single variable declaration is allowed in a 'for...in' statement." },
        Type_parameters_cannot_appear_on_a_constructor_declaration: { code: 1092, category: 1 /* Error */, key: "Type parameters cannot appear on a constructor declaration." },
        Type_annotation_cannot_appear_on_a_constructor_declaration: { code: 1093, category: 1 /* Error */, key: "Type annotation cannot appear on a constructor declaration." },
        An_accessor_cannot_have_type_parameters: { code: 1094, category: 1 /* Error */, key: "An accessor cannot have type parameters." },
        A_set_accessor_cannot_have_a_return_type_annotation: { code: 1095, category: 1 /* Error */, key: "A 'set' accessor cannot have a return type annotation." },
        An_index_signature_must_have_exactly_one_parameter: { code: 1096, category: 1 /* Error */, key: "An index signature must have exactly one parameter." },
        _0_list_cannot_be_empty: { code: 1097, category: 1 /* Error */, key: "'{0}' list cannot be empty." },
        Type_parameter_list_cannot_be_empty: { code: 1098, category: 1 /* Error */, key: "Type parameter list cannot be empty." },
        Type_argument_list_cannot_be_empty: { code: 1099, category: 1 /* Error */, key: "Type argument list cannot be empty." },
        Invalid_use_of_0_in_strict_mode: { code: 1100, category: 1 /* Error */, key: "Invalid use of '{0}' in strict mode." },
        with_statements_are_not_allowed_in_strict_mode: { code: 1101, category: 1 /* Error */, key: "'with' statements are not allowed in strict mode." },
        delete_cannot_be_called_on_an_identifier_in_strict_mode: { code: 1102, category: 1 /* Error */, key: "'delete' cannot be called on an identifier in strict mode." },
        A_continue_statement_can_only_be_used_within_an_enclosing_iteration_statement: { code: 1104, category: 1 /* Error */, key: "A 'continue' statement can only be used within an enclosing iteration statement." },
        A_break_statement_can_only_be_used_within_an_enclosing_iteration_or_switch_statement: { code: 1105, category: 1 /* Error */, key: "A 'break' statement can only be used within an enclosing iteration or switch statement." },
        Jump_target_cannot_cross_function_boundary: { code: 1107, category: 1 /* Error */, key: "Jump target cannot cross function boundary." },
        A_return_statement_can_only_be_used_within_a_function_body: { code: 1108, category: 1 /* Error */, key: "A 'return' statement can only be used within a function body." },
        Expression_expected: { code: 1109, category: 1 /* Error */, key: "Expression expected." },
        Type_expected: { code: 1110, category: 1 /* Error */, key: "Type expected." },
        A_constructor_implementation_cannot_be_declared_in_an_ambient_context: { code: 1111, category: 1 /* Error */, key: "A constructor implementation cannot be declared in an ambient context." },
        A_class_member_cannot_be_declared_optional: { code: 1112, category: 1 /* Error */, key: "A class member cannot be declared optional." },
        A_default_clause_cannot_appear_more_than_once_in_a_switch_statement: { code: 1113, category: 1 /* Error */, key: "A 'default' clause cannot appear more than once in a 'switch' statement." },
        Duplicate_label_0: { code: 1114, category: 1 /* Error */, key: "Duplicate label '{0}'" },
        A_continue_statement_can_only_jump_to_a_label_of_an_enclosing_iteration_statement: { code: 1115, category: 1 /* Error */, key: "A 'continue' statement can only jump to a label of an enclosing iteration statement." },
        A_break_statement_can_only_jump_to_a_label_of_an_enclosing_statement: { code: 1116, category: 1 /* Error */, key: "A 'break' statement can only jump to a label of an enclosing statement." },
        An_object_literal_cannot_have_multiple_properties_with_the_same_name_in_strict_mode: { code: 1117, category: 1 /* Error */, key: "An object literal cannot have multiple properties with the same name in strict mode." },
        An_object_literal_cannot_have_multiple_get_Slashset_accessors_with_the_same_name: { code: 1118, category: 1 /* Error */, key: "An object literal cannot have multiple get/set accessors with the same name." },
        An_object_literal_cannot_have_property_and_accessor_with_the_same_name: { code: 1119, category: 1 /* Error */, key: "An object literal cannot have property and accessor with the same name." },
        An_export_assignment_cannot_have_modifiers: { code: 1120, category: 1 /* Error */, key: "An export assignment cannot have modifiers." },
        Octal_literals_are_not_allowed_in_strict_mode: { code: 1121, category: 1 /* Error */, key: "Octal literals are not allowed in strict mode." },
        A_tuple_type_element_list_cannot_be_empty: { code: 1122, category: 1 /* Error */, key: "A tuple type element list cannot be empty." },
        Variable_declaration_list_cannot_be_empty: { code: 1123, category: 1 /* Error */, key: "Variable declaration list cannot be empty." },
        Digit_expected: { code: 1124, category: 1 /* Error */, key: "Digit expected." },
        Hexadecimal_digit_expected: { code: 1125, category: 1 /* Error */, key: "Hexadecimal digit expected." },
        Unexpected_end_of_text: { code: 1126, category: 1 /* Error */, key: "Unexpected end of text." },
        Invalid_character: { code: 1127, category: 1 /* Error */, key: "Invalid character." },
        Declaration_or_statement_expected: { code: 1128, category: 1 /* Error */, key: "Declaration or statement expected." },
        Statement_expected: { code: 1129, category: 1 /* Error */, key: "Statement expected." },
        case_or_default_expected: { code: 1130, category: 1 /* Error */, key: "'case' or 'default' expected." },
        Property_or_signature_expected: { code: 1131, category: 1 /* Error */, key: "Property or signature expected." },
        Enum_member_expected: { code: 1132, category: 1 /* Error */, key: "Enum member expected." },
        Type_reference_expected: { code: 1133, category: 1 /* Error */, key: "Type reference expected." },
        Variable_declaration_expected: { code: 1134, category: 1 /* Error */, key: "Variable declaration expected." },
        Argument_expression_expected: { code: 1135, category: 1 /* Error */, key: "Argument expression expected." },
        Property_assignment_expected: { code: 1136, category: 1 /* Error */, key: "Property assignment expected." },
        Expression_or_comma_expected: { code: 1137, category: 1 /* Error */, key: "Expression or comma expected." },
        Parameter_declaration_expected: { code: 1138, category: 1 /* Error */, key: "Parameter declaration expected." },
        Type_parameter_declaration_expected: { code: 1139, category: 1 /* Error */, key: "Type parameter declaration expected." },
        Type_argument_expected: { code: 1140, category: 1 /* Error */, key: "Type argument expected." },
        String_literal_expected: { code: 1141, category: 1 /* Error */, key: "String literal expected." },
        Line_break_not_permitted_here: { code: 1142, category: 1 /* Error */, key: "Line break not permitted here." },
        catch_or_finally_expected: { code: 1143, category: 1 /* Error */, key: "'catch' or 'finally' expected." },
        Block_or_expected: { code: 1144, category: 1 /* Error */, key: "Block or ';' expected." },
        Modifiers_not_permitted_on_index_signature_members: { code: 1145, category: 1 /* Error */, key: "Modifiers not permitted on index signature members." },
        Declaration_expected: { code: 1146, category: 1 /* Error */, key: "Declaration expected." },
        Import_declarations_in_an_internal_module_cannot_reference_an_external_module: { code: 1147, category: 1 /* Error */, key: "Import declarations in an internal module cannot reference an external module." },
        Cannot_compile_external_modules_unless_the_module_flag_is_provided: { code: 1148, category: 1 /* Error */, key: "Cannot compile external modules unless the '--module' flag is provided." },
        Filename_0_differs_from_already_included_filename_1_only_in_casing: { code: 1149, category: 1 /* Error */, key: "Filename '{0}' differs from already included filename '{1}' only in casing" },
        new_T_cannot_be_used_to_create_an_array_Use_new_Array_T_instead: { code: 1150, category: 1 /* Error */, key: "'new T[]' cannot be used to create an array. Use 'new Array<T>()' instead." },
        Duplicate_identifier_0: { code: 2300, category: 1 /* Error */, key: "Duplicate identifier '{0}'." },
        Initializer_of_instance_member_variable_0_cannot_reference_identifier_1_declared_in_the_constructor: { code: 2301, category: 1 /* Error */, key: "Initializer of instance member variable '{0}' cannot reference identifier '{1}' declared in the constructor." },
        Static_members_cannot_reference_class_type_parameters: { code: 2302, category: 1 /* Error */, key: "Static members cannot reference class type parameters." },
        Circular_definition_of_import_alias_0: { code: 2303, category: 1 /* Error */, key: "Circular definition of import alias '{0}'." },
        Cannot_find_name_0: { code: 2304, category: 1 /* Error */, key: "Cannot find name '{0}'." },
        Module_0_has_no_exported_member_1: { code: 2305, category: 1 /* Error */, key: "Module '{0}' has no exported member '{1}'." },
        File_0_is_not_an_external_module: { code: 2306, category: 1 /* Error */, key: "File '{0}' is not an external module." },
        Cannot_find_external_module_0: { code: 2307, category: 1 /* Error */, key: "Cannot find external module '{0}'." },
        A_module_cannot_have_more_than_one_export_assignment: { code: 2308, category: 1 /* Error */, key: "A module cannot have more than one export assignment." },
        An_export_assignment_cannot_be_used_in_a_module_with_other_exported_elements: { code: 2309, category: 1 /* Error */, key: "An export assignment cannot be used in a module with other exported elements." },
        Type_0_recursively_references_itself_as_a_base_type: { code: 2310, category: 1 /* Error */, key: "Type '{0}' recursively references itself as a base type." },
        A_class_may_only_extend_another_class: { code: 2311, category: 1 /* Error */, key: "A class may only extend another class." },
        An_interface_may_only_extend_a_class_or_another_interface: { code: 2312, category: 1 /* Error */, key: "An interface may only extend a class or another interface." },
        Constraint_of_a_type_parameter_cannot_reference_any_type_parameter_from_the_same_type_parameter_list: { code: 2313, category: 1 /* Error */, key: "Constraint of a type parameter cannot reference any type parameter from the same type parameter list." },
        Generic_type_0_requires_1_type_argument_s: { code: 2314, category: 1 /* Error */, key: "Generic type '{0}' requires {1} type argument(s)." },
        Type_0_is_not_generic: { code: 2315, category: 1 /* Error */, key: "Type '{0}' is not generic." },
        Global_type_0_must_be_a_class_or_interface_type: { code: 2316, category: 1 /* Error */, key: "Global type '{0}' must be a class or interface type." },
        Global_type_0_must_have_1_type_parameter_s: { code: 2317, category: 1 /* Error */, key: "Global type '{0}' must have {1} type parameter(s)." },
        Cannot_find_global_type_0: { code: 2318, category: 1 /* Error */, key: "Cannot find global type '{0}'." },
        Named_properties_0_of_types_1_and_2_are_not_identical: { code: 2319, category: 1 /* Error */, key: "Named properties '{0}' of types '{1}' and '{2}' are not identical." },
        Interface_0_cannot_simultaneously_extend_types_1_and_2_Colon: { code: 2320, category: 1 /* Error */, key: "Interface '{0}' cannot simultaneously extend types '{1}' and '{2}':" },
        Excessive_stack_depth_comparing_types_0_and_1: { code: 2321, category: 1 /* Error */, key: "Excessive stack depth comparing types '{0}' and '{1}'." },
        Type_0_is_not_assignable_to_type_1_Colon: { code: 2322, category: 1 /* Error */, key: "Type '{0}' is not assignable to type '{1}':" },
        Type_0_is_not_assignable_to_type_1: { code: 2323, category: 1 /* Error */, key: "Type '{0}' is not assignable to type '{1}'." },
        Property_0_is_missing_in_type_1: { code: 2324, category: 1 /* Error */, key: "Property '{0}' is missing in type '{1}'." },
        Property_0_is_private_in_type_1_but_not_in_type_2: { code: 2325, category: 1 /* Error */, key: "Property '{0}' is private in type '{1}' but not in type '{2}'." },
        Types_of_property_0_are_incompatible_Colon: { code: 2326, category: 1 /* Error */, key: "Types of property '{0}' are incompatible:" },
        Property_0_is_optional_in_type_1_but_required_in_type_2: { code: 2327, category: 1 /* Error */, key: "Property '{0}' is optional in type '{1}' but required in type '{2}'." },
        Types_of_parameters_0_and_1_are_incompatible_Colon: { code: 2328, category: 1 /* Error */, key: "Types of parameters '{0}' and '{1}' are incompatible:" },
        Index_signature_is_missing_in_type_0: { code: 2329, category: 1 /* Error */, key: "Index signature is missing in type '{0}'." },
        Index_signatures_are_incompatible_Colon: { code: 2330, category: 1 /* Error */, key: "Index signatures are incompatible:" },
        this_cannot_be_referenced_in_a_module_body: { code: 2331, category: 1 /* Error */, key: "'this' cannot be referenced in a module body." },
        this_cannot_be_referenced_in_current_location: { code: 2332, category: 1 /* Error */, key: "'this' cannot be referenced in current location." },
        this_cannot_be_referenced_in_constructor_arguments: { code: 2333, category: 1 /* Error */, key: "'this' cannot be referenced in constructor arguments." },
        this_cannot_be_referenced_in_a_static_property_initializer: { code: 2334, category: 1 /* Error */, key: "'this' cannot be referenced in a static property initializer." },
        super_can_only_be_referenced_in_a_derived_class: { code: 2335, category: 1 /* Error */, key: "'super' can only be referenced in a derived class." },
        super_cannot_be_referenced_in_constructor_arguments: { code: 2336, category: 1 /* Error */, key: "'super' cannot be referenced in constructor arguments." },
        Super_calls_are_not_permitted_outside_constructors_or_in_nested_functions_inside_constructors: { code: 2337, category: 1 /* Error */, key: "Super calls are not permitted outside constructors or in nested functions inside constructors" },
        super_property_access_is_permitted_only_in_a_constructor_member_function_or_member_accessor_of_a_derived_class: { code: 2338, category: 1 /* Error */, key: "'super' property access is permitted only in a constructor, member function, or member accessor of a derived class" },
        Property_0_does_not_exist_on_type_1: { code: 2339, category: 1 /* Error */, key: "Property '{0}' does not exist on type '{1}'." },
        Only_public_and_protected_methods_of_the_base_class_are_accessible_via_the_super_keyword: { code: 2340, category: 1 /* Error */, key: "Only public and protected methods of the base class are accessible via the 'super' keyword" },
        Property_0_is_private_and_only_accessible_within_class_1: { code: 2341, category: 1 /* Error */, key: "Property '{0}' is private and only accessible within class '{1}'." },
        An_index_expression_argument_must_be_of_type_string_number_or_any: { code: 2342, category: 1 /* Error */, key: "An index expression argument must be of type 'string', 'number', or 'any'." },
        Type_0_does_not_satisfy_the_constraint_1_Colon: { code: 2343, category: 1 /* Error */, key: "Type '{0}' does not satisfy the constraint '{1}':" },
        Type_0_does_not_satisfy_the_constraint_1: { code: 2344, category: 1 /* Error */, key: "Type '{0}' does not satisfy the constraint '{1}'." },
        Argument_of_type_0_is_not_assignable_to_parameter_of_type_1: { code: 2345, category: 1 /* Error */, key: "Argument of type '{0}' is not assignable to parameter of type '{1}'." },
        Supplied_parameters_do_not_match_any_signature_of_call_target: { code: 2346, category: 1 /* Error */, key: "Supplied parameters do not match any signature of call target." },
        Untyped_function_calls_may_not_accept_type_arguments: { code: 2347, category: 1 /* Error */, key: "Untyped function calls may not accept type arguments." },
        Value_of_type_0_is_not_callable_Did_you_mean_to_include_new: { code: 2348, category: 1 /* Error */, key: "Value of type '{0}' is not callable. Did you mean to include 'new'?" },
        Cannot_invoke_an_expression_whose_type_lacks_a_call_signature: { code: 2349, category: 1 /* Error */, key: "Cannot invoke an expression whose type lacks a call signature." },
        Only_a_void_function_can_be_called_with_the_new_keyword: { code: 2350, category: 1 /* Error */, key: "Only a void function can be called with the 'new' keyword." },
        Cannot_use_new_with_an_expression_whose_type_lacks_a_call_or_construct_signature: { code: 2351, category: 1 /* Error */, key: "Cannot use 'new' with an expression whose type lacks a call or construct signature." },
        Neither_type_0_nor_type_1_is_assignable_to_the_other: { code: 2352, category: 1 /* Error */, key: "Neither type '{0}' nor type '{1}' is assignable to the other." },
        Neither_type_0_nor_type_1_is_assignable_to_the_other_Colon: { code: 2353, category: 1 /* Error */, key: "Neither type '{0}' nor type '{1}' is assignable to the other:" },
        No_best_common_type_exists_among_return_expressions: { code: 2354, category: 1 /* Error */, key: "No best common type exists among return expressions." },
        A_function_whose_declared_type_is_neither_void_nor_any_must_return_a_value_or_consist_of_a_single_throw_statement: { code: 2355, category: 1 /* Error */, key: "A function whose declared type is neither 'void' nor 'any' must return a value or consist of a single 'throw' statement." },
        An_arithmetic_operand_must_be_of_type_any_number_or_an_enum_type: { code: 2356, category: 1 /* Error */, key: "An arithmetic operand must be of type 'any', 'number' or an enum type." },
        The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_property_or_indexer: { code: 2357, category: 1 /* Error */, key: "The operand of an increment or decrement operator must be a variable, property or indexer." },
        The_left_hand_side_of_an_instanceof_expression_must_be_of_type_any_an_object_type_or_a_type_parameter: { code: 2358, category: 1 /* Error */, key: "The left-hand side of an 'instanceof' expression must be of type 'any', an object type or a type parameter." },
        The_right_hand_side_of_an_instanceof_expression_must_be_of_type_any_or_of_a_type_assignable_to_the_Function_interface_type: { code: 2359, category: 1 /* Error */, key: "The right-hand side of an 'instanceof' expression must be of type 'any' or of a type assignable to the 'Function' interface type." },
        The_left_hand_side_of_an_in_expression_must_be_of_types_any_string_or_number: { code: 2360, category: 1 /* Error */, key: "The left-hand side of an 'in' expression must be of types 'any', 'string' or 'number'." },
        The_right_hand_side_of_an_in_expression_must_be_of_type_any_an_object_type_or_a_type_parameter: { code: 2361, category: 1 /* Error */, key: "The right-hand side of an 'in' expression must be of type 'any', an object type or a type parameter" },
        The_left_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_or_an_enum_type: { code: 2362, category: 1 /* Error */, key: "The left-hand side of an arithmetic operation must be of type 'any', 'number' or an enum type." },
        The_right_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_or_an_enum_type: { code: 2363, category: 1 /* Error */, key: "The right-hand side of an arithmetic operation must be of type 'any', 'number' or an enum type." },
        Invalid_left_hand_side_of_assignment_expression: { code: 2364, category: 1 /* Error */, key: "Invalid left-hand side of assignment expression." },
        Operator_0_cannot_be_applied_to_types_1_and_2: { code: 2365, category: 1 /* Error */, key: "Operator '{0}' cannot be applied to types '{1}' and '{2}'." },
        No_best_common_type_exists_between_0_1_and_2: { code: 2366, category: 1 /* Error */, key: "No best common type exists between '{0}', '{1}', and '{2}'." },
        No_best_common_type_exists_between_0_and_1: { code: 2367, category: 1 /* Error */, key: "No best common type exists between '{0}' and '{1}'." },
        Type_parameter_name_cannot_be_0: { code: 2368, category: 1 /* Error */, key: "Type parameter name cannot be '{0}'" },
        A_parameter_property_is_only_allowed_in_a_constructor_implementation: { code: 2369, category: 1 /* Error */, key: "A parameter property is only allowed in a constructor implementation." },
        A_rest_parameter_must_be_of_an_array_type: { code: 2370, category: 1 /* Error */, key: "A rest parameter must be of an array type." },
        A_parameter_initializer_is_only_allowed_in_a_function_or_constructor_implementation: { code: 2371, category: 1 /* Error */, key: "A parameter initializer is only allowed in a function or constructor implementation." },
        Parameter_0_cannot_be_referenced_in_its_initializer: { code: 2372, category: 1 /* Error */, key: "Parameter '{0}' cannot be referenced in its initializer." },
        Initializer_of_parameter_0_cannot_reference_identifier_1_declared_after_it: { code: 2373, category: 1 /* Error */, key: "Initializer of parameter '{0}' cannot reference identifier '{1}' declared after it." },
        Duplicate_string_index_signature: { code: 2374, category: 1 /* Error */, key: "Duplicate string index signature." },
        Duplicate_number_index_signature: { code: 2375, category: 1 /* Error */, key: "Duplicate number index signature." },
        A_super_call_must_be_the_first_statement_in_the_constructor_when_a_class_contains_initialized_properties_or_has_parameter_properties: { code: 2376, category: 1 /* Error */, key: "A 'super' call must be the first statement in the constructor when a class contains initialized properties or has parameter properties." },
        Constructors_for_derived_classes_must_contain_a_super_call: { code: 2377, category: 1 /* Error */, key: "Constructors for derived classes must contain a 'super' call." },
        A_get_accessor_must_return_a_value_or_consist_of_a_single_throw_statement: { code: 2378, category: 1 /* Error */, key: "A 'get' accessor must return a value or consist of a single 'throw' statement." },
        Getter_and_setter_accessors_do_not_agree_in_visibility: { code: 2379, category: 1 /* Error */, key: "Getter and setter accessors do not agree in visibility." },
        get_and_set_accessor_must_have_the_same_type: { code: 2380, category: 1 /* Error */, key: "'get' and 'set' accessor must have the same type." },
        A_signature_with_an_implementation_cannot_use_a_string_literal_type: { code: 2381, category: 1 /* Error */, key: "A signature with an implementation cannot use a string literal type." },
        Specialized_overload_signature_is_not_assignable_to_any_non_specialized_signature: { code: 2382, category: 1 /* Error */, key: "Specialized overload signature is not assignable to any non-specialized signature." },
        Overload_signatures_must_all_be_exported_or_not_exported: { code: 2383, category: 1 /* Error */, key: "Overload signatures must all be exported or not exported." },
        Overload_signatures_must_all_be_ambient_or_non_ambient: { code: 2384, category: 1 /* Error */, key: "Overload signatures must all be ambient or non-ambient." },
        Overload_signatures_must_all_be_public_private_or_protected: { code: 2385, category: 1 /* Error */, key: "Overload signatures must all be public, private or protected." },
        Overload_signatures_must_all_be_optional_or_required: { code: 2386, category: 1 /* Error */, key: "Overload signatures must all be optional or required." },
        Function_overload_must_be_static: { code: 2387, category: 1 /* Error */, key: "Function overload must be static." },
        Function_overload_must_not_be_static: { code: 2388, category: 1 /* Error */, key: "Function overload must not be static." },
        Function_implementation_name_must_be_0: { code: 2389, category: 1 /* Error */, key: "Function implementation name must be '{0}'." },
        Constructor_implementation_is_missing: { code: 2390, category: 1 /* Error */, key: "Constructor implementation is missing." },
        Function_implementation_is_missing_or_not_immediately_following_the_declaration: { code: 2391, category: 1 /* Error */, key: "Function implementation is missing or not immediately following the declaration." },
        Multiple_constructor_implementations_are_not_allowed: { code: 2392, category: 1 /* Error */, key: "Multiple constructor implementations are not allowed." },
        Duplicate_function_implementation: { code: 2393, category: 1 /* Error */, key: "Duplicate function implementation." },
        Overload_signature_is_not_compatible_with_function_implementation: { code: 2394, category: 1 /* Error */, key: "Overload signature is not compatible with function implementation." },
        Individual_declarations_in_merged_declaration_0_must_be_all_exported_or_all_local: { code: 2395, category: 1 /* Error */, key: "Individual declarations in merged declaration {0} must be all exported or all local." },
        Duplicate_identifier_arguments_Compiler_uses_arguments_to_initialize_rest_parameters: { code: 2396, category: 1 /* Error */, key: "Duplicate identifier 'arguments'. Compiler uses 'arguments' to initialize rest parameters." },
        Duplicate_identifier_i_Compiler_uses_i_to_initialize_rest_parameter: { code: 2397, category: 1 /* Error */, key: "Duplicate identifier '_i'. Compiler uses '_i' to initialize rest parameter." },
        Expression_resolves_to_variable_declaration_i_that_compiler_uses_to_initialize_rest_parameter: { code: 2398, category: 1 /* Error */, key: "Expression resolves to variable declaration '_i' that compiler uses to initialize rest parameter." },
        Duplicate_identifier_this_Compiler_uses_variable_declaration_this_to_capture_this_reference: { code: 2399, category: 1 /* Error */, key: "Duplicate identifier '_this'. Compiler uses variable declaration '_this' to capture 'this' reference." },
        Expression_resolves_to_variable_declaration_this_that_compiler_uses_to_capture_this_reference: { code: 2400, category: 1 /* Error */, key: "Expression resolves to variable declaration '_this' that compiler uses to capture 'this' reference." },
        Duplicate_identifier_super_Compiler_uses_super_to_capture_base_class_reference: { code: 2401, category: 1 /* Error */, key: "Duplicate identifier '_super'. Compiler uses '_super' to capture base class reference." },
        Expression_resolves_to_super_that_compiler_uses_to_capture_base_class_reference: { code: 2402, category: 1 /* Error */, key: "Expression resolves to '_super' that compiler uses to capture base class reference." },
        Subsequent_variable_declarations_must_have_the_same_type_Variable_0_must_be_of_type_1_but_here_has_type_2: { code: 2403, category: 1 /* Error */, key: "Subsequent variable declarations must have the same type.  Variable '{0}' must be of type '{1}', but here has type '{2}'." },
        The_left_hand_side_of_a_for_in_statement_cannot_use_a_type_annotation: { code: 2404, category: 1 /* Error */, key: "The left-hand side of a 'for...in' statement cannot use a type annotation." },
        The_left_hand_side_of_a_for_in_statement_must_be_of_type_string_or_any: { code: 2405, category: 1 /* Error */, key: "The left-hand side of a 'for...in' statement must be of type 'string' or 'any'." },
        Invalid_left_hand_side_in_for_in_statement: { code: 2406, category: 1 /* Error */, key: "Invalid left-hand side in 'for...in' statement." },
        The_right_hand_side_of_a_for_in_statement_must_be_of_type_any_an_object_type_or_a_type_parameter: { code: 2407, category: 1 /* Error */, key: "The right-hand side of a 'for...in' statement must be of type 'any', an object type or a type parameter." },
        Setters_cannot_return_a_value: { code: 2408, category: 1 /* Error */, key: "Setters cannot return a value." },
        Return_type_of_constructor_signature_must_be_assignable_to_the_instance_type_of_the_class: { code: 2409, category: 1 /* Error */, key: "Return type of constructor signature must be assignable to the instance type of the class" },
        All_symbols_within_a_with_block_will_be_resolved_to_any: { code: 2410, category: 1 /* Error */, key: "All symbols within a 'with' block will be resolved to 'any'." },
        Property_0_of_type_1_is_not_assignable_to_string_index_type_2: { code: 2411, category: 1 /* Error */, key: "Property '{0}' of type '{1}' is not assignable to string index type '{2}'." },
        Property_0_of_type_1_is_not_assignable_to_numeric_index_type_2: { code: 2412, category: 1 /* Error */, key: "Property '{0}' of type '{1}' is not assignable to numeric index type '{2}'." },
        Numeric_index_type_0_is_not_assignable_to_string_index_type_1: { code: 2413, category: 1 /* Error */, key: "Numeric index type '{0}' is not assignable to string index type '{1}'." },
        Class_name_cannot_be_0: { code: 2414, category: 1 /* Error */, key: "Class name cannot be '{0}'" },
        Class_0_incorrectly_extends_base_class_1: { code: 2415, category: 1 /* Error */, key: "Class '{0}' incorrectly extends base class '{1}'." },
        Class_0_incorrectly_extends_base_class_1_Colon: { code: 2416, category: 1 /* Error */, key: "Class '{0}' incorrectly extends base class '{1}':" },
        Class_static_side_0_incorrectly_extends_base_class_static_side_1: { code: 2417, category: 1 /* Error */, key: "Class static side '{0}' incorrectly extends base class static side '{1}'." },
        Class_static_side_0_incorrectly_extends_base_class_static_side_1_Colon: { code: 2418, category: 1 /* Error */, key: "Class static side '{0}' incorrectly extends base class static side '{1}':" },
        Type_name_0_in_extends_clause_does_not_reference_constructor_function_for_0: { code: 2419, category: 1 /* Error */, key: "Type name '{0}' in extends clause does not reference constructor function for '{0}'." },
        Class_0_incorrectly_implements_interface_1: { code: 2420, category: 1 /* Error */, key: "Class '{0}' incorrectly implements interface '{1}'." },
        Class_0_incorrectly_implements_interface_1_Colon: { code: 2421, category: 1 /* Error */, key: "Class '{0}' incorrectly implements interface '{1}':" },
        A_class_may_only_implement_another_class_or_interface: { code: 2422, category: 1 /* Error */, key: "A class may only implement another class or interface." },
        Class_0_defines_instance_member_function_1_but_extended_class_2_defines_it_as_instance_member_accessor: { code: 2423, category: 1 /* Error */, key: "Class '{0}' defines instance member function '{1}', but extended class '{2}' defines it as instance member accessor." },
        Class_0_defines_instance_member_function_1_but_extended_class_2_defines_it_as_instance_member_property: { code: 2424, category: 1 /* Error */, key: "Class '{0}' defines instance member function '{1}', but extended class '{2}' defines it as instance member property." },
        Class_0_defines_instance_member_property_1_but_extended_class_2_defines_it_as_instance_member_function: { code: 2425, category: 1 /* Error */, key: "Class '{0}' defines instance member property '{1}', but extended class '{2}' defines it as instance member function." },
        Class_0_defines_instance_member_accessor_1_but_extended_class_2_defines_it_as_instance_member_function: { code: 2426, category: 1 /* Error */, key: "Class '{0}' defines instance member accessor '{1}', but extended class '{2}' defines it as instance member function." },
        Interface_name_cannot_be_0: { code: 2427, category: 1 /* Error */, key: "Interface name cannot be '{0}'" },
        All_declarations_of_an_interface_must_have_identical_type_parameters: { code: 2428, category: 1 /* Error */, key: "All declarations of an interface must have identical type parameters." },
        Interface_0_incorrectly_extends_interface_1_Colon: { code: 2429, category: 1 /* Error */, key: "Interface '{0}' incorrectly extends interface '{1}':" },
        Interface_0_incorrectly_extends_interface_1: { code: 2430, category: 1 /* Error */, key: "Interface '{0}' incorrectly extends interface '{1}'." },
        Enum_name_cannot_be_0: { code: 2431, category: 1 /* Error */, key: "Enum name cannot be '{0}'" },
        In_an_enum_with_multiple_declarations_only_one_declaration_can_omit_an_initializer_for_its_first_enum_element: { code: 2432, category: 1 /* Error */, key: "In an enum with multiple declarations, only one declaration can omit an initializer for its first enum element." },
        A_module_declaration_cannot_be_in_a_different_file_from_a_class_or_function_with_which_it_is_merged: { code: 2433, category: 1 /* Error */, key: "A module declaration cannot be in a different file from a class or function with which it is merged" },
        A_module_declaration_cannot_be_located_prior_to_a_class_or_function_with_which_it_is_merged: { code: 2434, category: 1 /* Error */, key: "A module declaration cannot be located prior to a class or function with which it is merged" },
        Ambient_external_modules_cannot_be_nested_in_other_modules: { code: 2435, category: 1 /* Error */, key: "Ambient external modules cannot be nested in other modules." },
        Ambient_external_module_declaration_cannot_specify_relative_module_name: { code: 2436, category: 1 /* Error */, key: "Ambient external module declaration cannot specify relative module name." },
        Module_0_is_hidden_by_a_local_declaration_with_the_same_name: { code: 2437, category: 1 /* Error */, key: "Module '{0}' is hidden by a local declaration with the same name" },
        Import_name_cannot_be_0: { code: 2438, category: 1 /* Error */, key: "Import name cannot be '{0}'" },
        Import_declaration_in_an_ambient_external_module_declaration_cannot_reference_external_module_through_relative_external_module_name: { code: 2439, category: 1 /* Error */, key: "Import declaration in an ambient external module declaration cannot reference external module through relative external module name." },
        Import_declaration_conflicts_with_local_declaration_of_0: { code: 2440, category: 1 /* Error */, key: "Import declaration conflicts with local declaration of '{0}'" },
        Duplicate_identifier_0_Compiler_reserves_name_1_in_top_level_scope_of_an_external_module: { code: 2441, category: 1 /* Error */, key: "Duplicate identifier '{0}'. Compiler reserves name '{1}' in top level scope of an external module." },
        Types_have_separate_declarations_of_a_private_property_0: { code: 2442, category: 1 /* Error */, key: "Types have separate declarations of a private property '{0}'." },
        Property_0_is_protected_but_type_1_is_not_a_class_derived_from_2: { code: 2443, category: 1 /* Error */, key: "Property '{0}' is protected but type '{1}' is not a class derived from '{2}'." },
        Property_0_is_protected_in_type_1_but_public_in_type_2: { code: 2444, category: 1 /* Error */, key: "Property '{0}' is protected in type '{1}' but public in type '{2}'." },
        Property_0_is_protected_and_only_accessible_within_class_1_and_its_subclasses: { code: 2445, category: 1 /* Error */, key: "Property '{0}' is protected and only accessible within class '{1}' and its subclasses." },
        Property_0_is_protected_and_only_accessible_through_an_instance_of_class_1: { code: 2446, category: 1 /* Error */, key: "Property '{0}' is protected and only accessible through an instance of class '{1}'." },
        Import_declaration_0_is_using_private_name_1: { code: 4000, category: 1 /* Error */, key: "Import declaration '{0}' is using private name '{1}'." },
        Type_parameter_0_of_exported_class_has_or_is_using_name_1_from_private_module_2: { code: 4001, category: 1 /* Error */, key: "Type parameter '{0}' of exported class has or is using name '{1}' from private module '{2}'." },
        Type_parameter_0_of_exported_class_has_or_is_using_private_name_1: { code: 4002, category: 1 /* Error */, key: "Type parameter '{0}' of exported class has or is using private name '{1}'." },
        Type_parameter_0_of_exported_interface_has_or_is_using_name_1_from_private_module_2: { code: 4003, category: 1 /* Error */, key: "Type parameter '{0}' of exported interface has or is using name '{1}' from private module '{2}'." },
        Type_parameter_0_of_exported_interface_has_or_is_using_private_name_1: { code: 4004, category: 1 /* Error */, key: "Type parameter '{0}' of exported interface has or is using private name '{1}'." },
        Type_parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_name_1_from_private_module_2: { code: 4005, category: 1 /* Error */, key: "Type parameter '{0}' of constructor signature from exported interface has or is using name '{1}' from private module '{2}'." },
        Type_parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_private_name_1: { code: 4006, category: 1 /* Error */, key: "Type parameter '{0}' of constructor signature from exported interface has or is using private name '{1}'." },
        Type_parameter_0_of_call_signature_from_exported_interface_has_or_is_using_name_1_from_private_module_2: { code: 4007, category: 1 /* Error */, key: "Type parameter '{0}' of call signature from exported interface has or is using name '{1}' from private module '{2}'." },
        Type_parameter_0_of_call_signature_from_exported_interface_has_or_is_using_private_name_1: { code: 4008, category: 1 /* Error */, key: "Type parameter '{0}' of call signature from exported interface has or is using private name '{1}'." },
        Type_parameter_0_of_public_static_method_from_exported_class_has_or_is_using_name_1_from_private_module_2: { code: 4009, category: 1 /* Error */, key: "Type parameter '{0}' of public static method from exported class has or is using name '{1}' from private module '{2}'." },
        Type_parameter_0_of_public_static_method_from_exported_class_has_or_is_using_private_name_1: { code: 4010, category: 1 /* Error */, key: "Type parameter '{0}' of public static method from exported class has or is using private name '{1}'." },
        Type_parameter_0_of_public_method_from_exported_class_has_or_is_using_name_1_from_private_module_2: { code: 4011, category: 1 /* Error */, key: "Type parameter '{0}' of public method from exported class has or is using name '{1}' from private module '{2}'." },
        Type_parameter_0_of_public_method_from_exported_class_has_or_is_using_private_name_1: { code: 4012, category: 1 /* Error */, key: "Type parameter '{0}' of public method from exported class has or is using private name '{1}'." },
        Type_parameter_0_of_method_from_exported_interface_has_or_is_using_name_1_from_private_module_2: { code: 4013, category: 1 /* Error */, key: "Type parameter '{0}' of method from exported interface has or is using name '{1}' from private module '{2}'." },
        Type_parameter_0_of_method_from_exported_interface_has_or_is_using_private_name_1: { code: 4014, category: 1 /* Error */, key: "Type parameter '{0}' of method from exported interface has or is using private name '{1}'." },
        Type_parameter_0_of_exported_function_has_or_is_using_name_1_from_private_module_2: { code: 4015, category: 1 /* Error */, key: "Type parameter '{0}' of exported function has or is using name '{1}' from private module '{2}'." },
        Type_parameter_0_of_exported_function_has_or_is_using_private_name_1: { code: 4016, category: 1 /* Error */, key: "Type parameter '{0}' of exported function has or is using private name '{1}'." },
        Implements_clause_of_exported_class_0_has_or_is_using_name_1_from_private_module_2: { code: 4017, category: 1 /* Error */, key: "Implements clause of exported class '{0}' has or is using name '{1}' from private module '{2}'." },
        Extends_clause_of_exported_class_0_has_or_is_using_name_1_from_private_module_2: { code: 4018, category: 1 /* Error */, key: "Extends clause of exported class '{0}' has or is using name '{1}' from private module '{2}'." },
        Implements_clause_of_exported_class_0_has_or_is_using_private_name_1: { code: 4019, category: 1 /* Error */, key: "Implements clause of exported class '{0}' has or is using private name '{1}'." },
        Extends_clause_of_exported_class_0_has_or_is_using_private_name_1: { code: 4020, category: 1 /* Error */, key: "Extends clause of exported class '{0}' has or is using private name '{1}'." },
        Extends_clause_of_exported_interface_0_has_or_is_using_name_1_from_private_module_2: { code: 4021, category: 1 /* Error */, key: "Extends clause of exported interface '{0}' has or is using name '{1}' from private module '{2}'." },
        Extends_clause_of_exported_interface_0_has_or_is_using_private_name_1: { code: 4022, category: 1 /* Error */, key: "Extends clause of exported interface '{0}' has or is using private name '{1}'." },
        Exported_variable_0_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: { code: 4023, category: 1 /* Error */, key: "Exported variable '{0}' has or is using name '{1}' from external module {2} but cannot be named." },
        Exported_variable_0_has_or_is_using_name_1_from_private_module_2: { code: 4024, category: 1 /* Error */, key: "Exported variable '{0}' has or is using name '{1}' from private module '{2}'." },
        Exported_variable_0_has_or_is_using_private_name_1: { code: 4025, category: 1 /* Error */, key: "Exported variable '{0}' has or is using private name '{1}'." },
        Public_static_property_0_of_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: { code: 4026, category: 1 /* Error */, key: "Public static property '{0}' of exported class has or is using name '{1}' from external module {2} but cannot be named." },
        Public_static_property_0_of_exported_class_has_or_is_using_name_1_from_private_module_2: { code: 4027, category: 1 /* Error */, key: "Public static property '{0}' of exported class has or is using name '{1}' from private module '{2}'." },
        Public_static_property_0_of_exported_class_has_or_is_using_private_name_1: { code: 4028, category: 1 /* Error */, key: "Public static property '{0}' of exported class has or is using private name '{1}'." },
        Public_property_0_of_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: { code: 4029, category: 1 /* Error */, key: "Public property '{0}' of exported class has or is using name '{1}' from external module {2} but cannot be named." },
        Public_property_0_of_exported_class_has_or_is_using_name_1_from_private_module_2: { code: 4030, category: 1 /* Error */, key: "Public property '{0}' of exported class has or is using name '{1}' from private module '{2}'." },
        Public_property_0_of_exported_class_has_or_is_using_private_name_1: { code: 4031, category: 1 /* Error */, key: "Public property '{0}' of exported class has or is using private name '{1}'." },
        Property_0_of_exported_interface_has_or_is_using_name_1_from_private_module_2: { code: 4032, category: 1 /* Error */, key: "Property '{0}' of exported interface has or is using name '{1}' from private module '{2}'." },
        Property_0_of_exported_interface_has_or_is_using_private_name_1: { code: 4033, category: 1 /* Error */, key: "Property '{0}' of exported interface has or is using private name '{1}'." },
        Parameter_0_of_public_static_property_setter_from_exported_class_has_or_is_using_name_1_from_private_module_2: { code: 4034, category: 1 /* Error */, key: "Parameter '{0}' of public static property setter from exported class has or is using name '{1}' from private module '{2}'." },
        Parameter_0_of_public_static_property_setter_from_exported_class_has_or_is_using_private_name_1: { code: 4035, category: 1 /* Error */, key: "Parameter '{0}' of public static property setter from exported class has or is using private name '{1}'." },
        Parameter_0_of_public_property_setter_from_exported_class_has_or_is_using_name_1_from_private_module_2: { code: 4036, category: 1 /* Error */, key: "Parameter '{0}' of public property setter from exported class has or is using name '{1}' from private module '{2}'." },
        Parameter_0_of_public_property_setter_from_exported_class_has_or_is_using_private_name_1: { code: 4037, category: 1 /* Error */, key: "Parameter '{0}' of public property setter from exported class has or is using private name '{1}'." },
        Return_type_of_public_static_property_getter_from_exported_class_has_or_is_using_name_0_from_external_module_1_but_cannot_be_named: { code: 4038, category: 1 /* Error */, key: "Return type of public static property getter from exported class has or is using name '{0}' from external module {1} but cannot be named." },
        Return_type_of_public_static_property_getter_from_exported_class_has_or_is_using_name_0_from_private_module_1: { code: 4039, category: 1 /* Error */, key: "Return type of public static property getter from exported class has or is using name '{0}' from private module '{1}'." },
        Return_type_of_public_static_property_getter_from_exported_class_has_or_is_using_private_name_0: { code: 4040, category: 1 /* Error */, key: "Return type of public static property getter from exported class has or is using private name '{0}'." },
        Return_type_of_public_property_getter_from_exported_class_has_or_is_using_name_0_from_external_module_1_but_cannot_be_named: { code: 4041, category: 1 /* Error */, key: "Return type of public property getter from exported class has or is using name '{0}' from external module {1} but cannot be named." },
        Return_type_of_public_property_getter_from_exported_class_has_or_is_using_name_0_from_private_module_1: { code: 4042, category: 1 /* Error */, key: "Return type of public property getter from exported class has or is using name '{0}' from private module '{1}'." },
        Return_type_of_public_property_getter_from_exported_class_has_or_is_using_private_name_0: { code: 4043, category: 1 /* Error */, key: "Return type of public property getter from exported class has or is using private name '{0}'." },
        Return_type_of_constructor_signature_from_exported_interface_has_or_is_using_name_0_from_private_module_1: { code: 4044, category: 1 /* Error */, key: "Return type of constructor signature from exported interface has or is using name '{0}' from private module '{1}'." },
        Return_type_of_constructor_signature_from_exported_interface_has_or_is_using_private_name_0: { code: 4045, category: 1 /* Error */, key: "Return type of constructor signature from exported interface has or is using private name '{0}'." },
        Return_type_of_call_signature_from_exported_interface_has_or_is_using_name_0_from_private_module_1: { code: 4046, category: 1 /* Error */, key: "Return type of call signature from exported interface has or is using name '{0}' from private module '{1}'." },
        Return_type_of_call_signature_from_exported_interface_has_or_is_using_private_name_0: { code: 4047, category: 1 /* Error */, key: "Return type of call signature from exported interface has or is using private name '{0}'." },
        Return_type_of_index_signature_from_exported_interface_has_or_is_using_name_0_from_private_module_1: { code: 4048, category: 1 /* Error */, key: "Return type of index signature from exported interface has or is using name '{0}' from private module '{1}'." },
        Return_type_of_index_signature_from_exported_interface_has_or_is_using_private_name_0: { code: 4049, category: 1 /* Error */, key: "Return type of index signature from exported interface has or is using private name '{0}'." },
        Return_type_of_public_static_method_from_exported_class_has_or_is_using_name_0_from_external_module_1_but_cannot_be_named: { code: 4050, category: 1 /* Error */, key: "Return type of public static method from exported class has or is using name '{0}' from external module {1} but cannot be named." },
        Return_type_of_public_static_method_from_exported_class_has_or_is_using_name_0_from_private_module_1: { code: 4051, category: 1 /* Error */, key: "Return type of public static method from exported class has or is using name '{0}' from private module '{1}'." },
        Return_type_of_public_static_method_from_exported_class_has_or_is_using_private_name_0: { code: 4052, category: 1 /* Error */, key: "Return type of public static method from exported class has or is using private name '{0}'." },
        Return_type_of_public_method_from_exported_class_has_or_is_using_name_0_from_external_module_1_but_cannot_be_named: { code: 4053, category: 1 /* Error */, key: "Return type of public method from exported class has or is using name '{0}' from external module {1} but cannot be named." },
        Return_type_of_public_method_from_exported_class_has_or_is_using_name_0_from_private_module_1: { code: 4054, category: 1 /* Error */, key: "Return type of public method from exported class has or is using name '{0}' from private module '{1}'." },
        Return_type_of_public_method_from_exported_class_has_or_is_using_private_name_0: { code: 4055, category: 1 /* Error */, key: "Return type of public method from exported class has or is using private name '{0}'." },
        Return_type_of_method_from_exported_interface_has_or_is_using_name_0_from_private_module_1: { code: 4056, category: 1 /* Error */, key: "Return type of method from exported interface has or is using name '{0}' from private module '{1}'." },
        Return_type_of_method_from_exported_interface_has_or_is_using_private_name_0: { code: 4057, category: 1 /* Error */, key: "Return type of method from exported interface has or is using private name '{0}'." },
        Return_type_of_exported_function_has_or_is_using_name_0_from_external_module_1_but_cannot_be_named: { code: 4058, category: 1 /* Error */, key: "Return type of exported function has or is using name '{0}' from external module {1} but cannot be named." },
        Return_type_of_exported_function_has_or_is_using_name_0_from_private_module_1: { code: 4059, category: 1 /* Error */, key: "Return type of exported function has or is using name '{0}' from private module '{1}'." },
        Return_type_of_exported_function_has_or_is_using_private_name_0: { code: 4060, category: 1 /* Error */, key: "Return type of exported function has or is using private name '{0}'." },
        Parameter_0_of_constructor_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: { code: 4061, category: 1 /* Error */, key: "Parameter '{0}' of constructor from exported class has or is using name '{1}' from external module {2} but cannot be named." },
        Parameter_0_of_constructor_from_exported_class_has_or_is_using_name_1_from_private_module_2: { code: 4062, category: 1 /* Error */, key: "Parameter '{0}' of constructor from exported class has or is using name '{1}' from private module '{2}'." },
        Parameter_0_of_constructor_from_exported_class_has_or_is_using_private_name_1: { code: 4063, category: 1 /* Error */, key: "Parameter '{0}' of constructor from exported class has or is using private name '{1}'." },
        Parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_name_1_from_private_module_2: { code: 4064, category: 1 /* Error */, key: "Parameter '{0}' of constructor signature from exported interface has or is using name '{1}' from private module '{2}'." },
        Parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_private_name_1: { code: 4065, category: 1 /* Error */, key: "Parameter '{0}' of constructor signature from exported interface has or is using private name '{1}'." },
        Parameter_0_of_call_signature_from_exported_interface_has_or_is_using_name_1_from_private_module_2: { code: 4066, category: 1 /* Error */, key: "Parameter '{0}' of call signature from exported interface has or is using name '{1}' from private module '{2}'." },
        Parameter_0_of_call_signature_from_exported_interface_has_or_is_using_private_name_1: { code: 4067, category: 1 /* Error */, key: "Parameter '{0}' of call signature from exported interface has or is using private name '{1}'." },
        Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: { code: 4068, category: 1 /* Error */, key: "Parameter '{0}' of public static method from exported class has or is using name '{1}' from external module {2} but cannot be named." },
        Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_name_1_from_private_module_2: { code: 4069, category: 1 /* Error */, key: "Parameter '{0}' of public static method from exported class has or is using name '{1}' from private module '{2}'." },
        Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_private_name_1: { code: 4070, category: 1 /* Error */, key: "Parameter '{0}' of public static method from exported class has or is using private name '{1}'." },
        Parameter_0_of_public_method_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: { code: 4071, category: 1 /* Error */, key: "Parameter '{0}' of public method from exported class has or is using name '{1}' from external module {2} but cannot be named." },
        Parameter_0_of_public_method_from_exported_class_has_or_is_using_name_1_from_private_module_2: { code: 4072, category: 1 /* Error */, key: "Parameter '{0}' of public method from exported class has or is using name '{1}' from private module '{2}'." },
        Parameter_0_of_public_method_from_exported_class_has_or_is_using_private_name_1: { code: 4073, category: 1 /* Error */, key: "Parameter '{0}' of public method from exported class has or is using private name '{1}'." },
        Parameter_0_of_method_from_exported_interface_has_or_is_using_name_1_from_private_module_2: { code: 4074, category: 1 /* Error */, key: "Parameter '{0}' of method from exported interface has or is using name '{1}' from private module '{2}'." },
        Parameter_0_of_method_from_exported_interface_has_or_is_using_private_name_1: { code: 4075, category: 1 /* Error */, key: "Parameter '{0}' of method from exported interface has or is using private name '{1}'." },
        Parameter_0_of_exported_function_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: { code: 4076, category: 1 /* Error */, key: "Parameter '{0}' of exported function has or is using name '{1}' from external module {2} but cannot be named." },
        Parameter_0_of_exported_function_has_or_is_using_name_1_from_private_module_2: { code: 4077, category: 1 /* Error */, key: "Parameter '{0}' of exported function has or is using name '{1}' from private module '{2}'." },
        Parameter_0_of_exported_function_has_or_is_using_private_name_1: { code: 4078, category: 1 /* Error */, key: "Parameter '{0}' of exported function has or is using private name '{1}'." },
        The_current_host_does_not_support_the_0_option: { code: 5001, category: 1 /* Error */, key: "The current host does not support the '{0}' option." },
        Cannot_find_the_common_subdirectory_path_for_the_input_files: { code: 5009, category: 1 /* Error */, key: "Cannot find the common subdirectory path for the input files." },
        Cannot_read_file_0_Colon_1: { code: 5012, category: 1 /* Error */, key: "Cannot read file '{0}': {1}" },
        Unsupported_file_encoding: { code: 5013, category: 1 /* Error */, key: "Unsupported file encoding." },
        Unknown_compiler_option_0: { code: 5023, category: 1 /* Error */, key: "Unknown compiler option '{0}'." },
        Could_not_write_file_0_Colon_1: { code: 5033, category: 1 /* Error */, key: "Could not write file '{0}': {1}" },
        Option_mapRoot_cannot_be_specified_without_specifying_sourcemap_option: { code: 5038, category: 1 /* Error */, key: "Option mapRoot cannot be specified without specifying sourcemap option." },
        Option_sourceRoot_cannot_be_specified_without_specifying_sourcemap_option: { code: 5039, category: 1 /* Error */, key: "Option sourceRoot cannot be specified without specifying sourcemap option." },
        Concatenate_and_emit_output_to_single_file: { code: 6001, category: 2 /* Message */, key: "Concatenate and emit output to single file." },
        Generates_corresponding_d_ts_file: { code: 6002, category: 2 /* Message */, key: "Generates corresponding '.d.ts' file." },
        Specifies_the_location_where_debugger_should_locate_map_files_instead_of_generated_locations: { code: 6003, category: 2 /* Message */, key: "Specifies the location where debugger should locate map files instead of generated locations." },
        Specifies_the_location_where_debugger_should_locate_TypeScript_files_instead_of_source_locations: { code: 6004, category: 2 /* Message */, key: "Specifies the location where debugger should locate TypeScript files instead of source locations." },
        Watch_input_files: { code: 6005, category: 2 /* Message */, key: "Watch input files." },
        Redirect_output_structure_to_the_directory: { code: 6006, category: 2 /* Message */, key: "Redirect output structure to the directory." },
        Do_not_emit_comments_to_output: { code: 6009, category: 2 /* Message */, key: "Do not emit comments to output." },
        Specify_ECMAScript_target_version_Colon_ES3_default_or_ES5: { code: 6015, category: 2 /* Message */, key: "Specify ECMAScript target version: 'ES3' (default), or 'ES5'" },
        Specify_module_code_generation_Colon_commonjs_or_amd: { code: 6016, category: 2 /* Message */, key: "Specify module code generation: 'commonjs' or 'amd'" },
        Print_this_message: { code: 6017, category: 2 /* Message */, key: "Print this message." },
        Print_the_compiler_s_version: { code: 6019, category: 2 /* Message */, key: "Print the compiler's version." },
        Syntax_Colon_0: { code: 6023, category: 2 /* Message */, key: "Syntax: {0}" },
        options: { code: 6024, category: 2 /* Message */, key: "options" },
        file: { code: 6025, category: 2 /* Message */, key: "file" },
        Examples_Colon_0: { code: 6026, category: 2 /* Message */, key: "Examples: {0}" },
        Options_Colon: { code: 6027, category: 2 /* Message */, key: "Options:" },
        Version_0: { code: 6029, category: 2 /* Message */, key: "Version {0}" },
        Insert_command_line_options_and_files_from_a_file: { code: 6030, category: 2 /* Message */, key: "Insert command line options and files from a file." },
        File_change_detected_Compiling: { code: 6032, category: 2 /* Message */, key: "File change detected. Compiling..." },
        KIND: { code: 6034, category: 2 /* Message */, key: "KIND" },
        FILE: { code: 6035, category: 2 /* Message */, key: "FILE" },
        VERSION: { code: 6036, category: 2 /* Message */, key: "VERSION" },
        LOCATION: { code: 6037, category: 2 /* Message */, key: "LOCATION" },
        DIRECTORY: { code: 6038, category: 2 /* Message */, key: "DIRECTORY" },
        Compilation_complete_Watching_for_file_changes: { code: 6042, category: 2 /* Message */, key: "Compilation complete. Watching for file changes." },
        Generates_corresponding_map_file: { code: 6043, category: 2 /* Message */, key: "Generates corresponding '.map' file." },
        Compiler_option_0_expects_an_argument: { code: 6044, category: 1 /* Error */, key: "Compiler option '{0}' expects an argument." },
        Unterminated_quoted_string_in_response_file_0: { code: 6045, category: 1 /* Error */, key: "Unterminated quoted string in response file '{0}'." },
        Argument_for_module_option_must_be_commonjs_or_amd: { code: 6046, category: 1 /* Error */, key: "Argument for '--module' option must be 'commonjs' or 'amd'." },
        Argument_for_target_option_must_be_es3_or_es5: { code: 6047, category: 1 /* Error */, key: "Argument for '--target' option must be 'es3' or 'es5'." },
        Locale_must_be_of_the_form_language_or_language_territory_For_example_0_or_1: { code: 6048, category: 1 /* Error */, key: "Locale must be of the form <language> or <language>-<territory>. For example '{0}' or '{1}'." },
        Unsupported_locale_0: { code: 6049, category: 1 /* Error */, key: "Unsupported locale '{0}'." },
        Unable_to_open_file_0: { code: 6050, category: 1 /* Error */, key: "Unable to open file '{0}'." },
        Corrupted_locale_file_0: { code: 6051, category: 1 /* Error */, key: "Corrupted locale file {0}." },
        Warn_on_expressions_and_declarations_with_an_implied_any_type: { code: 6052, category: 2 /* Message */, key: "Warn on expressions and declarations with an implied 'any' type." },
        File_0_not_found: { code: 6053, category: 1 /* Error */, key: "File '{0}' not found." },
        File_0_must_have_extension_ts_or_d_ts: { code: 6054, category: 1 /* Error */, key: "File '{0}' must have extension '.ts' or '.d.ts'." },
        Variable_0_implicitly_has_an_1_type: { code: 7005, category: 1 /* Error */, key: "Variable '{0}' implicitly has an '{1}' type." },
        Parameter_0_implicitly_has_an_1_type: { code: 7006, category: 1 /* Error */, key: "Parameter '{0}' implicitly has an '{1}' type." },
        Member_0_implicitly_has_an_1_type: { code: 7008, category: 1 /* Error */, key: "Member '{0}' implicitly has an '{1}' type." },
        new_expression_whose_target_lacks_a_construct_signature_implicitly_has_an_any_type: { code: 7009, category: 1 /* Error */, key: "'new' expression, whose target lacks a construct signature, implicitly has an 'any' type." },
        _0_which_lacks_return_type_annotation_implicitly_has_an_1_return_type: { code: 7010, category: 1 /* Error */, key: "'{0}', which lacks return-type annotation, implicitly has an '{1}' return type." },
        Function_expression_which_lacks_return_type_annotation_implicitly_has_an_0_return_type: { code: 7011, category: 1 /* Error */, key: "Function expression, which lacks return-type annotation, implicitly has an '{0}' return type." },
        Construct_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type: { code: 7013, category: 1 /* Error */, key: "Construct signature, which lacks return-type annotation, implicitly has an 'any' return type." },
        Property_0_implicitly_has_type_any_because_its_set_accessor_lacks_a_type_annotation: { code: 7016, category: 1 /* Error */, key: "Property '{0}' implicitly has type 'any', because its 'set' accessor lacks a type annotation." },
        Index_signature_of_object_type_implicitly_has_an_any_type: { code: 7017, category: 1 /* Error */, key: "Index signature of object type implicitly has an 'any' type." },
        Object_literal_s_property_0_implicitly_has_an_1_type: { code: 7018, category: 1 /* Error */, key: "Object literal's property '{0}' implicitly has an '{1}' type." },
        Rest_parameter_0_implicitly_has_an_any_type: { code: 7019, category: 1 /* Error */, key: "Rest parameter '{0}' implicitly has an 'any[]' type." },
        Call_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type: { code: 7020, category: 1 /* Error */, key: "Call signature, which lacks return-type annotation, implicitly has an 'any' return type." },
        _0_implicitly_has_type_any_because_it_is_referenced_directly_or_indirectly_in_its_own_type_annotation: { code: 7021, category: 1 /* Error */, key: "'{0}' implicitly has type 'any' because it is referenced directly or indirectly in its own type annotation." },
        _0_implicitly_has_type_any_because_it_is_does_not_have_a_type_annotation_and_is_referenced_directly_or_indirectly_in_its_own_initializer: { code: 7022, category: 1 /* Error */, key: "'{0}' implicitly has type 'any' because it is does not have a type annotation and is referenced directly or indirectly in its own initializer." },
        _0_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_referenced_directly_or_indirectly_in_one_of_its_return_expressions: { code: 7023, category: 1 /* Error */, key: "'{0}' implicitly has return type 'any' because it does not have a return type annotation and is referenced directly or indirectly in one of its return expressions." },
        Function_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_referenced_directly_or_indirectly_in_one_of_its_return_expressions: { code: 7024, category: 1 /* Error */, key: "Function implicitly has return type 'any' because it does not have a return type annotation and is referenced directly or indirectly in one of its return expressions." },
        You_cannot_rename_this_element: { code: 8000, category: 1 /* Error */, key: "You cannot rename this element." }
    };
})(ts || (ts = {}));
/// <reference path="types.ts"/>
/// <reference path="core.ts"/>
/// <reference path="diagnosticInformationMap.generated.ts"/>
var ts;
(function (ts) {
    var textToToken = {
        "any": 105 /* AnyKeyword */,
        "boolean": 106 /* BooleanKeyword */,
        "break": 60 /* BreakKeyword */,
        "case": 61 /* CaseKeyword */,
        "catch": 62 /* CatchKeyword */,
        "class": 63 /* ClassKeyword */,
        "continue": 65 /* ContinueKeyword */,
        "const": 64 /* ConstKeyword */,
        "constructor": 107 /* ConstructorKeyword */,
        "debugger": 66 /* DebuggerKeyword */,
        "declare": 108 /* DeclareKeyword */,
        "default": 67 /* DefaultKeyword */,
        "delete": 68 /* DeleteKeyword */,
        "do": 69 /* DoKeyword */,
        "else": 70 /* ElseKeyword */,
        "enum": 71 /* EnumKeyword */,
        "export": 72 /* ExportKeyword */,
        "extends": 73 /* ExtendsKeyword */,
        "false": 74 /* FalseKeyword */,
        "finally": 75 /* FinallyKeyword */,
        "for": 76 /* ForKeyword */,
        "function": 77 /* FunctionKeyword */,
        "get": 109 /* GetKeyword */,
        "if": 78 /* IfKeyword */,
        "implements": 96 /* ImplementsKeyword */,
        "import": 79 /* ImportKeyword */,
        "in": 80 /* InKeyword */,
        "instanceof": 81 /* InstanceOfKeyword */,
        "interface": 97 /* InterfaceKeyword */,
        "let": 98 /* LetKeyword */,
        "module": 110 /* ModuleKeyword */,
        "new": 82 /* NewKeyword */,
        "null": 83 /* NullKeyword */,
        "number": 112 /* NumberKeyword */,
        "package": 99 /* PackageKeyword */,
        "private": 100 /* PrivateKeyword */,
        "protected": 101 /* ProtectedKeyword */,
        "public": 102 /* PublicKeyword */,
        "require": 111 /* RequireKeyword */,
        "return": 84 /* ReturnKeyword */,
        "set": 113 /* SetKeyword */,
        "static": 103 /* StaticKeyword */,
        "string": 114 /* StringKeyword */,
        "super": 85 /* SuperKeyword */,
        "switch": 86 /* SwitchKeyword */,
        "this": 87 /* ThisKeyword */,
        "throw": 88 /* ThrowKeyword */,
        "true": 89 /* TrueKeyword */,
        "try": 90 /* TryKeyword */,
        "typeof": 91 /* TypeOfKeyword */,
        "var": 92 /* VarKeyword */,
        "void": 93 /* VoidKeyword */,
        "while": 94 /* WhileKeyword */,
        "with": 95 /* WithKeyword */,
        "yield": 104 /* YieldKeyword */,
        "{": 9 /* OpenBraceToken */,
        "}": 10 /* CloseBraceToken */,
        "(": 11 /* OpenParenToken */,
        ")": 12 /* CloseParenToken */,
        "[": 13 /* OpenBracketToken */,
        "]": 14 /* CloseBracketToken */,
        ".": 15 /* DotToken */,
        "...": 16 /* DotDotDotToken */,
        ";": 17 /* SemicolonToken */,
        ",": 18 /* CommaToken */,
        "<": 19 /* LessThanToken */,
        ">": 20 /* GreaterThanToken */,
        "<=": 21 /* LessThanEqualsToken */,
        ">=": 22 /* GreaterThanEqualsToken */,
        "==": 23 /* EqualsEqualsToken */,
        "!=": 24 /* ExclamationEqualsToken */,
        "===": 25 /* EqualsEqualsEqualsToken */,
        "!==": 26 /* ExclamationEqualsEqualsToken */,
        "=>": 27 /* EqualsGreaterThanToken */,
        "+": 28 /* PlusToken */,
        "-": 29 /* MinusToken */,
        "*": 30 /* AsteriskToken */,
        "/": 31 /* SlashToken */,
        "%": 32 /* PercentToken */,
        "++": 33 /* PlusPlusToken */,
        "--": 34 /* MinusMinusToken */,
        "<<": 35 /* LessThanLessThanToken */,
        ">>": 36 /* GreaterThanGreaterThanToken */,
        ">>>": 37 /* GreaterThanGreaterThanGreaterThanToken */,
        "&": 38 /* AmpersandToken */,
        "|": 39 /* BarToken */,
        "^": 40 /* CaretToken */,
        "!": 41 /* ExclamationToken */,
        "~": 42 /* TildeToken */,
        "&&": 43 /* AmpersandAmpersandToken */,
        "||": 44 /* BarBarToken */,
        "?": 45 /* QuestionToken */,
        ":": 46 /* ColonToken */,
        "=": 47 /* EqualsToken */,
        "+=": 48 /* PlusEqualsToken */,
        "-=": 49 /* MinusEqualsToken */,
        "*=": 50 /* AsteriskEqualsToken */,
        "/=": 51 /* SlashEqualsToken */,
        "%=": 52 /* PercentEqualsToken */,
        "<<=": 53 /* LessThanLessThanEqualsToken */,
        ">>=": 54 /* GreaterThanGreaterThanEqualsToken */,
        ">>>=": 55 /* GreaterThanGreaterThanGreaterThanEqualsToken */,
        "&=": 56 /* AmpersandEqualsToken */,
        "|=": 57 /* BarEqualsToken */,
        "^=": 58 /* CaretEqualsToken */
    };
    /*
        As per ECMAScript Language Specification 3th Edition, Section 7.6: Identifiers
        IdentifierStart ::
            Can contain Unicode 3.0.0  categories:
            Uppercase letter (Lu),
            Lowercase letter (Ll),
            Titlecase letter (Lt),
            Modifier letter (Lm),
            Other letter (Lo), or
            Letter number (Nl).
        IdentifierPart :: =
            Can contain IdentifierStart + Unicode 3.0.0  categories:
            Non-spacing mark (Mn),
            Combining spacing mark (Mc),
            Decimal number (Nd), or
            Connector punctuation (Pc).

        Codepoint ranges for ES3 Identifiers are extracted from the Unicode 3.0.0 specification at:
        http://www.unicode.org/Public/3.0-Update/UnicodeData-3.0.0.txt
    */
    var unicodeES3IdentifierStart = [170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 543, 546, 563, 592, 685, 688, 696, 699, 705, 720, 721, 736, 740, 750, 750, 890, 890, 902, 902, 904, 906, 908, 908, 910, 929, 931, 974, 976, 983, 986, 1011, 1024, 1153, 1164, 1220, 1223, 1224, 1227, 1228, 1232, 1269, 1272, 1273, 1329, 1366, 1369, 1369, 1377, 1415, 1488, 1514, 1520, 1522, 1569, 1594, 1600, 1610, 1649, 1747, 1749, 1749, 1765, 1766, 1786, 1788, 1808, 1808, 1810, 1836, 1920, 1957, 2309, 2361, 2365, 2365, 2384, 2384, 2392, 2401, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2524, 2525, 2527, 2529, 2544, 2545, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616, 2617, 2649, 2652, 2654, 2654, 2674, 2676, 2693, 2699, 2701, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2749, 2749, 2768, 2768, 2784, 2784, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2870, 2873, 2877, 2877, 2908, 2909, 2911, 2913, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 2997, 2999, 3001, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123, 3125, 3129, 3168, 3169, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3294, 3294, 3296, 3297, 3333, 3340, 3342, 3344, 3346, 3368, 3370, 3385, 3424, 3425, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3585, 3632, 3634, 3635, 3648, 3654, 3713, 3714, 3716, 3716, 3719, 3720, 3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757, 3760, 3762, 3763, 3773, 3773, 3776, 3780, 3782, 3782, 3804, 3805, 3840, 3840, 3904, 3911, 3913, 3946, 3976, 3979, 4096, 4129, 4131, 4135, 4137, 4138, 4176, 4181, 4256, 4293, 4304, 4342, 4352, 4441, 4447, 4514, 4520, 4601, 4608, 4614, 4616, 4678, 4680, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4742, 4744, 4744, 4746, 4749, 4752, 4782, 4784, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4814, 4816, 4822, 4824, 4846, 4848, 4878, 4880, 4880, 4882, 4885, 4888, 4894, 4896, 4934, 4936, 4954, 5024, 5108, 5121, 5740, 5743, 5750, 5761, 5786, 5792, 5866, 6016, 6067, 6176, 6263, 6272, 6312, 7680, 7835, 7840, 7929, 7936, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8319, 8319, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8473, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8495, 8497, 8499, 8505, 8544, 8579, 12293, 12295, 12321, 12329, 12337, 12341, 12344, 12346, 12353, 12436, 12445, 12446, 12449, 12538, 12540, 12542, 12549, 12588, 12593, 12686, 12704, 12727, 13312, 19893, 19968, 40869, 40960, 42124, 44032, 55203, 63744, 64045, 64256, 64262, 64275, 64279, 64285, 64285, 64287, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019, 65136, 65138, 65140, 65140, 65142, 65276, 65313, 65338, 65345, 65370, 65382, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500, ];
    var unicodeES3IdentifierPart = [170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 543, 546, 563, 592, 685, 688, 696, 699, 705, 720, 721, 736, 740, 750, 750, 768, 846, 864, 866, 890, 890, 902, 902, 904, 906, 908, 908, 910, 929, 931, 974, 976, 983, 986, 1011, 1024, 1153, 1155, 1158, 1164, 1220, 1223, 1224, 1227, 1228, 1232, 1269, 1272, 1273, 1329, 1366, 1369, 1369, 1377, 1415, 1425, 1441, 1443, 1465, 1467, 1469, 1471, 1471, 1473, 1474, 1476, 1476, 1488, 1514, 1520, 1522, 1569, 1594, 1600, 1621, 1632, 1641, 1648, 1747, 1749, 1756, 1759, 1768, 1770, 1773, 1776, 1788, 1808, 1836, 1840, 1866, 1920, 1968, 2305, 2307, 2309, 2361, 2364, 2381, 2384, 2388, 2392, 2403, 2406, 2415, 2433, 2435, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2492, 2492, 2494, 2500, 2503, 2504, 2507, 2509, 2519, 2519, 2524, 2525, 2527, 2531, 2534, 2545, 2562, 2562, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616, 2617, 2620, 2620, 2622, 2626, 2631, 2632, 2635, 2637, 2649, 2652, 2654, 2654, 2662, 2676, 2689, 2691, 2693, 2699, 2701, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2748, 2757, 2759, 2761, 2763, 2765, 2768, 2768, 2784, 2784, 2790, 2799, 2817, 2819, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2870, 2873, 2876, 2883, 2887, 2888, 2891, 2893, 2902, 2903, 2908, 2909, 2911, 2913, 2918, 2927, 2946, 2947, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 2997, 2999, 3001, 3006, 3010, 3014, 3016, 3018, 3021, 3031, 3031, 3047, 3055, 3073, 3075, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123, 3125, 3129, 3134, 3140, 3142, 3144, 3146, 3149, 3157, 3158, 3168, 3169, 3174, 3183, 3202, 3203, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3262, 3268, 3270, 3272, 3274, 3277, 3285, 3286, 3294, 3294, 3296, 3297, 3302, 3311, 3330, 3331, 3333, 3340, 3342, 3344, 3346, 3368, 3370, 3385, 3390, 3395, 3398, 3400, 3402, 3405, 3415, 3415, 3424, 3425, 3430, 3439, 3458, 3459, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3530, 3530, 3535, 3540, 3542, 3542, 3544, 3551, 3570, 3571, 3585, 3642, 3648, 3662, 3664, 3673, 3713, 3714, 3716, 3716, 3719, 3720, 3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757, 3769, 3771, 3773, 3776, 3780, 3782, 3782, 3784, 3789, 3792, 3801, 3804, 3805, 3840, 3840, 3864, 3865, 3872, 3881, 3893, 3893, 3895, 3895, 3897, 3897, 3902, 3911, 3913, 3946, 3953, 3972, 3974, 3979, 3984, 3991, 3993, 4028, 4038, 4038, 4096, 4129, 4131, 4135, 4137, 4138, 4140, 4146, 4150, 4153, 4160, 4169, 4176, 4185, 4256, 4293, 4304, 4342, 4352, 4441, 4447, 4514, 4520, 4601, 4608, 4614, 4616, 4678, 4680, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4742, 4744, 4744, 4746, 4749, 4752, 4782, 4784, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4814, 4816, 4822, 4824, 4846, 4848, 4878, 4880, 4880, 4882, 4885, 4888, 4894, 4896, 4934, 4936, 4954, 4969, 4977, 5024, 5108, 5121, 5740, 5743, 5750, 5761, 5786, 5792, 5866, 6016, 6099, 6112, 6121, 6160, 6169, 6176, 6263, 6272, 6313, 7680, 7835, 7840, 7929, 7936, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8255, 8256, 8319, 8319, 8400, 8412, 8417, 8417, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8473, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8495, 8497, 8499, 8505, 8544, 8579, 12293, 12295, 12321, 12335, 12337, 12341, 12344, 12346, 12353, 12436, 12441, 12442, 12445, 12446, 12449, 12542, 12549, 12588, 12593, 12686, 12704, 12727, 13312, 19893, 19968, 40869, 40960, 42124, 44032, 55203, 63744, 64045, 64256, 64262, 64275, 64279, 64285, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019, 65056, 65059, 65075, 65076, 65101, 65103, 65136, 65138, 65140, 65140, 65142, 65276, 65296, 65305, 65313, 65338, 65343, 65343, 65345, 65370, 65381, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500, ];
    /*
        As per ECMAScript Language Specification 5th Edition, Section 7.6: ISyntaxToken Names and Identifiers
        IdentifierStart ::
            Can contain Unicode 6.2  categories:
            Uppercase letter (Lu),
            Lowercase letter (Ll),
            Titlecase letter (Lt),
            Modifier letter (Lm),
            Other letter (Lo), or
            Letter number (Nl).
        IdentifierPart ::
            Can contain IdentifierStart + Unicode 6.2  categories:
            Non-spacing mark (Mn),
            Combining spacing mark (Mc),
            Decimal number (Nd),
            Connector punctuation (Pc),
            <ZWNJ>, or
            <ZWJ>.

        Codepoint ranges for ES5 Identifiers are extracted from the Unicode 6.2 specification at:
        http://www.unicode.org/Public/6.2.0/ucd/UnicodeData.txt
    */
    var unicodeES5IdentifierStart = [170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 705, 710, 721, 736, 740, 748, 748, 750, 750, 880, 884, 886, 887, 890, 893, 902, 902, 904, 906, 908, 908, 910, 929, 931, 1013, 1015, 1153, 1162, 1319, 1329, 1366, 1369, 1369, 1377, 1415, 1488, 1514, 1520, 1522, 1568, 1610, 1646, 1647, 1649, 1747, 1749, 1749, 1765, 1766, 1774, 1775, 1786, 1788, 1791, 1791, 1808, 1808, 1810, 1839, 1869, 1957, 1969, 1969, 1994, 2026, 2036, 2037, 2042, 2042, 2048, 2069, 2074, 2074, 2084, 2084, 2088, 2088, 2112, 2136, 2208, 2208, 2210, 2220, 2308, 2361, 2365, 2365, 2384, 2384, 2392, 2401, 2417, 2423, 2425, 2431, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2493, 2493, 2510, 2510, 2524, 2525, 2527, 2529, 2544, 2545, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616, 2617, 2649, 2652, 2654, 2654, 2674, 2676, 2693, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2749, 2749, 2768, 2768, 2784, 2785, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2869, 2873, 2877, 2877, 2908, 2909, 2911, 2913, 2929, 2929, 2947, 2947, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 3001, 3024, 3024, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123, 3125, 3129, 3133, 3133, 3160, 3161, 3168, 3169, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3261, 3261, 3294, 3294, 3296, 3297, 3313, 3314, 3333, 3340, 3342, 3344, 3346, 3386, 3389, 3389, 3406, 3406, 3424, 3425, 3450, 3455, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3585, 3632, 3634, 3635, 3648, 3654, 3713, 3714, 3716, 3716, 3719, 3720, 3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757, 3760, 3762, 3763, 3773, 3773, 3776, 3780, 3782, 3782, 3804, 3807, 3840, 3840, 3904, 3911, 3913, 3948, 3976, 3980, 4096, 4138, 4159, 4159, 4176, 4181, 4186, 4189, 4193, 4193, 4197, 4198, 4206, 4208, 4213, 4225, 4238, 4238, 4256, 4293, 4295, 4295, 4301, 4301, 4304, 4346, 4348, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4744, 4746, 4749, 4752, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4822, 4824, 4880, 4882, 4885, 4888, 4954, 4992, 5007, 5024, 5108, 5121, 5740, 5743, 5759, 5761, 5786, 5792, 5866, 5870, 5872, 5888, 5900, 5902, 5905, 5920, 5937, 5952, 5969, 5984, 5996, 5998, 6000, 6016, 6067, 6103, 6103, 6108, 6108, 6176, 6263, 6272, 6312, 6314, 6314, 6320, 6389, 6400, 6428, 6480, 6509, 6512, 6516, 6528, 6571, 6593, 6599, 6656, 6678, 6688, 6740, 6823, 6823, 6917, 6963, 6981, 6987, 7043, 7072, 7086, 7087, 7098, 7141, 7168, 7203, 7245, 7247, 7258, 7293, 7401, 7404, 7406, 7409, 7413, 7414, 7424, 7615, 7680, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8305, 8305, 8319, 8319, 8336, 8348, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8473, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8495, 8505, 8508, 8511, 8517, 8521, 8526, 8526, 8544, 8584, 11264, 11310, 11312, 11358, 11360, 11492, 11499, 11502, 11506, 11507, 11520, 11557, 11559, 11559, 11565, 11565, 11568, 11623, 11631, 11631, 11648, 11670, 11680, 11686, 11688, 11694, 11696, 11702, 11704, 11710, 11712, 11718, 11720, 11726, 11728, 11734, 11736, 11742, 11823, 11823, 12293, 12295, 12321, 12329, 12337, 12341, 12344, 12348, 12353, 12438, 12445, 12447, 12449, 12538, 12540, 12543, 12549, 12589, 12593, 12686, 12704, 12730, 12784, 12799, 13312, 19893, 19968, 40908, 40960, 42124, 42192, 42237, 42240, 42508, 42512, 42527, 42538, 42539, 42560, 42606, 42623, 42647, 42656, 42735, 42775, 42783, 42786, 42888, 42891, 42894, 42896, 42899, 42912, 42922, 43000, 43009, 43011, 43013, 43015, 43018, 43020, 43042, 43072, 43123, 43138, 43187, 43250, 43255, 43259, 43259, 43274, 43301, 43312, 43334, 43360, 43388, 43396, 43442, 43471, 43471, 43520, 43560, 43584, 43586, 43588, 43595, 43616, 43638, 43642, 43642, 43648, 43695, 43697, 43697, 43701, 43702, 43705, 43709, 43712, 43712, 43714, 43714, 43739, 43741, 43744, 43754, 43762, 43764, 43777, 43782, 43785, 43790, 43793, 43798, 43808, 43814, 43816, 43822, 43968, 44002, 44032, 55203, 55216, 55238, 55243, 55291, 63744, 64109, 64112, 64217, 64256, 64262, 64275, 64279, 64285, 64285, 64287, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019, 65136, 65140, 65142, 65276, 65313, 65338, 65345, 65370, 65382, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500, ];
    var unicodeES5IdentifierPart = [170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 705, 710, 721, 736, 740, 748, 748, 750, 750, 768, 884, 886, 887, 890, 893, 902, 902, 904, 906, 908, 908, 910, 929, 931, 1013, 1015, 1153, 1155, 1159, 1162, 1319, 1329, 1366, 1369, 1369, 1377, 1415, 1425, 1469, 1471, 1471, 1473, 1474, 1476, 1477, 1479, 1479, 1488, 1514, 1520, 1522, 1552, 1562, 1568, 1641, 1646, 1747, 1749, 1756, 1759, 1768, 1770, 1788, 1791, 1791, 1808, 1866, 1869, 1969, 1984, 2037, 2042, 2042, 2048, 2093, 2112, 2139, 2208, 2208, 2210, 2220, 2276, 2302, 2304, 2403, 2406, 2415, 2417, 2423, 2425, 2431, 2433, 2435, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2492, 2500, 2503, 2504, 2507, 2510, 2519, 2519, 2524, 2525, 2527, 2531, 2534, 2545, 2561, 2563, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616, 2617, 2620, 2620, 2622, 2626, 2631, 2632, 2635, 2637, 2641, 2641, 2649, 2652, 2654, 2654, 2662, 2677, 2689, 2691, 2693, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2748, 2757, 2759, 2761, 2763, 2765, 2768, 2768, 2784, 2787, 2790, 2799, 2817, 2819, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2869, 2873, 2876, 2884, 2887, 2888, 2891, 2893, 2902, 2903, 2908, 2909, 2911, 2915, 2918, 2927, 2929, 2929, 2946, 2947, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 3001, 3006, 3010, 3014, 3016, 3018, 3021, 3024, 3024, 3031, 3031, 3046, 3055, 3073, 3075, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123, 3125, 3129, 3133, 3140, 3142, 3144, 3146, 3149, 3157, 3158, 3160, 3161, 3168, 3171, 3174, 3183, 3202, 3203, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3260, 3268, 3270, 3272, 3274, 3277, 3285, 3286, 3294, 3294, 3296, 3299, 3302, 3311, 3313, 3314, 3330, 3331, 3333, 3340, 3342, 3344, 3346, 3386, 3389, 3396, 3398, 3400, 3402, 3406, 3415, 3415, 3424, 3427, 3430, 3439, 3450, 3455, 3458, 3459, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3530, 3530, 3535, 3540, 3542, 3542, 3544, 3551, 3570, 3571, 3585, 3642, 3648, 3662, 3664, 3673, 3713, 3714, 3716, 3716, 3719, 3720, 3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757, 3769, 3771, 3773, 3776, 3780, 3782, 3782, 3784, 3789, 3792, 3801, 3804, 3807, 3840, 3840, 3864, 3865, 3872, 3881, 3893, 3893, 3895, 3895, 3897, 3897, 3902, 3911, 3913, 3948, 3953, 3972, 3974, 3991, 3993, 4028, 4038, 4038, 4096, 4169, 4176, 4253, 4256, 4293, 4295, 4295, 4301, 4301, 4304, 4346, 4348, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4744, 4746, 4749, 4752, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4822, 4824, 4880, 4882, 4885, 4888, 4954, 4957, 4959, 4992, 5007, 5024, 5108, 5121, 5740, 5743, 5759, 5761, 5786, 5792, 5866, 5870, 5872, 5888, 5900, 5902, 5908, 5920, 5940, 5952, 5971, 5984, 5996, 5998, 6000, 6002, 6003, 6016, 6099, 6103, 6103, 6108, 6109, 6112, 6121, 6155, 6157, 6160, 6169, 6176, 6263, 6272, 6314, 6320, 6389, 6400, 6428, 6432, 6443, 6448, 6459, 6470, 6509, 6512, 6516, 6528, 6571, 6576, 6601, 6608, 6617, 6656, 6683, 6688, 6750, 6752, 6780, 6783, 6793, 6800, 6809, 6823, 6823, 6912, 6987, 6992, 7001, 7019, 7027, 7040, 7155, 7168, 7223, 7232, 7241, 7245, 7293, 7376, 7378, 7380, 7414, 7424, 7654, 7676, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8204, 8205, 8255, 8256, 8276, 8276, 8305, 8305, 8319, 8319, 8336, 8348, 8400, 8412, 8417, 8417, 8421, 8432, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8473, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8495, 8505, 8508, 8511, 8517, 8521, 8526, 8526, 8544, 8584, 11264, 11310, 11312, 11358, 11360, 11492, 11499, 11507, 11520, 11557, 11559, 11559, 11565, 11565, 11568, 11623, 11631, 11631, 11647, 11670, 11680, 11686, 11688, 11694, 11696, 11702, 11704, 11710, 11712, 11718, 11720, 11726, 11728, 11734, 11736, 11742, 11744, 11775, 11823, 11823, 12293, 12295, 12321, 12335, 12337, 12341, 12344, 12348, 12353, 12438, 12441, 12442, 12445, 12447, 12449, 12538, 12540, 12543, 12549, 12589, 12593, 12686, 12704, 12730, 12784, 12799, 13312, 19893, 19968, 40908, 40960, 42124, 42192, 42237, 42240, 42508, 42512, 42539, 42560, 42607, 42612, 42621, 42623, 42647, 42655, 42737, 42775, 42783, 42786, 42888, 42891, 42894, 42896, 42899, 42912, 42922, 43000, 43047, 43072, 43123, 43136, 43204, 43216, 43225, 43232, 43255, 43259, 43259, 43264, 43309, 43312, 43347, 43360, 43388, 43392, 43456, 43471, 43481, 43520, 43574, 43584, 43597, 43600, 43609, 43616, 43638, 43642, 43643, 43648, 43714, 43739, 43741, 43744, 43759, 43762, 43766, 43777, 43782, 43785, 43790, 43793, 43798, 43808, 43814, 43816, 43822, 43968, 44010, 44012, 44013, 44016, 44025, 44032, 55203, 55216, 55238, 55243, 55291, 63744, 64109, 64112, 64217, 64256, 64262, 64275, 64279, 64285, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019, 65024, 65039, 65056, 65062, 65075, 65076, 65101, 65103, 65136, 65140, 65142, 65276, 65296, 65305, 65313, 65338, 65343, 65343, 65345, 65370, 65382, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500, ];
    function lookupInUnicodeMap(code, map) {
        // Bail out quickly if it couldn't possibly be in the map.
        if (code < map[0]) {
            return false;
        }
        // Perform binary search in one of the Unicode range maps
        var lo = 0;
        var hi = map.length;
        var mid;
        while (lo + 1 < hi) {
            mid = lo + (hi - lo) / 2;
            // mid has to be even to catch a range's beginning
            mid -= mid % 2;
            if (map[mid] <= code && code <= map[mid + 1]) {
                return true;
            }
            if (code < map[mid]) {
                hi = mid;
            }
            else {
                lo = mid + 2;
            }
        }
        return false;
    }
    function isUnicodeIdentifierStart(code, languageVersion) {
        return languageVersion === 0 /* ES3 */ ? lookupInUnicodeMap(code, unicodeES3IdentifierStart) : lookupInUnicodeMap(code, unicodeES5IdentifierStart);
    }
    function isUnicodeIdentifierPart(code, languageVersion) {
        return languageVersion === 0 /* ES3 */ ? lookupInUnicodeMap(code, unicodeES3IdentifierPart) : lookupInUnicodeMap(code, unicodeES5IdentifierPart);
    }
    function makeReverseMap(source) {
        var result = [];
        for (var name in source) {
            if (source.hasOwnProperty(name)) {
                result[source[name]] = name;
            }
        }
        return result;
    }
    var tokenStrings = makeReverseMap(textToToken);
    function tokenToString(t) {
        return tokenStrings[t];
    }
    ts.tokenToString = tokenToString;
    function getLineStarts(text) {
        var result = new Array();
        var pos = 0;
        var lineStart = 0;
        while (pos < text.length) {
            var ch = text.charCodeAt(pos++);
            switch (ch) {
                case 13 /* carriageReturn */:
                    if (text.charCodeAt(pos) === 10 /* lineFeed */) {
                        pos++;
                    }
                case 10 /* lineFeed */:
                    result.push(lineStart);
                    lineStart = pos;
                    break;
                default:
                    if (ch > 127 /* maxAsciiCharacter */ && isLineBreak(ch)) {
                        result.push(lineStart);
                        lineStart = pos;
                    }
                    break;
            }
        }
        result.push(lineStart);
        return result;
    }
    ts.getLineStarts = getLineStarts;
    function getPositionFromLineAndCharacter(lineStarts, line, character) {
        ts.Debug.assert(line > 0);
        return lineStarts[line - 1] + character - 1;
    }
    ts.getPositionFromLineAndCharacter = getPositionFromLineAndCharacter;
    function getLineAndCharacterOfPosition(lineStarts, position) {
        var lineNumber = ts.binarySearch(lineStarts, position);
        if (lineNumber < 0) {
            // If the actual position was not found, 
            // the binary search returns the negative value of the next line start
            // e.g. if the line starts at [5, 10, 23, 80] and the position requested was 20
            // then the search will return -2
            lineNumber = (~lineNumber) - 1;
        }
        return {
            line: lineNumber + 1,
            character: position - lineStarts[lineNumber] + 1
        };
    }
    ts.getLineAndCharacterOfPosition = getLineAndCharacterOfPosition;
    function positionToLineAndCharacter(text, pos) {
        var lineStarts = getLineStarts(text);
        return getLineAndCharacterOfPosition(lineStarts, pos);
    }
    ts.positionToLineAndCharacter = positionToLineAndCharacter;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    function isWhiteSpace(ch) {
        return ch === 32 /* space */ || ch === 9 /* tab */ || ch === 11 /* verticalTab */ || ch === 12 /* formFeed */ || ch === 160 /* nonBreakingSpace */ || ch === 5760 /* ogham */ || ch >= 8192 /* enQuad */ && ch <= 8203 /* zeroWidthSpace */ || ch === 8239 /* narrowNoBreakSpace */ || ch === 8287 /* mathematicalSpace */ || ch === 12288 /* ideographicSpace */ || ch === 65279 /* byteOrderMark */;
    }
    ts.isWhiteSpace = isWhiteSpace;
    function isLineBreak(ch) {
        return ch === 10 /* lineFeed */ || ch === 13 /* carriageReturn */ || ch === 8232 /* lineSeparator */ || ch === 8233 /* paragraphSeparator */ || ch === 133 /* nextLine */;
    }
    ts.isLineBreak = isLineBreak;
    function isDigit(ch) {
        return ch >= 48 /* _0 */ && ch <= 57 /* _9 */;
    }
    function isOctalDigit(ch) {
        return ch >= 48 /* _0 */ && ch <= 55 /* _7 */;
    }
    ts.isOctalDigit = isOctalDigit;
    function skipTrivia(text, pos, stopAfterLineBreak) {
        while (true) {
            var ch = text.charCodeAt(pos);
            switch (ch) {
                case 13 /* carriageReturn */:
                    if (text.charCodeAt(pos + 1) === 10 /* lineFeed */)
                        pos++;
                case 10 /* lineFeed */:
                    pos++;
                    if (stopAfterLineBreak)
                        return pos;
                    continue;
                case 9 /* tab */:
                case 11 /* verticalTab */:
                case 12 /* formFeed */:
                case 32 /* space */:
                    pos++;
                    continue;
                case 47 /* slash */:
                    if (text.charCodeAt(pos + 1) === 47 /* slash */) {
                        pos += 2;
                        while (pos < text.length) {
                            if (isLineBreak(text.charCodeAt(pos))) {
                                break;
                            }
                            pos++;
                        }
                        continue;
                    }
                    if (text.charCodeAt(pos + 1) === 42 /* asterisk */) {
                        pos += 2;
                        while (pos < text.length) {
                            if (text.charCodeAt(pos) === 42 /* asterisk */ && text.charCodeAt(pos + 1) === 47 /* slash */) {
                                pos += 2;
                                break;
                            }
                            pos++;
                        }
                        continue;
                    }
                    break;
                default:
                    if (ch > 127 /* maxAsciiCharacter */ && (isWhiteSpace(ch) || isLineBreak(ch))) {
                        pos++;
                        continue;
                    }
                    break;
            }
            return pos;
        }
    }
    ts.skipTrivia = skipTrivia;
    // Extract comments from the given source text starting at the given position. If trailing is false, whitespace is skipped until
    // the first line break and comments between that location and the next token are returned. If trailing is true, comments occurring
    // between the given position and the next line break are returned. The return value is an array containing a TextRange for each
    // comment. Single-line comment ranges include the beginning '//' characters but not the ending line break. Multi-line comment
    // ranges include the beginning '/* and ending '*/' characters. The return value is undefined if no comments were found.
    function getCommentRanges(text, pos, trailing) {
        var result;
        var collecting = trailing || pos === 0;
        while (true) {
            var ch = text.charCodeAt(pos);
            switch (ch) {
                case 13 /* carriageReturn */:
                    if (text.charCodeAt(pos + 1) === 10 /* lineFeed */)
                        pos++;
                case 10 /* lineFeed */:
                    pos++;
                    if (trailing) {
                        return result;
                    }
                    collecting = true;
                    if (result && result.length) {
                        result[result.length - 1].hasTrailingNewLine = true;
                    }
                    continue;
                case 9 /* tab */:
                case 11 /* verticalTab */:
                case 12 /* formFeed */:
                case 32 /* space */:
                    pos++;
                    continue;
                case 47 /* slash */:
                    var nextChar = text.charCodeAt(pos + 1);
                    var hasTrailingNewLine = false;
                    if (nextChar === 47 /* slash */ || nextChar === 42 /* asterisk */) {
                        var startPos = pos;
                        pos += 2;
                        if (nextChar === 47 /* slash */) {
                            while (pos < text.length) {
                                if (isLineBreak(text.charCodeAt(pos))) {
                                    hasTrailingNewLine = true;
                                    break;
                                }
                                pos++;
                            }
                        }
                        else {
                            while (pos < text.length) {
                                if (text.charCodeAt(pos) === 42 /* asterisk */ && text.charCodeAt(pos + 1) === 47 /* slash */) {
                                    pos += 2;
                                    break;
                                }
                                pos++;
                            }
                        }
                        if (collecting) {
                            if (!result)
                                result = [];
                            result.push({ pos: startPos, end: pos, hasTrailingNewLine: hasTrailingNewLine });
                        }
                        continue;
                    }
                    break;
                default:
                    if (ch > 127 /* maxAsciiCharacter */ && (isWhiteSpace(ch) || isLineBreak(ch))) {
                        if (result && result.length && isLineBreak(ch)) {
                            result[result.length - 1].hasTrailingNewLine = true;
                        }
                        pos++;
                        continue;
                    }
                    break;
            }
            return result;
        }
    }
    function getLeadingCommentRanges(text, pos) {
        return getCommentRanges(text, pos, false);
    }
    ts.getLeadingCommentRanges = getLeadingCommentRanges;
    function getTrailingCommentRanges(text, pos) {
        return getCommentRanges(text, pos, true);
    }
    ts.getTrailingCommentRanges = getTrailingCommentRanges;
    function isIdentifierStart(ch, languageVersion) {
        return ch >= 65 /* A */ && ch <= 90 /* Z */ || ch >= 97 /* a */ && ch <= 122 /* z */ || ch === 36 /* $ */ || ch === 95 /* _ */ || ch > 127 /* maxAsciiCharacter */ && isUnicodeIdentifierStart(ch, languageVersion);
    }
    ts.isIdentifierStart = isIdentifierStart;
    function isIdentifierPart(ch, languageVersion) {
        return ch >= 65 /* A */ && ch <= 90 /* Z */ || ch >= 97 /* a */ && ch <= 122 /* z */ || ch >= 48 /* _0 */ && ch <= 57 /* _9 */ || ch === 36 /* $ */ || ch === 95 /* _ */ || ch > 127 /* maxAsciiCharacter */ && isUnicodeIdentifierPart(ch, languageVersion);
    }
    ts.isIdentifierPart = isIdentifierPart;
    function createScanner(languageVersion, skipTrivia, text, onError, onComment) {
        var pos; // Current position (end position of text of current token)
        var len; // Length of text
        var startPos; // Start position of whitespace before current token
        var tokenPos; // Start position of text of current token
        var token;
        var tokenValue;
        var precedingLineBreak;
        function error(message) {
            if (onError) {
                onError(message);
            }
        }
        function isIdentifierStart(ch) {
            return ch >= 65 /* A */ && ch <= 90 /* Z */ || ch >= 97 /* a */ && ch <= 122 /* z */ || ch === 36 /* $ */ || ch === 95 /* _ */ || ch > 127 /* maxAsciiCharacter */ && isUnicodeIdentifierStart(ch, languageVersion);
        }
        function isIdentifierPart(ch) {
            return ch >= 65 /* A */ && ch <= 90 /* Z */ || ch >= 97 /* a */ && ch <= 122 /* z */ || ch >= 48 /* _0 */ && ch <= 57 /* _9 */ || ch === 36 /* $ */ || ch === 95 /* _ */ || ch > 127 /* maxAsciiCharacter */ && isUnicodeIdentifierPart(ch, languageVersion);
        }
        function scanNumber() {
            var start = pos;
            while (isDigit(text.charCodeAt(pos)))
                pos++;
            if (text.charCodeAt(pos) === 46 /* dot */) {
                pos++;
                while (isDigit(text.charCodeAt(pos)))
                    pos++;
            }
            var end = pos;
            if (text.charCodeAt(pos) === 69 /* E */ || text.charCodeAt(pos) === 101 /* e */) {
                pos++;
                if (text.charCodeAt(pos) === 43 /* plus */ || text.charCodeAt(pos) === 45 /* minus */)
                    pos++;
                if (isDigit(text.charCodeAt(pos))) {
                    pos++;
                    while (isDigit(text.charCodeAt(pos)))
                        pos++;
                    end = pos;
                }
                else {
                    error(ts.Diagnostics.Digit_expected);
                }
            }
            return +(text.substring(start, end));
        }
        function scanOctalDigits() {
            var start = pos;
            while (isOctalDigit(text.charCodeAt(pos))) {
                pos++;
            }
            return +(text.substring(start, pos));
        }
        function scanHexDigits(count, exact) {
            var digits = 0;
            var value = 0;
            while (digits < count || !exact) {
                var ch = text.charCodeAt(pos);
                if (ch >= 48 /* _0 */ && ch <= 57 /* _9 */) {
                    value = value * 16 + ch - 48 /* _0 */;
                }
                else if (ch >= 65 /* A */ && ch <= 70 /* F */) {
                    value = value * 16 + ch - 65 /* A */ + 10;
                }
                else if (ch >= 97 /* a */ && ch <= 102 /* f */) {
                    value = value * 16 + ch - 97 /* a */ + 10;
                }
                else {
                    break;
                }
                pos++;
                digits++;
            }
            if (digits < count) {
                value = -1;
            }
            return value;
        }
        function scanString() {
            var quote = text.charCodeAt(pos++);
            var result = "";
            var start = pos;
            while (true) {
                if (pos >= len) {
                    result += text.substring(start, pos);
                    error(ts.Diagnostics.Unexpected_end_of_text);
                    break;
                }
                var ch = text.charCodeAt(pos);
                if (ch === quote) {
                    result += text.substring(start, pos);
                    pos++;
                    break;
                }
                if (ch === 92 /* backslash */) {
                    result += text.substring(start, pos);
                    pos++;
                    if (pos >= len) {
                        error(ts.Diagnostics.Unexpected_end_of_text);
                        break;
                    }
                    ch = text.charCodeAt(pos++);
                    switch (ch) {
                        case 48 /* _0 */:
                            result += "\0";
                            break;
                        case 98 /* b */:
                            result += "\b";
                            break;
                        case 116 /* t */:
                            result += "\t";
                            break;
                        case 110 /* n */:
                            result += "\n";
                            break;
                        case 118 /* v */:
                            result += "\v";
                            break;
                        case 102 /* f */:
                            result += "\f";
                            break;
                        case 114 /* r */:
                            result += "\r";
                            break;
                        case 39 /* singleQuote */:
                            result += "\'";
                            break;
                        case 34 /* doubleQuote */:
                            result += "\"";
                            break;
                        case 120 /* x */:
                        case 117 /* u */:
                            var ch = scanHexDigits(ch === 120 /* x */ ? 2 : 4, true);
                            if (ch >= 0) {
                                result += String.fromCharCode(ch);
                            }
                            else {
                                error(ts.Diagnostics.Hexadecimal_digit_expected);
                            }
                            break;
                        case 13 /* carriageReturn */:
                            if (pos < len && text.charCodeAt(pos) === 10 /* lineFeed */)
                                pos++;
                            break;
                        case 10 /* lineFeed */:
                        case 8232 /* lineSeparator */:
                        case 8233 /* paragraphSeparator */:
                            break;
                        default:
                            result += String.fromCharCode(ch);
                    }
                    start = pos;
                    continue;
                }
                if (isLineBreak(ch)) {
                    result += text.substring(start, pos);
                    error(ts.Diagnostics.Unterminated_string_literal);
                    break;
                }
                pos++;
            }
            return result;
        }
        // Current character is known to be a backslash. Check for Unicode escape of the form '\uXXXX'
        // and return code point value if valid Unicode escape is found. Otherwise return -1.
        function peekUnicodeEscape() {
            if (pos + 5 < len && text.charCodeAt(pos + 1) === 117 /* u */) {
                var start = pos;
                pos += 2;
                var value = scanHexDigits(4, true);
                pos = start;
                return value;
            }
            return -1;
        }
        function scanIdentifierParts() {
            var result = "";
            var start = pos;
            while (pos < len) {
                var ch = text.charCodeAt(pos);
                if (isIdentifierPart(ch)) {
                    pos++;
                }
                else if (ch === 92 /* backslash */) {
                    ch = peekUnicodeEscape();
                    if (!(ch >= 0 && isIdentifierPart(ch))) {
                        break;
                    }
                    result += text.substring(start, pos);
                    result += String.fromCharCode(ch);
                    // Valid Unicode escape is always six characters
                    pos += 6;
                    start = pos;
                }
                else {
                    break;
                }
            }
            result += text.substring(start, pos);
            return result;
        }
        function getIdentifierToken() {
            // Reserved words are between 2 and 11 characters long and start with a lowercase letter
            var len = tokenValue.length;
            if (len >= 2 && len <= 11) {
                var ch = tokenValue.charCodeAt(0);
                if (ch >= 97 /* a */ && ch <= 122 /* z */ && hasOwnProperty.call(textToToken, tokenValue)) {
                    return token = textToToken[tokenValue];
                }
            }
            return token = 59 /* Identifier */;
        }
        function scan() {
            startPos = pos;
            precedingLineBreak = false;
            while (true) {
                tokenPos = pos;
                if (pos >= len) {
                    return token = 1 /* EndOfFileToken */;
                }
                var ch = text.charCodeAt(pos);
                switch (ch) {
                    case 10 /* lineFeed */:
                    case 13 /* carriageReturn */:
                        precedingLineBreak = true;
                        if (skipTrivia) {
                            pos++;
                            continue;
                        }
                        else {
                            if (ch === 13 /* carriageReturn */ && pos + 1 < len && text.charCodeAt(pos + 1) === 10 /* lineFeed */) {
                                // consume both CR and LF
                                pos += 2;
                            }
                            else {
                                pos++;
                            }
                            return token = 4 /* NewLineTrivia */;
                        }
                    case 9 /* tab */:
                    case 11 /* verticalTab */:
                    case 12 /* formFeed */:
                    case 32 /* space */:
                        if (skipTrivia) {
                            pos++;
                            continue;
                        }
                        else {
                            while (pos < len && isWhiteSpace(text.charCodeAt(pos))) {
                                pos++;
                            }
                            return token = 5 /* WhitespaceTrivia */;
                        }
                    case 33 /* exclamation */:
                        if (text.charCodeAt(pos + 1) === 61 /* equals */) {
                            if (text.charCodeAt(pos + 2) === 61 /* equals */) {
                                return pos += 3, token = 26 /* ExclamationEqualsEqualsToken */;
                            }
                            return pos += 2, token = 24 /* ExclamationEqualsToken */;
                        }
                        return pos++, token = 41 /* ExclamationToken */;
                    case 34 /* doubleQuote */:
                    case 39 /* singleQuote */:
                        tokenValue = scanString();
                        return token = 7 /* StringLiteral */;
                    case 37 /* percent */:
                        if (text.charCodeAt(pos + 1) === 61 /* equals */) {
                            return pos += 2, token = 52 /* PercentEqualsToken */;
                        }
                        return pos++, token = 32 /* PercentToken */;
                    case 38 /* ampersand */:
                        if (text.charCodeAt(pos + 1) === 38 /* ampersand */) {
                            return pos += 2, token = 43 /* AmpersandAmpersandToken */;
                        }
                        if (text.charCodeAt(pos + 1) === 61 /* equals */) {
                            return pos += 2, token = 56 /* AmpersandEqualsToken */;
                        }
                        return pos++, token = 38 /* AmpersandToken */;
                    case 40 /* openParen */:
                        return pos++, token = 11 /* OpenParenToken */;
                    case 41 /* closeParen */:
                        return pos++, token = 12 /* CloseParenToken */;
                    case 42 /* asterisk */:
                        if (text.charCodeAt(pos + 1) === 61 /* equals */) {
                            return pos += 2, token = 50 /* AsteriskEqualsToken */;
                        }
                        return pos++, token = 30 /* AsteriskToken */;
                    case 43 /* plus */:
                        if (text.charCodeAt(pos + 1) === 43 /* plus */) {
                            return pos += 2, token = 33 /* PlusPlusToken */;
                        }
                        if (text.charCodeAt(pos + 1) === 61 /* equals */) {
                            return pos += 2, token = 48 /* PlusEqualsToken */;
                        }
                        return pos++, token = 28 /* PlusToken */;
                    case 44 /* comma */:
                        return pos++, token = 18 /* CommaToken */;
                    case 45 /* minus */:
                        if (text.charCodeAt(pos + 1) === 45 /* minus */) {
                            return pos += 2, token = 34 /* MinusMinusToken */;
                        }
                        if (text.charCodeAt(pos + 1) === 61 /* equals */) {
                            return pos += 2, token = 49 /* MinusEqualsToken */;
                        }
                        return pos++, token = 29 /* MinusToken */;
                    case 46 /* dot */:
                        if (isDigit(text.charCodeAt(pos + 1))) {
                            tokenValue = "" + scanNumber();
                            return token = 6 /* NumericLiteral */;
                        }
                        if (text.charCodeAt(pos + 1) === 46 /* dot */ && text.charCodeAt(pos + 2) === 46 /* dot */) {
                            return pos += 3, token = 16 /* DotDotDotToken */;
                        }
                        return pos++, token = 15 /* DotToken */;
                    case 47 /* slash */:
                        // Single-line comment
                        if (text.charCodeAt(pos + 1) === 47 /* slash */) {
                            pos += 2;
                            while (pos < len) {
                                if (isLineBreak(text.charCodeAt(pos))) {
                                    break;
                                }
                                pos++;
                            }
                            if (onComment) {
                                onComment(tokenPos, pos);
                            }
                            if (skipTrivia) {
                                continue;
                            }
                            else {
                                return token = 2 /* SingleLineCommentTrivia */;
                            }
                        }
                        // Multi-line comment
                        if (text.charCodeAt(pos + 1) === 42 /* asterisk */) {
                            pos += 2;
                            var commentClosed = false;
                            while (pos < len) {
                                var ch = text.charCodeAt(pos);
                                if (ch === 42 /* asterisk */ && text.charCodeAt(pos + 1) === 47 /* slash */) {
                                    pos += 2;
                                    commentClosed = true;
                                    break;
                                }
                                if (isLineBreak(ch)) {
                                    precedingLineBreak = true;
                                }
                                pos++;
                            }
                            if (!commentClosed) {
                                error(ts.Diagnostics.Asterisk_Slash_expected);
                            }
                            if (onComment) {
                                onComment(tokenPos, pos);
                            }
                            if (skipTrivia) {
                                continue;
                            }
                            else {
                                return token = 3 /* MultiLineCommentTrivia */;
                            }
                        }
                        if (text.charCodeAt(pos + 1) === 61 /* equals */) {
                            return pos += 2, token = 51 /* SlashEqualsToken */;
                        }
                        return pos++, token = 31 /* SlashToken */;
                    case 48 /* _0 */:
                        if (pos + 2 < len && (text.charCodeAt(pos + 1) === 88 /* X */ || text.charCodeAt(pos + 1) === 120 /* x */)) {
                            pos += 2;
                            var value = scanHexDigits(1, false);
                            if (value < 0) {
                                error(ts.Diagnostics.Hexadecimal_digit_expected);
                                value = 0;
                            }
                            tokenValue = "" + value;
                            return 6 /* NumericLiteral */;
                        }
                        // Try to parse as an octal
                        if (pos + 1 < len && isOctalDigit(text.charCodeAt(pos + 1))) {
                            tokenValue = "" + scanOctalDigits();
                            return 6 /* NumericLiteral */;
                        }
                    case 49 /* _1 */:
                    case 50 /* _2 */:
                    case 51 /* _3 */:
                    case 52 /* _4 */:
                    case 53 /* _5 */:
                    case 54 /* _6 */:
                    case 55 /* _7 */:
                    case 56 /* _8 */:
                    case 57 /* _9 */:
                        tokenValue = "" + scanNumber();
                        return token = 6 /* NumericLiteral */;
                    case 58 /* colon */:
                        return pos++, token = 46 /* ColonToken */;
                    case 59 /* semicolon */:
                        return pos++, token = 17 /* SemicolonToken */;
                    case 60 /* lessThan */:
                        if (text.charCodeAt(pos + 1) === 60 /* lessThan */) {
                            if (text.charCodeAt(pos + 2) === 61 /* equals */) {
                                return pos += 3, token = 53 /* LessThanLessThanEqualsToken */;
                            }
                            return pos += 2, token = 35 /* LessThanLessThanToken */;
                        }
                        if (text.charCodeAt(pos + 1) === 61 /* equals */) {
                            return pos += 2, token = 21 /* LessThanEqualsToken */;
                        }
                        return pos++, token = 19 /* LessThanToken */;
                    case 61 /* equals */:
                        if (text.charCodeAt(pos + 1) === 61 /* equals */) {
                            if (text.charCodeAt(pos + 2) === 61 /* equals */) {
                                return pos += 3, token = 25 /* EqualsEqualsEqualsToken */;
                            }
                            return pos += 2, token = 23 /* EqualsEqualsToken */;
                        }
                        if (text.charCodeAt(pos + 1) === 62 /* greaterThan */) {
                            return pos += 2, token = 27 /* EqualsGreaterThanToken */;
                        }
                        return pos++, token = 47 /* EqualsToken */;
                    case 62 /* greaterThan */:
                        return pos++, token = 20 /* GreaterThanToken */;
                    case 63 /* question */:
                        return pos++, token = 45 /* QuestionToken */;
                    case 91 /* openBracket */:
                        return pos++, token = 13 /* OpenBracketToken */;
                    case 93 /* closeBracket */:
                        return pos++, token = 14 /* CloseBracketToken */;
                    case 94 /* caret */:
                        if (text.charCodeAt(pos + 1) === 61 /* equals */) {
                            return pos += 2, token = 58 /* CaretEqualsToken */;
                        }
                        return pos++, token = 40 /* CaretToken */;
                    case 123 /* openBrace */:
                        return pos++, token = 9 /* OpenBraceToken */;
                    case 124 /* bar */:
                        if (text.charCodeAt(pos + 1) === 124 /* bar */) {
                            return pos += 2, token = 44 /* BarBarToken */;
                        }
                        if (text.charCodeAt(pos + 1) === 61 /* equals */) {
                            return pos += 2, token = 57 /* BarEqualsToken */;
                        }
                        return pos++, token = 39 /* BarToken */;
                    case 125 /* closeBrace */:
                        return pos++, token = 10 /* CloseBraceToken */;
                    case 126 /* tilde */:
                        return pos++, token = 42 /* TildeToken */;
                    case 92 /* backslash */:
                        var ch = peekUnicodeEscape();
                        if (ch >= 0 && isIdentifierStart(ch)) {
                            pos += 6;
                            tokenValue = String.fromCharCode(ch) + scanIdentifierParts();
                            return token = getIdentifierToken();
                        }
                        error(ts.Diagnostics.Invalid_character);
                        return pos++, token = 0 /* Unknown */;
                    default:
                        if (isIdentifierStart(ch)) {
                            pos++;
                            while (pos < len && isIdentifierPart(ch = text.charCodeAt(pos)))
                                pos++;
                            tokenValue = text.substring(tokenPos, pos);
                            if (ch === 92 /* backslash */) {
                                tokenValue += scanIdentifierParts();
                            }
                            return token = getIdentifierToken();
                        }
                        else if (isWhiteSpace(ch)) {
                            pos++;
                            continue;
                        }
                        else if (isLineBreak(ch)) {
                            precedingLineBreak = true;
                            pos++;
                            continue;
                        }
                        error(ts.Diagnostics.Invalid_character);
                        return pos++, token = 0 /* Unknown */;
                }
            }
        }
        function reScanGreaterToken() {
            if (token === 20 /* GreaterThanToken */) {
                if (text.charCodeAt(pos) === 62 /* greaterThan */) {
                    if (text.charCodeAt(pos + 1) === 62 /* greaterThan */) {
                        if (text.charCodeAt(pos + 2) === 61 /* equals */) {
                            return pos += 3, token = 55 /* GreaterThanGreaterThanGreaterThanEqualsToken */;
                        }
                        return pos += 2, token = 37 /* GreaterThanGreaterThanGreaterThanToken */;
                    }
                    if (text.charCodeAt(pos + 1) === 61 /* equals */) {
                        return pos += 2, token = 54 /* GreaterThanGreaterThanEqualsToken */;
                    }
                    return pos++, token = 36 /* GreaterThanGreaterThanToken */;
                }
                if (text.charCodeAt(pos) === 61 /* equals */) {
                    return pos++, token = 22 /* GreaterThanEqualsToken */;
                }
            }
            return token;
        }
        function reScanSlashToken() {
            if (token === 31 /* SlashToken */ || token === 51 /* SlashEqualsToken */) {
                var p = tokenPos + 1;
                var inEscape = false;
                var inCharacterClass = false;
                while (true) {
                    // If we've hit EOF without closing off the regex,
                    // simply return the token we originally parsed.
                    if (p >= len) {
                        return token;
                    }
                    var ch = text.charCodeAt(p);
                    // Line breaks are not permissible in the middle of a RegExp.
                    if (isLineBreak(ch)) {
                        return token;
                    }
                    if (inEscape) {
                        // Parsing an escape character;
                        // reset the flag and just advance to the next char.
                        inEscape = false;
                    }
                    else if (ch === 47 /* slash */ && !inCharacterClass) {
                        break;
                    }
                    else if (ch === 91 /* openBracket */) {
                        inCharacterClass = true;
                    }
                    else if (ch === 92 /* backslash */) {
                        inEscape = true;
                    }
                    else if (ch === 93 /* closeBracket */) {
                        inCharacterClass = false;
                    }
                    p++;
                }
                p++;
                while (isIdentifierPart(text.charCodeAt(p))) {
                    p++;
                }
                pos = p;
                tokenValue = text.substring(tokenPos, pos);
                token = 8 /* RegularExpressionLiteral */;
            }
            return token;
        }
        function tryScan(callback) {
            var savePos = pos;
            var saveStartPos = startPos;
            var saveTokenPos = tokenPos;
            var saveToken = token;
            var saveTokenValue = tokenValue;
            var savePrecedingLineBreak = precedingLineBreak;
            var result = callback();
            if (!result) {
                pos = savePos;
                startPos = saveStartPos;
                tokenPos = saveTokenPos;
                token = saveToken;
                tokenValue = saveTokenValue;
                precedingLineBreak = savePrecedingLineBreak;
            }
            return result;
        }
        function setText(newText) {
            text = newText || "";
            len = text.length;
            setTextPos(0);
        }
        function setTextPos(textPos) {
            pos = textPos;
            startPos = textPos;
            tokenPos = textPos;
            token = 0 /* Unknown */;
            precedingLineBreak = false;
        }
        setText(text);
        return {
            getStartPos: function () { return startPos; },
            getTextPos: function () { return pos; },
            getToken: function () { return token; },
            getTokenPos: function () { return tokenPos; },
            getTokenText: function () { return text.substring(tokenPos, pos); },
            getTokenValue: function () { return tokenValue; },
            hasPrecedingLineBreak: function () { return precedingLineBreak; },
            isIdentifier: function () { return token === 59 /* Identifier */ || token > ts.SyntaxKind.LastReservedWord; },
            isReservedWord: function () { return token >= ts.SyntaxKind.FirstReservedWord && token <= ts.SyntaxKind.LastReservedWord; },
            reScanGreaterToken: reScanGreaterToken,
            reScanSlashToken: reScanSlashToken,
            scan: scan,
            setText: setText,
            setTextPos: setTextPos,
            tryScan: tryScan
        };
    }
    ts.createScanner = createScanner;
})(ts || (ts = {}));
/// <reference path="core.ts"/>
/// <reference path="scanner.ts"/>
var ts;
(function (ts) {
    // token > SyntaxKind.Identifer => token is a keyword
    (function (SyntaxKind) {
        SyntaxKind[SyntaxKind["Unknown"] = 0] = "Unknown";
        SyntaxKind[SyntaxKind["EndOfFileToken"] = 1] = "EndOfFileToken";
        SyntaxKind[SyntaxKind["SingleLineCommentTrivia"] = 2] = "SingleLineCommentTrivia";
        SyntaxKind[SyntaxKind["MultiLineCommentTrivia"] = 3] = "MultiLineCommentTrivia";
        SyntaxKind[SyntaxKind["NewLineTrivia"] = 4] = "NewLineTrivia";
        SyntaxKind[SyntaxKind["WhitespaceTrivia"] = 5] = "WhitespaceTrivia";
        // Literals
        SyntaxKind[SyntaxKind["NumericLiteral"] = 6] = "NumericLiteral";
        SyntaxKind[SyntaxKind["StringLiteral"] = 7] = "StringLiteral";
        SyntaxKind[SyntaxKind["RegularExpressionLiteral"] = 8] = "RegularExpressionLiteral";
        // Punctuation
        SyntaxKind[SyntaxKind["OpenBraceToken"] = 9] = "OpenBraceToken";
        SyntaxKind[SyntaxKind["CloseBraceToken"] = 10] = "CloseBraceToken";
        SyntaxKind[SyntaxKind["OpenParenToken"] = 11] = "OpenParenToken";
        SyntaxKind[SyntaxKind["CloseParenToken"] = 12] = "CloseParenToken";
        SyntaxKind[SyntaxKind["OpenBracketToken"] = 13] = "OpenBracketToken";
        SyntaxKind[SyntaxKind["CloseBracketToken"] = 14] = "CloseBracketToken";
        SyntaxKind[SyntaxKind["DotToken"] = 15] = "DotToken";
        SyntaxKind[SyntaxKind["DotDotDotToken"] = 16] = "DotDotDotToken";
        SyntaxKind[SyntaxKind["SemicolonToken"] = 17] = "SemicolonToken";
        SyntaxKind[SyntaxKind["CommaToken"] = 18] = "CommaToken";
        SyntaxKind[SyntaxKind["LessThanToken"] = 19] = "LessThanToken";
        SyntaxKind[SyntaxKind["GreaterThanToken"] = 20] = "GreaterThanToken";
        SyntaxKind[SyntaxKind["LessThanEqualsToken"] = 21] = "LessThanEqualsToken";
        SyntaxKind[SyntaxKind["GreaterThanEqualsToken"] = 22] = "GreaterThanEqualsToken";
        SyntaxKind[SyntaxKind["EqualsEqualsToken"] = 23] = "EqualsEqualsToken";
        SyntaxKind[SyntaxKind["ExclamationEqualsToken"] = 24] = "ExclamationEqualsToken";
        SyntaxKind[SyntaxKind["EqualsEqualsEqualsToken"] = 25] = "EqualsEqualsEqualsToken";
        SyntaxKind[SyntaxKind["ExclamationEqualsEqualsToken"] = 26] = "ExclamationEqualsEqualsToken";
        SyntaxKind[SyntaxKind["EqualsGreaterThanToken"] = 27] = "EqualsGreaterThanToken";
        SyntaxKind[SyntaxKind["PlusToken"] = 28] = "PlusToken";
        SyntaxKind[SyntaxKind["MinusToken"] = 29] = "MinusToken";
        SyntaxKind[SyntaxKind["AsteriskToken"] = 30] = "AsteriskToken";
        SyntaxKind[SyntaxKind["SlashToken"] = 31] = "SlashToken";
        SyntaxKind[SyntaxKind["PercentToken"] = 32] = "PercentToken";
        SyntaxKind[SyntaxKind["PlusPlusToken"] = 33] = "PlusPlusToken";
        SyntaxKind[SyntaxKind["MinusMinusToken"] = 34] = "MinusMinusToken";
        SyntaxKind[SyntaxKind["LessThanLessThanToken"] = 35] = "LessThanLessThanToken";
        SyntaxKind[SyntaxKind["GreaterThanGreaterThanToken"] = 36] = "GreaterThanGreaterThanToken";
        SyntaxKind[SyntaxKind["GreaterThanGreaterThanGreaterThanToken"] = 37] = "GreaterThanGreaterThanGreaterThanToken";
        SyntaxKind[SyntaxKind["AmpersandToken"] = 38] = "AmpersandToken";
        SyntaxKind[SyntaxKind["BarToken"] = 39] = "BarToken";
        SyntaxKind[SyntaxKind["CaretToken"] = 40] = "CaretToken";
        SyntaxKind[SyntaxKind["ExclamationToken"] = 41] = "ExclamationToken";
        SyntaxKind[SyntaxKind["TildeToken"] = 42] = "TildeToken";
        SyntaxKind[SyntaxKind["AmpersandAmpersandToken"] = 43] = "AmpersandAmpersandToken";
        SyntaxKind[SyntaxKind["BarBarToken"] = 44] = "BarBarToken";
        SyntaxKind[SyntaxKind["QuestionToken"] = 45] = "QuestionToken";
        SyntaxKind[SyntaxKind["ColonToken"] = 46] = "ColonToken";
        // Assignments
        SyntaxKind[SyntaxKind["EqualsToken"] = 47] = "EqualsToken";
        SyntaxKind[SyntaxKind["PlusEqualsToken"] = 48] = "PlusEqualsToken";
        SyntaxKind[SyntaxKind["MinusEqualsToken"] = 49] = "MinusEqualsToken";
        SyntaxKind[SyntaxKind["AsteriskEqualsToken"] = 50] = "AsteriskEqualsToken";
        SyntaxKind[SyntaxKind["SlashEqualsToken"] = 51] = "SlashEqualsToken";
        SyntaxKind[SyntaxKind["PercentEqualsToken"] = 52] = "PercentEqualsToken";
        SyntaxKind[SyntaxKind["LessThanLessThanEqualsToken"] = 53] = "LessThanLessThanEqualsToken";
        SyntaxKind[SyntaxKind["GreaterThanGreaterThanEqualsToken"] = 54] = "GreaterThanGreaterThanEqualsToken";
        SyntaxKind[SyntaxKind["GreaterThanGreaterThanGreaterThanEqualsToken"] = 55] = "GreaterThanGreaterThanGreaterThanEqualsToken";
        SyntaxKind[SyntaxKind["AmpersandEqualsToken"] = 56] = "AmpersandEqualsToken";
        SyntaxKind[SyntaxKind["BarEqualsToken"] = 57] = "BarEqualsToken";
        SyntaxKind[SyntaxKind["CaretEqualsToken"] = 58] = "CaretEqualsToken";
        // Identifiers
        SyntaxKind[SyntaxKind["Identifier"] = 59] = "Identifier";
        // Reserved words
        SyntaxKind[SyntaxKind["BreakKeyword"] = 60] = "BreakKeyword";
        SyntaxKind[SyntaxKind["CaseKeyword"] = 61] = "CaseKeyword";
        SyntaxKind[SyntaxKind["CatchKeyword"] = 62] = "CatchKeyword";
        SyntaxKind[SyntaxKind["ClassKeyword"] = 63] = "ClassKeyword";
        SyntaxKind[SyntaxKind["ConstKeyword"] = 64] = "ConstKeyword";
        SyntaxKind[SyntaxKind["ContinueKeyword"] = 65] = "ContinueKeyword";
        SyntaxKind[SyntaxKind["DebuggerKeyword"] = 66] = "DebuggerKeyword";
        SyntaxKind[SyntaxKind["DefaultKeyword"] = 67] = "DefaultKeyword";
        SyntaxKind[SyntaxKind["DeleteKeyword"] = 68] = "DeleteKeyword";
        SyntaxKind[SyntaxKind["DoKeyword"] = 69] = "DoKeyword";
        SyntaxKind[SyntaxKind["ElseKeyword"] = 70] = "ElseKeyword";
        SyntaxKind[SyntaxKind["EnumKeyword"] = 71] = "EnumKeyword";
        SyntaxKind[SyntaxKind["ExportKeyword"] = 72] = "ExportKeyword";
        SyntaxKind[SyntaxKind["ExtendsKeyword"] = 73] = "ExtendsKeyword";
        SyntaxKind[SyntaxKind["FalseKeyword"] = 74] = "FalseKeyword";
        SyntaxKind[SyntaxKind["FinallyKeyword"] = 75] = "FinallyKeyword";
        SyntaxKind[SyntaxKind["ForKeyword"] = 76] = "ForKeyword";
        SyntaxKind[SyntaxKind["FunctionKeyword"] = 77] = "FunctionKeyword";
        SyntaxKind[SyntaxKind["IfKeyword"] = 78] = "IfKeyword";
        SyntaxKind[SyntaxKind["ImportKeyword"] = 79] = "ImportKeyword";
        SyntaxKind[SyntaxKind["InKeyword"] = 80] = "InKeyword";
        SyntaxKind[SyntaxKind["InstanceOfKeyword"] = 81] = "InstanceOfKeyword";
        SyntaxKind[SyntaxKind["NewKeyword"] = 82] = "NewKeyword";
        SyntaxKind[SyntaxKind["NullKeyword"] = 83] = "NullKeyword";
        SyntaxKind[SyntaxKind["ReturnKeyword"] = 84] = "ReturnKeyword";
        SyntaxKind[SyntaxKind["SuperKeyword"] = 85] = "SuperKeyword";
        SyntaxKind[SyntaxKind["SwitchKeyword"] = 86] = "SwitchKeyword";
        SyntaxKind[SyntaxKind["ThisKeyword"] = 87] = "ThisKeyword";
        SyntaxKind[SyntaxKind["ThrowKeyword"] = 88] = "ThrowKeyword";
        SyntaxKind[SyntaxKind["TrueKeyword"] = 89] = "TrueKeyword";
        SyntaxKind[SyntaxKind["TryKeyword"] = 90] = "TryKeyword";
        SyntaxKind[SyntaxKind["TypeOfKeyword"] = 91] = "TypeOfKeyword";
        SyntaxKind[SyntaxKind["VarKeyword"] = 92] = "VarKeyword";
        SyntaxKind[SyntaxKind["VoidKeyword"] = 93] = "VoidKeyword";
        SyntaxKind[SyntaxKind["WhileKeyword"] = 94] = "WhileKeyword";
        SyntaxKind[SyntaxKind["WithKeyword"] = 95] = "WithKeyword";
        // Strict mode reserved words
        SyntaxKind[SyntaxKind["ImplementsKeyword"] = 96] = "ImplementsKeyword";
        SyntaxKind[SyntaxKind["InterfaceKeyword"] = 97] = "InterfaceKeyword";
        SyntaxKind[SyntaxKind["LetKeyword"] = 98] = "LetKeyword";
        SyntaxKind[SyntaxKind["PackageKeyword"] = 99] = "PackageKeyword";
        SyntaxKind[SyntaxKind["PrivateKeyword"] = 100] = "PrivateKeyword";
        SyntaxKind[SyntaxKind["ProtectedKeyword"] = 101] = "ProtectedKeyword";
        SyntaxKind[SyntaxKind["PublicKeyword"] = 102] = "PublicKeyword";
        SyntaxKind[SyntaxKind["StaticKeyword"] = 103] = "StaticKeyword";
        SyntaxKind[SyntaxKind["YieldKeyword"] = 104] = "YieldKeyword";
        // TypeScript keywords
        SyntaxKind[SyntaxKind["AnyKeyword"] = 105] = "AnyKeyword";
        SyntaxKind[SyntaxKind["BooleanKeyword"] = 106] = "BooleanKeyword";
        SyntaxKind[SyntaxKind["ConstructorKeyword"] = 107] = "ConstructorKeyword";
        SyntaxKind[SyntaxKind["DeclareKeyword"] = 108] = "DeclareKeyword";
        SyntaxKind[SyntaxKind["GetKeyword"] = 109] = "GetKeyword";
        SyntaxKind[SyntaxKind["ModuleKeyword"] = 110] = "ModuleKeyword";
        SyntaxKind[SyntaxKind["RequireKeyword"] = 111] = "RequireKeyword";
        SyntaxKind[SyntaxKind["NumberKeyword"] = 112] = "NumberKeyword";
        SyntaxKind[SyntaxKind["SetKeyword"] = 113] = "SetKeyword";
        SyntaxKind[SyntaxKind["StringKeyword"] = 114] = "StringKeyword";
        // Parse tree nodes
        SyntaxKind[SyntaxKind["Missing"] = 115] = "Missing";
        // Names
        SyntaxKind[SyntaxKind["QualifiedName"] = 116] = "QualifiedName";
        // Signature elements
        SyntaxKind[SyntaxKind["TypeParameter"] = 117] = "TypeParameter";
        SyntaxKind[SyntaxKind["Parameter"] = 118] = "Parameter";
        // TypeMember
        SyntaxKind[SyntaxKind["Property"] = 119] = "Property";
        SyntaxKind[SyntaxKind["Method"] = 120] = "Method";
        SyntaxKind[SyntaxKind["Constructor"] = 121] = "Constructor";
        SyntaxKind[SyntaxKind["GetAccessor"] = 122] = "GetAccessor";
        SyntaxKind[SyntaxKind["SetAccessor"] = 123] = "SetAccessor";
        SyntaxKind[SyntaxKind["CallSignature"] = 124] = "CallSignature";
        SyntaxKind[SyntaxKind["ConstructSignature"] = 125] = "ConstructSignature";
        SyntaxKind[SyntaxKind["IndexSignature"] = 126] = "IndexSignature";
        // Type
        SyntaxKind[SyntaxKind["TypeReference"] = 127] = "TypeReference";
        SyntaxKind[SyntaxKind["TypeQuery"] = 128] = "TypeQuery";
        SyntaxKind[SyntaxKind["TypeLiteral"] = 129] = "TypeLiteral";
        SyntaxKind[SyntaxKind["ArrayType"] = 130] = "ArrayType";
        SyntaxKind[SyntaxKind["TupleType"] = 131] = "TupleType";
        // Expression
        SyntaxKind[SyntaxKind["ArrayLiteral"] = 132] = "ArrayLiteral";
        SyntaxKind[SyntaxKind["ObjectLiteral"] = 133] = "ObjectLiteral";
        SyntaxKind[SyntaxKind["PropertyAssignment"] = 134] = "PropertyAssignment";
        SyntaxKind[SyntaxKind["PropertyAccess"] = 135] = "PropertyAccess";
        SyntaxKind[SyntaxKind["IndexedAccess"] = 136] = "IndexedAccess";
        SyntaxKind[SyntaxKind["CallExpression"] = 137] = "CallExpression";
        SyntaxKind[SyntaxKind["NewExpression"] = 138] = "NewExpression";
        SyntaxKind[SyntaxKind["TypeAssertion"] = 139] = "TypeAssertion";
        SyntaxKind[SyntaxKind["ParenExpression"] = 140] = "ParenExpression";
        SyntaxKind[SyntaxKind["FunctionExpression"] = 141] = "FunctionExpression";
        SyntaxKind[SyntaxKind["ArrowFunction"] = 142] = "ArrowFunction";
        SyntaxKind[SyntaxKind["PrefixOperator"] = 143] = "PrefixOperator";
        SyntaxKind[SyntaxKind["PostfixOperator"] = 144] = "PostfixOperator";
        SyntaxKind[SyntaxKind["BinaryExpression"] = 145] = "BinaryExpression";
        SyntaxKind[SyntaxKind["ConditionalExpression"] = 146] = "ConditionalExpression";
        SyntaxKind[SyntaxKind["OmittedExpression"] = 147] = "OmittedExpression";
        // Element
        SyntaxKind[SyntaxKind["Block"] = 148] = "Block";
        SyntaxKind[SyntaxKind["VariableStatement"] = 149] = "VariableStatement";
        SyntaxKind[SyntaxKind["EmptyStatement"] = 150] = "EmptyStatement";
        SyntaxKind[SyntaxKind["ExpressionStatement"] = 151] = "ExpressionStatement";
        SyntaxKind[SyntaxKind["IfStatement"] = 152] = "IfStatement";
        SyntaxKind[SyntaxKind["DoStatement"] = 153] = "DoStatement";
        SyntaxKind[SyntaxKind["WhileStatement"] = 154] = "WhileStatement";
        SyntaxKind[SyntaxKind["ForStatement"] = 155] = "ForStatement";
        SyntaxKind[SyntaxKind["ForInStatement"] = 156] = "ForInStatement";
        SyntaxKind[SyntaxKind["ContinueStatement"] = 157] = "ContinueStatement";
        SyntaxKind[SyntaxKind["BreakStatement"] = 158] = "BreakStatement";
        SyntaxKind[SyntaxKind["ReturnStatement"] = 159] = "ReturnStatement";
        SyntaxKind[SyntaxKind["WithStatement"] = 160] = "WithStatement";
        SyntaxKind[SyntaxKind["SwitchStatement"] = 161] = "SwitchStatement";
        SyntaxKind[SyntaxKind["CaseClause"] = 162] = "CaseClause";
        SyntaxKind[SyntaxKind["DefaultClause"] = 163] = "DefaultClause";
        SyntaxKind[SyntaxKind["LabeledStatement"] = 164] = "LabeledStatement";
        SyntaxKind[SyntaxKind["ThrowStatement"] = 165] = "ThrowStatement";
        SyntaxKind[SyntaxKind["TryStatement"] = 166] = "TryStatement";
        SyntaxKind[SyntaxKind["TryBlock"] = 167] = "TryBlock";
        SyntaxKind[SyntaxKind["CatchBlock"] = 168] = "CatchBlock";
        SyntaxKind[SyntaxKind["FinallyBlock"] = 169] = "FinallyBlock";
        SyntaxKind[SyntaxKind["DebuggerStatement"] = 170] = "DebuggerStatement";
        SyntaxKind[SyntaxKind["VariableDeclaration"] = 171] = "VariableDeclaration";
        SyntaxKind[SyntaxKind["FunctionDeclaration"] = 172] = "FunctionDeclaration";
        SyntaxKind[SyntaxKind["FunctionBlock"] = 173] = "FunctionBlock";
        SyntaxKind[SyntaxKind["ClassDeclaration"] = 174] = "ClassDeclaration";
        SyntaxKind[SyntaxKind["InterfaceDeclaration"] = 175] = "InterfaceDeclaration";
        SyntaxKind[SyntaxKind["EnumDeclaration"] = 176] = "EnumDeclaration";
        SyntaxKind[SyntaxKind["ModuleDeclaration"] = 177] = "ModuleDeclaration";
        SyntaxKind[SyntaxKind["ModuleBlock"] = 178] = "ModuleBlock";
        SyntaxKind[SyntaxKind["ImportDeclaration"] = 179] = "ImportDeclaration";
        SyntaxKind[SyntaxKind["ExportAssignment"] = 180] = "ExportAssignment";
        // Enum
        SyntaxKind[SyntaxKind["EnumMember"] = 181] = "EnumMember";
        // Top-level nodes
        SyntaxKind[SyntaxKind["SourceFile"] = 182] = "SourceFile";
        SyntaxKind[SyntaxKind["Program"] = 183] = "Program";
        // Synthesized list
        SyntaxKind[SyntaxKind["SyntaxList"] = 184] = "SyntaxList";
        // Enum value count
        SyntaxKind[SyntaxKind["Count"] = 185] = "Count";
        // Markers
        SyntaxKind[SyntaxKind["FirstAssignment"] = SyntaxKind.EqualsToken] = "FirstAssignment";
        SyntaxKind[SyntaxKind["LastAssignment"] = SyntaxKind.CaretEqualsToken] = "LastAssignment";
        SyntaxKind[SyntaxKind["FirstReservedWord"] = SyntaxKind.BreakKeyword] = "FirstReservedWord";
        SyntaxKind[SyntaxKind["LastReservedWord"] = SyntaxKind.WithKeyword] = "LastReservedWord";
        SyntaxKind[SyntaxKind["FirstKeyword"] = SyntaxKind.BreakKeyword] = "FirstKeyword";
        SyntaxKind[SyntaxKind["LastKeyword"] = SyntaxKind.StringKeyword] = "LastKeyword";
        SyntaxKind[SyntaxKind["FirstFutureReservedWord"] = SyntaxKind.ImplementsKeyword] = "FirstFutureReservedWord";
        SyntaxKind[SyntaxKind["LastFutureReservedWord"] = SyntaxKind.YieldKeyword] = "LastFutureReservedWord";
        SyntaxKind[SyntaxKind["FirstTypeNode"] = SyntaxKind.TypeReference] = "FirstTypeNode";
        SyntaxKind[SyntaxKind["LastTypeNode"] = SyntaxKind.TupleType] = "LastTypeNode";
        SyntaxKind[SyntaxKind["FirstPunctuation"] = SyntaxKind.OpenBraceToken] = "FirstPunctuation";
        SyntaxKind[SyntaxKind["LastPunctuation"] = SyntaxKind.CaretEqualsToken] = "LastPunctuation";
        SyntaxKind[SyntaxKind["FirstToken"] = SyntaxKind.EndOfFileToken] = "FirstToken";
        SyntaxKind[SyntaxKind["LastToken"] = SyntaxKind.StringKeyword] = "LastToken";
    })(ts.SyntaxKind || (ts.SyntaxKind = {}));
    var SyntaxKind = ts.SyntaxKind;
    (function (NodeFlags) {
        NodeFlags[NodeFlags["Export"] = 0x00000001] = "Export";
        NodeFlags[NodeFlags["Ambient"] = 0x00000002] = "Ambient";
        NodeFlags[NodeFlags["QuestionMark"] = 0x00000004] = "QuestionMark";
        NodeFlags[NodeFlags["Rest"] = 0x00000008] = "Rest";
        NodeFlags[NodeFlags["Public"] = 0x00000010] = "Public";
        NodeFlags[NodeFlags["Private"] = 0x00000020] = "Private";
        NodeFlags[NodeFlags["Protected"] = 0x00000040] = "Protected";
        NodeFlags[NodeFlags["Static"] = 0x00000080] = "Static";
        NodeFlags[NodeFlags["MultiLine"] = 0x00000100] = "MultiLine";
        NodeFlags[NodeFlags["Synthetic"] = 0x00000200] = "Synthetic";
        NodeFlags[NodeFlags["DeclarationFile"] = 0x00000400] = "DeclarationFile";
        NodeFlags[NodeFlags["Modifier"] = NodeFlags.Export | NodeFlags.Ambient | NodeFlags.Public | NodeFlags.Private | NodeFlags.Protected | NodeFlags.Static] = "Modifier";
        NodeFlags[NodeFlags["AccessibilityModifier"] = NodeFlags.Public | NodeFlags.Private | NodeFlags.Protected] = "AccessibilityModifier";
    })(ts.NodeFlags || (ts.NodeFlags = {}));
    var NodeFlags = ts.NodeFlags;
    // Return code used by getEmitOutput function to indicate status of the function
    (function (EmitReturnStatus) {
        EmitReturnStatus[EmitReturnStatus["Succeeded"] = 0] = "Succeeded";
        EmitReturnStatus[EmitReturnStatus["AllOutputGenerationSkipped"] = 1] = "AllOutputGenerationSkipped";
        EmitReturnStatus[EmitReturnStatus["JSGeneratedWithSemanticErrors"] = 2] = "JSGeneratedWithSemanticErrors";
        EmitReturnStatus[EmitReturnStatus["DeclarationGenerationSkipped"] = 3] = "DeclarationGenerationSkipped";
        EmitReturnStatus[EmitReturnStatus["EmitErrorsEncountered"] = 4] = "EmitErrorsEncountered";
        EmitReturnStatus[EmitReturnStatus["CompilerOptionsErrors"] = 5] = "CompilerOptionsErrors";
    })(ts.EmitReturnStatus || (ts.EmitReturnStatus = {}));
    var EmitReturnStatus = ts.EmitReturnStatus;
    (function (TypeFormatFlags) {
        TypeFormatFlags[TypeFormatFlags["None"] = 0x00000000] = "None";
        TypeFormatFlags[TypeFormatFlags["WriteArrayAsGenericType"] = 0x00000001] = "WriteArrayAsGenericType";
        TypeFormatFlags[TypeFormatFlags["UseTypeOfFunction"] = 0x00000002] = "UseTypeOfFunction";
        TypeFormatFlags[TypeFormatFlags["NoTruncation"] = 0x00000004] = "NoTruncation";
    })(ts.TypeFormatFlags || (ts.TypeFormatFlags = {}));
    var TypeFormatFlags = ts.TypeFormatFlags;
    (function (SymbolAccessibility) {
        SymbolAccessibility[SymbolAccessibility["Accessible"] = 0] = "Accessible";
        SymbolAccessibility[SymbolAccessibility["NotAccessible"] = 1] = "NotAccessible";
        SymbolAccessibility[SymbolAccessibility["CannotBeNamed"] = 2] = "CannotBeNamed";
    })(ts.SymbolAccessibility || (ts.SymbolAccessibility = {}));
    var SymbolAccessibility = ts.SymbolAccessibility;
    (function (SymbolFlags) {
        SymbolFlags[SymbolFlags["Variable"] = 0x00000001] = "Variable";
        SymbolFlags[SymbolFlags["Property"] = 0x00000002] = "Property";
        SymbolFlags[SymbolFlags["EnumMember"] = 0x00000004] = "EnumMember";
        SymbolFlags[SymbolFlags["Function"] = 0x00000008] = "Function";
        SymbolFlags[SymbolFlags["Class"] = 0x00000010] = "Class";
        SymbolFlags[SymbolFlags["Interface"] = 0x00000020] = "Interface";
        SymbolFlags[SymbolFlags["Enum"] = 0x00000040] = "Enum";
        SymbolFlags[SymbolFlags["ValueModule"] = 0x00000080] = "ValueModule";
        SymbolFlags[SymbolFlags["NamespaceModule"] = 0x00000100] = "NamespaceModule";
        SymbolFlags[SymbolFlags["TypeLiteral"] = 0x00000200] = "TypeLiteral";
        SymbolFlags[SymbolFlags["ObjectLiteral"] = 0x00000400] = "ObjectLiteral";
        SymbolFlags[SymbolFlags["Method"] = 0x00000800] = "Method";
        SymbolFlags[SymbolFlags["Constructor"] = 0x00001000] = "Constructor";
        SymbolFlags[SymbolFlags["GetAccessor"] = 0x00002000] = "GetAccessor";
        SymbolFlags[SymbolFlags["SetAccessor"] = 0x00004000] = "SetAccessor";
        SymbolFlags[SymbolFlags["CallSignature"] = 0x00008000] = "CallSignature";
        SymbolFlags[SymbolFlags["ConstructSignature"] = 0x00010000] = "ConstructSignature";
        SymbolFlags[SymbolFlags["IndexSignature"] = 0x00020000] = "IndexSignature";
        SymbolFlags[SymbolFlags["TypeParameter"] = 0x00040000] = "TypeParameter";
        // Export markers (see comment in declareModuleMember in binder)
        SymbolFlags[SymbolFlags["ExportValue"] = 0x00080000] = "ExportValue";
        SymbolFlags[SymbolFlags["ExportType"] = 0x00100000] = "ExportType";
        SymbolFlags[SymbolFlags["ExportNamespace"] = 0x00200000] = "ExportNamespace";
        SymbolFlags[SymbolFlags["Import"] = 0x00400000] = "Import";
        SymbolFlags[SymbolFlags["Instantiated"] = 0x00800000] = "Instantiated";
        SymbolFlags[SymbolFlags["Merged"] = 0x01000000] = "Merged";
        SymbolFlags[SymbolFlags["Transient"] = 0x02000000] = "Transient";
        SymbolFlags[SymbolFlags["Prototype"] = 0x04000000] = "Prototype";
        SymbolFlags[SymbolFlags["Value"] = SymbolFlags.Variable | SymbolFlags.Property | SymbolFlags.EnumMember | SymbolFlags.Function | SymbolFlags.Class | SymbolFlags.Enum | SymbolFlags.ValueModule | SymbolFlags.Method | SymbolFlags.GetAccessor | SymbolFlags.SetAccessor] = "Value";
        SymbolFlags[SymbolFlags["Type"] = SymbolFlags.Class | SymbolFlags.Interface | SymbolFlags.Enum | SymbolFlags.TypeLiteral | SymbolFlags.ObjectLiteral | SymbolFlags.TypeParameter] = "Type";
        SymbolFlags[SymbolFlags["Namespace"] = SymbolFlags.ValueModule | SymbolFlags.NamespaceModule] = "Namespace";
        SymbolFlags[SymbolFlags["Module"] = SymbolFlags.ValueModule | SymbolFlags.NamespaceModule] = "Module";
        SymbolFlags[SymbolFlags["Accessor"] = SymbolFlags.GetAccessor | SymbolFlags.SetAccessor] = "Accessor";
        SymbolFlags[SymbolFlags["Signature"] = SymbolFlags.CallSignature | SymbolFlags.ConstructSignature | SymbolFlags.IndexSignature] = "Signature";
        SymbolFlags[SymbolFlags["ParameterExcludes"] = SymbolFlags.Value] = "ParameterExcludes";
        SymbolFlags[SymbolFlags["VariableExcludes"] = SymbolFlags.Value & ~SymbolFlags.Variable] = "VariableExcludes";
        SymbolFlags[SymbolFlags["PropertyExcludes"] = SymbolFlags.Value] = "PropertyExcludes";
        SymbolFlags[SymbolFlags["EnumMemberExcludes"] = SymbolFlags.Value] = "EnumMemberExcludes";
        SymbolFlags[SymbolFlags["FunctionExcludes"] = SymbolFlags.Value & ~(SymbolFlags.Function | SymbolFlags.ValueModule)] = "FunctionExcludes";
        SymbolFlags[SymbolFlags["ClassExcludes"] = (SymbolFlags.Value | SymbolFlags.Type) & ~SymbolFlags.ValueModule] = "ClassExcludes";
        SymbolFlags[SymbolFlags["InterfaceExcludes"] = SymbolFlags.Type & ~SymbolFlags.Interface] = "InterfaceExcludes";
        SymbolFlags[SymbolFlags["EnumExcludes"] = (SymbolFlags.Value | SymbolFlags.Type) & ~(SymbolFlags.Enum | SymbolFlags.ValueModule)] = "EnumExcludes";
        SymbolFlags[SymbolFlags["ValueModuleExcludes"] = SymbolFlags.Value & ~(SymbolFlags.Function | SymbolFlags.Class | SymbolFlags.Enum | SymbolFlags.ValueModule)] = "ValueModuleExcludes";
        SymbolFlags[SymbolFlags["NamespaceModuleExcludes"] = 0] = "NamespaceModuleExcludes";
        SymbolFlags[SymbolFlags["MethodExcludes"] = SymbolFlags.Value & ~SymbolFlags.Method] = "MethodExcludes";
        SymbolFlags[SymbolFlags["GetAccessorExcludes"] = SymbolFlags.Value & ~SymbolFlags.SetAccessor] = "GetAccessorExcludes";
        SymbolFlags[SymbolFlags["SetAccessorExcludes"] = SymbolFlags.Value & ~SymbolFlags.GetAccessor] = "SetAccessorExcludes";
        SymbolFlags[SymbolFlags["TypeParameterExcludes"] = SymbolFlags.Type & ~SymbolFlags.TypeParameter] = "TypeParameterExcludes";
        // Imports collide with all other imports with the same name.
        SymbolFlags[SymbolFlags["ImportExcludes"] = SymbolFlags.Import] = "ImportExcludes";
        SymbolFlags[SymbolFlags["ModuleMember"] = SymbolFlags.Variable | SymbolFlags.Function | SymbolFlags.Class | SymbolFlags.Interface | SymbolFlags.Enum | SymbolFlags.Module | SymbolFlags.Import] = "ModuleMember";
        SymbolFlags[SymbolFlags["ExportHasLocal"] = SymbolFlags.Function | SymbolFlags.Class | SymbolFlags.Enum | SymbolFlags.ValueModule] = "ExportHasLocal";
        SymbolFlags[SymbolFlags["HasLocals"] = SymbolFlags.Function | SymbolFlags.Module | SymbolFlags.Method | SymbolFlags.Constructor | SymbolFlags.Accessor | SymbolFlags.Signature] = "HasLocals";
        SymbolFlags[SymbolFlags["HasExports"] = SymbolFlags.Class | SymbolFlags.Enum | SymbolFlags.Module] = "HasExports";
        SymbolFlags[SymbolFlags["HasMembers"] = SymbolFlags.Class | SymbolFlags.Interface | SymbolFlags.TypeLiteral | SymbolFlags.ObjectLiteral] = "HasMembers";
        SymbolFlags[SymbolFlags["IsContainer"] = SymbolFlags.HasLocals | SymbolFlags.HasExports | SymbolFlags.HasMembers] = "IsContainer";
        SymbolFlags[SymbolFlags["PropertyOrAccessor"] = SymbolFlags.Property | SymbolFlags.Accessor] = "PropertyOrAccessor";
        SymbolFlags[SymbolFlags["Export"] = SymbolFlags.ExportNamespace | SymbolFlags.ExportType | SymbolFlags.ExportValue] = "Export";
    })(ts.SymbolFlags || (ts.SymbolFlags = {}));
    var SymbolFlags = ts.SymbolFlags;
    (function (NodeCheckFlags) {
        NodeCheckFlags[NodeCheckFlags["TypeChecked"] = 0x00000001] = "TypeChecked";
        NodeCheckFlags[NodeCheckFlags["LexicalThis"] = 0x00000002] = "LexicalThis";
        NodeCheckFlags[NodeCheckFlags["CaptureThis"] = 0x00000004] = "CaptureThis";
        NodeCheckFlags[NodeCheckFlags["EmitExtends"] = 0x00000008] = "EmitExtends";
        NodeCheckFlags[NodeCheckFlags["SuperInstance"] = 0x00000010] = "SuperInstance";
        NodeCheckFlags[NodeCheckFlags["SuperStatic"] = 0x00000020] = "SuperStatic";
        NodeCheckFlags[NodeCheckFlags["ContextChecked"] = 0x00000040] = "ContextChecked";
        // Values for enum members have been computed, and any errors have been reported for them.
        NodeCheckFlags[NodeCheckFlags["EnumValuesComputed"] = 0x00000080] = "EnumValuesComputed";
    })(ts.NodeCheckFlags || (ts.NodeCheckFlags = {}));
    var NodeCheckFlags = ts.NodeCheckFlags;
    (function (TypeFlags) {
        TypeFlags[TypeFlags["Any"] = 0x00000001] = "Any";
        TypeFlags[TypeFlags["String"] = 0x00000002] = "String";
        TypeFlags[TypeFlags["Number"] = 0x00000004] = "Number";
        TypeFlags[TypeFlags["Boolean"] = 0x00000008] = "Boolean";
        TypeFlags[TypeFlags["Void"] = 0x00000010] = "Void";
        TypeFlags[TypeFlags["Undefined"] = 0x00000020] = "Undefined";
        TypeFlags[TypeFlags["Null"] = 0x00000040] = "Null";
        TypeFlags[TypeFlags["Enum"] = 0x00000080] = "Enum";
        TypeFlags[TypeFlags["StringLiteral"] = 0x00000100] = "StringLiteral";
        TypeFlags[TypeFlags["TypeParameter"] = 0x00000200] = "TypeParameter";
        TypeFlags[TypeFlags["Class"] = 0x00000400] = "Class";
        TypeFlags[TypeFlags["Interface"] = 0x00000800] = "Interface";
        TypeFlags[TypeFlags["Reference"] = 0x00001000] = "Reference";
        TypeFlags[TypeFlags["Tuple"] = 0x00002000] = "Tuple";
        TypeFlags[TypeFlags["Anonymous"] = 0x00004000] = "Anonymous";
        TypeFlags[TypeFlags["FromSignature"] = 0x00008000] = "FromSignature";
        TypeFlags[TypeFlags["Intrinsic"] = TypeFlags.Any | TypeFlags.String | TypeFlags.Number | TypeFlags.Boolean | TypeFlags.Void | TypeFlags.Undefined | TypeFlags.Null] = "Intrinsic";
        TypeFlags[TypeFlags["StringLike"] = TypeFlags.String | TypeFlags.StringLiteral] = "StringLike";
        TypeFlags[TypeFlags["NumberLike"] = TypeFlags.Number | TypeFlags.Enum] = "NumberLike";
        TypeFlags[TypeFlags["ObjectType"] = TypeFlags.Class | TypeFlags.Interface | TypeFlags.Reference | TypeFlags.Tuple | TypeFlags.Anonymous] = "ObjectType";
    })(ts.TypeFlags || (ts.TypeFlags = {}));
    var TypeFlags = ts.TypeFlags;
    (function (SignatureKind) {
        SignatureKind[SignatureKind["Call"] = 0] = "Call";
        SignatureKind[SignatureKind["Construct"] = 1] = "Construct";
    })(ts.SignatureKind || (ts.SignatureKind = {}));
    var SignatureKind = ts.SignatureKind;
    (function (IndexKind) {
        IndexKind[IndexKind["String"] = 0] = "String";
        IndexKind[IndexKind["Number"] = 1] = "Number";
    })(ts.IndexKind || (ts.IndexKind = {}));
    var IndexKind = ts.IndexKind;
    (function (DiagnosticCategory) {
        DiagnosticCategory[DiagnosticCategory["Warning"] = 0] = "Warning";
        DiagnosticCategory[DiagnosticCategory["Error"] = 1] = "Error";
        DiagnosticCategory[DiagnosticCategory["Message"] = 2] = "Message";
    })(ts.DiagnosticCategory || (ts.DiagnosticCategory = {}));
    var DiagnosticCategory = ts.DiagnosticCategory;
    (function (ModuleKind) {
        ModuleKind[ModuleKind["None"] = 0] = "None";
        ModuleKind[ModuleKind["CommonJS"] = 1] = "CommonJS";
        ModuleKind[ModuleKind["AMD"] = 2] = "AMD";
    })(ts.ModuleKind || (ts.ModuleKind = {}));
    var ModuleKind = ts.ModuleKind;
    (function (ScriptTarget) {
        ScriptTarget[ScriptTarget["ES3"] = 0] = "ES3";
        ScriptTarget[ScriptTarget["ES5"] = 1] = "ES5";
    })(ts.ScriptTarget || (ts.ScriptTarget = {}));
    var ScriptTarget = ts.ScriptTarget;
    (function (CharacterCodes) {
        CharacterCodes[CharacterCodes["nullCharacter"] = 0] = "nullCharacter";
        CharacterCodes[CharacterCodes["maxAsciiCharacter"] = 0x7F] = "maxAsciiCharacter";
        CharacterCodes[CharacterCodes["lineFeed"] = 0x0A] = "lineFeed";
        CharacterCodes[CharacterCodes["carriageReturn"] = 0x0D] = "carriageReturn";
        CharacterCodes[CharacterCodes["lineSeparator"] = 0x2028] = "lineSeparator";
        CharacterCodes[CharacterCodes["paragraphSeparator"] = 0x2029] = "paragraphSeparator";
        CharacterCodes[CharacterCodes["nextLine"] = 0x0085] = "nextLine";
        // Unicode 3.0 space characters
        CharacterCodes[CharacterCodes["space"] = 0x0020] = "space";
        CharacterCodes[CharacterCodes["nonBreakingSpace"] = 0x00A0] = "nonBreakingSpace";
        CharacterCodes[CharacterCodes["enQuad"] = 0x2000] = "enQuad";
        CharacterCodes[CharacterCodes["emQuad"] = 0x2001] = "emQuad";
        CharacterCodes[CharacterCodes["enSpace"] = 0x2002] = "enSpace";
        CharacterCodes[CharacterCodes["emSpace"] = 0x2003] = "emSpace";
        CharacterCodes[CharacterCodes["threePerEmSpace"] = 0x2004] = "threePerEmSpace";
        CharacterCodes[CharacterCodes["fourPerEmSpace"] = 0x2005] = "fourPerEmSpace";
        CharacterCodes[CharacterCodes["sixPerEmSpace"] = 0x2006] = "sixPerEmSpace";
        CharacterCodes[CharacterCodes["figureSpace"] = 0x2007] = "figureSpace";
        CharacterCodes[CharacterCodes["punctuationSpace"] = 0x2008] = "punctuationSpace";
        CharacterCodes[CharacterCodes["thinSpace"] = 0x2009] = "thinSpace";
        CharacterCodes[CharacterCodes["hairSpace"] = 0x200A] = "hairSpace";
        CharacterCodes[CharacterCodes["zeroWidthSpace"] = 0x200B] = "zeroWidthSpace";
        CharacterCodes[CharacterCodes["narrowNoBreakSpace"] = 0x202F] = "narrowNoBreakSpace";
        CharacterCodes[CharacterCodes["ideographicSpace"] = 0x3000] = "ideographicSpace";
        CharacterCodes[CharacterCodes["mathematicalSpace"] = 0x205F] = "mathematicalSpace";
        CharacterCodes[CharacterCodes["ogham"] = 0x1680] = "ogham";
        CharacterCodes[CharacterCodes["_"] = 0x5F] = "_";
        CharacterCodes[CharacterCodes["$"] = 0x24] = "$";
        CharacterCodes[CharacterCodes["_0"] = 0x30] = "_0";
        CharacterCodes[CharacterCodes["_1"] = 0x31] = "_1";
        CharacterCodes[CharacterCodes["_2"] = 0x32] = "_2";
        CharacterCodes[CharacterCodes["_3"] = 0x33] = "_3";
        CharacterCodes[CharacterCodes["_4"] = 0x34] = "_4";
        CharacterCodes[CharacterCodes["_5"] = 0x35] = "_5";
        CharacterCodes[CharacterCodes["_6"] = 0x36] = "_6";
        CharacterCodes[CharacterCodes["_7"] = 0x37] = "_7";
        CharacterCodes[CharacterCodes["_8"] = 0x38] = "_8";
        CharacterCodes[CharacterCodes["_9"] = 0x39] = "_9";
        CharacterCodes[CharacterCodes["a"] = 0x61] = "a";
        CharacterCodes[CharacterCodes["b"] = 0x62] = "b";
        CharacterCodes[CharacterCodes["c"] = 0x63] = "c";
        CharacterCodes[CharacterCodes["d"] = 0x64] = "d";
        CharacterCodes[CharacterCodes["e"] = 0x65] = "e";
        CharacterCodes[CharacterCodes["f"] = 0x66] = "f";
        CharacterCodes[CharacterCodes["g"] = 0x67] = "g";
        CharacterCodes[CharacterCodes["h"] = 0x68] = "h";
        CharacterCodes[CharacterCodes["i"] = 0x69] = "i";
        CharacterCodes[CharacterCodes["j"] = 0x6A] = "j";
        CharacterCodes[CharacterCodes["k"] = 0x6B] = "k";
        CharacterCodes[CharacterCodes["l"] = 0x6C] = "l";
        CharacterCodes[CharacterCodes["m"] = 0x6D] = "m";
        CharacterCodes[CharacterCodes["n"] = 0x6E] = "n";
        CharacterCodes[CharacterCodes["o"] = 0x6F] = "o";
        CharacterCodes[CharacterCodes["p"] = 0x70] = "p";
        CharacterCodes[CharacterCodes["q"] = 0x71] = "q";
        CharacterCodes[CharacterCodes["r"] = 0x72] = "r";
        CharacterCodes[CharacterCodes["s"] = 0x73] = "s";
        CharacterCodes[CharacterCodes["t"] = 0x74] = "t";
        CharacterCodes[CharacterCodes["u"] = 0x75] = "u";
        CharacterCodes[CharacterCodes["v"] = 0x76] = "v";
        CharacterCodes[CharacterCodes["w"] = 0x77] = "w";
        CharacterCodes[CharacterCodes["x"] = 0x78] = "x";
        CharacterCodes[CharacterCodes["y"] = 0x79] = "y";
        CharacterCodes[CharacterCodes["z"] = 0x7A] = "z";
        CharacterCodes[CharacterCodes["A"] = 0x41] = "A";
        CharacterCodes[CharacterCodes["B"] = 0x42] = "B";
        CharacterCodes[CharacterCodes["C"] = 0x43] = "C";
        CharacterCodes[CharacterCodes["D"] = 0x44] = "D";
        CharacterCodes[CharacterCodes["E"] = 0x45] = "E";
        CharacterCodes[CharacterCodes["F"] = 0x46] = "F";
        CharacterCodes[CharacterCodes["G"] = 0x47] = "G";
        CharacterCodes[CharacterCodes["H"] = 0x48] = "H";
        CharacterCodes[CharacterCodes["I"] = 0x49] = "I";
        CharacterCodes[CharacterCodes["J"] = 0x4A] = "J";
        CharacterCodes[CharacterCodes["K"] = 0x4B] = "K";
        CharacterCodes[CharacterCodes["L"] = 0x4C] = "L";
        CharacterCodes[CharacterCodes["M"] = 0x4D] = "M";
        CharacterCodes[CharacterCodes["N"] = 0x4E] = "N";
        CharacterCodes[CharacterCodes["O"] = 0x4F] = "O";
        CharacterCodes[CharacterCodes["P"] = 0x50] = "P";
        CharacterCodes[CharacterCodes["Q"] = 0x51] = "Q";
        CharacterCodes[CharacterCodes["R"] = 0x52] = "R";
        CharacterCodes[CharacterCodes["S"] = 0x53] = "S";
        CharacterCodes[CharacterCodes["T"] = 0x54] = "T";
        CharacterCodes[CharacterCodes["U"] = 0x55] = "U";
        CharacterCodes[CharacterCodes["V"] = 0x56] = "V";
        CharacterCodes[CharacterCodes["W"] = 0x57] = "W";
        CharacterCodes[CharacterCodes["X"] = 0x58] = "X";
        CharacterCodes[CharacterCodes["Y"] = 0x59] = "Y";
        CharacterCodes[CharacterCodes["Z"] = 0x5a] = "Z";
        CharacterCodes[CharacterCodes["ampersand"] = 0x26] = "ampersand";
        CharacterCodes[CharacterCodes["asterisk"] = 0x2A] = "asterisk";
        CharacterCodes[CharacterCodes["at"] = 0x40] = "at";
        CharacterCodes[CharacterCodes["backslash"] = 0x5C] = "backslash";
        CharacterCodes[CharacterCodes["bar"] = 0x7C] = "bar";
        CharacterCodes[CharacterCodes["caret"] = 0x5E] = "caret";
        CharacterCodes[CharacterCodes["closeBrace"] = 0x7D] = "closeBrace";
        CharacterCodes[CharacterCodes["closeBracket"] = 0x5D] = "closeBracket";
        CharacterCodes[CharacterCodes["closeParen"] = 0x29] = "closeParen";
        CharacterCodes[CharacterCodes["colon"] = 0x3A] = "colon";
        CharacterCodes[CharacterCodes["comma"] = 0x2C] = "comma";
        CharacterCodes[CharacterCodes["dot"] = 0x2E] = "dot";
        CharacterCodes[CharacterCodes["doubleQuote"] = 0x22] = "doubleQuote";
        CharacterCodes[CharacterCodes["equals"] = 0x3D] = "equals";
        CharacterCodes[CharacterCodes["exclamation"] = 0x21] = "exclamation";
        CharacterCodes[CharacterCodes["greaterThan"] = 0x3E] = "greaterThan";
        CharacterCodes[CharacterCodes["lessThan"] = 0x3C] = "lessThan";
        CharacterCodes[CharacterCodes["minus"] = 0x2D] = "minus";
        CharacterCodes[CharacterCodes["openBrace"] = 0x7B] = "openBrace";
        CharacterCodes[CharacterCodes["openBracket"] = 0x5B] = "openBracket";
        CharacterCodes[CharacterCodes["openParen"] = 0x28] = "openParen";
        CharacterCodes[CharacterCodes["percent"] = 0x25] = "percent";
        CharacterCodes[CharacterCodes["plus"] = 0x2B] = "plus";
        CharacterCodes[CharacterCodes["question"] = 0x3F] = "question";
        CharacterCodes[CharacterCodes["semicolon"] = 0x3B] = "semicolon";
        CharacterCodes[CharacterCodes["singleQuote"] = 0x27] = "singleQuote";
        CharacterCodes[CharacterCodes["slash"] = 0x2F] = "slash";
        CharacterCodes[CharacterCodes["tilde"] = 0x7E] = "tilde";
        CharacterCodes[CharacterCodes["backspace"] = 0x08] = "backspace";
        CharacterCodes[CharacterCodes["formFeed"] = 0x0C] = "formFeed";
        CharacterCodes[CharacterCodes["byteOrderMark"] = 0xFEFF] = "byteOrderMark";
        CharacterCodes[CharacterCodes["tab"] = 0x09] = "tab";
        CharacterCodes[CharacterCodes["verticalTab"] = 0x0B] = "verticalTab";
    })(ts.CharacterCodes || (ts.CharacterCodes = {}));
    var CharacterCodes = ts.CharacterCodes;
    var SymbolDisplayPart = (function () {
        function SymbolDisplayPart(text, kind, symbol) {
            this.text = text;
            this.kind = kind;
            this.symbol = symbol;
        }
        SymbolDisplayPart.prototype.toJSON = function () {
            return {
                text: this.text,
                kind: SymbolDisplayPartKind[this.kind]
            };
        };
        return SymbolDisplayPart;
    })();
    ts.SymbolDisplayPart = SymbolDisplayPart;
    (function (SymbolDisplayPartKind) {
        SymbolDisplayPartKind[SymbolDisplayPartKind["aliasName"] = 0] = "aliasName";
        SymbolDisplayPartKind[SymbolDisplayPartKind["className"] = 1] = "className";
        SymbolDisplayPartKind[SymbolDisplayPartKind["enumName"] = 2] = "enumName";
        SymbolDisplayPartKind[SymbolDisplayPartKind["fieldName"] = 3] = "fieldName";
        SymbolDisplayPartKind[SymbolDisplayPartKind["interfaceName"] = 4] = "interfaceName";
        SymbolDisplayPartKind[SymbolDisplayPartKind["keyword"] = 5] = "keyword";
        SymbolDisplayPartKind[SymbolDisplayPartKind["labelName"] = 6] = "labelName";
        SymbolDisplayPartKind[SymbolDisplayPartKind["lineBreak"] = 7] = "lineBreak";
        SymbolDisplayPartKind[SymbolDisplayPartKind["numericLiteral"] = 8] = "numericLiteral";
        SymbolDisplayPartKind[SymbolDisplayPartKind["stringLiteral"] = 9] = "stringLiteral";
        SymbolDisplayPartKind[SymbolDisplayPartKind["localName"] = 10] = "localName";
        SymbolDisplayPartKind[SymbolDisplayPartKind["methodName"] = 11] = "methodName";
        SymbolDisplayPartKind[SymbolDisplayPartKind["moduleName"] = 12] = "moduleName";
        SymbolDisplayPartKind[SymbolDisplayPartKind["namespaceName"] = 13] = "namespaceName";
        SymbolDisplayPartKind[SymbolDisplayPartKind["operator"] = 14] = "operator";
        SymbolDisplayPartKind[SymbolDisplayPartKind["parameterName"] = 15] = "parameterName";
        SymbolDisplayPartKind[SymbolDisplayPartKind["propertyName"] = 16] = "propertyName";
        SymbolDisplayPartKind[SymbolDisplayPartKind["punctuation"] = 17] = "punctuation";
        SymbolDisplayPartKind[SymbolDisplayPartKind["space"] = 18] = "space";
        SymbolDisplayPartKind[SymbolDisplayPartKind["anonymousTypeIndicator"] = 19] = "anonymousTypeIndicator";
        SymbolDisplayPartKind[SymbolDisplayPartKind["text"] = 20] = "text";
        SymbolDisplayPartKind[SymbolDisplayPartKind["typeParameterName"] = 21] = "typeParameterName";
        SymbolDisplayPartKind[SymbolDisplayPartKind["enumMemberName"] = 22] = "enumMemberName";
        SymbolDisplayPartKind[SymbolDisplayPartKind["functionName"] = 23] = "functionName";
        SymbolDisplayPartKind[SymbolDisplayPartKind["regularExpressionLiteral"] = 24] = "regularExpressionLiteral";
    })(ts.SymbolDisplayPartKind || (ts.SymbolDisplayPartKind = {}));
    var SymbolDisplayPartKind = ts.SymbolDisplayPartKind;
})(ts || (ts = {}));
/// <reference path="types.ts"/>
var ts;
(function (ts) {
    function forEach(array, callback) {
        var result;
        if (array) {
            for (var i = 0, len = array.length; i < len; i++) {
                if (result = callback(array[i]))
                    break;
            }
        }
        return result;
    }
    ts.forEach = forEach;
    function contains(array, value) {
        if (array) {
            for (var i = 0, len = array.length; i < len; i++) {
                if (array[i] === value) {
                    return true;
                }
            }
        }
        return false;
    }
    ts.contains = contains;
    function indexOf(array, value) {
        if (array) {
            for (var i = 0, len = array.length; i < len; i++) {
                if (array[i] === value) {
                    return i;
                }
            }
        }
        return -1;
    }
    ts.indexOf = indexOf;
    function filter(array, f) {
        if (array) {
            var result = [];
            for (var i = 0, len = array.length; i < len; i++) {
                var item = array[i];
                if (f(item)) {
                    result.push(item);
                }
            }
        }
        return result;
    }
    ts.filter = filter;
    function map(array, f) {
        if (array) {
            var result = [];
            for (var i = 0, len = array.length; i < len; i++) {
                result.push(f(array[i]));
            }
        }
        return result;
    }
    ts.map = map;
    function concatenate(array1, array2) {
        if (!array2 || !array2.length)
            return array1;
        if (!array1 || !array1.length)
            return array2;
        return array1.concat(array2);
    }
    ts.concatenate = concatenate;
    function uniqueElements(array) {
        if (array) {
            var result = [];
            for (var i = 0, len = array.length; i < len; i++) {
                var item = array[i];
                if (!contains(result, item))
                    result.push(item);
            }
        }
        return result;
    }
    ts.uniqueElements = uniqueElements;
    function sum(array, prop) {
        var result = 0;
        for (var i = 0; i < array.length; i++) {
            result += array[i][prop];
        }
        return result;
    }
    ts.sum = sum;
    function binarySearch(array, value) {
        var low = 0;
        var high = array.length - 1;
        while (low <= high) {
            var middle = low + ((high - low) >> 1);
            var midValue = array[middle];
            if (midValue === value) {
                return middle;
            }
            else if (midValue > value) {
                high = middle - 1;
            }
            else {
                low = middle + 1;
            }
        }
        return ~low;
    }
    ts.binarySearch = binarySearch;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    function hasProperty(map, key) {
        return hasOwnProperty.call(map, key);
    }
    ts.hasProperty = hasProperty;
    function getProperty(map, key) {
        return hasOwnProperty.call(map, key) ? map[key] : undefined;
    }
    ts.getProperty = getProperty;
    function isEmpty(map) {
        for (var id in map) {
            if (hasProperty(map, id)) {
                return false;
            }
        }
        return true;
    }
    ts.isEmpty = isEmpty;
    function clone(object) {
        var result = {};
        for (var id in object) {
            result[id] = object[id];
        }
        return result;
    }
    ts.clone = clone;
    function forEachValue(map, callback) {
        var result;
        for (var id in map) {
            if (result = callback(map[id]))
                break;
        }
        return result;
    }
    ts.forEachValue = forEachValue;
    function forEachKey(map, callback) {
        var result;
        for (var id in map) {
            if (result = callback(id))
                break;
        }
        return result;
    }
    ts.forEachKey = forEachKey;
    function lookUp(map, key) {
        return hasProperty(map, key) ? map[key] : undefined;
    }
    ts.lookUp = lookUp;
    function mapToArray(map) {
        var result = [];
        for (var id in map) {
            result.push(map[id]);
        }
        return result;
    }
    ts.mapToArray = mapToArray;
    /**
     * Creates a map from the elements of an array.
     *
     * @param array the array of input elements.
     * @param makeKey a function that produces a key for a given element.
     *
     * This function makes no effort to avoid collisions; if any two elements produce
     * the same key with the given 'makeKey' function, then the element with the higher
     * index in the array will be the one associated with the produced key.
     */
    function arrayToMap(array, makeKey) {
        var result = {};
        forEach(array, function (value) {
            result[makeKey(value)] = value;
        });
        return result;
    }
    ts.arrayToMap = arrayToMap;
    function formatStringFromArgs(text, args, baseIndex) {
        baseIndex = baseIndex || 0;
        return text.replace(/{(\d+)}/g, function (match, index) { return args[+index + baseIndex]; });
    }
    ts.localizedDiagnosticMessages = undefined;
    function getLocaleSpecificMessage(message) {
        if (ts.localizedDiagnosticMessages) {
            message = ts.localizedDiagnosticMessages[message];
        }
        return message;
    }
    ts.getLocaleSpecificMessage = getLocaleSpecificMessage;
    function createFileDiagnostic(file, start, length, message) {
        Debug.assert(start >= 0, "start must be non-negative, is " + start);
        Debug.assert(length >= 0, "length must be non-negative, is " + length);
        var text = getLocaleSpecificMessage(message.key);
        if (arguments.length > 4) {
            text = formatStringFromArgs(text, arguments, 4);
        }
        return {
            file: file,
            start: start,
            length: length,
            messageText: text,
            category: message.category,
            code: message.code
        };
    }
    ts.createFileDiagnostic = createFileDiagnostic;
    function createCompilerDiagnostic(message) {
        var text = getLocaleSpecificMessage(message.key);
        if (arguments.length > 1) {
            text = formatStringFromArgs(text, arguments, 1);
        }
        return {
            file: undefined,
            start: undefined,
            length: undefined,
            messageText: text,
            category: message.category,
            code: message.code
        };
    }
    ts.createCompilerDiagnostic = createCompilerDiagnostic;
    function chainDiagnosticMessages(details, message) {
        var text = getLocaleSpecificMessage(message.key);
        if (arguments.length > 2) {
            text = formatStringFromArgs(text, arguments, 2);
        }
        return {
            messageText: text,
            category: message.category,
            code: message.code,
            next: details
        };
    }
    ts.chainDiagnosticMessages = chainDiagnosticMessages;
    function flattenDiagnosticChain(file, start, length, diagnosticChain, newLine) {
        Debug.assert(start >= 0, "start must be non-negative, is " + start);
        Debug.assert(length >= 0, "length must be non-negative, is " + length);
        var code = diagnosticChain.code;
        var category = diagnosticChain.category;
        var messageText = "";
        var indent = 0;
        while (diagnosticChain) {
            if (indent) {
                messageText += newLine;
                for (var i = 0; i < indent; i++) {
                    messageText += "  ";
                }
            }
            messageText += diagnosticChain.messageText;
            indent++;
            diagnosticChain = diagnosticChain.next;
        }
        return {
            file: file,
            start: start,
            length: length,
            code: code,
            category: category,
            messageText: messageText
        };
    }
    ts.flattenDiagnosticChain = flattenDiagnosticChain;
    function compareValues(a, b) {
        if (a === b)
            return 0;
        if (a === undefined)
            return -1;
        if (b === undefined)
            return 1;
        return a < b ? -1 : 1;
    }
    ts.compareValues = compareValues;
    function getDiagnosticFilename(diagnostic) {
        return diagnostic.file ? diagnostic.file.filename : undefined;
    }
    function compareDiagnostics(d1, d2) {
        return compareValues(getDiagnosticFilename(d1), getDiagnosticFilename(d2)) || compareValues(d1.start, d2.start) || compareValues(d1.length, d2.length) || compareValues(d1.code, d2.code) || compareValues(d1.messageText, d2.messageText) || 0;
    }
    ts.compareDiagnostics = compareDiagnostics;
    function deduplicateSortedDiagnostics(diagnostics) {
        if (diagnostics.length < 2) {
            return diagnostics;
        }
        var newDiagnostics = [diagnostics[0]];
        var previousDiagnostic = diagnostics[0];
        for (var i = 1; i < diagnostics.length; i++) {
            var currentDiagnostic = diagnostics[i];
            var isDupe = compareDiagnostics(currentDiagnostic, previousDiagnostic) === 0;
            if (!isDupe) {
                newDiagnostics.push(currentDiagnostic);
                previousDiagnostic = currentDiagnostic;
            }
        }
        return newDiagnostics;
    }
    ts.deduplicateSortedDiagnostics = deduplicateSortedDiagnostics;
    function normalizeSlashes(path) {
        return path.replace(/\\/g, "/");
    }
    ts.normalizeSlashes = normalizeSlashes;
    // Returns length of path root (i.e. length of "/", "x:/", "//server/share/")
    function getRootLength(path) {
        if (path.charCodeAt(0) === 47 /* slash */) {
            if (path.charCodeAt(1) !== 47 /* slash */)
                return 1;
            var p1 = path.indexOf("/", 2);
            if (p1 < 0)
                return 2;
            var p2 = path.indexOf("/", p1 + 1);
            if (p2 < 0)
                return p1 + 1;
            return p2 + 1;
        }
        if (path.charCodeAt(1) === 58 /* colon */) {
            if (path.charCodeAt(2) === 47 /* slash */)
                return 3;
            return 2;
        }
        return 0;
    }
    ts.getRootLength = getRootLength;
    ts.directorySeparator = "/";
    function getNormalizedParts(normalizedSlashedPath, rootLength) {
        var parts = normalizedSlashedPath.substr(rootLength).split(ts.directorySeparator);
        var normalized = [];
        for (var i = 0; i < parts.length; i++) {
            var part = parts[i];
            if (part !== ".") {
                if (part === ".." && normalized.length > 0 && normalized[normalized.length - 1] !== "..") {
                    normalized.pop();
                }
                else {
                    normalized.push(part);
                }
            }
        }
        return normalized;
    }
    function normalizePath(path) {
        var path = normalizeSlashes(path);
        var rootLength = getRootLength(path);
        var normalized = getNormalizedParts(path, rootLength);
        return path.substr(0, rootLength) + normalized.join(ts.directorySeparator);
    }
    ts.normalizePath = normalizePath;
    function getDirectoryPath(path) {
        return path.substr(0, Math.max(getRootLength(path), path.lastIndexOf(ts.directorySeparator)));
    }
    ts.getDirectoryPath = getDirectoryPath;
    function isUrl(path) {
        return path && !isRootedDiskPath(path) && path.indexOf("://") !== -1;
    }
    ts.isUrl = isUrl;
    function isRootedDiskPath(path) {
        return getRootLength(path) !== 0;
    }
    ts.isRootedDiskPath = isRootedDiskPath;
    function normalizedPathComponents(path, rootLength) {
        var normalizedParts = getNormalizedParts(path, rootLength);
        return [path.substr(0, rootLength)].concat(normalizedParts);
    }
    function getNormalizedPathComponents(path, currentDirectory) {
        var path = normalizeSlashes(path);
        var rootLength = getRootLength(path);
        if (rootLength == 0) {
            // If the path is not rooted it is relative to current directory
            path = combinePaths(normalizeSlashes(currentDirectory), path);
            rootLength = getRootLength(path);
        }
        return normalizedPathComponents(path, rootLength);
    }
    ts.getNormalizedPathComponents = getNormalizedPathComponents;
    function getNormalizedPathFromPathComponents(pathComponents) {
        if (pathComponents && pathComponents.length) {
            return pathComponents[0] + pathComponents.slice(1).join(ts.directorySeparator);
        }
    }
    ts.getNormalizedPathFromPathComponents = getNormalizedPathFromPathComponents;
    function getNormalizedPathComponentsOfUrl(url) {
        // Get root length of http://www.website.com/folder1/foler2/
        // In this example the root is:  http://www.website.com/ 
        // normalized path components should be ["http://www.website.com/", "folder1", "folder2"]
        var urlLength = url.length;
        // Initial root length is http:// part
        var rootLength = url.indexOf("://") + "://".length;
        while (rootLength < urlLength) {
            // Consume all immediate slashes in the protocol 
            // eg.initial rootlength is just file:// but it needs to consume another "/" in file:///
            if (url.charCodeAt(rootLength) === 47 /* slash */) {
                rootLength++;
            }
            else {
                break;
            }
        }
        // there are no parts after http:// just return current string as the pathComponent
        if (rootLength === urlLength) {
            return [url];
        }
        // Find the index of "/" after website.com so the root can be http://www.website.com/ (from existing http://)
        var indexOfNextSlash = url.indexOf(ts.directorySeparator, rootLength);
        if (indexOfNextSlash !== -1) {
            // Found the "/" after the website.com so the root is length of http://www.website.com/ 
            // and get components afetr the root normally like any other folder components
            rootLength = indexOfNextSlash + 1;
            return normalizedPathComponents(url, rootLength);
        }
        else {
            // Can't find the host assume the rest of the string as component 
            // but make sure we append "/"  to it as root is not joined using "/"
            // eg. if url passed in was http://website.com we want to use root as [http://website.com/] 
            // so that other path manipulations will be correct and it can be merged with relative paths correctly
            return [url + ts.directorySeparator];
        }
    }
    function getNormalizedPathOrUrlComponents(pathOrUrl, currentDirectory) {
        if (isUrl(pathOrUrl)) {
            return getNormalizedPathComponentsOfUrl(pathOrUrl);
        }
        else {
            return getNormalizedPathComponents(pathOrUrl, currentDirectory);
        }
    }
    function getRelativePathToDirectoryOrUrl(directoryPathOrUrl, relativeOrAbsolutePath, currentDirectory, isAbsolutePathAnUrl) {
        var pathComponents = getNormalizedPathOrUrlComponents(relativeOrAbsolutePath, currentDirectory);
        var directoryComponents = getNormalizedPathOrUrlComponents(directoryPathOrUrl, currentDirectory);
        if (directoryComponents.length > 1 && directoryComponents[directoryComponents.length - 1] === "") {
            // If the directory path given was of type test/cases/ then we really need components of directory to be only till its name
            // that is  ["test", "cases", ""] needs to be actually ["test", "cases"]
            directoryComponents.length--;
        }
        for (var joinStartIndex = 0; joinStartIndex < pathComponents.length && joinStartIndex < directoryComponents.length; joinStartIndex++) {
            if (directoryComponents[joinStartIndex] !== pathComponents[joinStartIndex]) {
                break;
            }
        }
        // Get the relative path
        if (joinStartIndex) {
            var relativePath = "";
            var relativePathComponents = pathComponents.slice(joinStartIndex, pathComponents.length);
            for (; joinStartIndex < directoryComponents.length; joinStartIndex++) {
                if (directoryComponents[joinStartIndex] !== "") {
                    relativePath = relativePath + ".." + ts.directorySeparator;
                }
            }
            return relativePath + relativePathComponents.join(ts.directorySeparator);
        }
        // Cant find the relative path, get the absolute path
        var absolutePath = getNormalizedPathFromPathComponents(pathComponents);
        if (isAbsolutePathAnUrl && isRootedDiskPath(absolutePath)) {
            absolutePath = "file:///" + absolutePath;
        }
        return absolutePath;
    }
    ts.getRelativePathToDirectoryOrUrl = getRelativePathToDirectoryOrUrl;
    function getBaseFilename(path) {
        var i = path.lastIndexOf(ts.directorySeparator);
        return i < 0 ? path : path.substring(i + 1);
    }
    ts.getBaseFilename = getBaseFilename;
    function combinePaths(path1, path2) {
        if (!(path1 && path1.length))
            return path2;
        if (!(path2 && path2.length))
            return path1;
        if (path2.charAt(0) === ts.directorySeparator)
            return path2;
        if (path1.charAt(path1.length - 1) === ts.directorySeparator)
            return path1 + path2;
        return path1 + ts.directorySeparator + path2;
    }
    ts.combinePaths = combinePaths;
    function fileExtensionIs(path, extension) {
        var pathLen = path.length;
        var extLen = extension.length;
        return pathLen > extLen && path.substr(pathLen - extLen, extLen) === extension;
    }
    ts.fileExtensionIs = fileExtensionIs;
    function Symbol(flags, name) {
        this.flags = flags;
        this.name = name;
        this.declarations = undefined;
    }
    function Type(checker, flags) {
        this.flags = flags;
    }
    function Signature(checker) {
    }
    ts.objectAllocator = {
        getNodeConstructor: function (kind) {
            function Node() {
            }
            Node.prototype = {
                kind: kind,
                pos: 0,
                end: 0,
                flags: 0,
                parent: undefined
            };
            return Node;
        },
        getSymbolConstructor: function () { return Symbol; },
        getTypeConstructor: function () { return Type; },
        getSignatureConstructor: function () { return Signature; }
    };
    (function (AssertionLevel) {
        AssertionLevel[AssertionLevel["None"] = 0] = "None";
        AssertionLevel[AssertionLevel["Normal"] = 1] = "Normal";
        AssertionLevel[AssertionLevel["Aggressive"] = 2] = "Aggressive";
        AssertionLevel[AssertionLevel["VeryAggressive"] = 3] = "VeryAggressive";
    })(ts.AssertionLevel || (ts.AssertionLevel = {}));
    var AssertionLevel = ts.AssertionLevel;
    var Debug;
    (function (Debug) {
        var currentAssertionLevel = 0 /* None */;
        function shouldAssert(level) {
            return currentAssertionLevel >= level;
        }
        Debug.shouldAssert = shouldAssert;
        function assert(expression, message, verboseDebugInfo) {
            if (!expression) {
                var verboseDebugString = "";
                if (verboseDebugInfo) {
                    verboseDebugString = "\r\nVerbose Debug Information: " + verboseDebugInfo();
                }
                throw new Error("Debug Failure. False expression: " + (message || "") + verboseDebugString);
            }
        }
        Debug.assert = assert;
        function fail(message) {
            Debug.assert(false, message);
        }
        Debug.fail = fail;
    })(Debug = ts.Debug || (ts.Debug = {}));
})(ts || (ts = {}));
/// <reference path="types.ts"/>
/// <reference path="core.ts"/>
/// <reference path="scanner.ts"/>
var ts;
(function (ts) {
    var nodeConstructors = new Array(185 /* Count */);
    function getNodeConstructor(kind) {
        return nodeConstructors[kind] || (nodeConstructors[kind] = ts.objectAllocator.getNodeConstructor(kind));
    }
    ts.getNodeConstructor = getNodeConstructor;
    function createRootNode(kind, pos, end, flags) {
        var node = new (getNodeConstructor(kind))();
        node.pos = pos;
        node.end = end;
        node.flags = flags;
        return node;
    }
    var moduleExtensions = [".d.ts", ".ts", ".js"];
    function getModuleNameFromFilename(filename) {
        for (var i = 0; i < moduleExtensions.length; i++) {
            var ext = moduleExtensions[i];
            var len = filename.length - ext.length;
            if (len > 0 && filename.substr(len) === ext)
                return filename.substr(0, len);
        }
        return filename;
    }
    ts.getModuleNameFromFilename = getModuleNameFromFilename;
    function getSourceFileOfNode(node) {
        while (node && node.kind !== 182 /* SourceFile */)
            node = node.parent;
        return node;
    }
    ts.getSourceFileOfNode = getSourceFileOfNode;
    // This is a useful function for debugging purposes.
    function nodePosToString(node) {
        var file = getSourceFileOfNode(node);
        var loc = file.getLineAndCharacterFromPosition(node.pos);
        return file.filename + "(" + loc.line + "," + loc.character + ")";
    }
    ts.nodePosToString = nodePosToString;
    function getStartPosOfNode(node) {
        return node.pos;
    }
    ts.getStartPosOfNode = getStartPosOfNode;
    function getTokenPosOfNode(node, sourceFile) {
        return ts.skipTrivia((sourceFile || getSourceFileOfNode(node)).text, node.pos);
    }
    ts.getTokenPosOfNode = getTokenPosOfNode;
    function getSourceTextOfNodeFromSourceText(sourceText, node) {
        return sourceText.substring(ts.skipTrivia(sourceText, node.pos), node.end);
    }
    ts.getSourceTextOfNodeFromSourceText = getSourceTextOfNodeFromSourceText;
    function getSourceTextOfNode(node) {
        var text = getSourceFileOfNode(node).text;
        return text.substring(ts.skipTrivia(text, node.pos), node.end);
    }
    ts.getSourceTextOfNode = getSourceTextOfNode;
    // Add an extra underscore to identifiers that start with two underscores to avoid issues with magic names like '__proto__'
    function escapeIdentifier(identifier) {
        return identifier.length >= 2 && identifier.charCodeAt(0) === 95 /* _ */ && identifier.charCodeAt(1) === 95 /* _ */ ? "_" + identifier : identifier;
    }
    ts.escapeIdentifier = escapeIdentifier;
    // Remove extra underscore from escaped identifier
    function unescapeIdentifier(identifier) {
        return identifier.length >= 3 && identifier.charCodeAt(0) === 95 /* _ */ && identifier.charCodeAt(1) === 95 /* _ */ && identifier.charCodeAt(2) === 95 /* _ */ ? identifier.substr(1) : identifier;
    }
    ts.unescapeIdentifier = unescapeIdentifier;
    // Return display name of an identifier
    function identifierToString(identifier) {
        return identifier.kind === 115 /* Missing */ ? "(Missing)" : getSourceTextOfNode(identifier);
    }
    ts.identifierToString = identifierToString;
    function createDiagnosticForNode(node, message, arg0, arg1, arg2) {
        node = getErrorSpanForNode(node);
        var file = getSourceFileOfNode(node);
        var start = node.kind === 115 /* Missing */ ? node.pos : ts.skipTrivia(file.text, node.pos);
        var length = node.end - start;
        return ts.createFileDiagnostic(file, start, length, message, arg0, arg1, arg2);
    }
    ts.createDiagnosticForNode = createDiagnosticForNode;
    function createDiagnosticForNodeFromMessageChain(node, messageChain, newLine) {
        node = getErrorSpanForNode(node);
        var file = getSourceFileOfNode(node);
        var start = ts.skipTrivia(file.text, node.pos);
        var length = node.end - start;
        return ts.flattenDiagnosticChain(file, start, length, messageChain, newLine);
    }
    ts.createDiagnosticForNodeFromMessageChain = createDiagnosticForNodeFromMessageChain;
    function getErrorSpanForNode(node) {
        var errorSpan;
        switch (node.kind) {
            case 171 /* VariableDeclaration */:
            case 174 /* ClassDeclaration */:
            case 175 /* InterfaceDeclaration */:
            case 177 /* ModuleDeclaration */:
            case 176 /* EnumDeclaration */:
            case 181 /* EnumMember */:
                errorSpan = node.name;
                break;
        }
        // We now have the ideal error span, but it may be a node that is optional and absent
        // (e.g. the name of a function expression), in which case errorSpan will be undefined.
        // Alternatively, it might be required and missing (e.g. the name of a module), in which
        // case its pos will equal its end (length 0). In either of these cases, we should fall
        // back to the original node that the error was issued on.
        return errorSpan && errorSpan.pos < errorSpan.end ? errorSpan : node;
    }
    ts.getErrorSpanForNode = getErrorSpanForNode;
    function isExternalModule(file) {
        return file.externalModuleIndicator !== undefined;
    }
    ts.isExternalModule = isExternalModule;
    function isPrologueDirective(node) {
        return node.kind === 151 /* ExpressionStatement */ && node.expression.kind === 7 /* StringLiteral */;
    }
    ts.isPrologueDirective = isPrologueDirective;
    function isEvalOrArgumentsIdentifier(node) {
        return node.kind === 59 /* Identifier */ && node.text && (node.text === "eval" || node.text === "arguments");
    }
    /// Should be called only on prologue directives (isPrologueDirective(node) should be true)
    function isUseStrictPrologueDirective(node) {
        ts.Debug.assert(isPrologueDirective(node));
        return node.expression.text === "use strict";
    }
    function getLeadingCommentRangesOfNode(node, sourceFileOfNode) {
        sourceFileOfNode = sourceFileOfNode || getSourceFileOfNode(node);
        // If parameter/type parameter, the prev token trailing comments are part of this node too
        if (node.kind === 118 /* Parameter */ || node.kind === 117 /* TypeParameter */) {
            // e.g.   (/** blah */ a, /** blah */ b);
            return ts.concatenate(ts.getTrailingCommentRanges(sourceFileOfNode.text, node.pos), ts.getLeadingCommentRanges(sourceFileOfNode.text, node.pos));
        }
        else {
            return ts.getLeadingCommentRanges(sourceFileOfNode.text, node.pos);
        }
    }
    ts.getLeadingCommentRangesOfNode = getLeadingCommentRangesOfNode;
    function getJsDocComments(node, sourceFileOfNode) {
        return ts.filter(getLeadingCommentRangesOfNode(node, sourceFileOfNode), function (comment) { return isJsDocComment(comment); });
        function isJsDocComment(comment) {
            // True if the comment starts with '/**' but not if it is '/**/'
            return sourceFileOfNode.text.charCodeAt(comment.pos + 1) === 42 /* asterisk */ && sourceFileOfNode.text.charCodeAt(comment.pos + 2) === 42 /* asterisk */ && sourceFileOfNode.text.charCodeAt(comment.pos + 3) !== 47 /* slash */;
        }
    }
    ts.getJsDocComments = getJsDocComments;
    ts.fullTripleSlashReferencePathRegEx = /^(\/\/\/\s*<reference\s+path\s*=\s*)('|")(.+?)\2.*?\/>/;
    // Invokes a callback for each child of the given node. The 'cbNode' callback is invoked for all child nodes
    // stored in properties. If a 'cbNodes' callback is specified, it is invoked for embedded arrays; otherwise,
    // embedded arrays are flattened and the 'cbNode' callback is invoked for each element. If a callback returns
    // a truthy value, iteration stops and that value is returned. Otherwise, undefined is returned.
    function forEachChild(node, cbNode, cbNodes) {
        function child(node) {
            if (node)
                return cbNode(node);
        }
        function children(nodes) {
            if (nodes) {
                if (cbNodes)
                    return cbNodes(nodes);
                var result;
                for (var i = 0, len = nodes.length; i < len; i++) {
                    if (result = cbNode(nodes[i]))
                        break;
                }
                return result;
            }
        }
        if (!node)
            return;
        switch (node.kind) {
            case 116 /* QualifiedName */:
                return child(node.left) || child(node.right);
            case 117 /* TypeParameter */:
                return child(node.name) || child(node.constraint);
            case 118 /* Parameter */:
                return child(node.name) || child(node.type) || child(node.initializer);
            case 119 /* Property */:
            case 134 /* PropertyAssignment */:
                return child(node.name) || child(node.type) || child(node.initializer);
            case 124 /* CallSignature */:
            case 125 /* ConstructSignature */:
            case 126 /* IndexSignature */:
                return children(node.typeParameters) || children(node.parameters) || child(node.type);
            case 120 /* Method */:
            case 121 /* Constructor */:
            case 122 /* GetAccessor */:
            case 123 /* SetAccessor */:
            case 141 /* FunctionExpression */:
            case 172 /* FunctionDeclaration */:
            case 142 /* ArrowFunction */:
                return child(node.name) || children(node.typeParameters) || children(node.parameters) || child(node.type) || child(node.body);
            case 127 /* TypeReference */:
                return child(node.typeName) || children(node.typeArguments);
            case 128 /* TypeQuery */:
                return child(node.exprName);
            case 129 /* TypeLiteral */:
                return children(node.members);
            case 130 /* ArrayType */:
                return child(node.elementType);
            case 131 /* TupleType */:
                return children(node.elementTypes);
            case 132 /* ArrayLiteral */:
                return children(node.elements);
            case 133 /* ObjectLiteral */:
                return children(node.properties);
            case 135 /* PropertyAccess */:
                return child(node.left) || child(node.right);
            case 136 /* IndexedAccess */:
                return child(node.object) || child(node.index);
            case 137 /* CallExpression */:
            case 138 /* NewExpression */:
                return child(node.func) || children(node.typeArguments) || children(node.arguments);
            case 139 /* TypeAssertion */:
                return child(node.type) || child(node.operand);
            case 140 /* ParenExpression */:
                return child(node.expression);
            case 143 /* PrefixOperator */:
            case 144 /* PostfixOperator */:
                return child(node.operand);
            case 145 /* BinaryExpression */:
                return child(node.left) || child(node.right);
            case 146 /* ConditionalExpression */:
                return child(node.condition) || child(node.whenTrue) || child(node.whenFalse);
            case 148 /* Block */:
            case 167 /* TryBlock */:
            case 169 /* FinallyBlock */:
            case 173 /* FunctionBlock */:
            case 178 /* ModuleBlock */:
            case 182 /* SourceFile */:
                return children(node.statements);
            case 149 /* VariableStatement */:
                return children(node.declarations);
            case 151 /* ExpressionStatement */:
                return child(node.expression);
            case 152 /* IfStatement */:
                return child(node.expression) || child(node.thenStatement) || child(node.elseStatement);
            case 153 /* DoStatement */:
                return child(node.statement) || child(node.expression);
            case 154 /* WhileStatement */:
                return child(node.expression) || child(node.statement);
            case 155 /* ForStatement */:
                return children(node.declarations) || child(node.initializer) || child(node.condition) || child(node.iterator) || child(node.statement);
            case 156 /* ForInStatement */:
                return child(node.declaration) || child(node.variable) || child(node.expression) || child(node.statement);
            case 157 /* ContinueStatement */:
            case 158 /* BreakStatement */:
                return child(node.label);
            case 159 /* ReturnStatement */:
                return child(node.expression);
            case 160 /* WithStatement */:
                return child(node.expression) || child(node.statement);
            case 161 /* SwitchStatement */:
                return child(node.expression) || children(node.clauses);
            case 162 /* CaseClause */:
            case 163 /* DefaultClause */:
                return child(node.expression) || children(node.statements);
            case 164 /* LabeledStatement */:
                return child(node.label) || child(node.statement);
            case 165 /* ThrowStatement */:
                return child(node.expression);
            case 166 /* TryStatement */:
                return child(node.tryBlock) || child(node.catchBlock) || child(node.finallyBlock);
            case 168 /* CatchBlock */:
                return child(node.variable) || children(node.statements);
            case 171 /* VariableDeclaration */:
                return child(node.name) || child(node.type) || child(node.initializer);
            case 174 /* ClassDeclaration */:
                return child(node.name) || children(node.typeParameters) || child(node.baseType) || children(node.implementedTypes) || children(node.members);
            case 175 /* InterfaceDeclaration */:
                return child(node.name) || children(node.typeParameters) || children(node.baseTypes) || children(node.members);
            case 176 /* EnumDeclaration */:
                return child(node.name) || children(node.members);
            case 181 /* EnumMember */:
                return child(node.name) || child(node.initializer);
            case 177 /* ModuleDeclaration */:
                return child(node.name) || child(node.body);
            case 179 /* ImportDeclaration */:
                return child(node.name) || child(node.entityName) || child(node.externalModuleName);
            case 180 /* ExportAssignment */:
                return child(node.exportName);
        }
    }
    ts.forEachChild = forEachChild;
    // Warning: This has the same semantics as the forEach family of functions,
    //          in that traversal terminates in the event that 'visitor' supplies a truthy value.
    function forEachReturnStatement(body, visitor) {
        return traverse(body);
        function traverse(node) {
            switch (node.kind) {
                case 159 /* ReturnStatement */:
                    return visitor(node);
                case 148 /* Block */:
                case 173 /* FunctionBlock */:
                case 152 /* IfStatement */:
                case 153 /* DoStatement */:
                case 154 /* WhileStatement */:
                case 155 /* ForStatement */:
                case 156 /* ForInStatement */:
                case 160 /* WithStatement */:
                case 161 /* SwitchStatement */:
                case 162 /* CaseClause */:
                case 163 /* DefaultClause */:
                case 164 /* LabeledStatement */:
                case 166 /* TryStatement */:
                case 167 /* TryBlock */:
                case 168 /* CatchBlock */:
                case 169 /* FinallyBlock */:
                    return forEachChild(node, traverse);
            }
        }
    }
    ts.forEachReturnStatement = forEachReturnStatement;
    function isAnyFunction(node) {
        if (node) {
            switch (node.kind) {
                case 141 /* FunctionExpression */:
                case 172 /* FunctionDeclaration */:
                case 142 /* ArrowFunction */:
                case 120 /* Method */:
                case 122 /* GetAccessor */:
                case 123 /* SetAccessor */:
                case 121 /* Constructor */:
                    return true;
            }
        }
        return false;
    }
    ts.isAnyFunction = isAnyFunction;
    function getContainingFunction(node) {
        while (true) {
            node = node.parent;
            if (!node || isAnyFunction(node)) {
                return node;
            }
        }
    }
    ts.getContainingFunction = getContainingFunction;
    function getThisContainer(node, includeArrowFunctions) {
        while (true) {
            node = node.parent;
            if (!node) {
                return undefined;
            }
            switch (node.kind) {
                case 142 /* ArrowFunction */:
                    if (!includeArrowFunctions) {
                        continue;
                    }
                case 172 /* FunctionDeclaration */:
                case 141 /* FunctionExpression */:
                case 177 /* ModuleDeclaration */:
                case 119 /* Property */:
                case 120 /* Method */:
                case 121 /* Constructor */:
                case 122 /* GetAccessor */:
                case 123 /* SetAccessor */:
                case 176 /* EnumDeclaration */:
                case 182 /* SourceFile */:
                    return node;
            }
        }
    }
    ts.getThisContainer = getThisContainer;
    function getSuperContainer(node) {
        while (true) {
            node = node.parent;
            if (!node) {
                return undefined;
            }
            switch (node.kind) {
                case 119 /* Property */:
                case 120 /* Method */:
                case 121 /* Constructor */:
                case 122 /* GetAccessor */:
                case 123 /* SetAccessor */:
                    return node;
            }
        }
    }
    ts.getSuperContainer = getSuperContainer;
    function hasRestParameters(s) {
        return s.parameters.length > 0 && (s.parameters[s.parameters.length - 1].flags & 8 /* Rest */) !== 0;
    }
    ts.hasRestParameters = hasRestParameters;
    function isInAmbientContext(node) {
        while (node) {
            if (node.flags & (2 /* Ambient */ | 1024 /* DeclarationFile */))
                return true;
            node = node.parent;
        }
        return false;
    }
    ts.isInAmbientContext = isInAmbientContext;
    function isDeclaration(node) {
        switch (node.kind) {
            case 117 /* TypeParameter */:
            case 118 /* Parameter */:
            case 171 /* VariableDeclaration */:
            case 119 /* Property */:
            case 134 /* PropertyAssignment */:
            case 181 /* EnumMember */:
            case 120 /* Method */:
            case 172 /* FunctionDeclaration */:
            case 122 /* GetAccessor */:
            case 123 /* SetAccessor */:
            case 174 /* ClassDeclaration */:
            case 175 /* InterfaceDeclaration */:
            case 176 /* EnumDeclaration */:
            case 177 /* ModuleDeclaration */:
            case 179 /* ImportDeclaration */:
                return true;
        }
        return false;
    }
    ts.isDeclaration = isDeclaration;
    function isStatement(n) {
        switch (n.kind) {
            case 158 /* BreakStatement */:
            case 157 /* ContinueStatement */:
            case 170 /* DebuggerStatement */:
            case 153 /* DoStatement */:
            case 151 /* ExpressionStatement */:
            case 150 /* EmptyStatement */:
            case 156 /* ForInStatement */:
            case 155 /* ForStatement */:
            case 152 /* IfStatement */:
            case 164 /* LabeledStatement */:
            case 159 /* ReturnStatement */:
            case 161 /* SwitchStatement */:
            case 88 /* ThrowKeyword */:
            case 166 /* TryStatement */:
            case 149 /* VariableStatement */:
            case 154 /* WhileStatement */:
            case 160 /* WithStatement */:
            case 180 /* ExportAssignment */:
                return true;
            default:
                return false;
        }
    }
    ts.isStatement = isStatement;
    // True if the given identifier, string literal, or number literal is the name of a declaration node
    function isDeclarationOrFunctionExpressionOrCatchVariableName(name) {
        if (name.kind !== 59 /* Identifier */ && name.kind !== 7 /* StringLiteral */ && name.kind !== 6 /* NumericLiteral */) {
            return false;
        }
        var parent = name.parent;
        if (isDeclaration(parent) || parent.kind === 141 /* FunctionExpression */) {
            return parent.name === name;
        }
        if (parent.kind === 168 /* CatchBlock */) {
            return parent.variable === name;
        }
        return false;
    }
    ts.isDeclarationOrFunctionExpressionOrCatchVariableName = isDeclarationOrFunctionExpressionOrCatchVariableName;
    function getAncestor(node, kind) {
        switch (kind) {
            case 174 /* ClassDeclaration */:
                while (node) {
                    switch (node.kind) {
                        case 174 /* ClassDeclaration */:
                            return node;
                        case 176 /* EnumDeclaration */:
                        case 175 /* InterfaceDeclaration */:
                        case 177 /* ModuleDeclaration */:
                        case 179 /* ImportDeclaration */:
                            // early exit cases - declarations cannot be nested in classes
                            return undefined;
                        default:
                            node = node.parent;
                            continue;
                    }
                }
                break;
            default:
                while (node) {
                    if (node.kind === kind) {
                        return node;
                    }
                    node = node.parent;
                }
                break;
        }
        return undefined;
    }
    ts.getAncestor = getAncestor;
    var ParsingContext;
    (function (ParsingContext) {
        ParsingContext[ParsingContext["SourceElements"] = 0] = "SourceElements";
        ParsingContext[ParsingContext["ModuleElements"] = 1] = "ModuleElements";
        ParsingContext[ParsingContext["BlockStatements"] = 2] = "BlockStatements";
        ParsingContext[ParsingContext["SwitchClauses"] = 3] = "SwitchClauses";
        ParsingContext[ParsingContext["SwitchClauseStatements"] = 4] = "SwitchClauseStatements";
        ParsingContext[ParsingContext["TypeMembers"] = 5] = "TypeMembers";
        ParsingContext[ParsingContext["ClassMembers"] = 6] = "ClassMembers";
        ParsingContext[ParsingContext["EnumMembers"] = 7] = "EnumMembers";
        ParsingContext[ParsingContext["BaseTypeReferences"] = 8] = "BaseTypeReferences";
        ParsingContext[ParsingContext["VariableDeclarations"] = 9] = "VariableDeclarations";
        ParsingContext[ParsingContext["ArgumentExpressions"] = 10] = "ArgumentExpressions";
        ParsingContext[ParsingContext["ObjectLiteralMembers"] = 11] = "ObjectLiteralMembers";
        ParsingContext[ParsingContext["ArrayLiteralMembers"] = 12] = "ArrayLiteralMembers";
        ParsingContext[ParsingContext["Parameters"] = 13] = "Parameters";
        ParsingContext[ParsingContext["TypeParameters"] = 14] = "TypeParameters";
        ParsingContext[ParsingContext["TypeArguments"] = 15] = "TypeArguments";
        ParsingContext[ParsingContext["TupleElementTypes"] = 16] = "TupleElementTypes";
        ParsingContext[ParsingContext["Count"] = 17] = "Count"; // Number of parsing contexts
    })(ParsingContext || (ParsingContext = {}));
    var Tristate;
    (function (Tristate) {
        Tristate[Tristate["False"] = 0] = "False";
        Tristate[Tristate["True"] = 1] = "True";
        Tristate[Tristate["Unknown"] = 2] = "Unknown";
    })(Tristate || (Tristate = {}));
    function parsingContextErrors(context) {
        switch (context) {
            case 0 /* SourceElements */:
                return ts.Diagnostics.Declaration_or_statement_expected;
            case 1 /* ModuleElements */:
                return ts.Diagnostics.Declaration_or_statement_expected;
            case 2 /* BlockStatements */:
                return ts.Diagnostics.Statement_expected;
            case 3 /* SwitchClauses */:
                return ts.Diagnostics.case_or_default_expected;
            case 4 /* SwitchClauseStatements */:
                return ts.Diagnostics.Statement_expected;
            case 5 /* TypeMembers */:
                return ts.Diagnostics.Property_or_signature_expected;
            case 6 /* ClassMembers */:
                return ts.Diagnostics.Unexpected_token_A_constructor_method_accessor_or_property_was_expected;
            case 7 /* EnumMembers */:
                return ts.Diagnostics.Enum_member_expected;
            case 8 /* BaseTypeReferences */:
                return ts.Diagnostics.Type_reference_expected;
            case 9 /* VariableDeclarations */:
                return ts.Diagnostics.Variable_declaration_expected;
            case 10 /* ArgumentExpressions */:
                return ts.Diagnostics.Argument_expression_expected;
            case 11 /* ObjectLiteralMembers */:
                return ts.Diagnostics.Property_assignment_expected;
            case 12 /* ArrayLiteralMembers */:
                return ts.Diagnostics.Expression_or_comma_expected;
            case 13 /* Parameters */:
                return ts.Diagnostics.Parameter_declaration_expected;
            case 14 /* TypeParameters */:
                return ts.Diagnostics.Type_parameter_declaration_expected;
            case 15 /* TypeArguments */:
                return ts.Diagnostics.Type_argument_expected;
            case 16 /* TupleElementTypes */:
                return ts.Diagnostics.Type_expected;
        }
    }
    ;
    var LookAheadMode;
    (function (LookAheadMode) {
        LookAheadMode[LookAheadMode["NotLookingAhead"] = 0] = "NotLookingAhead";
        LookAheadMode[LookAheadMode["NoErrorYet"] = 1] = "NoErrorYet";
        LookAheadMode[LookAheadMode["Error"] = 2] = "Error";
    })(LookAheadMode || (LookAheadMode = {}));
    var ModifierContext;
    (function (ModifierContext) {
        ModifierContext[ModifierContext["SourceElements"] = 0] = "SourceElements";
        ModifierContext[ModifierContext["ModuleElements"] = 1] = "ModuleElements";
        ModifierContext[ModifierContext["ClassMembers"] = 2] = "ClassMembers";
        ModifierContext[ModifierContext["Parameters"] = 3] = "Parameters";
    })(ModifierContext || (ModifierContext = {}));
    var TrailingCommaBehavior;
    (function (TrailingCommaBehavior) {
        TrailingCommaBehavior[TrailingCommaBehavior["Disallow"] = 0] = "Disallow";
        TrailingCommaBehavior[TrailingCommaBehavior["Allow"] = 1] = "Allow";
        TrailingCommaBehavior[TrailingCommaBehavior["Preserve"] = 2] = "Preserve";
    })(TrailingCommaBehavior || (TrailingCommaBehavior = {}));
    // Tracks whether we nested (directly or indirectly) in a certain control block.
    // Used for validating break and continue statements.
    var ControlBlockContext;
    (function (ControlBlockContext) {
        ControlBlockContext[ControlBlockContext["NotNested"] = 0] = "NotNested";
        ControlBlockContext[ControlBlockContext["Nested"] = 1] = "Nested";
        ControlBlockContext[ControlBlockContext["CrossingFunctionBoundary"] = 2] = "CrossingFunctionBoundary";
    })(ControlBlockContext || (ControlBlockContext = {}));
    function isKeyword(token) {
        return ts.SyntaxKind.FirstKeyword <= token && token <= ts.SyntaxKind.LastKeyword;
    }
    ts.isKeyword = isKeyword;
    function isModifier(token) {
        switch (token) {
            case 102 /* PublicKeyword */:
            case 100 /* PrivateKeyword */:
            case 101 /* ProtectedKeyword */:
            case 103 /* StaticKeyword */:
            case 72 /* ExportKeyword */:
            case 108 /* DeclareKeyword */:
                return true;
        }
        return false;
    }
    ts.isModifier = isModifier;
    function createSourceFile(filename, sourceText, languageVersion, version, isOpen) {
        if (isOpen === void 0) { isOpen = false; }
        var file;
        var scanner;
        var token;
        var parsingContext;
        var commentRanges;
        var identifiers = {};
        var identifierCount = 0;
        var nodeCount = 0;
        var lineStarts;
        var isInStrictMode = false;
        var lookAheadMode = 0 /* NotLookingAhead */;
        var inAmbientContext = false;
        var inFunctionBody = false;
        var inSwitchStatement = 0 /* NotNested */;
        var inIterationStatement = 0 /* NotNested */;
        // The following is a state machine that tracks what labels are in our current parsing
        // context. So if we are parsing a node that is nested (arbitrarily deeply) in a label,
        // it will be tracked in this data structure. It is used for checking break/continue
        // statements, and checking for duplicate labels.
        var labelledStatementInfo = (function () {
            // These are initialized on demand because labels are rare, so it is usually
            // not even necessary to allocate these.
            var functionBoundarySentinel;
            var currentLabelSet;
            var labelSetStack;
            var isIterationStack;
            function addLabel(label) {
                if (!currentLabelSet) {
                    currentLabelSet = {};
                }
                currentLabelSet[label.text] = true;
            }
            function pushCurrentLabelSet(isIterationStatement) {
                if (!labelSetStack && !isIterationStack) {
                    labelSetStack = [];
                    isIterationStack = [];
                }
                ts.Debug.assert(currentLabelSet !== undefined);
                labelSetStack.push(currentLabelSet);
                isIterationStack.push(isIterationStatement);
                currentLabelSet = undefined;
            }
            function pushFunctionBoundary() {
                if (!functionBoundarySentinel) {
                    functionBoundarySentinel = {};
                    if (!labelSetStack && !isIterationStack) {
                        labelSetStack = [];
                        isIterationStack = [];
                    }
                }
                ts.Debug.assert(currentLabelSet === undefined);
                labelSetStack.push(functionBoundarySentinel);
                // It does not matter what we push here, since we will never ask if a function boundary
                // is an iteration statement
                isIterationStack.push(false);
            }
            function pop() {
                // Assert that we are in a "pushed" state
                ts.Debug.assert(labelSetStack.length && isIterationStack.length && currentLabelSet === undefined);
                labelSetStack.pop();
                isIterationStack.pop();
            }
            function nodeIsNestedInLabel(label, requireIterationStatement, stopAtFunctionBoundary) {
                if (!requireIterationStatement && currentLabelSet && ts.hasProperty(currentLabelSet, label.text)) {
                    return 1 /* Nested */;
                }
                if (!labelSetStack) {
                    return 0 /* NotNested */;
                }
                // We want to start searching for the label at the lowest point in the tree,
                // and climb up from there. So we start at the end of the labelSetStack array.
                var crossedFunctionBoundary = false;
                for (var i = labelSetStack.length - 1; i >= 0; i--) {
                    var labelSet = labelSetStack[i];
                    // Not allowed to cross function boundaries, so stop if we encounter one
                    if (labelSet === functionBoundarySentinel) {
                        if (stopAtFunctionBoundary) {
                            break;
                        }
                        else {
                            crossedFunctionBoundary = true;
                            continue;
                        }
                    }
                    // If we require an iteration statement, only search in the current
                    // statement if it is an iteration statement
                    if (requireIterationStatement && isIterationStack[i] === false) {
                        continue;
                    }
                    if (ts.hasProperty(labelSet, label.text)) {
                        return crossedFunctionBoundary ? 2 /* CrossingFunctionBoundary */ : 1 /* Nested */;
                    }
                }
                // This is a bit of a misnomer. If the caller passed true for stopAtFunctionBoundary,
                // there actually may be an enclosing label across a function boundary, but we will
                // just return NotNested
                return 0 /* NotNested */;
            }
            return {
                addLabel: addLabel,
                pushCurrentLabelSet: pushCurrentLabelSet,
                pushFunctionBoundary: pushFunctionBoundary,
                pop: pop,
                nodeIsNestedInLabel: nodeIsNestedInLabel
            };
        })();
        function getLineAndCharacterlFromSourcePosition(position) {
            if (!lineStarts) {
                lineStarts = ts.getLineStarts(sourceText);
            }
            return ts.getLineAndCharacterOfPosition(lineStarts, position);
        }
        function getPositionFromSourceLineAndCharacter(line, character) {
            if (!lineStarts) {
                lineStarts = ts.getLineStarts(sourceText);
            }
            return ts.getPositionFromLineAndCharacter(lineStarts, line, character);
        }
        function error(message, arg0, arg1, arg2) {
            var start = scanner.getTokenPos();
            var length = scanner.getTextPos() - start;
            errorAtPos(start, length, message, arg0, arg1, arg2);
        }
        // This is just like createDiagnosticForNode except that it uses the current file
        // being parsed instead of the file containing the node. This is because during
        // parse, the nodes do not have parent pointers to get to the file.
        //
        // It is very intentional that we are not checking or changing the lookAheadMode value
        // here. 'grammarErrorOnNode' is called when we are doing extra grammar checks and not
        // when we are doing the actual parsing to determine what the user wrote.  In other 
        // words, this function is called once we have already parsed the node, and are just
        // applying some stricter checks on that node.
        function grammarErrorOnNode(node, message, arg0, arg1, arg2) {
            var span = getErrorSpanForNode(node);
            var start = span.end > span.pos ? ts.skipTrivia(file.text, span.pos) : span.pos;
            var length = span.end - start;
            file.syntacticErrors.push(ts.createFileDiagnostic(file, start, length, message, arg0, arg1, arg2));
        }
        function reportInvalidUseInStrictMode(node) {
            // identifierToString cannot be used here since it uses a backreference to 'parent' that is not yet set
            var name = sourceText.substring(ts.skipTrivia(sourceText, node.pos), node.end);
            grammarErrorOnNode(node, ts.Diagnostics.Invalid_use_of_0_in_strict_mode, name);
        }
        function grammarErrorAtPos(start, length, message, arg0, arg1, arg2) {
            file.syntacticErrors.push(ts.createFileDiagnostic(file, start, length, message, arg0, arg1, arg2));
        }
        function errorAtPos(start, length, message, arg0, arg1, arg2) {
            var lastErrorPos = file.syntacticErrors.length ? file.syntacticErrors[file.syntacticErrors.length - 1].start : -1;
            if (start !== lastErrorPos) {
                file.syntacticErrors.push(ts.createFileDiagnostic(file, start, length, message, arg0, arg1, arg2));
            }
            if (lookAheadMode === 1 /* NoErrorYet */) {
                lookAheadMode = 2 /* Error */;
            }
        }
        function scanError(message) {
            var pos = scanner.getTextPos();
            errorAtPos(pos, 0, message);
        }
        function onComment(pos, end) {
            if (commentRanges)
                commentRanges.push({ pos: pos, end: end });
        }
        function getNodePos() {
            return scanner.getStartPos();
        }
        function getNodeEnd() {
            return scanner.getStartPos();
        }
        function nextToken() {
            return token = scanner.scan();
        }
        function getTokenPos(pos) {
            return ts.skipTrivia(sourceText, pos);
        }
        function reScanGreaterToken() {
            return token = scanner.reScanGreaterToken();
        }
        function reScanSlashToken() {
            return token = scanner.reScanSlashToken();
        }
        function lookAheadHelper(callback, alwaysResetState) {
            // Keep track of the state we'll need to rollback to if lookahead fails (or if the 
            // caller asked us to always reset our state).
            var saveToken = token;
            var saveSyntacticErrorsLength = file.syntacticErrors.length;
            // Keep track of the current look ahead mode (this matters if we have nested 
            // speculative parsing).
            var saveLookAheadMode = lookAheadMode;
            // Mark that we're in speculative parsing and then try to parse out whatever code
            // the callback wants.
            lookAheadMode = 1 /* NoErrorYet */;
            var result = callback();
            // If we switched from 1 to -1 then a parse error occurred during the callback.
            // If that's the case, then we want to act as if we never got any result at all.
            ts.Debug.assert(lookAheadMode === 2 /* Error */ || lookAheadMode === 1 /* NoErrorYet */);
            if (lookAheadMode === 2 /* Error */) {
                result = undefined;
            }
            // Now restore as appropriate.
            lookAheadMode = saveLookAheadMode;
            if (!result || alwaysResetState) {
                token = saveToken;
                file.syntacticErrors.length = saveSyntacticErrorsLength;
            }
            return result;
        }
        function lookAhead(callback) {
            var result;
            scanner.tryScan(function () {
                result = lookAheadHelper(callback, true);
                // Returning false here indicates to the scanner that it should always jump
                // back to where it started.  This makes sense as 'lookahead' acts as if 
                // neither the parser nor scanner was affected by the operation.
                //
                // Note: the rewinding of the parser state is already handled in lookAheadHelper
                // (because we passed 'true' for alwaysResetState).
                return false;
            });
            return result;
        }
        function tryParse(callback) {
            return scanner.tryScan(function () { return lookAheadHelper(callback, false); });
        }
        function isIdentifier() {
            return token === 59 /* Identifier */ || (isInStrictMode ? token > ts.SyntaxKind.LastFutureReservedWord : token > ts.SyntaxKind.LastReservedWord);
        }
        function parseExpected(t) {
            if (token === t) {
                nextToken();
                return true;
            }
            error(ts.Diagnostics._0_expected, ts.tokenToString(t));
            return false;
        }
        function parseOptional(t) {
            if (token === t) {
                nextToken();
                return true;
            }
            return false;
        }
        function canParseSemicolon() {
            // If there's a real semicolon, then we can always parse it out.
            if (token === 17 /* SemicolonToken */) {
                return true;
            }
            // We can parse out an optional semicolon in ASI cases in the following cases.
            return token === 10 /* CloseBraceToken */ || token === 1 /* EndOfFileToken */ || scanner.hasPrecedingLineBreak();
        }
        function parseSemicolon() {
            if (canParseSemicolon()) {
                if (token === 17 /* SemicolonToken */) {
                    // consume the semicolon if it was explicitly provided.
                    nextToken();
                }
            }
            else {
                error(ts.Diagnostics._0_expected, ";");
            }
        }
        function createNode(kind, pos) {
            nodeCount++;
            var node = new (nodeConstructors[kind] || (nodeConstructors[kind] = ts.objectAllocator.getNodeConstructor(kind)))();
            if (!(pos >= 0))
                pos = scanner.getStartPos();
            node.pos = pos;
            node.end = pos;
            return node;
        }
        function finishNode(node) {
            node.end = scanner.getStartPos();
            return node;
        }
        function createMissingNode() {
            return createNode(115 /* Missing */);
        }
        function internIdentifier(text) {
            return ts.hasProperty(identifiers, text) ? identifiers[text] : (identifiers[text] = text);
        }
        // An identifier that starts with two underscores has an extra underscore character prepended to it to avoid issues
        // with magic property names like '__proto__'. The 'identifiers' object is used to share a single string instance for
        // each identifier in order to reduce memory consumption.
        function createIdentifier(isIdentifier) {
            identifierCount++;
            if (isIdentifier) {
                var node = createNode(59 /* Identifier */);
                var text = escapeIdentifier(scanner.getTokenValue());
                node.text = internIdentifier(text);
                nextToken();
                return finishNode(node);
            }
            error(ts.Diagnostics.Identifier_expected);
            return createMissingNode();
        }
        function parseIdentifier() {
            return createIdentifier(isIdentifier());
        }
        function parseIdentifierName() {
            return createIdentifier(token >= 59 /* Identifier */);
        }
        function isPropertyName() {
            return token >= 59 /* Identifier */ || token === 7 /* StringLiteral */ || token === 6 /* NumericLiteral */;
        }
        function parsePropertyName() {
            if (token === 7 /* StringLiteral */ || token === 6 /* NumericLiteral */) {
                return parseLiteralNode(true);
            }
            return parseIdentifierName();
        }
        function parseContextualModifier(t) {
            return token === t && tryParse(function () {
                nextToken();
                return token === 13 /* OpenBracketToken */ || isPropertyName();
            });
        }
        function parseAnyContextualModifier() {
            return isModifier(token) && tryParse(function () {
                nextToken();
                return token === 13 /* OpenBracketToken */ || isPropertyName();
            });
        }
        // True if positioned at the start of a list element
        function isListElement(kind, inErrorRecovery) {
            switch (kind) {
                case 0 /* SourceElements */:
                case 1 /* ModuleElements */:
                    return isSourceElement(inErrorRecovery);
                case 2 /* BlockStatements */:
                case 4 /* SwitchClauseStatements */:
                    return isStatement(inErrorRecovery);
                case 3 /* SwitchClauses */:
                    return token === 61 /* CaseKeyword */ || token === 67 /* DefaultKeyword */;
                case 5 /* TypeMembers */:
                    return isTypeMember();
                case 6 /* ClassMembers */:
                    return lookAhead(isClassMemberStart);
                case 7 /* EnumMembers */:
                case 11 /* ObjectLiteralMembers */:
                    return isPropertyName();
                case 8 /* BaseTypeReferences */:
                    return isIdentifier() && ((token !== 73 /* ExtendsKeyword */ && token !== 96 /* ImplementsKeyword */) || !lookAhead(function () { return (nextToken(), isIdentifier()); }));
                case 9 /* VariableDeclarations */:
                case 14 /* TypeParameters */:
                    return isIdentifier();
                case 10 /* ArgumentExpressions */:
                    return isExpression();
                case 12 /* ArrayLiteralMembers */:
                    return token === 18 /* CommaToken */ || isExpression();
                case 13 /* Parameters */:
                    return isParameter();
                case 15 /* TypeArguments */:
                case 16 /* TupleElementTypes */:
                    return isType();
            }
            ts.Debug.fail("Non-exhaustive case in 'isListElement'.");
        }
        // True if positioned at a list terminator
        function isListTerminator(kind) {
            if (token === 1 /* EndOfFileToken */) {
                // Being at the end of the file ends all lists.
                return true;
            }
            switch (kind) {
                case 1 /* ModuleElements */:
                case 2 /* BlockStatements */:
                case 3 /* SwitchClauses */:
                case 5 /* TypeMembers */:
                case 6 /* ClassMembers */:
                case 7 /* EnumMembers */:
                case 11 /* ObjectLiteralMembers */:
                    return token === 10 /* CloseBraceToken */;
                case 4 /* SwitchClauseStatements */:
                    return token === 10 /* CloseBraceToken */ || token === 61 /* CaseKeyword */ || token === 67 /* DefaultKeyword */;
                case 8 /* BaseTypeReferences */:
                    return token === 9 /* OpenBraceToken */ || token === 73 /* ExtendsKeyword */ || token === 96 /* ImplementsKeyword */;
                case 9 /* VariableDeclarations */:
                    return isVariableDeclaratorListTerminator();
                case 14 /* TypeParameters */:
                    // Tokens other than '>' are here for better error recovery
                    return token === 20 /* GreaterThanToken */ || token === 11 /* OpenParenToken */ || token === 9 /* OpenBraceToken */ || token === 73 /* ExtendsKeyword */ || token === 96 /* ImplementsKeyword */;
                case 10 /* ArgumentExpressions */:
                    // Tokens other than ')' are here for better error recovery
                    return token === 12 /* CloseParenToken */ || token === 17 /* SemicolonToken */;
                case 12 /* ArrayLiteralMembers */:
                case 16 /* TupleElementTypes */:
                    return token === 14 /* CloseBracketToken */;
                case 13 /* Parameters */:
                    // Tokens other than ')' and ']' (the latter for index signatures) are here for better error recovery
                    return token === 12 /* CloseParenToken */ || token === 14 /* CloseBracketToken */ || token === 9 /* OpenBraceToken */;
                case 15 /* TypeArguments */:
                    // Tokens other than '>' are here for better error recovery
                    return token === 20 /* GreaterThanToken */ || token === 11 /* OpenParenToken */;
            }
        }
        function isVariableDeclaratorListTerminator() {
            // If we can consume a semicolon (either explicitly, or with ASI), then consider us done 
            // with parsing the list of  variable declarators.
            if (canParseSemicolon()) {
                return true;
            }
            // in the case where we're parsing the variable declarator of a 'for-in' statement, we 
            // are done if we see an 'in' keyword in front of us.
            if (token === 80 /* InKeyword */) {
                return true;
            }
            // ERROR RECOVERY TWEAK:
            // For better error recovery, if we see an '=>' then we just stop immediately.  We've got an
            // arrow function here and it's going to be very unlikely that we'll resynchronize and get
            // another variable declaration.
            if (token === 27 /* EqualsGreaterThanToken */) {
                return true;
            }
            // Keep trying to parse out variable declarators.
            return false;
        }
        // True if positioned at element or terminator of the current list or any enclosing list
        function isInSomeParsingContext() {
            for (var kind = 0; kind < 17 /* Count */; kind++) {
                if (parsingContext & (1 << kind)) {
                    if (isListElement(kind, true) || isListTerminator(kind)) {
                        return true;
                    }
                }
            }
            return false;
        }
        // Parses a list of elements
        function parseList(kind, checkForStrictMode, parseElement) {
            var saveParsingContext = parsingContext;
            parsingContext |= 1 << kind;
            var result = [];
            result.pos = getNodePos();
            var saveIsInStrictMode = isInStrictMode;
            while (!isListTerminator(kind)) {
                if (isListElement(kind, false)) {
                    var element = parseElement();
                    result.push(element);
                    // test elements only if we are not already in strict mode
                    if (!isInStrictMode && checkForStrictMode) {
                        if (isPrologueDirective(element)) {
                            if (isUseStrictPrologueDirective(element)) {
                                isInStrictMode = true;
                                checkForStrictMode = false;
                            }
                        }
                        else {
                            checkForStrictMode = false;
                        }
                    }
                }
                else {
                    error(parsingContextErrors(kind));
                    if (isInSomeParsingContext()) {
                        break;
                    }
                    nextToken();
                }
            }
            isInStrictMode = saveIsInStrictMode;
            result.end = getNodeEnd();
            parsingContext = saveParsingContext;
            return result;
        }
        // Parses a comma-delimited list of elements
        function parseDelimitedList(kind, parseElement, trailingCommaBehavior) {
            var saveParsingContext = parsingContext;
            parsingContext |= 1 << kind;
            var result = [];
            result.pos = getNodePos();
            // Keep track of how many errors we had before the list started. If we don't see any new
            // errors resulting from the list being malformed, we are free to complain about a trailing comma.
            var errorCountBeforeParsingList = file.syntacticErrors.length;
            var commaStart = -1; // Meaning the previous token was not a comma
            while (true) {
                if (isListElement(kind, false)) {
                    result.push(parseElement());
                    commaStart = scanner.getTokenPos();
                    if (parseOptional(18 /* CommaToken */)) {
                        continue;
                    }
                    commaStart = -1; // Back to the state where the last token was not a comma
                    if (isListTerminator(kind)) {
                        break;
                    }
                    error(ts.Diagnostics._0_expected, ",");
                }
                else if (isListTerminator(kind)) {
                    // Check if the last token was a comma.
                    if (commaStart >= 0) {
                        if (trailingCommaBehavior === 0 /* Disallow */) {
                            if (file.syntacticErrors.length === errorCountBeforeParsingList) {
                                // Report a grammar error so we don't affect lookahead
                                grammarErrorAtPos(commaStart, scanner.getStartPos() - commaStart, ts.Diagnostics.Trailing_comma_not_allowed);
                            }
                        }
                        else if (trailingCommaBehavior === 2 /* Preserve */) {
                            result.push(createNode(147 /* OmittedExpression */));
                        }
                    }
                    break;
                }
                else {
                    error(parsingContextErrors(kind));
                    if (isInSomeParsingContext()) {
                        break;
                    }
                    nextToken();
                }
            }
            result.end = getNodeEnd();
            parsingContext = saveParsingContext;
            return result;
        }
        function createMissingList() {
            var pos = getNodePos();
            var result = [];
            result.pos = pos;
            result.end = pos;
            return result;
        }
        function createNodeArray(node) {
            var result = [node];
            result.pos = node.pos;
            result.end = node.end;
            return result;
        }
        function parseBracketedList(kind, parseElement, startToken, endToken) {
            if (parseExpected(startToken)) {
                var result = parseDelimitedList(kind, parseElement, 0 /* Disallow */);
                parseExpected(endToken);
                return result;
            }
            return createMissingList();
        }
        // The allowReservedWords parameter controls whether reserved words are permitted after the first dot
        function parseEntityName(allowReservedWords) {
            var entity = parseIdentifier();
            while (parseOptional(15 /* DotToken */)) {
                var node = createNode(116 /* QualifiedName */, entity.pos);
                node.left = entity;
                node.right = allowReservedWords ? parseIdentifierName() : parseIdentifier();
                entity = finishNode(node);
            }
            return entity;
        }
        function parseTokenNode() {
            var node = createNode(token);
            nextToken();
            return finishNode(node);
        }
        function parseLiteralNode(internName) {
            var node = createNode(token);
            var text = scanner.getTokenValue();
            node.text = internName ? internIdentifier(text) : text;
            var tokenPos = scanner.getTokenPos();
            nextToken();
            finishNode(node);
            // Octal literals are not allowed in strict mode or ES5
            // Note that theoretically the following condition would hold true literals like 009,
            // which is not octal.But because of how the scanner separates the tokens, we would
            // never get a token like this.Instead, we would get 00 and 9 as two separate tokens.
            // We also do not need to check for negatives because any prefix operator would be part of a
            // parent unary expression.
            if (node.kind === 6 /* NumericLiteral */ && sourceText.charCodeAt(tokenPos) === 48 /* _0 */ && ts.isOctalDigit(sourceText.charCodeAt(tokenPos + 1))) {
                if (isInStrictMode) {
                    grammarErrorOnNode(node, ts.Diagnostics.Octal_literals_are_not_allowed_in_strict_mode);
                }
                else if (languageVersion >= 1 /* ES5 */) {
                    grammarErrorOnNode(node, ts.Diagnostics.Octal_literals_are_not_available_when_targeting_ECMAScript_5_and_higher);
                }
            }
            return node;
        }
        function parseStringLiteral() {
            if (token === 7 /* StringLiteral */)
                return parseLiteralNode(true);
            error(ts.Diagnostics.String_literal_expected);
            return createMissingNode();
        }
        // TYPES
        function parseTypeReference() {
            var node = createNode(127 /* TypeReference */);
            node.typeName = parseEntityName(false);
            if (!scanner.hasPrecedingLineBreak() && token === 19 /* LessThanToken */) {
                node.typeArguments = parseTypeArguments();
            }
            return finishNode(node);
        }
        function parseTypeQuery() {
            var node = createNode(128 /* TypeQuery */);
            parseExpected(91 /* TypeOfKeyword */);
            node.exprName = parseEntityName(true);
            return finishNode(node);
        }
        function parseTypeParameter() {
            var node = createNode(117 /* TypeParameter */);
            node.name = parseIdentifier();
            if (parseOptional(73 /* ExtendsKeyword */)) {
                // It's not uncommon for people to write improper constraints to a generic.  If the 
                // user writes a constraint that is an expression and not an actual type, then parse
                // it out as an expression (so we can recover well), but report that a type is needed
                // instead.
                if (isType() || !isExpression()) {
                    node.constraint = parseType();
                }
                else {
                    // It was not a type, and it looked like an expression.  Parse out an expression
                    // here so we recover well.  Note: it is important that we call parseUnaryExpression
                    // and not parseExpression here.  If the user has:
                    //
                    //      <T extends "">
                    //
                    // We do *not* want to consume the  >  as we're consuming the expression for "".
                    var expr = parseUnaryExpression();
                    grammarErrorOnNode(expr, ts.Diagnostics.Type_expected);
                }
            }
            return finishNode(node);
        }
        function parseTypeParameters() {
            if (token === 19 /* LessThanToken */) {
                var pos = getNodePos();
                var result = parseBracketedList(14 /* TypeParameters */, parseTypeParameter, 19 /* LessThanToken */, 20 /* GreaterThanToken */);
                if (!result.length) {
                    var start = getTokenPos(pos);
                    var length = getNodePos() - start;
                    errorAtPos(start, length, ts.Diagnostics.Type_parameter_list_cannot_be_empty);
                }
                return result;
            }
        }
        function parseParameterType() {
            return parseOptional(46 /* ColonToken */) ? token === 7 /* StringLiteral */ ? parseStringLiteral() : parseType() : undefined;
        }
        function isParameter() {
            return token === 16 /* DotDotDotToken */ || isIdentifier() || isModifier(token);
        }
        function parseParameter(flags) {
            if (flags === void 0) { flags = 0; }
            var node = createNode(118 /* Parameter */);
            node.flags |= parseAndCheckModifiers(3 /* Parameters */);
            if (parseOptional(16 /* DotDotDotToken */)) {
                node.flags |= 8 /* Rest */;
            }
            node.name = parseIdentifier();
            if (node.name.kind === 115 /* Missing */ && node.flags === 0 && isModifier(token)) {
                // in cases like
                // 'use strict' 
                // function foo(static)
                // isParameter('static') === true, because of isModifier('static')
                // however 'static' is not a legal identifier in a strict mode.
                // so result of this function will be ParameterDeclaration (flags = 0, name = missing, type = undefined, initializer = undefined)
                // and current token will not change => parsing of the enclosing parameter list will last till the end of time (or OOM)
                // to avoid this we'll advance cursor to the next token.
                nextToken();
            }
            if (parseOptional(45 /* QuestionToken */)) {
                node.flags |= 4 /* QuestionMark */;
            }
            node.type = parseParameterType();
            node.initializer = parseInitializer(true);
            // Do not check for initializers in an ambient context for parameters. This is not
            // a grammar error because the grammar allows arbitrary call signatures in
            // an ambient context.
            // It is actually not necessary for this to be an error at all. The reason is that
            // function/constructor implementations are syntactically disallowed in ambient
            // contexts. In addition, parameter initializers are semantically disallowed in
            // overload signatures. So parameter initializers are transitively disallowed in
            // ambient contexts.
            return finishNode(node);
        }
        function parseSignature(kind, returnToken, returnTokenRequired) {
            if (kind === 125 /* ConstructSignature */) {
                parseExpected(82 /* NewKeyword */);
            }
            var typeParameters = parseTypeParameters();
            var parameters = parseParameterList(11 /* OpenParenToken */, 12 /* CloseParenToken */);
            checkParameterList(parameters);
            var type;
            if (returnTokenRequired) {
                parseExpected(returnToken);
                type = parseType();
            }
            else if (parseOptional(returnToken)) {
                type = parseType();
            }
            return {
                typeParameters: typeParameters,
                parameters: parameters,
                type: type
            };
        }
        // Because we use this for index signatures as well, we sometimes use
        // parentheses, and sometimes use brackets.
        function parseParameterList(startDelimiter, endDelimiter) {
            return parseBracketedList(13 /* Parameters */, parseParameter, startDelimiter, endDelimiter);
        }
        function checkParameterList(parameters) {
            var seenOptionalParameter = false;
            var parameterCount = parameters.length;
            for (var i = 0; i < parameterCount; i++) {
                var parameter = parameters[i];
                // It is a SyntaxError if the Identifier "eval" or the Identifier "arguments" occurs as the 
                // Identifier in a PropertySetParameterList of a PropertyAssignment that is contained in strict code 
                // or if its FunctionBody is strict code(11.1.5).
                // It is a SyntaxError if the identifier eval or arguments appears within a FormalParameterList of a 
                // strict mode FunctionDeclaration or FunctionExpression(13.1) 
                if (isInStrictMode && isEvalOrArgumentsIdentifier(parameter.name)) {
                    reportInvalidUseInStrictMode(parameter.name);
                    return;
                }
                else if (parameter.flags & 8 /* Rest */) {
                    if (i !== (parameterCount - 1)) {
                        grammarErrorOnNode(parameter.name, ts.Diagnostics.A_rest_parameter_must_be_last_in_a_parameter_list);
                        return;
                    }
                    if (parameter.flags & 4 /* QuestionMark */) {
                        grammarErrorOnNode(parameter.name, ts.Diagnostics.A_rest_parameter_cannot_be_optional);
                        return;
                    }
                    if (parameter.initializer) {
                        grammarErrorOnNode(parameter.name, ts.Diagnostics.A_rest_parameter_cannot_have_an_initializer);
                        return;
                    }
                }
                else if (parameter.flags & 4 /* QuestionMark */ || parameter.initializer) {
                    seenOptionalParameter = true;
                    if (parameter.flags & 4 /* QuestionMark */ && parameter.initializer) {
                        grammarErrorOnNode(parameter.name, ts.Diagnostics.Parameter_cannot_have_question_mark_and_initializer);
                        return;
                    }
                }
                else {
                    if (seenOptionalParameter) {
                        grammarErrorOnNode(parameter.name, ts.Diagnostics.A_required_parameter_cannot_follow_an_optional_parameter);
                        return;
                    }
                }
            }
        }
        function parseSignatureMember(kind, returnToken) {
            var node = createNode(kind);
            var sig = parseSignature(kind, returnToken, false);
            node.typeParameters = sig.typeParameters;
            node.parameters = sig.parameters;
            node.type = sig.type;
            parseSemicolon();
            return finishNode(node);
        }
        function parseIndexSignatureMember() {
            var node = createNode(126 /* IndexSignature */);
            var errorCountBeforeIndexSignature = file.syntacticErrors.length;
            var indexerStart = scanner.getTokenPos();
            node.parameters = parseParameterList(13 /* OpenBracketToken */, 14 /* CloseBracketToken */);
            var indexerLength = scanner.getStartPos() - indexerStart;
            node.type = parseTypeAnnotation();
            parseSemicolon();
            if (file.syntacticErrors.length === errorCountBeforeIndexSignature) {
                checkIndexSignature(node, indexerStart, indexerLength);
            }
            return finishNode(node);
        }
        function checkIndexSignature(node, indexerStart, indexerLength) {
            var parameter = node.parameters[0];
            if (node.parameters.length !== 1) {
                var arityDiagnostic = ts.Diagnostics.An_index_signature_must_have_exactly_one_parameter;
                if (parameter) {
                    grammarErrorOnNode(parameter.name, arityDiagnostic);
                }
                else {
                    grammarErrorAtPos(indexerStart, indexerLength, arityDiagnostic);
                }
                return;
            }
            else if (parameter.flags & 8 /* Rest */) {
                grammarErrorOnNode(parameter.name, ts.Diagnostics.An_index_signature_cannot_have_a_rest_parameter);
                return;
            }
            else if (parameter.flags & ts.NodeFlags.Modifier) {
                grammarErrorOnNode(parameter.name, ts.Diagnostics.An_index_signature_parameter_cannot_have_an_accessibility_modifier);
                return;
            }
            else if (parameter.flags & 4 /* QuestionMark */) {
                grammarErrorOnNode(parameter.name, ts.Diagnostics.An_index_signature_parameter_cannot_have_a_question_mark);
                return;
            }
            else if (parameter.initializer) {
                grammarErrorOnNode(parameter.name, ts.Diagnostics.An_index_signature_parameter_cannot_have_an_initializer);
                return;
            }
            else if (!parameter.type) {
                grammarErrorOnNode(parameter.name, ts.Diagnostics.An_index_signature_parameter_must_have_a_type_annotation);
                return;
            }
            else if (parameter.type.kind !== 114 /* StringKeyword */ && parameter.type.kind !== 112 /* NumberKeyword */) {
                grammarErrorOnNode(parameter.name, ts.Diagnostics.An_index_signature_parameter_type_must_be_string_or_number);
                return;
            }
            else if (!node.type) {
                grammarErrorAtPos(indexerStart, indexerLength, ts.Diagnostics.An_index_signature_must_have_a_type_annotation);
                return;
            }
        }
        function parsePropertyOrMethod() {
            var node = createNode(0 /* Unknown */);
            node.name = parsePropertyName();
            if (parseOptional(45 /* QuestionToken */)) {
                node.flags |= 4 /* QuestionMark */;
            }
            if (token === 11 /* OpenParenToken */ || token === 19 /* LessThanToken */) {
                node.kind = 120 /* Method */;
                var sig = parseSignature(124 /* CallSignature */, 46 /* ColonToken */, false);
                node.typeParameters = sig.typeParameters;
                node.parameters = sig.parameters;
                node.type = sig.type;
            }
            else {
                node.kind = 119 /* Property */;
                node.type = parseTypeAnnotation();
            }
            parseSemicolon();
            return finishNode(node);
        }
        function isTypeMember() {
            switch (token) {
                case 11 /* OpenParenToken */:
                case 19 /* LessThanToken */:
                case 13 /* OpenBracketToken */:
                    return true;
                default:
                    return isPropertyName() && lookAhead(function () { return nextToken() === 11 /* OpenParenToken */ || token === 19 /* LessThanToken */ || token === 45 /* QuestionToken */ || token === 46 /* ColonToken */ || canParseSemicolon(); });
            }
        }
        function parseTypeMember() {
            switch (token) {
                case 11 /* OpenParenToken */:
                case 19 /* LessThanToken */:
                    return parseSignatureMember(124 /* CallSignature */, 46 /* ColonToken */);
                case 13 /* OpenBracketToken */:
                    return parseIndexSignatureMember();
                case 82 /* NewKeyword */:
                    if (lookAhead(function () { return nextToken() === 11 /* OpenParenToken */ || token === 19 /* LessThanToken */; })) {
                        return parseSignatureMember(125 /* ConstructSignature */, 46 /* ColonToken */);
                    }
                case 7 /* StringLiteral */:
                case 6 /* NumericLiteral */:
                    return parsePropertyOrMethod();
                default:
                    if (token >= 59 /* Identifier */) {
                        return parsePropertyOrMethod();
                    }
            }
        }
        function parseTypeLiteral() {
            var node = createNode(129 /* TypeLiteral */);
            if (parseExpected(9 /* OpenBraceToken */)) {
                node.members = parseList(5 /* TypeMembers */, false, parseTypeMember);
                parseExpected(10 /* CloseBraceToken */);
            }
            else {
                node.members = createMissingList();
            }
            return finishNode(node);
        }
        function parseTupleType() {
            var node = createNode(131 /* TupleType */);
            var startTokenPos = scanner.getTokenPos();
            var startErrorCount = file.syntacticErrors.length;
            node.elementTypes = parseBracketedList(16 /* TupleElementTypes */, parseType, 13 /* OpenBracketToken */, 14 /* CloseBracketToken */);
            if (!node.elementTypes.length && file.syntacticErrors.length === startErrorCount) {
                grammarErrorAtPos(startTokenPos, scanner.getStartPos() - startTokenPos, ts.Diagnostics.A_tuple_type_element_list_cannot_be_empty);
            }
            return finishNode(node);
        }
        function parseFunctionType(signatureKind) {
            var node = createNode(129 /* TypeLiteral */);
            var member = createNode(signatureKind);
            var sig = parseSignature(signatureKind, 27 /* EqualsGreaterThanToken */, true);
            member.typeParameters = sig.typeParameters;
            member.parameters = sig.parameters;
            member.type = sig.type;
            finishNode(member);
            node.members = createNodeArray(member);
            return finishNode(node);
        }
        function parseKeywordAndNoDot() {
            var node = parseTokenNode();
            return token === 15 /* DotToken */ ? undefined : node;
        }
        function parseNonArrayType() {
            switch (token) {
                case 105 /* AnyKeyword */:
                case 114 /* StringKeyword */:
                case 112 /* NumberKeyword */:
                case 106 /* BooleanKeyword */:
                case 93 /* VoidKeyword */:
                    var node = tryParse(parseKeywordAndNoDot);
                    return node || parseTypeReference();
                case 91 /* TypeOfKeyword */:
                    return parseTypeQuery();
                case 9 /* OpenBraceToken */:
                    return parseTypeLiteral();
                case 13 /* OpenBracketToken */:
                    return parseTupleType();
                case 11 /* OpenParenToken */:
                case 19 /* LessThanToken */:
                    return parseFunctionType(124 /* CallSignature */);
                case 82 /* NewKeyword */:
                    return parseFunctionType(125 /* ConstructSignature */);
                default:
                    if (isIdentifier()) {
                        return parseTypeReference();
                    }
            }
            error(ts.Diagnostics.Type_expected);
            return createMissingNode();
        }
        function isType() {
            switch (token) {
                case 105 /* AnyKeyword */:
                case 114 /* StringKeyword */:
                case 112 /* NumberKeyword */:
                case 106 /* BooleanKeyword */:
                case 93 /* VoidKeyword */:
                case 91 /* TypeOfKeyword */:
                case 9 /* OpenBraceToken */:
                case 13 /* OpenBracketToken */:
                case 19 /* LessThanToken */:
                case 82 /* NewKeyword */:
                    return true;
                case 11 /* OpenParenToken */:
                    // Only consider an ( as the start of a type if we have  ()  or  (id
                    // We don't want to consider things like  (1)  as a function type.
                    return lookAhead(function () {
                        nextToken();
                        return token === 12 /* CloseParenToken */ || isParameter();
                    });
                default:
                    return isIdentifier();
            }
        }
        function parseType() {
            var type = parseNonArrayType();
            while (type && !scanner.hasPrecedingLineBreak() && parseOptional(13 /* OpenBracketToken */)) {
                parseExpected(14 /* CloseBracketToken */);
                var node = createNode(130 /* ArrayType */, type.pos);
                node.elementType = type;
                type = finishNode(node);
            }
            return type;
        }
        function parseTypeAnnotation() {
            return parseOptional(46 /* ColonToken */) ? parseType() : undefined;
        }
        // EXPRESSIONS
        function isExpression() {
            switch (token) {
                case 87 /* ThisKeyword */:
                case 85 /* SuperKeyword */:
                case 83 /* NullKeyword */:
                case 89 /* TrueKeyword */:
                case 74 /* FalseKeyword */:
                case 6 /* NumericLiteral */:
                case 7 /* StringLiteral */:
                case 11 /* OpenParenToken */:
                case 13 /* OpenBracketToken */:
                case 9 /* OpenBraceToken */:
                case 77 /* FunctionKeyword */:
                case 82 /* NewKeyword */:
                case 31 /* SlashToken */:
                case 51 /* SlashEqualsToken */:
                case 28 /* PlusToken */:
                case 29 /* MinusToken */:
                case 42 /* TildeToken */:
                case 41 /* ExclamationToken */:
                case 68 /* DeleteKeyword */:
                case 91 /* TypeOfKeyword */:
                case 93 /* VoidKeyword */:
                case 33 /* PlusPlusToken */:
                case 34 /* MinusMinusToken */:
                case 19 /* LessThanToken */:
                case 59 /* Identifier */:
                    return true;
                default:
                    return isIdentifier();
            }
        }
        function isExpressionStatement() {
            // As per the grammar, neither '{' nor 'function' can start an expression statement.
            return token !== 9 /* OpenBraceToken */ && token !== 77 /* FunctionKeyword */ && isExpression();
        }
        function parseExpression(noIn) {
            var expr = parseAssignmentExpression(noIn);
            while (parseOptional(18 /* CommaToken */)) {
                expr = makeBinaryExpression(expr, 18 /* CommaToken */, parseAssignmentExpression(noIn));
            }
            return expr;
        }
        function parseInitializer(inParameter, noIn) {
            if (token !== 47 /* EqualsToken */) {
                // It's not uncommon during typing for the user to miss writing the '=' token.  Check if
                // there is no newline after the last token and if we're on an expression.  If so, parse
                // this as an equals-value clause with a missing equals.
                // NOTE: There are two places where we allow equals-value clauses.  The first is in a 
                // variable declarator.  The second is with a parameter.  For variable declarators
                // it's more likely that a { would be a allowed (as an object literal).  While this
                // is also allowed for parameters, the risk is that we consume the { as an object
                // literal when it really will be for the block following the parameter.
                if (scanner.hasPrecedingLineBreak() || (inParameter && token === 9 /* OpenBraceToken */) || !isExpression()) {
                    // preceding line break, open brace in a parameter (likely a function body) or current token is not an expression - 
                    // do not try to parse initializer
                    return undefined;
                }
            }
            parseExpected(47 /* EqualsToken */);
            return parseAssignmentExpression(noIn);
        }
        function parseAssignmentExpression(noIn) {
            // Augmented by TypeScript:
            //
            //  AssignmentExpression[in]:
            //      1) ConditionalExpression[in]
            //      2) LeftHandSideExpression = AssignmentExpression[in]
            //      3) LeftHandSideExpression AssignmentOperator AssignmentExpression[in]
            //      4) ArrowFunctionExpression <-- added by TypeScript
            //
            // Note: for ease of implementation we treat productions '2' and '3' as the same thing. 
            // (i.e. they're both BinaryExpressions with an assignment operator in it).
            // First, check if we have an arrow function (production '4') that starts with a parenthesized
            // parameter list. If we do, we must *not* recurse for productions 1, 2 or 3. An ArrowFunction is
            // not a  LeftHandSideExpression, nor does it start a ConditionalExpression.  So we are done 
            // with AssignmentExpression if we see one.
            var arrowExpression = tryParseParenthesizedArrowFunctionExpression();
            if (arrowExpression) {
                return arrowExpression;
            }
            // Now try to handle the rest of the cases.  First, see if we can parse out up to and
            // including a conditional expression.
            var expr = parseConditionalExpression(noIn);
            // To avoid a look-ahead, we did not handle the case of an arrow function with a single un-parenthesized
            // parameter ('x => ...') above. We handle it here by checking if the parsed expression was a single
            // identifier and the current token is an arrow.
            if (expr.kind === 59 /* Identifier */ && token === 27 /* EqualsGreaterThanToken */) {
                return parseSimpleArrowFunctionExpression(expr);
            }
            // Now see if we might be in cases '2' or '3'.
            // If the expression was a LHS expression, and we  have an assignment operator, then 
            // we're in '2' or '3'.  Consume the assignment and return.
            if (isLeftHandSideExpression(expr) && isAssignmentOperator()) {
                if (isInStrictMode && isEvalOrArgumentsIdentifier(expr)) {
                    // ECMA 262 (Annex C) The identifier eval or arguments may not appear as the LeftHandSideExpression of an 
                    // Assignment operator(11.13) or of a PostfixExpression(11.3)
                    reportInvalidUseInStrictMode(expr);
                }
                var operator = token;
                nextToken();
                return makeBinaryExpression(expr, operator, parseAssignmentExpression(noIn));
            }
            // otherwise this was production '1'.  Return whatever we parsed so far.
            return expr;
        }
        function isLeftHandSideExpression(expr) {
            if (expr) {
                switch (expr.kind) {
                    case 135 /* PropertyAccess */:
                    case 136 /* IndexedAccess */:
                    case 138 /* NewExpression */:
                    case 137 /* CallExpression */:
                    case 132 /* ArrayLiteral */:
                    case 140 /* ParenExpression */:
                    case 133 /* ObjectLiteral */:
                    case 141 /* FunctionExpression */:
                    case 59 /* Identifier */:
                    case 115 /* Missing */:
                    case 8 /* RegularExpressionLiteral */:
                    case 6 /* NumericLiteral */:
                    case 7 /* StringLiteral */:
                    case 74 /* FalseKeyword */:
                    case 83 /* NullKeyword */:
                    case 87 /* ThisKeyword */:
                    case 89 /* TrueKeyword */:
                    case 85 /* SuperKeyword */:
                        return true;
                }
            }
            return false;
        }
        function parseSimpleArrowFunctionExpression(identifier) {
            ts.Debug.assert(token === 27 /* EqualsGreaterThanToken */, "parseSimpleArrowFunctionExpression should only have been called if we had a =>");
            parseExpected(27 /* EqualsGreaterThanToken */);
            var parameter = createNode(118 /* Parameter */, identifier.pos);
            parameter.name = identifier;
            finishNode(parameter);
            var parameters = [];
            parameters.push(parameter);
            parameters.pos = parameter.pos;
            parameters.end = parameter.end;
            var signature = { parameters: parameters };
            return parseArrowExpressionTail(identifier.pos, signature, false);
        }
        function tryParseParenthesizedArrowFunctionExpression() {
            // Indicates whether we are certain that we should parse an arrow expression.
            var triState = isParenthesizedArrowFunctionExpression();
            if (triState === 0 /* False */) {
                return undefined;
            }
            var pos = getNodePos();
            if (triState === 1 /* True */) {
                var sig = parseSignature(124 /* CallSignature */, 46 /* ColonToken */, false);
                // If we have an arrow, then try to parse the body.
                // Even if not, try to parse if we have an opening brace, just in case we're in an error state.
                if (parseExpected(27 /* EqualsGreaterThanToken */) || token === 9 /* OpenBraceToken */) {
                    return parseArrowExpressionTail(pos, sig, false);
                }
                else {
                    // If not, we're probably better off bailing out and returning a bogus function expression.
                    return makeFunctionExpression(142 /* ArrowFunction */, pos, undefined, sig, createMissingNode());
                }
            }
            // *Maybe* we had an arrow function and we need to try to parse it out,
            // rolling back and trying other parses if we fail.
            var sig = tryParseSignatureIfArrowOrBraceFollows();
            if (sig) {
                parseExpected(27 /* EqualsGreaterThanToken */);
                return parseArrowExpressionTail(pos, sig, false);
            }
            else {
                return undefined;
            }
        }
        //  True        -> We definitely expect a parenthesized arrow function here.
        //  False       -> There *cannot* be a parenthesized arrow function here.
        //  Unknown     -> There *might* be a parenthesized arrow function here.
        //                 Speculatively look ahead to be sure, and rollback if not.
        function isParenthesizedArrowFunctionExpression() {
            if (token === 11 /* OpenParenToken */ || token === 19 /* LessThanToken */) {
                return lookAhead(function () {
                    var first = token;
                    var second = nextToken();
                    if (first === 11 /* OpenParenToken */) {
                        if (second === 12 /* CloseParenToken */) {
                            // Simple cases: "() =>", "(): ", and  "() {".
                            // This is an arrow function with no parameters.
                            // The last one is not actually an arrow function,
                            // but this is probably what the user intended.
                            var third = nextToken();
                            switch (third) {
                                case 27 /* EqualsGreaterThanToken */:
                                case 46 /* ColonToken */:
                                case 9 /* OpenBraceToken */:
                                    return 1 /* True */;
                                default:
                                    return 0 /* False */;
                            }
                        }
                        // Simple case: "(..."
                        // This is an arrow function with a rest parameter.
                        if (second === 16 /* DotDotDotToken */) {
                            return 1 /* True */;
                        }
                        // If we had "(" followed by something that's not an identifier,
                        // then this definitely doesn't look like a lambda.
                        // Note: we could be a little more lenient and allow
                        // "(public" or "(private". These would not ever actually be allowed,
                        // but we could provide a good error message instead of bailing out.
                        if (!isIdentifier()) {
                            return 0 /* False */;
                        }
                        // If we have something like "(a:", then we must have a
                        // type-annotated parameter in an arrow function expression.
                        if (nextToken() === 46 /* ColonToken */) {
                            return 1 /* True */;
                        }
                        // This *could* be a parenthesized arrow function.
                        // Return Unknown to let the caller know.
                        return 2 /* Unknown */;
                    }
                    else {
                        ts.Debug.assert(first === 19 /* LessThanToken */);
                        // If we have "<" not followed by an identifier,
                        // then this definitely is not an arrow function.
                        if (!isIdentifier()) {
                            return 0 /* False */;
                        }
                        // This *could* be a parenthesized arrow function.
                        return 2 /* Unknown */;
                    }
                });
            }
            if (token === 27 /* EqualsGreaterThanToken */) {
                // ERROR RECOVERY TWEAK:
                // If we see a standalone => try to parse it as an arrow function expression as that's
                // likely what the user intended to write.
                return 1 /* True */;
            }
            // Definitely not a parenthesized arrow function.
            return 0 /* False */;
        }
        function tryParseSignatureIfArrowOrBraceFollows() {
            return tryParse(function () {
                var sig = parseSignature(124 /* CallSignature */, 46 /* ColonToken */, false);
                // Parsing a signature isn't enough.
                // Parenthesized arrow signatures often look like other valid expressions.
                // For instance:
                //  - "(x = 10)" is an assignment expression parsed as a signature with a default parameter value.
                //  - "(x,y)" is a comma expression parsed as a signature with two parameters.
                //  - "a ? (b): c" will have "(b):" parsed as a signature with a return type annotation.
                //
                // So we need just a bit of lookahead to ensure that it can only be a signature.
                if (token === 27 /* EqualsGreaterThanToken */ || token === 9 /* OpenBraceToken */) {
                    return sig;
                }
                return undefined;
            });
        }
        function parseArrowExpressionTail(pos, sig, noIn) {
            var body;
            if (token === 9 /* OpenBraceToken */) {
                body = parseBody(false);
            }
            else if (isStatement(true) && !isExpressionStatement() && token !== 77 /* FunctionKeyword */) {
                // Check if we got a plain statement (i.e. no expression-statements, no functions expressions/declarations)
                //
                // Here we try to recover from a potential error situation in the case where the 
                // user meant to supply a block. For example, if the user wrote:
                //
                //  a =>
                //      var v = 0;
                //  }
                //
                // they may be missing an open brace.  Check to see if that's the case so we can
                // try to recover better.  If we don't do this, then the next close curly we see may end
                // up preemptively closing the containing construct.
                //
                // Note: even when 'ignoreMissingOpenBrace' is passed as true, parseBody will still error.
                body = parseBody(true);
            }
            else {
                body = parseAssignmentExpression(noIn);
            }
            return makeFunctionExpression(142 /* ArrowFunction */, pos, undefined, sig, body);
        }
        function isAssignmentOperator() {
            return token >= ts.SyntaxKind.FirstAssignment && token <= ts.SyntaxKind.LastAssignment;
        }
        function parseConditionalExpression(noIn) {
            var expr = parseBinaryExpression(noIn);
            while (parseOptional(45 /* QuestionToken */)) {
                var node = createNode(146 /* ConditionalExpression */, expr.pos);
                node.condition = expr;
                node.whenTrue = parseAssignmentExpression(false);
                parseExpected(46 /* ColonToken */);
                node.whenFalse = parseAssignmentExpression(noIn);
                expr = finishNode(node);
            }
            return expr;
        }
        function parseBinaryExpression(noIn) {
            return parseBinaryOperators(parseUnaryExpression(), 0, noIn);
        }
        function parseBinaryOperators(expr, minPrecedence, noIn) {
            while (true) {
                reScanGreaterToken();
                var precedence = getOperatorPrecedence();
                if (precedence && precedence > minPrecedence && (!noIn || token !== 80 /* InKeyword */)) {
                    var operator = token;
                    nextToken();
                    expr = makeBinaryExpression(expr, operator, parseBinaryOperators(parseUnaryExpression(), precedence, noIn));
                    continue;
                }
                return expr;
            }
        }
        function getOperatorPrecedence() {
            switch (token) {
                case 44 /* BarBarToken */:
                    return 1;
                case 43 /* AmpersandAmpersandToken */:
                    return 2;
                case 39 /* BarToken */:
                    return 3;
                case 40 /* CaretToken */:
                    return 4;
                case 38 /* AmpersandToken */:
                    return 5;
                case 23 /* EqualsEqualsToken */:
                case 24 /* ExclamationEqualsToken */:
                case 25 /* EqualsEqualsEqualsToken */:
                case 26 /* ExclamationEqualsEqualsToken */:
                    return 6;
                case 19 /* LessThanToken */:
                case 20 /* GreaterThanToken */:
                case 21 /* LessThanEqualsToken */:
                case 22 /* GreaterThanEqualsToken */:
                case 81 /* InstanceOfKeyword */:
                case 80 /* InKeyword */:
                    return 7;
                case 35 /* LessThanLessThanToken */:
                case 36 /* GreaterThanGreaterThanToken */:
                case 37 /* GreaterThanGreaterThanGreaterThanToken */:
                    return 8;
                case 28 /* PlusToken */:
                case 29 /* MinusToken */:
                    return 9;
                case 30 /* AsteriskToken */:
                case 31 /* SlashToken */:
                case 32 /* PercentToken */:
                    return 10;
            }
            return undefined;
        }
        function makeBinaryExpression(left, operator, right) {
            var node = createNode(145 /* BinaryExpression */, left.pos);
            node.left = left;
            node.operator = operator;
            node.right = right;
            return finishNode(node);
        }
        function parseUnaryExpression() {
            var pos = getNodePos();
            switch (token) {
                case 28 /* PlusToken */:
                case 29 /* MinusToken */:
                case 42 /* TildeToken */:
                case 41 /* ExclamationToken */:
                case 68 /* DeleteKeyword */:
                case 91 /* TypeOfKeyword */:
                case 93 /* VoidKeyword */:
                case 33 /* PlusPlusToken */:
                case 34 /* MinusMinusToken */:
                    var operator = token;
                    nextToken();
                    var operand = parseUnaryExpression();
                    if (isInStrictMode) {
                        // The identifier eval or arguments may not appear as the LeftHandSideExpression of an 
                        // Assignment operator(11.13) or of a PostfixExpression(11.3) or as the UnaryExpression 
                        // operated upon by a Prefix Increment(11.4.4) or a Prefix Decrement(11.4.5) operator
                        if ((token === 33 /* PlusPlusToken */ || token === 34 /* MinusMinusToken */) && isEvalOrArgumentsIdentifier(operand)) {
                            reportInvalidUseInStrictMode(operand);
                        }
                        else if (token === 68 /* DeleteKeyword */ && operand.kind === 59 /* Identifier */) {
                            // When a delete operator occurs within strict mode code, a SyntaxError is thrown if its 
                            // UnaryExpression is a direct reference to a variable, function argument, or function name
                            grammarErrorOnNode(operand, ts.Diagnostics.delete_cannot_be_called_on_an_identifier_in_strict_mode);
                        }
                    }
                    return makeUnaryExpression(143 /* PrefixOperator */, pos, operator, operand);
                case 19 /* LessThanToken */:
                    return parseTypeAssertion();
            }
            var primaryExpression = parsePrimaryExpression();
            // TS 1.0 spec (2014): 4.8
            // CallExpression:  ( Modified )
            //  super   (   ArgumentListopt   )
            //  super   .   IdentifierName
            var illegalUsageOfSuperKeyword = primaryExpression.kind === 85 /* SuperKeyword */ && token !== 11 /* OpenParenToken */ && token !== 15 /* DotToken */;
            if (illegalUsageOfSuperKeyword) {
                error(ts.Diagnostics.super_must_be_followed_by_an_argument_list_or_member_access);
            }
            var expr = parseCallAndAccess(primaryExpression, false);
            ts.Debug.assert(isLeftHandSideExpression(expr));
            if ((token === 33 /* PlusPlusToken */ || token === 34 /* MinusMinusToken */) && !scanner.hasPrecedingLineBreak()) {
                // The identifier eval or arguments may not appear as the LeftHandSideExpression of an 
                // Assignment operator(11.13) or of a PostfixExpression(11.3) or as the UnaryExpression 
                // operated upon by a Prefix Increment(11.4.4) or a Prefix Decrement(11.4.5) operator. 
                if (isInStrictMode && isEvalOrArgumentsIdentifier(expr)) {
                    reportInvalidUseInStrictMode(expr);
                }
                var operator = token;
                nextToken();
                expr = makeUnaryExpression(144 /* PostfixOperator */, expr.pos, operator, expr);
            }
            return expr;
        }
        function parseTypeAssertion() {
            var node = createNode(139 /* TypeAssertion */);
            parseExpected(19 /* LessThanToken */);
            node.type = parseType();
            parseExpected(20 /* GreaterThanToken */);
            node.operand = parseUnaryExpression();
            return finishNode(node);
        }
        function makeUnaryExpression(kind, pos, operator, operand) {
            var node = createNode(kind, pos);
            node.operator = operator;
            node.operand = operand;
            return finishNode(node);
        }
        function parseCallAndAccess(expr, inNewExpression) {
            while (true) {
                var dotStart = scanner.getTokenPos();
                if (parseOptional(15 /* DotToken */)) {
                    var propertyAccess = createNode(135 /* PropertyAccess */, expr.pos);
                    // Technically a keyword is valid here as all keywords are identifier names.
                    // However, often we'll encounter this in error situations when the keyword
                    // is actually starting another valid construct.
                    //
                    // So, we check for the following specific case:
                    //
                    //      name.
                    //      keyword identifierNameOrKeyword
                    //
                    // Note: the newlines are important here.  For example, if that above code 
                    // were rewritten into:
                    //
                    //      name.keyword
                    //      identifierNameOrKeyword
                    //
                    // Then we would consider it valid.  That's because ASI would take effect and
                    // the code would be implicitly: "name.keyword; identifierNameOrKeyword".  
                    // In the first case though, ASI will not take effect because there is not a
                    // line terminator after the keyword.
                    if (scanner.hasPrecedingLineBreak() && scanner.isReservedWord() && lookAhead(function () { return scanner.isReservedWord(); })) {
                        grammarErrorAtPos(dotStart, scanner.getStartPos() - dotStart, ts.Diagnostics.Identifier_expected);
                        var id = createMissingNode();
                    }
                    else {
                        var id = parseIdentifierName();
                    }
                    propertyAccess.left = expr;
                    propertyAccess.right = id;
                    expr = finishNode(propertyAccess);
                    continue;
                }
                var bracketStart = scanner.getTokenPos();
                if (parseOptional(13 /* OpenBracketToken */)) {
                    var indexedAccess = createNode(136 /* IndexedAccess */, expr.pos);
                    indexedAccess.object = expr;
                    // It's not uncommon for a user to write: "new Type[]".
                    // Check for that common pattern and report a better error message.
                    if (inNewExpression && parseOptional(14 /* CloseBracketToken */)) {
                        indexedAccess.index = createMissingNode();
                        grammarErrorAtPos(bracketStart, scanner.getStartPos() - bracketStart, ts.Diagnostics.new_T_cannot_be_used_to_create_an_array_Use_new_Array_T_instead);
                    }
                    else {
                        indexedAccess.index = parseExpression();
                        if (indexedAccess.index.kind === 7 /* StringLiteral */ || indexedAccess.index.kind === 6 /* NumericLiteral */) {
                            var literal = indexedAccess.index;
                            literal.text = internIdentifier(literal.text);
                        }
                        parseExpected(14 /* CloseBracketToken */);
                    }
                    expr = finishNode(indexedAccess);
                    continue;
                }
                // Try to parse a Call Expression unless we are in a New Expression.
                // If we are parsing a New Expression, then parentheses are optional, 
                // and is taken care of by the 'parseNewExpression' caller.
                if ((token === 11 /* OpenParenToken */ || token === 19 /* LessThanToken */) && !inNewExpression) {
                    var callExpr = createNode(137 /* CallExpression */, expr.pos);
                    callExpr.func = expr;
                    if (token === 19 /* LessThanToken */) {
                        if (!(callExpr.typeArguments = tryParse(parseTypeArgumentsAndOpenParen)))
                            return expr;
                    }
                    else {
                        parseExpected(11 /* OpenParenToken */);
                    }
                    callExpr.arguments = parseDelimitedList(10 /* ArgumentExpressions */, parseAssignmentExpression, 0 /* Disallow */);
                    parseExpected(12 /* CloseParenToken */);
                    expr = finishNode(callExpr);
                    continue;
                }
                return expr;
            }
        }
        function parseTypeArgumentsAndOpenParen() {
            var result = parseTypeArguments();
            parseExpected(11 /* OpenParenToken */);
            return result;
        }
        function parseTypeArguments() {
            var typeArgumentListStart = scanner.getTokenPos();
            var errorCountBeforeTypeParameterList = file.syntacticErrors.length;
            var result = parseBracketedList(15 /* TypeArguments */, parseType, 19 /* LessThanToken */, 20 /* GreaterThanToken */);
            if (!result.length && file.syntacticErrors.length === errorCountBeforeTypeParameterList) {
                grammarErrorAtPos(typeArgumentListStart, scanner.getStartPos() - typeArgumentListStart, ts.Diagnostics.Type_argument_list_cannot_be_empty);
            }
            return result;
        }
        function parsePrimaryExpression() {
            switch (token) {
                case 87 /* ThisKeyword */:
                case 85 /* SuperKeyword */:
                case 83 /* NullKeyword */:
                case 89 /* TrueKeyword */:
                case 74 /* FalseKeyword */:
                    return parseTokenNode();
                case 6 /* NumericLiteral */:
                case 7 /* StringLiteral */:
                    return parseLiteralNode();
                case 11 /* OpenParenToken */:
                    return parseParenExpression();
                case 13 /* OpenBracketToken */:
                    return parseArrayLiteral();
                case 9 /* OpenBraceToken */:
                    return parseObjectLiteral();
                case 77 /* FunctionKeyword */:
                    return parseFunctionExpression();
                case 82 /* NewKeyword */:
                    return parseNewExpression();
                case 31 /* SlashToken */:
                case 51 /* SlashEqualsToken */:
                    if (reScanSlashToken() === 8 /* RegularExpressionLiteral */) {
                        return parseLiteralNode();
                    }
                    break;
                default:
                    if (isIdentifier()) {
                        return parseIdentifier();
                    }
            }
            error(ts.Diagnostics.Expression_expected);
            return createMissingNode();
        }
        function parseParenExpression() {
            var node = createNode(140 /* ParenExpression */);
            parseExpected(11 /* OpenParenToken */);
            node.expression = parseExpression();
            parseExpected(12 /* CloseParenToken */);
            return finishNode(node);
        }
        function parseArrayLiteralElement() {
            return token === 18 /* CommaToken */ ? createNode(147 /* OmittedExpression */) : parseAssignmentExpression();
        }
        function parseArrayLiteral() {
            var node = createNode(132 /* ArrayLiteral */);
            parseExpected(13 /* OpenBracketToken */);
            if (scanner.hasPrecedingLineBreak())
                node.flags |= 256 /* MultiLine */;
            node.elements = parseDelimitedList(12 /* ArrayLiteralMembers */, parseArrayLiteralElement, 2 /* Preserve */);
            parseExpected(14 /* CloseBracketToken */);
            return finishNode(node);
        }
        function parsePropertyAssignment() {
            var node = createNode(134 /* PropertyAssignment */);
            node.name = parsePropertyName();
            if (token === 11 /* OpenParenToken */ || token === 19 /* LessThanToken */) {
                var sig = parseSignature(124 /* CallSignature */, 46 /* ColonToken */, false);
                var body = parseBody(false);
                // do not propagate property name as name for function expression
                // for scenarios like 
                // var x = 1;
                // var y = { x() { } } 
                // otherwise this will bring y.x into the scope of x which is incorrect
                node.initializer = makeFunctionExpression(141 /* FunctionExpression */, node.pos, undefined, sig, body);
            }
            else {
                parseExpected(46 /* ColonToken */);
                node.initializer = parseAssignmentExpression(false);
            }
            return finishNode(node);
        }
        function parseObjectLiteralMember() {
            var initialPos = getNodePos();
            var initialToken = token;
            if (parseContextualModifier(109 /* GetKeyword */) || parseContextualModifier(113 /* SetKeyword */)) {
                var kind = initialToken === 109 /* GetKeyword */ ? 122 /* GetAccessor */ : 123 /* SetAccessor */;
                return parseAndCheckMemberAccessorDeclaration(kind, initialPos, 0);
            }
            return parsePropertyAssignment();
        }
        function parseObjectLiteral() {
            var node = createNode(133 /* ObjectLiteral */);
            parseExpected(9 /* OpenBraceToken */);
            if (scanner.hasPrecedingLineBreak()) {
                node.flags |= 256 /* MultiLine */;
            }
            // ES3 itself does not accept a trailing comma in an object literal, however, we'd like to preserve it in ES5.
            var trailingCommaBehavior = languageVersion === 0 /* ES3 */ ? 1 /* Allow */ : 2 /* Preserve */;
            node.properties = parseDelimitedList(11 /* ObjectLiteralMembers */, parseObjectLiteralMember, trailingCommaBehavior);
            parseExpected(10 /* CloseBraceToken */);
            var seen = {};
            var Property = 1;
            var GetAccessor = 2;
            var SetAccesor = 4;
            var GetOrSetAccessor = GetAccessor | SetAccesor;
            ts.forEach(node.properties, function (p) {
                if (p.kind === 147 /* OmittedExpression */) {
                    return;
                }
                // ECMA-262 11.1.5 Object Initialiser 
                // If previous is not undefined then throw a SyntaxError exception if any of the following conditions are true
                // a.This production is contained in strict code and IsDataDescriptor(previous) is true and 
                // IsDataDescriptor(propId.descriptor) is true.
                //    b.IsDataDescriptor(previous) is true and IsAccessorDescriptor(propId.descriptor) is true.
                //    c.IsAccessorDescriptor(previous) is true and IsDataDescriptor(propId.descriptor) is true.
                //    d.IsAccessorDescriptor(previous) is true and IsAccessorDescriptor(propId.descriptor) is true 
                // and either both previous and propId.descriptor have[[Get]] fields or both previous and propId.descriptor have[[Set]] fields 
                var currentKind;
                if (p.kind === 134 /* PropertyAssignment */) {
                    currentKind = Property;
                }
                else if (p.kind === 122 /* GetAccessor */) {
                    currentKind = GetAccessor;
                }
                else if (p.kind === 123 /* SetAccessor */) {
                    currentKind = SetAccesor;
                }
                else {
                    ts.Debug.fail("Unexpected syntax kind:" + ts.SyntaxKind[p.kind]);
                }
                if (!ts.hasProperty(seen, p.name.text)) {
                    seen[p.name.text] = currentKind;
                }
                else {
                    var existingKind = seen[p.name.text];
                    if (currentKind === Property && existingKind === Property) {
                        if (isInStrictMode) {
                            grammarErrorOnNode(p.name, ts.Diagnostics.An_object_literal_cannot_have_multiple_properties_with_the_same_name_in_strict_mode);
                        }
                    }
                    else if ((currentKind & GetOrSetAccessor) && (existingKind & GetOrSetAccessor)) {
                        if (existingKind !== GetOrSetAccessor && currentKind !== existingKind) {
                            seen[p.name.text] = currentKind | existingKind;
                        }
                        else {
                            grammarErrorOnNode(p.name, ts.Diagnostics.An_object_literal_cannot_have_multiple_get_Slashset_accessors_with_the_same_name);
                        }
                    }
                    else {
                        grammarErrorOnNode(p.name, ts.Diagnostics.An_object_literal_cannot_have_property_and_accessor_with_the_same_name);
                    }
                }
            });
            return finishNode(node);
        }
        function parseFunctionExpression() {
            var pos = getNodePos();
            parseExpected(77 /* FunctionKeyword */);
            var name = isIdentifier() ? parseIdentifier() : undefined;
            var sig = parseSignature(124 /* CallSignature */, 46 /* ColonToken */, false);
            var body = parseBody(false);
            if (name && isInStrictMode && isEvalOrArgumentsIdentifier(name)) {
                // It is a SyntaxError to use within strict mode code the identifiers eval or arguments as the 
                // Identifier of a FunctionDeclaration or FunctionExpression or as a formal parameter name(13.1)
                reportInvalidUseInStrictMode(name);
            }
            return makeFunctionExpression(141 /* FunctionExpression */, pos, name, sig, body);
        }
        function makeFunctionExpression(kind, pos, name, sig, body) {
            var node = createNode(kind, pos);
            node.name = name;
            node.typeParameters = sig.typeParameters;
            node.parameters = sig.parameters;
            node.type = sig.type;
            node.body = body;
            return finishNode(node);
        }
        function parseNewExpression() {
            var node = createNode(138 /* NewExpression */);
            parseExpected(82 /* NewKeyword */);
            node.func = parseCallAndAccess(parsePrimaryExpression(), true);
            if (parseOptional(11 /* OpenParenToken */) || token === 19 /* LessThanToken */ && (node.typeArguments = tryParse(parseTypeArgumentsAndOpenParen))) {
                node.arguments = parseDelimitedList(10 /* ArgumentExpressions */, parseAssignmentExpression, 0 /* Disallow */);
                parseExpected(12 /* CloseParenToken */);
            }
            return finishNode(node);
        }
        // STATEMENTS
        function parseBlock(ignoreMissingOpenBrace, checkForStrictMode) {
            var node = createNode(148 /* Block */);
            if (parseExpected(9 /* OpenBraceToken */) || ignoreMissingOpenBrace) {
                node.statements = parseList(2 /* BlockStatements */, checkForStrictMode, parseStatement);
                parseExpected(10 /* CloseBraceToken */);
            }
            else {
                node.statements = createMissingList();
            }
            return finishNode(node);
        }
        function parseBody(ignoreMissingOpenBrace) {
            var saveInFunctionBody = inFunctionBody;
            var saveInSwitchStatement = inSwitchStatement;
            var saveInIterationStatement = inIterationStatement;
            inFunctionBody = true;
            if (inSwitchStatement === 1 /* Nested */) {
                inSwitchStatement = 2 /* CrossingFunctionBoundary */;
            }
            if (inIterationStatement === 1 /* Nested */) {
                inIterationStatement = 2 /* CrossingFunctionBoundary */;
            }
            labelledStatementInfo.pushFunctionBoundary();
            var block = parseBlock(ignoreMissingOpenBrace, true);
            block.kind = 173 /* FunctionBlock */;
            labelledStatementInfo.pop();
            inFunctionBody = saveInFunctionBody;
            inSwitchStatement = saveInSwitchStatement;
            inIterationStatement = saveInIterationStatement;
            return block;
        }
        function parseEmptyStatement() {
            var node = createNode(150 /* EmptyStatement */);
            parseExpected(17 /* SemicolonToken */);
            return finishNode(node);
        }
        function parseIfStatement() {
            var node = createNode(152 /* IfStatement */);
            parseExpected(78 /* IfKeyword */);
            parseExpected(11 /* OpenParenToken */);
            node.expression = parseExpression();
            parseExpected(12 /* CloseParenToken */);
            node.thenStatement = parseStatement();
            node.elseStatement = parseOptional(70 /* ElseKeyword */) ? parseStatement() : undefined;
            return finishNode(node);
        }
        function parseDoStatement() {
            var node = createNode(153 /* DoStatement */);
            parseExpected(69 /* DoKeyword */);
            var saveInIterationStatement = inIterationStatement;
            inIterationStatement = 1 /* Nested */;
            node.statement = parseStatement();
            inIterationStatement = saveInIterationStatement;
            parseExpected(94 /* WhileKeyword */);
            parseExpected(11 /* OpenParenToken */);
            node.expression = parseExpression();
            parseExpected(12 /* CloseParenToken */);
            // From: https://mail.mozilla.org/pipermail/es-discuss/2011-August/016188.html
            // 157 min --- All allen at wirfs-brock.com CONF --- "do{;}while(false)false" prohibited in 
            // spec but allowed in consensus reality. Approved -- this is the de-facto standard whereby
            //  do;while(0)x will have a semicolon inserted before x.
            parseOptional(17 /* SemicolonToken */);
            return finishNode(node);
        }
        function parseWhileStatement() {
            var node = createNode(154 /* WhileStatement */);
            parseExpected(94 /* WhileKeyword */);
            parseExpected(11 /* OpenParenToken */);
            node.expression = parseExpression();
            parseExpected(12 /* CloseParenToken */);
            var saveInIterationStatement = inIterationStatement;
            inIterationStatement = 1 /* Nested */;
            node.statement = parseStatement();
            inIterationStatement = saveInIterationStatement;
            return finishNode(node);
        }
        function parseForOrForInStatement() {
            var pos = getNodePos();
            parseExpected(76 /* ForKeyword */);
            parseExpected(11 /* OpenParenToken */);
            if (token !== 17 /* SemicolonToken */) {
                if (parseOptional(92 /* VarKeyword */)) {
                    var declarations = parseVariableDeclarationList(0, true);
                    if (!declarations.length) {
                        error(ts.Diagnostics.Variable_declaration_list_cannot_be_empty);
                    }
                }
                else {
                    var varOrInit = parseExpression(true);
                }
            }
            var forOrForInStatement;
            if (parseOptional(80 /* InKeyword */)) {
                var forInStatement = createNode(156 /* ForInStatement */, pos);
                if (declarations) {
                    if (declarations.length > 1) {
                        error(ts.Diagnostics.Only_a_single_variable_declaration_is_allowed_in_a_for_in_statement);
                    }
                    forInStatement.declaration = declarations[0];
                }
                else {
                    forInStatement.variable = varOrInit;
                }
                forInStatement.expression = parseExpression();
                parseExpected(12 /* CloseParenToken */);
                forOrForInStatement = forInStatement;
            }
            else {
                var forStatement = createNode(155 /* ForStatement */, pos);
                if (declarations)
                    forStatement.declarations = declarations;
                if (varOrInit)
                    forStatement.initializer = varOrInit;
                parseExpected(17 /* SemicolonToken */);
                if (token !== 17 /* SemicolonToken */ && token !== 12 /* CloseParenToken */) {
                    forStatement.condition = parseExpression();
                }
                parseExpected(17 /* SemicolonToken */);
                if (token !== 12 /* CloseParenToken */) {
                    forStatement.iterator = parseExpression();
                }
                parseExpected(12 /* CloseParenToken */);
                forOrForInStatement = forStatement;
            }
            var saveInIterationStatement = inIterationStatement;
            inIterationStatement = 1 /* Nested */;
            forOrForInStatement.statement = parseStatement();
            inIterationStatement = saveInIterationStatement;
            return finishNode(forOrForInStatement);
        }
        function parseBreakOrContinueStatement(kind) {
            var node = createNode(kind);
            var errorCountBeforeStatement = file.syntacticErrors.length;
            parseExpected(kind === 158 /* BreakStatement */ ? 60 /* BreakKeyword */ : 65 /* ContinueKeyword */);
            if (!canParseSemicolon())
                node.label = parseIdentifier();
            parseSemicolon();
            finishNode(node);
            // In an ambient context, we will already give an error for having a statement.
            if (!inAmbientContext && errorCountBeforeStatement === file.syntacticErrors.length) {
                if (node.label) {
                    checkBreakOrContinueStatementWithLabel(node);
                }
                else {
                    checkBareBreakOrContinueStatement(node);
                }
            }
            return node;
        }
        function checkBareBreakOrContinueStatement(node) {
            if (node.kind === 158 /* BreakStatement */) {
                if (inIterationStatement === 1 /* Nested */ || inSwitchStatement === 1 /* Nested */) {
                    return;
                }
                else if (inIterationStatement === 0 /* NotNested */ && inSwitchStatement === 0 /* NotNested */) {
                    grammarErrorOnNode(node, ts.Diagnostics.A_break_statement_can_only_be_used_within_an_enclosing_iteration_or_switch_statement);
                    return;
                }
            }
            else if (node.kind === 157 /* ContinueStatement */) {
                if (inIterationStatement === 1 /* Nested */) {
                    return;
                }
                else if (inIterationStatement === 0 /* NotNested */) {
                    grammarErrorOnNode(node, ts.Diagnostics.A_continue_statement_can_only_be_used_within_an_enclosing_iteration_statement);
                    return;
                }
            }
            else {
                ts.Debug.fail("checkAnonymousBreakOrContinueStatement");
            }
            ts.Debug.assert(inIterationStatement === 2 /* CrossingFunctionBoundary */ || inSwitchStatement === 2 /* CrossingFunctionBoundary */);
            grammarErrorOnNode(node, ts.Diagnostics.Jump_target_cannot_cross_function_boundary);
        }
        function checkBreakOrContinueStatementWithLabel(node) {
            // For error specificity, if the label is not found, we want to distinguish whether it is because
            // it crossed a function boundary or it was simply not found. To do this, we pass false for
            // stopAtFunctionBoundary.
            var nodeIsNestedInLabel = labelledStatementInfo.nodeIsNestedInLabel(node.label, node.kind === 157 /* ContinueStatement */, false);
            if (nodeIsNestedInLabel === 1 /* Nested */) {
                return;
            }
            if (nodeIsNestedInLabel === 2 /* CrossingFunctionBoundary */) {
                grammarErrorOnNode(node, ts.Diagnostics.Jump_target_cannot_cross_function_boundary);
                return;
            }
            // It is NotNested
            if (node.kind === 157 /* ContinueStatement */) {
                grammarErrorOnNode(node, ts.Diagnostics.A_continue_statement_can_only_jump_to_a_label_of_an_enclosing_iteration_statement);
            }
            else if (node.kind === 158 /* BreakStatement */) {
                grammarErrorOnNode(node, ts.Diagnostics.A_break_statement_can_only_jump_to_a_label_of_an_enclosing_statement);
            }
            else {
                ts.Debug.fail("checkBreakOrContinueStatementWithLabel");
            }
        }
        function parseReturnStatement() {
            var node = createNode(159 /* ReturnStatement */);
            var errorCountBeforeReturnStatement = file.syntacticErrors.length;
            var returnTokenStart = scanner.getTokenPos();
            var returnTokenLength = scanner.getTextPos() - returnTokenStart;
            parseExpected(84 /* ReturnKeyword */);
            if (!canParseSemicolon())
                node.expression = parseExpression();
            parseSemicolon();
            // In an ambient context, we will already give an error for having a statement.
            if (!inFunctionBody && !inAmbientContext && errorCountBeforeReturnStatement === file.syntacticErrors.length) {
                grammarErrorAtPos(returnTokenStart, returnTokenLength, ts.Diagnostics.A_return_statement_can_only_be_used_within_a_function_body);
            }
            return finishNode(node);
        }
        function parseWithStatement() {
            var node = createNode(160 /* WithStatement */);
            var startPos = scanner.getTokenPos();
            parseExpected(95 /* WithKeyword */);
            var endPos = scanner.getStartPos();
            parseExpected(11 /* OpenParenToken */);
            node.expression = parseExpression();
            parseExpected(12 /* CloseParenToken */);
            node.statement = parseStatement();
            node = finishNode(node);
            if (isInStrictMode) {
                // Strict mode code may not include a WithStatement. The occurrence of a WithStatement in such 
                // a context is an 
                grammarErrorAtPos(startPos, endPos - startPos, ts.Diagnostics.with_statements_are_not_allowed_in_strict_mode);
            }
            return node;
        }
        function parseCaseClause() {
            var node = createNode(162 /* CaseClause */);
            parseExpected(61 /* CaseKeyword */);
            node.expression = parseExpression();
            parseExpected(46 /* ColonToken */);
            node.statements = parseList(4 /* SwitchClauseStatements */, false, parseStatement);
            return finishNode(node);
        }
        function parseDefaultClause() {
            var node = createNode(163 /* DefaultClause */);
            parseExpected(67 /* DefaultKeyword */);
            parseExpected(46 /* ColonToken */);
            node.statements = parseList(4 /* SwitchClauseStatements */, false, parseStatement);
            return finishNode(node);
        }
        function parseCaseOrDefaultClause() {
            return token === 61 /* CaseKeyword */ ? parseCaseClause() : parseDefaultClause();
        }
        function parseSwitchStatement() {
            var node = createNode(161 /* SwitchStatement */);
            parseExpected(86 /* SwitchKeyword */);
            parseExpected(11 /* OpenParenToken */);
            node.expression = parseExpression();
            parseExpected(12 /* CloseParenToken */);
            parseExpected(9 /* OpenBraceToken */);
            var saveInSwitchStatement = inSwitchStatement;
            inSwitchStatement = 1 /* Nested */;
            node.clauses = parseList(3 /* SwitchClauses */, false, parseCaseOrDefaultClause);
            inSwitchStatement = saveInSwitchStatement;
            parseExpected(10 /* CloseBraceToken */);
            // Error on duplicate 'default' clauses.
            var defaultClauses = ts.filter(node.clauses, function (clause) { return clause.kind === 163 /* DefaultClause */; });
            for (var i = 1, n = defaultClauses.length; i < n; i++) {
                var clause = defaultClauses[i];
                var start = ts.skipTrivia(file.text, clause.pos);
                var end = clause.statements.length > 0 ? clause.statements[0].pos : clause.end;
                grammarErrorAtPos(start, end - start, ts.Diagnostics.A_default_clause_cannot_appear_more_than_once_in_a_switch_statement);
            }
            return finishNode(node);
        }
        function parseThrowStatement() {
            var node = createNode(165 /* ThrowStatement */);
            parseExpected(88 /* ThrowKeyword */);
            if (scanner.hasPrecedingLineBreak()) {
                error(ts.Diagnostics.Line_break_not_permitted_here);
            }
            node.expression = parseExpression();
            parseSemicolon();
            return finishNode(node);
        }
        // TODO: Review for error recovery
        function parseTryStatement() {
            var node = createNode(166 /* TryStatement */);
            node.tryBlock = parseTokenAndBlock(90 /* TryKeyword */, 167 /* TryBlock */);
            if (token === 62 /* CatchKeyword */) {
                node.catchBlock = parseCatchBlock();
            }
            if (token === 75 /* FinallyKeyword */) {
                node.finallyBlock = parseTokenAndBlock(75 /* FinallyKeyword */, 169 /* FinallyBlock */);
            }
            if (!(node.catchBlock || node.finallyBlock)) {
                error(ts.Diagnostics.catch_or_finally_expected);
            }
            return finishNode(node);
        }
        function parseTokenAndBlock(token, kind) {
            var pos = getNodePos();
            parseExpected(token);
            var result = parseBlock(false, false);
            result.kind = kind;
            result.pos = pos;
            return result;
        }
        function parseCatchBlock() {
            var pos = getNodePos();
            parseExpected(62 /* CatchKeyword */);
            parseExpected(11 /* OpenParenToken */);
            var variable = parseIdentifier();
            var typeAnnotationColonStart = scanner.getTokenPos();
            var typeAnnotationColonLength = scanner.getTextPos() - typeAnnotationColonStart;
            var typeAnnotation = parseTypeAnnotation();
            parseExpected(12 /* CloseParenToken */);
            var result = parseBlock(false, false);
            result.kind = 168 /* CatchBlock */;
            result.pos = pos;
            result.variable = variable;
            if (typeAnnotation) {
                errorAtPos(typeAnnotationColonStart, typeAnnotationColonLength, ts.Diagnostics.Catch_clause_parameter_cannot_have_a_type_annotation);
            }
            if (isInStrictMode && isEvalOrArgumentsIdentifier(variable)) {
                // It is a SyntaxError if a TryStatement with a Catch occurs within strict code and the Identifier of the 
                // Catch production is eval or arguments
                reportInvalidUseInStrictMode(variable);
            }
            return result;
        }
        function parseDebuggerStatement() {
            var node = createNode(170 /* DebuggerStatement */);
            parseExpected(66 /* DebuggerKeyword */);
            parseSemicolon();
            return finishNode(node);
        }
        function isIterationStatementStart() {
            return token === 94 /* WhileKeyword */ || token === 69 /* DoKeyword */ || token === 76 /* ForKeyword */;
        }
        function parseStatementWithLabelSet() {
            labelledStatementInfo.pushCurrentLabelSet(isIterationStatementStart());
            var statement = parseStatement();
            labelledStatementInfo.pop();
            return statement;
        }
        function isLabel() {
            return isIdentifier() && lookAhead(function () { return nextToken() === 46 /* ColonToken */; });
        }
        function parseLabelledStatement() {
            var node = createNode(164 /* LabeledStatement */);
            node.label = parseIdentifier();
            parseExpected(46 /* ColonToken */);
            if (labelledStatementInfo.nodeIsNestedInLabel(node.label, false, true)) {
                grammarErrorOnNode(node.label, ts.Diagnostics.Duplicate_label_0, getSourceTextOfNodeFromSourceText(sourceText, node.label));
            }
            labelledStatementInfo.addLabel(node.label);
            // We only want to call parseStatementWithLabelSet when the label set is complete
            // Therefore, keep parsing labels until we know we're done.
            node.statement = isLabel() ? parseLabelledStatement() : parseStatementWithLabelSet();
            return finishNode(node);
        }
        function parseExpressionStatement() {
            var node = createNode(151 /* ExpressionStatement */);
            node.expression = parseExpression();
            parseSemicolon();
            return finishNode(node);
        }
        function isStatement(inErrorRecovery) {
            switch (token) {
                case 17 /* SemicolonToken */:
                    // If we're in error recovery, then we don't want to treat ';' as an empty statement.
                    // The problem is that ';' can show up in far too many contexts, and if we see one
                    // and assume it's a statement, then we may bail out inappropriately from whatever
                    // we're parsing.  For example, if we have a semicolon in the middle of a class, then
                    // we really don't want to assume the class is over and we're on a statement in the
                    // outer module.  We just want to consume and move on.
                    return !inErrorRecovery;
                case 9 /* OpenBraceToken */:
                case 92 /* VarKeyword */:
                case 77 /* FunctionKeyword */:
                case 78 /* IfKeyword */:
                case 69 /* DoKeyword */:
                case 94 /* WhileKeyword */:
                case 76 /* ForKeyword */:
                case 65 /* ContinueKeyword */:
                case 60 /* BreakKeyword */:
                case 84 /* ReturnKeyword */:
                case 95 /* WithKeyword */:
                case 86 /* SwitchKeyword */:
                case 88 /* ThrowKeyword */:
                case 90 /* TryKeyword */:
                case 66 /* DebuggerKeyword */:
                case 62 /* CatchKeyword */:
                case 75 /* FinallyKeyword */:
                    return true;
                case 97 /* InterfaceKeyword */:
                case 63 /* ClassKeyword */:
                case 110 /* ModuleKeyword */:
                case 71 /* EnumKeyword */:
                    // When followed by an identifier, these do not start a statement but might
                    // instead be following declarations
                    if (isDeclaration()) {
                        return false;
                    }
                case 102 /* PublicKeyword */:
                case 100 /* PrivateKeyword */:
                case 101 /* ProtectedKeyword */:
                case 103 /* StaticKeyword */:
                    // When followed by an identifier or keyword, these do not start a statement but
                    // might instead be following type members
                    if (lookAhead(function () { return nextToken() >= 59 /* Identifier */; })) {
                        return false;
                    }
                default:
                    return isExpression();
            }
        }
        function parseStatement() {
            switch (token) {
                case 9 /* OpenBraceToken */:
                    return parseBlock(false, false);
                case 92 /* VarKeyword */:
                    return parseVariableStatement();
                case 77 /* FunctionKeyword */:
                    return parseFunctionDeclaration();
                case 17 /* SemicolonToken */:
                    return parseEmptyStatement();
                case 78 /* IfKeyword */:
                    return parseIfStatement();
                case 69 /* DoKeyword */:
                    return parseDoStatement();
                case 94 /* WhileKeyword */:
                    return parseWhileStatement();
                case 76 /* ForKeyword */:
                    return parseForOrForInStatement();
                case 65 /* ContinueKeyword */:
                    return parseBreakOrContinueStatement(157 /* ContinueStatement */);
                case 60 /* BreakKeyword */:
                    return parseBreakOrContinueStatement(158 /* BreakStatement */);
                case 84 /* ReturnKeyword */:
                    return parseReturnStatement();
                case 95 /* WithKeyword */:
                    return parseWithStatement();
                case 86 /* SwitchKeyword */:
                    return parseSwitchStatement();
                case 88 /* ThrowKeyword */:
                    return parseThrowStatement();
                case 90 /* TryKeyword */:
                case 62 /* CatchKeyword */:
                case 75 /* FinallyKeyword */:
                    return parseTryStatement();
                case 66 /* DebuggerKeyword */:
                    return parseDebuggerStatement();
                default:
                    if (isLabel()) {
                        return parseLabelledStatement();
                    }
                    return parseExpressionStatement();
            }
        }
        function parseStatementOrFunction() {
            return token === 77 /* FunctionKeyword */ ? parseFunctionDeclaration() : parseStatement();
        }
        function parseAndCheckFunctionBody(isConstructor) {
            var initialPosition = scanner.getTokenPos();
            var errorCountBeforeBody = file.syntacticErrors.length;
            if (token === 9 /* OpenBraceToken */) {
                var body = parseBody(false);
                if (body && inAmbientContext && file.syntacticErrors.length === errorCountBeforeBody) {
                    var diagnostic = isConstructor ? ts.Diagnostics.A_constructor_implementation_cannot_be_declared_in_an_ambient_context : ts.Diagnostics.A_function_implementation_cannot_be_declared_in_an_ambient_context;
                    grammarErrorAtPos(initialPosition, 1, diagnostic);
                }
                return body;
            }
            if (canParseSemicolon()) {
                parseSemicolon();
                return undefined;
            }
            error(ts.Diagnostics.Block_or_expected); // block or ';' expected
        }
        // DECLARATIONS
        function parseVariableDeclaration(flags, noIn) {
            var node = createNode(171 /* VariableDeclaration */);
            node.flags = flags;
            var errorCountBeforeVariableDeclaration = file.syntacticErrors.length;
            node.name = parseIdentifier();
            node.type = parseTypeAnnotation();
            // Issue any initializer-related errors on the equals token
            var initializerStart = scanner.getTokenPos();
            var initializerFirstTokenLength = scanner.getTextPos() - initializerStart;
            node.initializer = parseInitializer(false, noIn);
            if (inAmbientContext && node.initializer && errorCountBeforeVariableDeclaration === file.syntacticErrors.length) {
                grammarErrorAtPos(initializerStart, initializerFirstTokenLength, ts.Diagnostics.Initializers_are_not_allowed_in_ambient_contexts);
            }
            if (isInStrictMode && isEvalOrArgumentsIdentifier(node.name)) {
                // It is a SyntaxError if a VariableDeclaration or VariableDeclarationNoIn occurs within strict code 
                // and its Identifier is eval or arguments 
                reportInvalidUseInStrictMode(node.name);
            }
            return finishNode(node);
        }
        function parseVariableDeclarationList(flags, noIn) {
            return parseDelimitedList(9 /* VariableDeclarations */, function () { return parseVariableDeclaration(flags, noIn); }, 0 /* Disallow */);
        }
        function parseVariableStatement(pos, flags) {
            var node = createNode(149 /* VariableStatement */, pos);
            if (flags)
                node.flags = flags;
            var errorCountBeforeVarStatement = file.syntacticErrors.length;
            parseExpected(92 /* VarKeyword */);
            node.declarations = parseVariableDeclarationList(flags, false);
            parseSemicolon();
            finishNode(node);
            if (!node.declarations.length && file.syntacticErrors.length === errorCountBeforeVarStatement) {
                grammarErrorOnNode(node, ts.Diagnostics.Variable_declaration_list_cannot_be_empty);
            }
            return node;
        }
        function parseFunctionDeclaration(pos, flags) {
            var node = createNode(172 /* FunctionDeclaration */, pos);
            if (flags)
                node.flags = flags;
            parseExpected(77 /* FunctionKeyword */);
            node.name = parseIdentifier();
            var sig = parseSignature(124 /* CallSignature */, 46 /* ColonToken */, false);
            node.typeParameters = sig.typeParameters;
            node.parameters = sig.parameters;
            node.type = sig.type;
            node.body = parseAndCheckFunctionBody(false);
            if (isInStrictMode && isEvalOrArgumentsIdentifier(node.name)) {
                // It is a SyntaxError to use within strict mode code the identifiers eval or arguments as the 
                // Identifier of a FunctionDeclaration or FunctionExpression or as a formal parameter name(13.1)
                reportInvalidUseInStrictMode(node.name);
            }
            return finishNode(node);
        }
        function parseConstructorDeclaration(pos, flags) {
            var node = createNode(121 /* Constructor */, pos);
            node.flags = flags;
            parseExpected(107 /* ConstructorKeyword */);
            var sig = parseSignature(124 /* CallSignature */, 46 /* ColonToken */, false);
            node.typeParameters = sig.typeParameters;
            node.parameters = sig.parameters;
            node.type = sig.type;
            node.body = parseAndCheckFunctionBody(true);
            if (node.typeParameters) {
                grammarErrorAtPos(node.typeParameters.pos, node.typeParameters.end - node.typeParameters.pos, ts.Diagnostics.Type_parameters_cannot_appear_on_a_constructor_declaration);
            }
            if (node.type) {
                grammarErrorOnNode(node.type, ts.Diagnostics.Type_annotation_cannot_appear_on_a_constructor_declaration);
            }
            return finishNode(node);
        }
        function parsePropertyMemberDeclaration(pos, flags) {
            var errorCountBeforePropertyDeclaration = file.syntacticErrors.length;
            var name = parsePropertyName();
            var questionStart = scanner.getTokenPos();
            if (parseOptional(45 /* QuestionToken */)) {
                errorAtPos(questionStart, scanner.getStartPos() - questionStart, ts.Diagnostics.A_class_member_cannot_be_declared_optional);
            }
            if (token === 11 /* OpenParenToken */ || token === 19 /* LessThanToken */) {
                var method = createNode(120 /* Method */, pos);
                method.flags = flags;
                method.name = name;
                var sig = parseSignature(124 /* CallSignature */, 46 /* ColonToken */, false);
                method.typeParameters = sig.typeParameters;
                method.parameters = sig.parameters;
                method.type = sig.type;
                method.body = parseAndCheckFunctionBody(false);
                return finishNode(method);
            }
            else {
                var property = createNode(119 /* Property */, pos);
                property.flags = flags;
                property.name = name;
                property.type = parseTypeAnnotation();
                var initializerStart = scanner.getTokenPos();
                var initializerFirstTokenLength = scanner.getTextPos() - initializerStart;
                property.initializer = parseInitializer(false);
                parseSemicolon();
                if (inAmbientContext && property.initializer && errorCountBeforePropertyDeclaration === file.syntacticErrors.length) {
                    grammarErrorAtPos(initializerStart, initializerFirstTokenLength, ts.Diagnostics.Initializers_are_not_allowed_in_ambient_contexts);
                }
                return finishNode(property);
            }
        }
        function parseAndCheckMemberAccessorDeclaration(kind, pos, flags) {
            var errorCountBeforeAccessor = file.syntacticErrors.length;
            var accessor = parseMemberAccessorDeclaration(kind, pos, flags);
            if (errorCountBeforeAccessor === file.syntacticErrors.length) {
                if (languageVersion < 1 /* ES5 */) {
                    grammarErrorOnNode(accessor.name, ts.Diagnostics.Accessors_are_only_available_when_targeting_ECMAScript_5_and_higher);
                }
                else if (inAmbientContext) {
                    grammarErrorOnNode(accessor.name, ts.Diagnostics.An_accessor_cannot_be_declared_in_an_ambient_context);
                }
                else if (accessor.typeParameters) {
                    grammarErrorOnNode(accessor.name, ts.Diagnostics.An_accessor_cannot_have_type_parameters);
                }
                else if (kind === 122 /* GetAccessor */ && accessor.parameters.length) {
                    grammarErrorOnNode(accessor.name, ts.Diagnostics.A_get_accessor_cannot_have_parameters);
                }
                else if (kind === 123 /* SetAccessor */) {
                    if (accessor.type) {
                        grammarErrorOnNode(accessor.name, ts.Diagnostics.A_set_accessor_cannot_have_a_return_type_annotation);
                    }
                    else if (accessor.parameters.length !== 1) {
                        grammarErrorOnNode(accessor.name, ts.Diagnostics.A_set_accessor_must_have_exactly_one_parameter);
                    }
                    else {
                        var parameter = accessor.parameters[0];
                        if (parameter.flags & 8 /* Rest */) {
                            grammarErrorOnNode(accessor.name, ts.Diagnostics.A_set_accessor_cannot_have_rest_parameter);
                        }
                        else if (parameter.flags & ts.NodeFlags.Modifier) {
                            grammarErrorOnNode(accessor.name, ts.Diagnostics.A_parameter_property_is_only_allowed_in_a_constructor_implementation);
                        }
                        else if (parameter.flags & 4 /* QuestionMark */) {
                            grammarErrorOnNode(accessor.name, ts.Diagnostics.A_set_accessor_cannot_have_an_optional_parameter);
                        }
                        else if (parameter.initializer) {
                            grammarErrorOnNode(accessor.name, ts.Diagnostics.A_set_accessor_parameter_cannot_have_an_initializer);
                        }
                    }
                }
            }
            return accessor;
        }
        function parseMemberAccessorDeclaration(kind, pos, flags) {
            var node = createNode(kind, pos);
            node.flags = flags;
            node.name = parsePropertyName();
            var sig = parseSignature(124 /* CallSignature */, 46 /* ColonToken */, false);
            node.typeParameters = sig.typeParameters;
            node.parameters = sig.parameters;
            node.type = sig.type;
            // A common error is to try to declare an accessor in an ambient class.
            if (inAmbientContext && canParseSemicolon()) {
                parseSemicolon();
                node.body = createMissingNode();
            }
            else {
                node.body = parseBody(false);
            }
            return finishNode(node);
        }
        function isClassMemberStart() {
            var idToken;
            while (isModifier(token)) {
                idToken = token;
                nextToken();
            }
            // Try to get the first property-like token following all modifiers.
            // This can either be an identifier or the 'get' or 'set' keywords.
            if (isPropertyName()) {
                idToken = token;
                nextToken();
            }
            // Index signatures are class members; we can parse.
            if (token === 13 /* OpenBracketToken */) {
                return true;
            }
            // If we were able to get any potential identifier...
            if (idToken !== undefined) {
                // If we have a non-keyword identifier, or if we have an accessor, then it's safe to parse.
                if (!isKeyword(idToken) || idToken === 113 /* SetKeyword */ || idToken === 109 /* GetKeyword */) {
                    return true;
                }
                switch (token) {
                    case 11 /* OpenParenToken */:
                    case 19 /* LessThanToken */:
                    case 46 /* ColonToken */:
                    case 47 /* EqualsToken */:
                    case 45 /* QuestionToken */:
                        return true;
                    default:
                        // Covers
                        //  - Semicolons     (declaration termination)
                        //  - Closing braces (end-of-class, must be declaration)
                        //  - End-of-files   (not valid, but permitted so that it gets caught later on)
                        //  - Line-breaks    (enabling *automatic semicolon insertion*)
                        return canParseSemicolon();
                }
            }
            return false;
        }
        function parseAndCheckModifiers(context) {
            var flags = 0;
            var lastStaticModifierStart;
            var lastStaticModifierLength;
            var lastDeclareModifierStart;
            var lastDeclareModifierLength;
            var lastPrivateModifierStart;
            var lastPrivateModifierLength;
            var lastProtectedModifierStart;
            var lastProtectedModifierLength;
            while (true) {
                var modifierStart = scanner.getTokenPos();
                var modifierToken = token;
                // Try to parse the modifier
                if (!parseAnyContextualModifier())
                    break;
                var modifierLength = scanner.getStartPos() - modifierStart;
                switch (modifierToken) {
                    case 102 /* PublicKeyword */:
                        if (flags & ts.NodeFlags.AccessibilityModifier) {
                            grammarErrorAtPos(modifierStart, modifierLength, ts.Diagnostics.Accessibility_modifier_already_seen);
                        }
                        else if (flags & 128 /* Static */) {
                            grammarErrorAtPos(modifierStart, modifierLength, ts.Diagnostics._0_modifier_must_precede_1_modifier, "public", "static");
                        }
                        else if (context === 1 /* ModuleElements */ || context === 0 /* SourceElements */) {
                            grammarErrorAtPos(modifierStart, modifierLength, ts.Diagnostics._0_modifier_cannot_appear_on_a_module_element, "public");
                        }
                        flags |= 16 /* Public */;
                        break;
                    case 100 /* PrivateKeyword */:
                        if (flags & ts.NodeFlags.AccessibilityModifier) {
                            grammarErrorAtPos(modifierStart, modifierLength, ts.Diagnostics.Accessibility_modifier_already_seen);
                        }
                        else if (flags & 128 /* Static */) {
                            grammarErrorAtPos(modifierStart, modifierLength, ts.Diagnostics._0_modifier_must_precede_1_modifier, "private", "static");
                        }
                        else if (context === 1 /* ModuleElements */ || context === 0 /* SourceElements */) {
                            grammarErrorAtPos(modifierStart, modifierLength, ts.Diagnostics._0_modifier_cannot_appear_on_a_module_element, "private");
                        }
                        lastPrivateModifierStart = modifierStart;
                        lastPrivateModifierLength = modifierLength;
                        flags |= 32 /* Private */;
                        break;
                    case 101 /* ProtectedKeyword */:
                        if (flags & 16 /* Public */ || flags & 32 /* Private */ || flags & 64 /* Protected */) {
                            grammarErrorAtPos(modifierStart, modifierLength, ts.Diagnostics.Accessibility_modifier_already_seen);
                        }
                        else if (flags & 128 /* Static */) {
                            grammarErrorAtPos(modifierStart, modifierLength, ts.Diagnostics._0_modifier_must_precede_1_modifier, "protected", "static");
                        }
                        else if (context === 1 /* ModuleElements */ || context === 0 /* SourceElements */) {
                            grammarErrorAtPos(modifierStart, modifierLength, ts.Diagnostics._0_modifier_cannot_appear_on_a_module_element, "protected");
                        }
                        lastProtectedModifierStart = modifierStart;
                        lastProtectedModifierLength = modifierLength;
                        flags |= 64 /* Protected */;
                        break;
                    case 103 /* StaticKeyword */:
                        if (flags & 128 /* Static */) {
                            grammarErrorAtPos(modifierStart, modifierLength, ts.Diagnostics._0_modifier_already_seen, "static");
                        }
                        else if (context === 1 /* ModuleElements */ || context === 0 /* SourceElements */) {
                            grammarErrorAtPos(modifierStart, modifierLength, ts.Diagnostics._0_modifier_cannot_appear_on_a_module_element, "static");
                        }
                        else if (context === 3 /* Parameters */) {
                            grammarErrorAtPos(modifierStart, modifierLength, ts.Diagnostics._0_modifier_cannot_appear_on_a_parameter, "static");
                        }
                        lastStaticModifierStart = modifierStart;
                        lastStaticModifierLength = modifierLength;
                        flags |= 128 /* Static */;
                        break;
                    case 72 /* ExportKeyword */:
                        if (flags & 1 /* Export */) {
                            grammarErrorAtPos(modifierStart, modifierLength, ts.Diagnostics._0_modifier_already_seen, "export");
                        }
                        else if (flags & 2 /* Ambient */) {
                            grammarErrorAtPos(modifierStart, modifierLength, ts.Diagnostics._0_modifier_must_precede_1_modifier, "export", "declare");
                        }
                        else if (context === 2 /* ClassMembers */) {
                            grammarErrorAtPos(modifierStart, modifierLength, ts.Diagnostics._0_modifier_cannot_appear_on_a_class_element, "export");
                        }
                        else if (context === 3 /* Parameters */) {
                            grammarErrorAtPos(modifierStart, modifierLength, ts.Diagnostics._0_modifier_cannot_appear_on_a_parameter, "export");
                        }
                        flags |= 1 /* Export */;
                        break;
                    case 108 /* DeclareKeyword */:
                        if (flags & 2 /* Ambient */) {
                            grammarErrorAtPos(modifierStart, modifierLength, ts.Diagnostics._0_modifier_already_seen, "declare");
                        }
                        else if (context === 2 /* ClassMembers */) {
                            grammarErrorAtPos(modifierStart, modifierLength, ts.Diagnostics._0_modifier_cannot_appear_on_a_class_element, "declare");
                        }
                        else if (context === 3 /* Parameters */) {
                            grammarErrorAtPos(modifierStart, modifierLength, ts.Diagnostics._0_modifier_cannot_appear_on_a_parameter, "declare");
                        }
                        else if (inAmbientContext && context === 1 /* ModuleElements */) {
                            grammarErrorAtPos(modifierStart, modifierLength, ts.Diagnostics.A_declare_modifier_cannot_be_used_in_an_already_ambient_context);
                        }
                        lastDeclareModifierStart = modifierStart;
                        lastDeclareModifierLength = modifierLength;
                        flags |= 2 /* Ambient */;
                        break;
                }
            }
            if (token === 107 /* ConstructorKeyword */ && flags & 128 /* Static */) {
                grammarErrorAtPos(lastStaticModifierStart, lastStaticModifierLength, ts.Diagnostics._0_modifier_cannot_appear_on_a_constructor_declaration, "static");
            }
            else if (token === 107 /* ConstructorKeyword */ && flags & 32 /* Private */) {
                grammarErrorAtPos(lastPrivateModifierStart, lastPrivateModifierLength, ts.Diagnostics._0_modifier_cannot_appear_on_a_constructor_declaration, "private");
            }
            else if (token === 107 /* ConstructorKeyword */ && flags & 64 /* Protected */) {
                grammarErrorAtPos(lastProtectedModifierStart, lastProtectedModifierLength, ts.Diagnostics._0_modifier_cannot_appear_on_a_constructor_declaration, "protected");
            }
            else if (token === 79 /* ImportKeyword */) {
                if (flags & 2 /* Ambient */) {
                    grammarErrorAtPos(lastDeclareModifierStart, lastDeclareModifierLength, ts.Diagnostics.A_declare_modifier_cannot_be_used_with_an_import_declaration, "declare");
                }
            }
            else if (token === 97 /* InterfaceKeyword */) {
                if (flags & 2 /* Ambient */) {
                    grammarErrorAtPos(lastDeclareModifierStart, lastDeclareModifierLength, ts.Diagnostics.A_declare_modifier_cannot_be_used_with_an_interface_declaration, "declare");
                }
            }
            else if (token !== 72 /* ExportKeyword */ && !(flags & 2 /* Ambient */) && inAmbientContext && context === 0 /* SourceElements */) {
                // A declare modifier is required for any top level .d.ts declaration except export=, interfaces and imports:
                // categories:
                //
                //  DeclarationElement:
                //     ExportAssignment
                //     export_opt   InterfaceDeclaration
                //     export_opt   ImportDeclaration
                //     export_opt   ExternalImportDeclaration
                //     export_opt   AmbientDeclaration
                //
                var declarationStart = scanner.getTokenPos();
                var declarationFirstTokenLength = scanner.getTextPos() - declarationStart;
                grammarErrorAtPos(declarationStart, declarationFirstTokenLength, ts.Diagnostics.A_declare_modifier_is_required_for_a_top_level_declaration_in_a_d_ts_file);
            }
            return flags;
        }
        function parseClassMemberDeclaration() {
            var pos = getNodePos();
            var flags = parseAndCheckModifiers(2 /* ClassMembers */);
            if (parseContextualModifier(109 /* GetKeyword */)) {
                return parseAndCheckMemberAccessorDeclaration(122 /* GetAccessor */, pos, flags);
            }
            if (parseContextualModifier(113 /* SetKeyword */)) {
                return parseAndCheckMemberAccessorDeclaration(123 /* SetAccessor */, pos, flags);
            }
            if (token === 107 /* ConstructorKeyword */) {
                return parseConstructorDeclaration(pos, flags);
            }
            if (token >= 59 /* Identifier */ || token === 7 /* StringLiteral */ || token === 6 /* NumericLiteral */) {
                return parsePropertyMemberDeclaration(pos, flags);
            }
            if (token === 13 /* OpenBracketToken */) {
                if (flags) {
                    var start = getTokenPos(pos);
                    var length = getNodePos() - start;
                    errorAtPos(start, length, ts.Diagnostics.Modifiers_not_permitted_on_index_signature_members);
                }
                return parseIndexSignatureMember();
            }
            // 'isClassMemberStart' should have hinted not to attempt parsing.
            ts.Debug.fail("Should not have attempted to parse class member declaration.");
        }
        function parseClassDeclaration(pos, flags) {
            var node = createNode(174 /* ClassDeclaration */, pos);
            node.flags = flags;
            var errorCountBeforeClassDeclaration = file.syntacticErrors.length;
            parseExpected(63 /* ClassKeyword */);
            node.name = parseIdentifier();
            node.typeParameters = parseTypeParameters();
            // TODO(jfreeman): Parse arbitrary sequence of heritage clauses and error for order and duplicates
            node.baseType = parseOptional(73 /* ExtendsKeyword */) ? parseTypeReference() : undefined;
            var implementsKeywordStart = scanner.getTokenPos();
            var implementsKeywordLength;
            if (parseOptional(96 /* ImplementsKeyword */)) {
                implementsKeywordLength = scanner.getStartPos() - implementsKeywordStart;
                node.implementedTypes = parseDelimitedList(8 /* BaseTypeReferences */, parseTypeReference, 0 /* Disallow */);
            }
            var errorCountBeforeClassBody = file.syntacticErrors.length;
            if (parseExpected(9 /* OpenBraceToken */)) {
                node.members = parseList(6 /* ClassMembers */, false, parseClassMemberDeclaration);
                parseExpected(10 /* CloseBraceToken */);
            }
            else {
                node.members = createMissingList();
            }
            if (node.implementedTypes && !node.implementedTypes.length && errorCountBeforeClassBody === errorCountBeforeClassDeclaration) {
                grammarErrorAtPos(implementsKeywordStart, implementsKeywordLength, ts.Diagnostics._0_list_cannot_be_empty, "implements");
            }
            return finishNode(node);
        }
        function parseInterfaceDeclaration(pos, flags) {
            var node = createNode(175 /* InterfaceDeclaration */, pos);
            node.flags = flags;
            var errorCountBeforeInterfaceDeclaration = file.syntacticErrors.length;
            parseExpected(97 /* InterfaceKeyword */);
            node.name = parseIdentifier();
            node.typeParameters = parseTypeParameters();
            // TODO(jfreeman): Parse arbitrary sequence of heritage clauses and error for order and duplicates
            var extendsKeywordStart = scanner.getTokenPos();
            var extendsKeywordLength;
            if (parseOptional(73 /* ExtendsKeyword */)) {
                extendsKeywordLength = scanner.getStartPos() - extendsKeywordStart;
                node.baseTypes = parseDelimitedList(8 /* BaseTypeReferences */, parseTypeReference, 0 /* Disallow */);
            }
            var errorCountBeforeInterfaceBody = file.syntacticErrors.length;
            node.members = parseTypeLiteral().members;
            if (node.baseTypes && !node.baseTypes.length && errorCountBeforeInterfaceBody === errorCountBeforeInterfaceDeclaration) {
                grammarErrorAtPos(extendsKeywordStart, extendsKeywordLength, ts.Diagnostics._0_list_cannot_be_empty, "extends");
            }
            return finishNode(node);
        }
        function parseAndCheckEnumDeclaration(pos, flags) {
            function isIntegerLiteral(expression) {
                function isInteger(literalExpression) {
                    // Allows for scientific notation since literalExpression.text was formed by
                    // coercing a number to a string. Sometimes this coercion can yield a string
                    // in scientific notation.
                    // We also don't need special logic for hex because a hex integer is converted
                    // to decimal when it is coerced.
                    return /^[0-9]+([eE]\+?[0-9]+)?$/.test(literalExpression.text);
                }
                if (expression.kind === 143 /* PrefixOperator */) {
                    var unaryExpression = expression;
                    if (unaryExpression.operator === 28 /* PlusToken */ || unaryExpression.operator === 29 /* MinusToken */) {
                        expression = unaryExpression.operand;
                    }
                }
                if (expression.kind === 6 /* NumericLiteral */) {
                    return isInteger(expression);
                }
                return false;
            }
            var inConstantEnumMemberSection = true;
            // In an ambient declaration, the grammar only allows integer literals as initializers.
            // In a non-ambient declaration, the grammar allows uninitialized members only in a
            // ConstantEnumMemberSection, which starts at the beginning of an enum declaration
            // or any time an integer literal initializer is encountered.
            function parseAndCheckEnumMember() {
                var node = createNode(181 /* EnumMember */);
                var errorCountBeforeEnumMember = file.syntacticErrors.length;
                node.name = parsePropertyName();
                node.initializer = parseInitializer(false);
                if (inAmbientContext) {
                    if (node.initializer && !isIntegerLiteral(node.initializer) && errorCountBeforeEnumMember === file.syntacticErrors.length) {
                        grammarErrorOnNode(node.name, ts.Diagnostics.Ambient_enum_elements_can_only_have_integer_literal_initializers);
                    }
                }
                else if (node.initializer) {
                    inConstantEnumMemberSection = isIntegerLiteral(node.initializer);
                }
                else if (!inConstantEnumMemberSection && errorCountBeforeEnumMember === file.syntacticErrors.length) {
                    grammarErrorOnNode(node.name, ts.Diagnostics.Enum_member_must_have_initializer);
                }
                return finishNode(node);
            }
            var node = createNode(176 /* EnumDeclaration */, pos);
            node.flags = flags;
            parseExpected(71 /* EnumKeyword */);
            node.name = parseIdentifier();
            if (parseExpected(9 /* OpenBraceToken */)) {
                node.members = parseDelimitedList(7 /* EnumMembers */, parseAndCheckEnumMember, 1 /* Allow */);
                parseExpected(10 /* CloseBraceToken */);
            }
            else {
                node.members = createMissingList();
            }
            return finishNode(node);
        }
        function parseModuleBody() {
            var node = createNode(178 /* ModuleBlock */);
            if (parseExpected(9 /* OpenBraceToken */)) {
                node.statements = parseList(1 /* ModuleElements */, false, parseModuleElement);
                parseExpected(10 /* CloseBraceToken */);
            }
            else {
                node.statements = createMissingList();
            }
            return finishNode(node);
        }
        function parseInternalModuleTail(pos, flags) {
            var node = createNode(177 /* ModuleDeclaration */, pos);
            node.flags = flags;
            node.name = parseIdentifier();
            if (parseOptional(15 /* DotToken */)) {
                node.body = parseInternalModuleTail(getNodePos(), 1 /* Export */);
            }
            else {
                node.body = parseModuleBody();
                ts.forEach(node.body.statements, function (s) {
                    if (s.kind === 180 /* ExportAssignment */) {
                        // Export assignments are not allowed in an internal module
                        grammarErrorOnNode(s, ts.Diagnostics.An_export_assignment_cannot_be_used_in_an_internal_module);
                    }
                    else if (s.kind === 179 /* ImportDeclaration */ && s.externalModuleName) {
                        grammarErrorOnNode(s, ts.Diagnostics.Import_declarations_in_an_internal_module_cannot_reference_an_external_module);
                    }
                });
            }
            return finishNode(node);
        }
        function parseAmbientExternalModuleDeclaration(pos, flags) {
            var node = createNode(177 /* ModuleDeclaration */, pos);
            node.flags = flags;
            node.name = parseStringLiteral();
            if (!inAmbientContext) {
                var errorCount = file.syntacticErrors.length;
                // Only report this error if we have not already errored about a missing declare modifier,
                // which would have been at or after pos
                if (!errorCount || file.syntacticErrors[errorCount - 1].start < getTokenPos(pos)) {
                    grammarErrorOnNode(node.name, ts.Diagnostics.Only_ambient_modules_can_use_quoted_names);
                }
            }
            // For error recovery, just in case the user forgot the declare modifier on this ambient
            // external module, treat it as ambient anyway.
            var saveInAmbientContext = inAmbientContext;
            inAmbientContext = true;
            node.body = parseModuleBody();
            inAmbientContext = saveInAmbientContext;
            return finishNode(node);
        }
        function parseModuleDeclaration(pos, flags) {
            parseExpected(110 /* ModuleKeyword */);
            return token === 7 /* StringLiteral */ ? parseAmbientExternalModuleDeclaration(pos, flags) : parseInternalModuleTail(pos, flags);
        }
        function parseImportDeclaration(pos, flags) {
            var node = createNode(179 /* ImportDeclaration */, pos);
            node.flags = flags;
            parseExpected(79 /* ImportKeyword */);
            node.name = parseIdentifier();
            parseExpected(47 /* EqualsToken */);
            var entityName = parseEntityName(false);
            if (entityName.kind === 59 /* Identifier */ && entityName.text === "require" && parseOptional(11 /* OpenParenToken */)) {
                node.externalModuleName = parseStringLiteral();
                parseExpected(12 /* CloseParenToken */);
            }
            else {
                node.entityName = entityName;
            }
            parseSemicolon();
            return finishNode(node);
        }
        function parseExportAssignmentTail(pos) {
            var node = createNode(180 /* ExportAssignment */, pos);
            node.exportName = parseIdentifier();
            parseSemicolon();
            return finishNode(node);
        }
        function isDeclaration() {
            switch (token) {
                case 92 /* VarKeyword */:
                case 77 /* FunctionKeyword */:
                    return true;
                case 63 /* ClassKeyword */:
                case 97 /* InterfaceKeyword */:
                case 71 /* EnumKeyword */:
                case 79 /* ImportKeyword */:
                    // Not true keywords so ensure an identifier follows
                    return lookAhead(function () { return nextToken() >= 59 /* Identifier */; });
                case 110 /* ModuleKeyword */:
                    // Not a true keyword so ensure an identifier or string literal follows
                    return lookAhead(function () { return nextToken() >= 59 /* Identifier */ || token === 7 /* StringLiteral */; });
                case 72 /* ExportKeyword */:
                    // Check for export assignment or modifier on source element
                    return lookAhead(function () { return nextToken() === 47 /* EqualsToken */ || isDeclaration(); });
                case 108 /* DeclareKeyword */:
                case 102 /* PublicKeyword */:
                case 100 /* PrivateKeyword */:
                case 101 /* ProtectedKeyword */:
                case 103 /* StaticKeyword */:
                    // Check for modifier on source element
                    return lookAhead(function () {
                        nextToken();
                        return isDeclaration();
                    });
            }
        }
        function parseDeclaration(modifierContext) {
            var pos = getNodePos();
            var errorCountBeforeModifiers = file.syntacticErrors.length;
            var flags = parseAndCheckModifiers(modifierContext);
            if (token === 72 /* ExportKeyword */) {
                var modifiersEnd = scanner.getStartPos();
                nextToken();
                if (parseOptional(47 /* EqualsToken */)) {
                    var exportAssignmentTail = parseExportAssignmentTail(pos);
                    if (flags !== 0 && errorCountBeforeModifiers === file.syntacticErrors.length) {
                        var modifiersStart = ts.skipTrivia(sourceText, pos);
                        grammarErrorAtPos(modifiersStart, modifiersEnd - modifiersStart, ts.Diagnostics.An_export_assignment_cannot_have_modifiers);
                    }
                    return exportAssignmentTail;
                }
            }
            var saveInAmbientContext = inAmbientContext;
            if (flags & 2 /* Ambient */) {
                inAmbientContext = true;
            }
            var result;
            switch (token) {
                case 92 /* VarKeyword */:
                    result = parseVariableStatement(pos, flags);
                    break;
                case 77 /* FunctionKeyword */:
                    result = parseFunctionDeclaration(pos, flags);
                    break;
                case 63 /* ClassKeyword */:
                    result = parseClassDeclaration(pos, flags);
                    break;
                case 97 /* InterfaceKeyword */:
                    result = parseInterfaceDeclaration(pos, flags);
                    break;
                case 71 /* EnumKeyword */:
                    result = parseAndCheckEnumDeclaration(pos, flags);
                    break;
                case 110 /* ModuleKeyword */:
                    result = parseModuleDeclaration(pos, flags);
                    break;
                case 79 /* ImportKeyword */:
                    result = parseImportDeclaration(pos, flags);
                    break;
                default:
                    error(ts.Diagnostics.Declaration_expected);
            }
            inAmbientContext = saveInAmbientContext;
            return result;
        }
        function isSourceElement(inErrorRecovery) {
            return isDeclaration() || isStatement(inErrorRecovery);
        }
        function parseSourceElement() {
            return parseSourceElementOrModuleElement(0 /* SourceElements */);
        }
        function parseModuleElement() {
            return parseSourceElementOrModuleElement(1 /* ModuleElements */);
        }
        function parseSourceElementOrModuleElement(modifierContext) {
            if (isDeclaration()) {
                return parseDeclaration(modifierContext);
            }
            var statementStart = scanner.getTokenPos();
            var statementFirstTokenLength = scanner.getTextPos() - statementStart;
            var errorCountBeforeStatement = file.syntacticErrors.length;
            var statement = parseStatement();
            if (inAmbientContext && file.syntacticErrors.length === errorCountBeforeStatement) {
                grammarErrorAtPos(statementStart, statementFirstTokenLength, ts.Diagnostics.Statements_are_not_allowed_in_ambient_contexts);
            }
            return statement;
        }
        function processReferenceComments() {
            var referencedFiles = [];
            var amdDependencies = [];
            commentRanges = [];
            token = scanner.scan();
            for (var i = 0; i < commentRanges.length; i++) {
                var range = commentRanges[i];
                var comment = sourceText.substring(range.pos, range.end);
                var simpleReferenceRegEx = /^\/\/\/\s*<reference\s+/gim;
                if (simpleReferenceRegEx.exec(comment)) {
                    var isNoDefaultLibRegEx = /^(\/\/\/\s*<reference\s+no-default-lib=)('|")(.+?)\2\s*\/>/gim;
                    if (isNoDefaultLibRegEx.exec(comment)) {
                        file.hasNoDefaultLib = true;
                    }
                    else {
                        var matchResult = ts.fullTripleSlashReferencePathRegEx.exec(comment);
                        if (!matchResult) {
                            var start = range.pos;
                            var length = range.end - start;
                            errorAtPos(start, length, ts.Diagnostics.Invalid_reference_directive_syntax);
                        }
                        else {
                            referencedFiles.push({
                                pos: range.pos,
                                end: range.end,
                                filename: matchResult[3]
                            });
                        }
                    }
                }
                else {
                    var amdDependencyRegEx = /^\/\/\/\s*<amd-dependency\s+path\s*=\s*('|")(.+?)\1/gim;
                    var amdDependencyMatchResult = amdDependencyRegEx.exec(comment);
                    if (amdDependencyMatchResult) {
                        amdDependencies.push(amdDependencyMatchResult[2]);
                    }
                }
            }
            commentRanges = undefined;
            return {
                referencedFiles: referencedFiles,
                amdDependencies: amdDependencies
            };
        }
        function getExternalModuleIndicator() {
            return ts.forEach(file.statements, function (node) { return node.flags & 1 /* Export */ || node.kind === 179 /* ImportDeclaration */ && node.externalModuleName || node.kind === 180 /* ExportAssignment */ ? node : undefined; });
        }
        scanner = ts.createScanner(languageVersion, true, sourceText, scanError, onComment);
        var rootNodeFlags = 0;
        if (ts.fileExtensionIs(filename, ".d.ts")) {
            rootNodeFlags = 1024 /* DeclarationFile */;
            inAmbientContext = true;
        }
        file = createRootNode(182 /* SourceFile */, 0, sourceText.length, rootNodeFlags);
        file.filename = ts.normalizePath(filename);
        file.text = sourceText;
        file.getLineAndCharacterFromPosition = getLineAndCharacterlFromSourcePosition;
        file.getPositionFromLineAndCharacter = getPositionFromSourceLineAndCharacter;
        file.syntacticErrors = [];
        file.semanticErrors = [];
        var referenceComments = processReferenceComments();
        file.referencedFiles = referenceComments.referencedFiles;
        file.amdDependencies = referenceComments.amdDependencies;
        file.statements = parseList(0 /* SourceElements */, true, parseSourceElement);
        file.externalModuleIndicator = getExternalModuleIndicator();
        file.nodeCount = nodeCount;
        file.identifierCount = identifierCount;
        file.version = version;
        file.isOpen = isOpen;
        file.languageVersion = languageVersion;
        file.identifiers = identifiers;
        return file;
    }
    ts.createSourceFile = createSourceFile;
    function createProgram(rootNames, options, host) {
        var program;
        var files = [];
        var filesByName = {};
        var errors = [];
        var seenNoDefaultLib = options.noLib;
        var commonSourceDirectory;
        ts.forEach(rootNames, function (name) { return processRootFile(name, false); });
        if (!seenNoDefaultLib) {
            processRootFile(host.getDefaultLibFilename(), true);
        }
        verifyCompilerOptions();
        errors.sort(ts.compareDiagnostics);
        program = {
            getSourceFile: getSourceFile,
            getSourceFiles: function () { return files; },
            getCompilerOptions: function () { return options; },
            getCompilerHost: function () { return host; },
            getDiagnostics: getDiagnostics,
            getGlobalDiagnostics: getGlobalDiagnostics,
            getTypeChecker: function (fullTypeCheckMode) { return ts.createTypeChecker(program, fullTypeCheckMode); },
            getCommonSourceDirectory: function () { return commonSourceDirectory; }
        };
        return program;
        function getSourceFile(filename) {
            filename = host.getCanonicalFileName(filename);
            return ts.hasProperty(filesByName, filename) ? filesByName[filename] : undefined;
        }
        function getDiagnostics(sourceFile) {
            return sourceFile ? ts.filter(errors, function (e) { return e.file === sourceFile; }) : errors;
        }
        function getGlobalDiagnostics() {
            return ts.filter(errors, function (e) { return !e.file; });
        }
        function hasExtension(filename) {
            return ts.getBaseFilename(filename).indexOf(".") >= 0;
        }
        function processRootFile(filename, isDefaultLib) {
            processSourceFile(ts.normalizePath(filename), isDefaultLib);
        }
        function processSourceFile(filename, isDefaultLib, refFile, refPos, refEnd) {
            if (refEnd !== undefined && refPos !== undefined) {
                var start = refPos;
                var length = refEnd - refPos;
            }
            var diagnostic;
            if (hasExtension(filename)) {
                if (!ts.fileExtensionIs(filename, ".ts")) {
                    diagnostic = ts.Diagnostics.File_0_must_have_extension_ts_or_d_ts;
                }
                else if (!findSourceFile(filename, isDefaultLib, refFile, refPos, refEnd)) {
                    diagnostic = ts.Diagnostics.File_0_not_found;
                }
            }
            else {
                if (!(findSourceFile(filename + ".ts", isDefaultLib, refFile, refPos, refEnd) || findSourceFile(filename + ".d.ts", isDefaultLib, refFile, refPos, refEnd))) {
                    diagnostic = ts.Diagnostics.File_0_not_found;
                    filename += ".ts";
                }
            }
            if (diagnostic) {
                if (refFile) {
                    errors.push(ts.createFileDiagnostic(refFile, start, length, diagnostic, filename));
                }
                else {
                    errors.push(ts.createCompilerDiagnostic(diagnostic, filename));
                }
            }
        }
        // Get source file from normalized filename
        function findSourceFile(filename, isDefaultLib, refFile, refStart, refLength) {
            var canonicalName = host.getCanonicalFileName(filename);
            if (ts.hasProperty(filesByName, canonicalName)) {
                // We've already looked for this file, use cached result
                var file = filesByName[canonicalName];
                if (file && host.useCaseSensitiveFileNames() && canonicalName !== file.filename) {
                    errors.push(ts.createFileDiagnostic(refFile, refStart, refLength, ts.Diagnostics.Filename_0_differs_from_already_included_filename_1_only_in_casing, filename, file.filename));
                }
            }
            else {
                // We haven't looked for this file, do so now and cache result
                var file = filesByName[canonicalName] = host.getSourceFile(filename, options.target, function (hostErrorMessage) {
                    errors.push(ts.createFileDiagnostic(refFile, refStart, refLength, ts.Diagnostics.Cannot_read_file_0_Colon_1, filename, hostErrorMessage));
                });
                if (file) {
                    seenNoDefaultLib = seenNoDefaultLib || file.hasNoDefaultLib;
                    if (!options.noResolve) {
                        var basePath = ts.getDirectoryPath(filename);
                        processReferencedFiles(file, basePath);
                        processImportedModules(file, basePath);
                    }
                    if (isDefaultLib) {
                        files.unshift(file);
                    }
                    else {
                        files.push(file);
                    }
                    ts.forEach(file.syntacticErrors, function (e) {
                        errors.push(e);
                    });
                }
            }
            return file;
        }
        function processReferencedFiles(file, basePath) {
            ts.forEach(file.referencedFiles, function (ref) {
                processSourceFile(ts.normalizePath(ts.combinePaths(basePath, ref.filename)), false, file, ref.pos, ref.end);
            });
        }
        function processImportedModules(file, basePath) {
            ts.forEach(file.statements, function (node) {
                if (node.kind === 179 /* ImportDeclaration */ && node.externalModuleName) {
                    var nameLiteral = node.externalModuleName;
                    var moduleName = nameLiteral.text;
                    if (moduleName) {
                        var searchPath = basePath;
                        while (true) {
                            var searchName = ts.normalizePath(ts.combinePaths(searchPath, moduleName));
                            if (findModuleSourceFile(searchName + ".ts", nameLiteral) || findModuleSourceFile(searchName + ".d.ts", nameLiteral)) {
                                break;
                            }
                            var parentPath = ts.getDirectoryPath(searchPath);
                            if (parentPath === searchPath) {
                                break;
                            }
                            searchPath = parentPath;
                        }
                    }
                }
                else if (node.kind === 177 /* ModuleDeclaration */ && node.name.kind === 7 /* StringLiteral */ && (node.flags & 2 /* Ambient */ || file.flags & 1024 /* DeclarationFile */)) {
                    // TypeScript 1.0 spec (April 2014): 12.1.6
                    // An AmbientExternalModuleDeclaration declares an external module. 
                    // This type of declaration is permitted only in the global module.
                    // The StringLiteral must specify a top - level external module name.
                    // Relative external module names are not permitted
                    forEachChild(node.body, function (node) {
                        if (node.kind === 179 /* ImportDeclaration */ && node.externalModuleName) {
                            var nameLiteral = node.externalModuleName;
                            var moduleName = nameLiteral.text;
                            if (moduleName) {
                                // TypeScript 1.0 spec (April 2014): 12.1.6
                                // An ExternalImportDeclaration in anAmbientExternalModuleDeclaration may reference other external modules 
                                // only through top - level external module names. Relative external module names are not permitted.
                                var searchName = ts.normalizePath(ts.combinePaths(basePath, moduleName));
                                var tsFile = findModuleSourceFile(searchName + ".ts", nameLiteral);
                                if (!tsFile) {
                                    findModuleSourceFile(searchName + ".d.ts", nameLiteral);
                                }
                            }
                        }
                    });
                }
            });
            function findModuleSourceFile(filename, nameLiteral) {
                return findSourceFile(filename, false, file, nameLiteral.pos, nameLiteral.end - nameLiteral.pos);
            }
        }
        function verifyCompilerOptions() {
            if (!options.sourceMap && (options.mapRoot || options.sourceRoot)) {
                // Error to specify --mapRoot or --sourceRoot without mapSourceFiles
                if (options.mapRoot) {
                    errors.push(ts.createCompilerDiagnostic(ts.Diagnostics.Option_mapRoot_cannot_be_specified_without_specifying_sourcemap_option));
                }
                if (options.sourceRoot) {
                    errors.push(ts.createCompilerDiagnostic(ts.Diagnostics.Option_sourceRoot_cannot_be_specified_without_specifying_sourcemap_option));
                }
                return;
            }
            var firstExternalModule = ts.forEach(files, function (f) { return isExternalModule(f) ? f : undefined; });
            if (firstExternalModule && options.module === 0 /* None */) {
                // We cannot use createDiagnosticFromNode because nodes do not have parents yet
                var externalModuleErrorSpan = getErrorSpanForNode(firstExternalModule.externalModuleIndicator);
                var errorStart = ts.skipTrivia(firstExternalModule.text, externalModuleErrorSpan.pos);
                var errorLength = externalModuleErrorSpan.end - errorStart;
                errors.push(ts.createFileDiagnostic(firstExternalModule, errorStart, errorLength, ts.Diagnostics.Cannot_compile_external_modules_unless_the_module_flag_is_provided));
            }
            // there has to be common source directory if user specified --outdir || --sourcRoot
            // if user specified --mapRoot, there needs to be common source directory if there would be multiple files being emitted
            if (options.outDir || options.sourceRoot || (options.mapRoot && (!options.out || firstExternalModule !== undefined))) {
                var commonPathComponents;
                ts.forEach(files, function (sourceFile) {
                    // Each file contributes into common source file path
                    if (!(sourceFile.flags & 1024 /* DeclarationFile */) && !ts.fileExtensionIs(sourceFile.filename, ".js")) {
                        var sourcePathComponents = ts.getNormalizedPathComponents(sourceFile.filename, host.getCurrentDirectory());
                        sourcePathComponents.pop(); // FileName is not part of directory
                        if (commonPathComponents) {
                            for (var i = 0; i < Math.min(commonPathComponents.length, sourcePathComponents.length); i++) {
                                if (commonPathComponents[i] !== sourcePathComponents[i]) {
                                    if (i === 0) {
                                        errors.push(ts.createCompilerDiagnostic(ts.Diagnostics.Cannot_find_the_common_subdirectory_path_for_the_input_files));
                                        return;
                                    }
                                    // New common path found that is 0 -> i-1
                                    commonPathComponents.length = i;
                                    break;
                                }
                            }
                            // If the fileComponent path completely matched and less than already found update the length
                            if (sourcePathComponents.length < commonPathComponents.length) {
                                commonPathComponents.length = sourcePathComponents.length;
                            }
                        }
                        else {
                            // first file
                            commonPathComponents = sourcePathComponents;
                        }
                    }
                });
                commonSourceDirectory = ts.getNormalizedPathFromPathComponents(commonPathComponents);
                if (commonSourceDirectory) {
                    // Make sure directory path ends with directory separator so this string can directly 
                    // used to replace with "" to get the relative path of the source file and the relative path doesn't
                    // start with / making it rooted path
                    commonSourceDirectory += ts.directorySeparator;
                }
            }
        }
    }
    ts.createProgram = createProgram;
})(ts || (ts = {}));
/// <reference path="types.ts"/>
/// <reference path="core.ts"/>
/// <reference path="scanner.ts"/>
/// <reference path="parser.ts"/>
var ts;
(function (ts) {
    function isInstantiated(node) {
        // A module is uninstantiated if it contains only 
        // 1. interface declarations
        if (node.kind === 175 /* InterfaceDeclaration */) {
            return false;
        }
        else if (node.kind === 179 /* ImportDeclaration */ && !(node.flags & 1 /* Export */)) {
            return false;
        }
        else if (node.kind === 178 /* ModuleBlock */ && !ts.forEachChild(node, isInstantiated)) {
            return false;
        }
        else if (node.kind === 177 /* ModuleDeclaration */ && !isInstantiated(node.body)) {
            return false;
        }
        else {
            return true;
        }
    }
    ts.isInstantiated = isInstantiated;
    function bindSourceFile(file) {
        var parent;
        var container;
        var lastContainer;
        var symbolCount = 0;
        var Symbol = ts.objectAllocator.getSymbolConstructor();
        if (!file.locals) {
            file.locals = {};
            container = file;
            bind(file);
            file.symbolCount = symbolCount;
        }
        function createSymbol(flags, name) {
            symbolCount++;
            return new Symbol(flags, name);
        }
        function addDeclarationToSymbol(symbol, node, symbolKind) {
            symbol.flags |= symbolKind;
            if (!symbol.declarations)
                symbol.declarations = [];
            symbol.declarations.push(node);
            if (symbolKind & ts.SymbolFlags.HasExports && !symbol.exports)
                symbol.exports = {};
            if (symbolKind & ts.SymbolFlags.HasMembers && !symbol.members)
                symbol.members = {};
            node.symbol = symbol;
            if (symbolKind & ts.SymbolFlags.Value && !symbol.valueDeclaration)
                symbol.valueDeclaration = node;
        }
        function getDeclarationName(node) {
            if (node.name) {
                if (node.kind === 177 /* ModuleDeclaration */ && node.name.kind === 7 /* StringLiteral */) {
                    return '"' + node.name.text + '"';
                }
                return node.name.text;
            }
            switch (node.kind) {
                case 121 /* Constructor */:
                    return "__constructor";
                case 124 /* CallSignature */:
                    return "__call";
                case 125 /* ConstructSignature */:
                    return "__new";
                case 126 /* IndexSignature */:
                    return "__index";
            }
        }
        function getDisplayName(node) {
            return node.name ? ts.identifierToString(node.name) : getDeclarationName(node);
        }
        function declareSymbol(symbols, parent, node, includes, excludes) {
            var name = getDeclarationName(node);
            if (name !== undefined) {
                var symbol = ts.hasProperty(symbols, name) ? symbols[name] : (symbols[name] = createSymbol(0, name));
                if (symbol.flags & excludes) {
                    if (node.name) {
                        node.name.parent = node;
                    }
                    file.semanticErrors.push(ts.createDiagnosticForNode(node.name ? node.name : node, ts.Diagnostics.Duplicate_identifier_0, getDisplayName(node)));
                    symbol = createSymbol(0, name);
                }
            }
            else {
                symbol = createSymbol(0, "__missing");
            }
            addDeclarationToSymbol(symbol, node, includes);
            symbol.parent = parent;
            if (node.kind === 174 /* ClassDeclaration */ && symbol.exports) {
                // TypeScript 1.0 spec (April 2014): 8.4
                // Every class automatically contains a static property member named 'prototype', 
                // the type of which is an instantiation of the class type with type Any supplied as a type argument for each type parameter.
                // It is an error to explicitly declare a static property member with the name 'prototype'.
                var prototypeSymbol = createSymbol(2 /* Property */ | 67108864 /* Prototype */, "prototype");
                if (ts.hasProperty(symbol.exports, prototypeSymbol.name)) {
                    if (node.name) {
                        node.name.parent = node;
                    }
                    file.semanticErrors.push(ts.createDiagnosticForNode(symbol.exports[prototypeSymbol.name].declarations[0], ts.Diagnostics.Duplicate_identifier_0, prototypeSymbol.name));
                }
                symbol.exports[prototypeSymbol.name] = prototypeSymbol;
                prototypeSymbol.parent = symbol;
            }
            return symbol;
        }
        function isAmbientContext(node) {
            while (node) {
                if (node.flags & 2 /* Ambient */)
                    return true;
                node = node.parent;
            }
            return false;
        }
        function declareModuleMember(node, symbolKind, symbolExcludes) {
            // Exported module members are given 2 symbols: A local symbol that is classified with an ExportValue,
            // ExportType, or ExportContainer flag, and an associated export symbol with all the correct flags set
            // on it. There are 2 main reasons:
            //
            //   1. We treat locals and exports of the same name as mutually exclusive within a container. 
            //      That means the binder will issue a Duplicate Identifier error if you mix locals and exports
            //      with the same name in the same container.
            //      TODO: Make this a more specific error and decouple it from the exclusion logic.
            //   2. When we checkIdentifier in the checker, we set its resolved symbol to the local symbol,
            //      but return the export symbol (by calling getExportSymbolOfValueSymbolIfExported). That way
            //      when the emitter comes back to it, it knows not to qualify the name if it was found in a containing scope.
            var exportKind = 0;
            if (symbolKind & ts.SymbolFlags.Value) {
                exportKind |= 524288 /* ExportValue */;
            }
            if (symbolKind & ts.SymbolFlags.Type) {
                exportKind |= 1048576 /* ExportType */;
            }
            if (symbolKind & ts.SymbolFlags.Namespace) {
                exportKind |= 2097152 /* ExportNamespace */;
            }
            if (node.flags & 1 /* Export */ || (node.kind !== 179 /* ImportDeclaration */ && isAmbientContext(container))) {
                if (exportKind) {
                    var local = declareSymbol(container.locals, undefined, node, exportKind, symbolExcludes);
                    local.exportSymbol = declareSymbol(container.symbol.exports, container.symbol, node, symbolKind, symbolExcludes);
                    node.localSymbol = local;
                }
                else {
                    declareSymbol(container.symbol.exports, container.symbol, node, symbolKind, symbolExcludes);
                }
            }
            else {
                declareSymbol(container.locals, undefined, node, symbolKind, symbolExcludes);
            }
        }
        // All container nodes are kept on a linked list in declaration order. This list is used by the getLocalNameOfContainer function
        // in the type checker to validate that the local name used for a container is unique.
        function bindChildren(node, symbolKind) {
            if (symbolKind & ts.SymbolFlags.HasLocals) {
                node.locals = {};
            }
            var saveParent = parent;
            var saveContainer = container;
            parent = node;
            if (symbolKind & ts.SymbolFlags.IsContainer) {
                container = node;
                // If container is not on container list, add it to the list
                if (lastContainer !== container && !container.nextContainer) {
                    if (lastContainer) {
                        lastContainer.nextContainer = container;
                    }
                    lastContainer = container;
                }
            }
            ts.forEachChild(node, bind);
            container = saveContainer;
            parent = saveParent;
        }
        function bindDeclaration(node, symbolKind, symbolExcludes) {
            switch (container.kind) {
                case 177 /* ModuleDeclaration */:
                    declareModuleMember(node, symbolKind, symbolExcludes);
                    break;
                case 182 /* SourceFile */:
                    if (ts.isExternalModule(container)) {
                        declareModuleMember(node, symbolKind, symbolExcludes);
                        break;
                    }
                case 124 /* CallSignature */:
                case 125 /* ConstructSignature */:
                case 126 /* IndexSignature */:
                case 120 /* Method */:
                case 121 /* Constructor */:
                case 122 /* GetAccessor */:
                case 123 /* SetAccessor */:
                case 172 /* FunctionDeclaration */:
                case 141 /* FunctionExpression */:
                case 142 /* ArrowFunction */:
                    declareSymbol(container.locals, undefined, node, symbolKind, symbolExcludes);
                    break;
                case 174 /* ClassDeclaration */:
                    if (node.flags & 128 /* Static */) {
                        declareSymbol(container.symbol.exports, container.symbol, node, symbolKind, symbolExcludes);
                        break;
                    }
                case 129 /* TypeLiteral */:
                case 133 /* ObjectLiteral */:
                case 175 /* InterfaceDeclaration */:
                    declareSymbol(container.symbol.members, container.symbol, node, symbolKind, symbolExcludes);
                    break;
                case 176 /* EnumDeclaration */:
                    declareSymbol(container.symbol.exports, container.symbol, node, symbolKind, symbolExcludes);
                    break;
            }
            bindChildren(node, symbolKind);
        }
        function bindConstructorDeclaration(node) {
            bindDeclaration(node, 4096 /* Constructor */, 0);
            ts.forEach(node.parameters, function (p) {
                if (p.flags & (16 /* Public */ | 32 /* Private */ | 64 /* Protected */)) {
                    bindDeclaration(p, 2 /* Property */, ts.SymbolFlags.PropertyExcludes);
                }
            });
        }
        function bindModuleDeclaration(node) {
            if (node.name.kind === 7 /* StringLiteral */) {
                bindDeclaration(node, 128 /* ValueModule */, ts.SymbolFlags.ValueModuleExcludes);
            }
            else if (isInstantiated(node)) {
                bindDeclaration(node, 128 /* ValueModule */, ts.SymbolFlags.ValueModuleExcludes);
            }
            else {
                bindDeclaration(node, 256 /* NamespaceModule */, 0 /* NamespaceModuleExcludes */);
            }
        }
        function bindAnonymousDeclaration(node, symbolKind, name) {
            var symbol = createSymbol(symbolKind, name);
            addDeclarationToSymbol(symbol, node, symbolKind);
            bindChildren(node, symbolKind);
        }
        function bindCatchVariableDeclaration(node) {
            var symbol = createSymbol(1 /* Variable */, node.variable.text || "__missing");
            addDeclarationToSymbol(symbol, node, 1 /* Variable */);
            var saveParent = parent;
            parent = node;
            ts.forEachChild(node, bind);
            parent = saveParent;
        }
        function bind(node) {
            node.parent = parent;
            switch (node.kind) {
                case 117 /* TypeParameter */:
                    bindDeclaration(node, 262144 /* TypeParameter */, ts.SymbolFlags.TypeParameterExcludes);
                    break;
                case 118 /* Parameter */:
                    bindDeclaration(node, 1 /* Variable */, ts.SymbolFlags.ParameterExcludes);
                    break;
                case 171 /* VariableDeclaration */:
                    bindDeclaration(node, 1 /* Variable */, ts.SymbolFlags.VariableExcludes);
                    break;
                case 119 /* Property */:
                case 134 /* PropertyAssignment */:
                    bindDeclaration(node, 2 /* Property */, ts.SymbolFlags.PropertyExcludes);
                    break;
                case 181 /* EnumMember */:
                    bindDeclaration(node, 4 /* EnumMember */, ts.SymbolFlags.EnumMemberExcludes);
                    break;
                case 124 /* CallSignature */:
                    bindDeclaration(node, 32768 /* CallSignature */, 0);
                    break;
                case 120 /* Method */:
                    bindDeclaration(node, 2048 /* Method */, ts.SymbolFlags.MethodExcludes);
                    break;
                case 125 /* ConstructSignature */:
                    bindDeclaration(node, 65536 /* ConstructSignature */, 0);
                    break;
                case 126 /* IndexSignature */:
                    bindDeclaration(node, 131072 /* IndexSignature */, 0);
                    break;
                case 172 /* FunctionDeclaration */:
                    bindDeclaration(node, 8 /* Function */, ts.SymbolFlags.FunctionExcludes);
                    break;
                case 121 /* Constructor */:
                    bindConstructorDeclaration(node);
                    break;
                case 122 /* GetAccessor */:
                    bindDeclaration(node, 8192 /* GetAccessor */, ts.SymbolFlags.GetAccessorExcludes);
                    break;
                case 123 /* SetAccessor */:
                    bindDeclaration(node, 16384 /* SetAccessor */, ts.SymbolFlags.SetAccessorExcludes);
                    break;
                case 129 /* TypeLiteral */:
                    bindAnonymousDeclaration(node, 512 /* TypeLiteral */, "__type");
                    break;
                case 133 /* ObjectLiteral */:
                    bindAnonymousDeclaration(node, 1024 /* ObjectLiteral */, "__object");
                    break;
                case 141 /* FunctionExpression */:
                case 142 /* ArrowFunction */:
                    bindAnonymousDeclaration(node, 8 /* Function */, "__function");
                    break;
                case 168 /* CatchBlock */:
                    bindCatchVariableDeclaration(node);
                    break;
                case 174 /* ClassDeclaration */:
                    bindDeclaration(node, 16 /* Class */, ts.SymbolFlags.ClassExcludes);
                    break;
                case 175 /* InterfaceDeclaration */:
                    bindDeclaration(node, 32 /* Interface */, ts.SymbolFlags.InterfaceExcludes);
                    break;
                case 176 /* EnumDeclaration */:
                    bindDeclaration(node, 64 /* Enum */, ts.SymbolFlags.EnumExcludes);
                    break;
                case 177 /* ModuleDeclaration */:
                    bindModuleDeclaration(node);
                    break;
                case 179 /* ImportDeclaration */:
                    bindDeclaration(node, 4194304 /* Import */, ts.SymbolFlags.ImportExcludes);
                    break;
                case 182 /* SourceFile */:
                    if (ts.isExternalModule(node)) {
                        bindAnonymousDeclaration(node, 128 /* ValueModule */, '"' + ts.getModuleNameFromFilename(node.filename) + '"');
                        break;
                    }
                default:
                    var saveParent = parent;
                    parent = node;
                    ts.forEachChild(node, bind);
                    parent = saveParent;
            }
        }
    }
    ts.bindSourceFile = bindSourceFile;
})(ts || (ts = {}));
/// <reference path="types.ts"/>
/// <reference path="core.ts"/>
/// <reference path="scanner.ts"/>
/// <reference path="parser.ts"/>
var ts;
(function (ts) {
    var indentStrings = ["", "    "];
    function getIndentString(level) {
        if (indentStrings[level] === undefined) {
            indentStrings[level] = getIndentString(level - 1) + indentStrings[1];
        }
        return indentStrings[level];
    }
    function getIndentSize() {
        return indentStrings[1].length;
    }
    function shouldEmitToOwnFile(sourceFile, compilerOptions) {
        if (!(sourceFile.flags & 1024 /* DeclarationFile */)) {
            if ((ts.isExternalModule(sourceFile) || !compilerOptions.out) && !ts.fileExtensionIs(sourceFile.filename, ".js")) {
                return true;
            }
            return false;
        }
        return false;
    }
    ts.shouldEmitToOwnFile = shouldEmitToOwnFile;
    function isExternalModuleOrDeclarationFile(sourceFile) {
        return ts.isExternalModule(sourceFile) || (sourceFile.flags & 1024 /* DeclarationFile */) !== 0;
    }
    ts.isExternalModuleOrDeclarationFile = isExternalModuleOrDeclarationFile;
    // targetSourceFile is when users only want one file in entire project to be emitted. This is used in compilerOnSave feature
    function emitFiles(resolver, targetSourceFile) {
        var program = resolver.getProgram();
        var compilerHost = program.getCompilerHost();
        var compilerOptions = program.getCompilerOptions();
        var sourceMapDataList = compilerOptions.sourceMap ? [] : undefined;
        var diagnostics = [];
        var newLine = program.getCompilerHost().getNewLine();
        function getSourceFilePathInNewDir(newDirPath, sourceFile) {
            var sourceFilePath = ts.getNormalizedPathFromPathComponents(ts.getNormalizedPathComponents(sourceFile.filename, compilerHost.getCurrentDirectory()));
            sourceFilePath = sourceFilePath.replace(program.getCommonSourceDirectory(), "");
            return ts.combinePaths(newDirPath, sourceFilePath);
        }
        function getOwnEmitOutputFilePath(sourceFile, extension) {
            if (compilerOptions.outDir) {
                var emitOutputFilePathWithoutExtension = ts.getModuleNameFromFilename(getSourceFilePathInNewDir(compilerOptions.outDir, sourceFile));
            }
            else {
                var emitOutputFilePathWithoutExtension = ts.getModuleNameFromFilename(sourceFile.filename);
            }
            return emitOutputFilePathWithoutExtension + extension;
        }
        function getFirstConstructorWithBody(node) {
            return ts.forEach(node.members, function (member) {
                if (member.kind === 121 /* Constructor */ && member.body) {
                    return member;
                }
            });
        }
        function getAllAccessorDeclarations(node, accessor) {
            var firstAccessor;
            var getAccessor;
            var setAccessor;
            ts.forEach(node.members, function (member) {
                if ((member.kind === 122 /* GetAccessor */ || member.kind === 123 /* SetAccessor */) && member.name.text === accessor.name.text && (member.flags & 128 /* Static */) === (accessor.flags & 128 /* Static */)) {
                    if (!firstAccessor) {
                        firstAccessor = member;
                    }
                    if (member.kind === 122 /* GetAccessor */ && !getAccessor) {
                        getAccessor = member;
                    }
                    if (member.kind === 123 /* SetAccessor */ && !setAccessor) {
                        setAccessor = member;
                    }
                }
            });
            return {
                firstAccessor: firstAccessor,
                getAccessor: getAccessor,
                setAccessor: setAccessor
            };
        }
        function createTextWriter(trackSymbol) {
            var output = "";
            var indent = 0;
            var lineStart = true;
            var lineCount = 0;
            var linePos = 0;
            function write(s) {
                if (s && s.length) {
                    if (lineStart) {
                        output += getIndentString(indent);
                        lineStart = false;
                    }
                    output += s;
                }
            }
            function rawWrite(s) {
                if (s !== undefined) {
                    if (lineStart) {
                        lineStart = false;
                    }
                    output += s;
                }
            }
            function writeLiteral(s) {
                if (s && s.length) {
                    write(s);
                    var lineStartsOfS = ts.getLineStarts(s);
                    if (lineStartsOfS.length > 1) {
                        lineCount = lineCount + lineStartsOfS.length - 1;
                        linePos = output.length - s.length + lineStartsOfS[lineStartsOfS.length - 1];
                    }
                }
            }
            function writeLine() {
                if (!lineStart) {
                    output += newLine;
                    lineCount++;
                    linePos = output.length;
                    lineStart = true;
                }
            }
            return {
                write: write,
                trackSymbol: trackSymbol,
                rawWrite: rawWrite,
                writeLiteral: writeLiteral,
                writeLine: writeLine,
                increaseIndent: function () { return indent++; },
                decreaseIndent: function () { return indent--; },
                getIndent: function () { return indent; },
                getTextPos: function () { return output.length; },
                getLine: function () { return lineCount + 1; },
                getColumn: function () { return lineStart ? indent * getIndentSize() + 1 : output.length - linePos + 1; },
                getText: function () { return output; }
            };
        }
        // Get source text of node in the current source file. Unlike getSourceTextOfNode this function
        // doesn't walk the parent chain to find the containing source file, rather it assumes the node is
        // in the source file currently being processed.
        var currentSourceFile;
        function getSourceTextOfLocalNode(node) {
            var text = currentSourceFile.text;
            return text.substring(ts.skipTrivia(text, node.pos), node.end);
        }
        function getLineOfLocalPosition(pos) {
            return currentSourceFile.getLineAndCharacterFromPosition(pos).line;
        }
        function writeFile(filename, data, writeByteOrderMark) {
            compilerHost.writeFile(filename, data, writeByteOrderMark, function (hostErrorMessage) {
                diagnostics.push(ts.createCompilerDiagnostic(ts.Diagnostics.Could_not_write_file_0_Colon_1, filename, hostErrorMessage));
            });
        }
        function emitComments(comments, trailingSeparator, writer, writeComment) {
            var emitLeadingSpace = !trailingSeparator;
            ts.forEach(comments, function (comment) {
                if (emitLeadingSpace) {
                    writer.write(" ");
                    emitLeadingSpace = false;
                }
                writeComment(comment, writer);
                if (comment.hasTrailingNewLine) {
                    writer.writeLine();
                }
                else if (trailingSeparator) {
                    writer.write(" ");
                }
                else {
                    // Emit leading space to separate comment during next comment emit
                    emitLeadingSpace = true;
                }
            });
        }
        function emitNewLineBeforeLeadingComments(node, leadingComments, writer) {
            // If the leading comments start on different line than the start of node, write new line
            if (leadingComments && leadingComments.length && node.pos !== leadingComments[0].pos && getLineOfLocalPosition(node.pos) !== getLineOfLocalPosition(leadingComments[0].pos)) {
                writer.writeLine();
            }
        }
        function writeCommentRange(comment, writer) {
            if (currentSourceFile.text.charCodeAt(comment.pos + 1) === 42 /* asterisk */) {
                var firstCommentLineAndCharacter = currentSourceFile.getLineAndCharacterFromPosition(comment.pos);
                var firstCommentLineIndent;
                for (var pos = comment.pos, currentLine = firstCommentLineAndCharacter.line; pos < comment.end; currentLine++) {
                    var nextLineStart = currentSourceFile.getPositionFromLineAndCharacter(currentLine + 1, 1);
                    if (pos !== comment.pos) {
                        // If we are not emitting first line, we need to write the spaces to adjust the alignment
                        if (firstCommentLineIndent === undefined) {
                            firstCommentLineIndent = calculateIndent(currentSourceFile.getPositionFromLineAndCharacter(firstCommentLineAndCharacter.line, 1), comment.pos);
                        }
                        // These are number of spaces writer is going to write at current indent
                        var currentWriterIndentSpacing = writer.getIndent() * getIndentSize();
                        // Number of spaces we want to be writing
                        // eg: Assume writer indent
                        // module m {
                        //         /* starts at character 9 this is line 1
                        //    * starts at character pos 4 line                        --1  = 8 - 8 + 3
                        //   More left indented comment */                            --2  = 8 - 8 + 2
                        //     class c { }
                        // }
                        // module m {
                        //     /* this is line 1 -- Assume current writer indent 8
                        //      * line                                                --3 = 8 - 4 + 5 
                        //            More right indented comment */                  --4 = 8 - 4 + 11
                        //     class c { }
                        // }
                        var spacesToEmit = currentWriterIndentSpacing - firstCommentLineIndent + calculateIndent(pos, nextLineStart);
                        if (spacesToEmit > 0) {
                            var numberOfSingleSpacesToEmit = spacesToEmit % getIndentSize();
                            var indentSizeSpaceString = getIndentString((spacesToEmit - numberOfSingleSpacesToEmit) / getIndentSize());
                            // Write indent size string ( in eg 1: = "", 2: "" , 3: string with 8 spaces 4: string with 12 spaces
                            writer.rawWrite(indentSizeSpaceString);
                            while (numberOfSingleSpacesToEmit) {
                                writer.rawWrite(" ");
                                numberOfSingleSpacesToEmit--;
                            }
                        }
                        else {
                            // No spaces to emit write empty string
                            writer.rawWrite("");
                        }
                    }
                    // Write the comment line text
                    writeTrimmedCurrentLine(pos, nextLineStart);
                    pos = nextLineStart;
                }
            }
            else {
                // Single line comment of style //....
                writer.write(currentSourceFile.text.substring(comment.pos, comment.end));
            }
            function writeTrimmedCurrentLine(pos, nextLineStart) {
                var end = Math.min(comment.end, nextLineStart - 1);
                var currentLineText = currentSourceFile.text.substring(pos, end).replace(/^\s+|\s+$/g, '');
                if (currentLineText) {
                    // trimmed forward and ending spaces text
                    writer.write(currentLineText);
                    if (end !== comment.end) {
                        writer.writeLine();
                    }
                }
                else {
                    // Empty string - make sure we write empty line
                    writer.writeLiteral(newLine);
                }
            }
            function calculateIndent(pos, end) {
                var currentLineIndent = 0;
                for (; pos < end && ts.isWhiteSpace(currentSourceFile.text.charCodeAt(pos)); pos++) {
                    if (currentSourceFile.text.charCodeAt(pos) === 9 /* tab */) {
                        // Tabs = TabSize = indent size and go to next tabStop
                        currentLineIndent += getIndentSize() - (currentLineIndent % getIndentSize());
                    }
                    else {
                        // Single space
                        currentLineIndent++;
                    }
                }
                return currentLineIndent;
            }
        }
        function emitJavaScript(jsFilePath, root) {
            var writer = createTextWriter(trackSymbol);
            var write = writer.write;
            var writeLine = writer.writeLine;
            var increaseIndent = writer.increaseIndent;
            var decreaseIndent = writer.decreaseIndent;
            var extendsEmitted = false;
            /** write emitted output to disk*/
            var writeEmittedFiles = writeJavaScriptFile;
            /** Emit leading comments of the node */
            var emitLeadingComments = compilerOptions.removeComments ? function (node) {
            } : emitLeadingDeclarationComments;
            /** Emit Trailing comments of the node */
            var emitTrailingComments = compilerOptions.removeComments ? function (node) {
            } : emitTrailingDeclarationComments;
            var emitLeadingCommentsOfPosition = compilerOptions.removeComments ? function (pos) {
            } : emitLeadingCommentsOfLocalPosition;
            var detachedCommentsInfo;
            /** Emit detached comments of the node */
            var emitDetachedComments = compilerOptions.removeComments ? function (node) {
            } : emitDetachedCommentsAtPosition;
            /** Emits /// or pinned which is comment starting with /*! comments */
            var emitPinnedOrTripleSlashComments = compilerOptions.removeComments ? function (node) {
            } : emitPinnedOrTripleSlashCommentsOfNode;
            var writeComment = writeCommentRange;
            /** Emit a node */
            var emit = emitNode;
            /** Called just before starting emit of a node */
            var emitStart = function (node) {
            };
            /** Called once the emit of the node is done */
            var emitEnd = function (node) {
            };
            /** Emit the text for the given token that comes after startPos
              * This by default writes the text provided with the given tokenKind
              * but if optional emitFn callback is provided the text is emitted using the callback instead of default text
              * @param tokenKind the kind of the token to search and emit
              * @param startPos the position in the source to start searching for the token
              * @param emitFn if given will be invoked to emit the text instead of actual token emit */
            var emitToken = emitTokenText;
            /** Called to before starting the lexical scopes as in function/class in the emitted code because of node
              * @param scopeDeclaration node that starts the lexical scope
              * @param scopeName Optional name of this scope instead of deducing one from the declaration node */
            var scopeEmitStart = function (scopeDeclaration, scopeName) {
            };
            /** Called after coming out of the scope */
            var scopeEmitEnd = function () {
            };
            /** Sourcemap data that will get encoded */
            var sourceMapData;
            function trackSymbol(symbol, enclosingDeclaration, meaning) {
            }
            function initializeEmitterWithSourceMaps() {
                var sourceMapDir; // The directory in which sourcemap will be
                // Current source map file and its index in the sources list
                var sourceMapSourceIndex = -1;
                // Names and its index map
                var sourceMapNameIndexMap = {};
                var sourceMapNameIndices = [];
                function getSourceMapNameIndex() {
                    return sourceMapNameIndices.length ? sourceMapNameIndices[sourceMapNameIndices.length - 1] : -1;
                }
                // Last recorded and encoded spans
                var lastRecordedSourceMapSpan;
                var lastEncodedSourceMapSpan = {
                    emittedLine: 1,
                    emittedColumn: 1,
                    sourceLine: 1,
                    sourceColumn: 1,
                    sourceIndex: 0
                };
                var lastEncodedNameIndex = 0;
                // Encoding for sourcemap span
                function encodeLastRecordedSourceMapSpan() {
                    if (!lastRecordedSourceMapSpan || lastRecordedSourceMapSpan === lastEncodedSourceMapSpan) {
                        return;
                    }
                    var prevEncodedEmittedColumn = lastEncodedSourceMapSpan.emittedColumn;
                    // Line/Comma delimiters
                    if (lastEncodedSourceMapSpan.emittedLine == lastRecordedSourceMapSpan.emittedLine) {
                        // Emit comma to separate the entry
                        if (sourceMapData.sourceMapMappings) {
                            sourceMapData.sourceMapMappings += ",";
                        }
                    }
                    else {
                        for (var encodedLine = lastEncodedSourceMapSpan.emittedLine; encodedLine < lastRecordedSourceMapSpan.emittedLine; encodedLine++) {
                            sourceMapData.sourceMapMappings += ";";
                        }
                        prevEncodedEmittedColumn = 1;
                    }
                    // 1. Relative Column 0 based
                    sourceMapData.sourceMapMappings += base64VLQFormatEncode(lastRecordedSourceMapSpan.emittedColumn - prevEncodedEmittedColumn);
                    // 2. Relative sourceIndex 
                    sourceMapData.sourceMapMappings += base64VLQFormatEncode(lastRecordedSourceMapSpan.sourceIndex - lastEncodedSourceMapSpan.sourceIndex);
                    // 3. Relative sourceLine 0 based
                    sourceMapData.sourceMapMappings += base64VLQFormatEncode(lastRecordedSourceMapSpan.sourceLine - lastEncodedSourceMapSpan.sourceLine);
                    // 4. Relative sourceColumn 0 based 
                    sourceMapData.sourceMapMappings += base64VLQFormatEncode(lastRecordedSourceMapSpan.sourceColumn - lastEncodedSourceMapSpan.sourceColumn);
                    // 5. Relative namePosition 0 based
                    if (lastRecordedSourceMapSpan.nameIndex >= 0) {
                        sourceMapData.sourceMapMappings += base64VLQFormatEncode(lastRecordedSourceMapSpan.nameIndex - lastEncodedNameIndex);
                        lastEncodedNameIndex = lastRecordedSourceMapSpan.nameIndex;
                    }
                    lastEncodedSourceMapSpan = lastRecordedSourceMapSpan;
                    sourceMapData.sourceMapDecodedMappings.push(lastEncodedSourceMapSpan);
                    function base64VLQFormatEncode(inValue) {
                        function base64FormatEncode(inValue) {
                            if (inValue < 64) {
                                return 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.charAt(inValue);
                            }
                            throw TypeError(inValue + ": not a 64 based value");
                        }
                        // Add a new least significant bit that has the sign of the value.
                        // if negative number the least significant bit that gets added to the number has value 1
                        // else least significant bit value that gets added is 0
                        // eg. -1 changes to binary : 01 [1] => 3
                        //     +1 changes to binary : 01 [0] => 2
                        if (inValue < 0) {
                            inValue = ((-inValue) << 1) + 1;
                        }
                        else {
                            inValue = inValue << 1;
                        }
                        // Encode 5 bits at a time starting from least significant bits
                        var encodedStr = "";
                        do {
                            var currentDigit = inValue & 31; // 11111
                            inValue = inValue >> 5;
                            if (inValue > 0) {
                                // There are still more digits to decode, set the msb (6th bit)
                                currentDigit = currentDigit | 32;
                            }
                            encodedStr = encodedStr + base64FormatEncode(currentDigit);
                        } while (inValue > 0);
                        return encodedStr;
                    }
                }
                function recordSourceMapSpan(pos) {
                    var sourceLinePos = currentSourceFile.getLineAndCharacterFromPosition(pos);
                    var emittedLine = writer.getLine();
                    var emittedColumn = writer.getColumn();
                    // If this location wasn't recorded or the location in source is going backwards, record the span
                    if (!lastRecordedSourceMapSpan || lastRecordedSourceMapSpan.emittedLine != emittedLine || lastRecordedSourceMapSpan.emittedColumn != emittedColumn || (lastRecordedSourceMapSpan.sourceIndex === sourceMapSourceIndex && (lastRecordedSourceMapSpan.sourceLine > sourceLinePos.line || (lastRecordedSourceMapSpan.sourceLine === sourceLinePos.line && lastRecordedSourceMapSpan.sourceColumn > sourceLinePos.character)))) {
                        // Encode the last recordedSpan before assigning new
                        encodeLastRecordedSourceMapSpan();
                        // New span
                        lastRecordedSourceMapSpan = {
                            emittedLine: emittedLine,
                            emittedColumn: emittedColumn,
                            sourceLine: sourceLinePos.line,
                            sourceColumn: sourceLinePos.character,
                            nameIndex: getSourceMapNameIndex(),
                            sourceIndex: sourceMapSourceIndex
                        };
                    }
                    else {
                        // Take the new pos instead since there is no change in emittedLine and column since last location
                        lastRecordedSourceMapSpan.sourceLine = sourceLinePos.line;
                        lastRecordedSourceMapSpan.sourceColumn = sourceLinePos.character;
                        lastRecordedSourceMapSpan.sourceIndex = sourceMapSourceIndex;
                    }
                }
                function recordEmitNodeStartSpan(node) {
                    // Get the token pos after skipping to the token (ignoring the leading trivia)
                    recordSourceMapSpan(ts.skipTrivia(currentSourceFile.text, node.pos));
                }
                function recordEmitNodeEndSpan(node) {
                    recordSourceMapSpan(node.end);
                }
                function writeTextWithSpanRecord(tokenKind, startPos, emitFn) {
                    var tokenStartPos = ts.skipTrivia(currentSourceFile.text, startPos);
                    recordSourceMapSpan(tokenStartPos);
                    var tokenEndPos = emitTokenText(tokenKind, tokenStartPos, emitFn);
                    recordSourceMapSpan(tokenEndPos);
                    return tokenEndPos;
                }
                function recordNewSourceFileStart(node) {
                    // Add the file to tsFilePaths
                    // If sourceroot option: Use the relative path corresponding to the common directory path 
                    // otherwise source locations relative to map file location
                    var sourcesDirectoryPath = compilerOptions.sourceRoot ? program.getCommonSourceDirectory() : sourceMapDir;
                    sourceMapData.sourceMapSources.push(ts.getRelativePathToDirectoryOrUrl(sourcesDirectoryPath, node.filename, compilerHost.getCurrentDirectory(), true));
                    sourceMapSourceIndex = sourceMapData.sourceMapSources.length - 1;
                    // The one that can be used from program to get the actual source file
                    sourceMapData.inputSourceFileNames.push(node.filename);
                }
                function recordScopeNameOfNode(node, scopeName) {
                    function recordScopeNameIndex(scopeNameIndex) {
                        sourceMapNameIndices.push(scopeNameIndex);
                    }
                    function recordScopeNameStart(scopeName) {
                        var scopeNameIndex = -1;
                        if (scopeName) {
                            var parentIndex = getSourceMapNameIndex();
                            if (parentIndex !== -1) {
                                scopeName = sourceMapData.sourceMapNames[parentIndex] + "." + scopeName;
                            }
                            scopeNameIndex = ts.getProperty(sourceMapNameIndexMap, scopeName);
                            if (scopeNameIndex === undefined) {
                                scopeNameIndex = sourceMapData.sourceMapNames.length;
                                sourceMapData.sourceMapNames.push(scopeName);
                                sourceMapNameIndexMap[scopeName] = scopeNameIndex;
                            }
                        }
                        recordScopeNameIndex(scopeNameIndex);
                    }
                    if (scopeName) {
                        // The scope was already given a name  use it
                        recordScopeNameStart(scopeName);
                    }
                    else if (node.kind === 172 /* FunctionDeclaration */ || node.kind === 141 /* FunctionExpression */ || node.kind === 120 /* Method */ || node.kind === 122 /* GetAccessor */ || node.kind === 123 /* SetAccessor */ || node.kind === 177 /* ModuleDeclaration */ || node.kind === 174 /* ClassDeclaration */ || node.kind === 176 /* EnumDeclaration */) {
                        // Declaration and has associated name use it
                        if (node.name) {
                            scopeName = node.name.text;
                        }
                        recordScopeNameStart(scopeName);
                    }
                    else {
                        // Block just use the name from upper level scope
                        recordScopeNameIndex(getSourceMapNameIndex());
                    }
                }
                function recordScopeNameEnd() {
                    sourceMapNameIndices.pop();
                }
                ;
                function writeCommentRangeWithMap(comment, writer) {
                    recordSourceMapSpan(comment.pos);
                    writeCommentRange(comment, writer);
                    recordSourceMapSpan(comment.end);
                }
                var escapedCharsRegExp = /[\t\v\f\b\0\r\n\"\u2028\u2029\u0085]/g;
                var escapedCharsMap = {
                    "\t": "\\t",
                    "\v": "\\v",
                    "\f": "\\f",
                    "\b": "\\b",
                    "\0": "\\0",
                    "\r": "\\r",
                    "\n": "\\n",
                    "\"": "\\\"",
                    "\u2028": "\\u2028",
                    "\u2029": "\\u2029",
                    "\u0085": "\\u0085" // nextLine
                };
                function serializeSourceMapContents(version, file, sourceRoot, sources, names, mappings) {
                    if (typeof JSON !== "undefined") {
                        return JSON.stringify({
                            version: version,
                            file: file,
                            sourceRoot: sourceRoot,
                            sources: sources,
                            names: names,
                            mappings: mappings
                        });
                    }
                    return "{\"version\":" + version + ",\"file\":\"" + escapeString(file) + "\",\"sourceRoot\":\"" + escapeString(sourceRoot) + "\",\"sources\":[" + serializeStringArray(sources) + "],\"names\":[" + serializeStringArray(names) + "],\"mappings\":\"" + escapeString(mappings) + "\"}";
                    /** This does not support the full escape characters, it only supports the subset that can be used in file names
                      * or string literals. If the information encoded in the map changes, this needs to be revisited. */
                    function escapeString(s) {
                        return escapedCharsRegExp.test(s) ? s.replace(escapedCharsRegExp, function (c) {
                            return escapedCharsMap[c] || c;
                        }) : s;
                    }
                    function serializeStringArray(list) {
                        var output = "";
                        for (var i = 0, n = list.length; i < n; i++) {
                            if (i) {
                                output += ",";
                            }
                            output += "\"" + escapeString(list[i]) + "\"";
                        }
                        return output;
                    }
                }
                function writeJavaScriptAndSourceMapFile(emitOutput, writeByteOrderMark) {
                    // Write source map file
                    encodeLastRecordedSourceMapSpan();
                    writeFile(sourceMapData.sourceMapFilePath, serializeSourceMapContents(3, sourceMapData.sourceMapFile, sourceMapData.sourceMapSourceRoot, sourceMapData.sourceMapSources, sourceMapData.sourceMapNames, sourceMapData.sourceMapMappings), false);
                    sourceMapDataList.push(sourceMapData);
                    // Write sourcemap url to the js file and write the js file
                    writeJavaScriptFile(emitOutput + "//# sourceMappingURL=" + sourceMapData.jsSourceMappingURL, writeByteOrderMark);
                }
                // Initialize source map data
                var sourceMapJsFile = ts.getBaseFilename(ts.normalizeSlashes(jsFilePath));
                sourceMapData = {
                    sourceMapFilePath: jsFilePath + ".map",
                    jsSourceMappingURL: sourceMapJsFile + ".map",
                    sourceMapFile: sourceMapJsFile,
                    sourceMapSourceRoot: compilerOptions.sourceRoot || "",
                    sourceMapSources: [],
                    inputSourceFileNames: [],
                    sourceMapNames: [],
                    sourceMapMappings: "",
                    sourceMapDecodedMappings: []
                };
                // Normalize source root and make sure it has trailing "/" so that it can be used to combine paths with the 
                // relative paths of the sources list in the sourcemap
                sourceMapData.sourceMapSourceRoot = ts.normalizeSlashes(sourceMapData.sourceMapSourceRoot);
                if (sourceMapData.sourceMapSourceRoot.length && sourceMapData.sourceMapSourceRoot.charCodeAt(sourceMapData.sourceMapSourceRoot.length - 1) !== 47 /* slash */) {
                    sourceMapData.sourceMapSourceRoot += ts.directorySeparator;
                }
                if (compilerOptions.mapRoot) {
                    sourceMapDir = ts.normalizeSlashes(compilerOptions.mapRoot);
                    if (root) {
                        // For modules or multiple emit files the mapRoot will have directory structure like the sources
                        // So if src\a.ts and src\lib\b.ts are compiled together user would be moving the maps into mapRoot\a.js.map and mapRoot\lib\b.js.map
                        sourceMapDir = ts.getDirectoryPath(getSourceFilePathInNewDir(sourceMapDir, root));
                    }
                    if (!ts.isRootedDiskPath(sourceMapDir) && !ts.isUrl(sourceMapDir)) {
                        // The relative paths are relative to the common directory
                        sourceMapDir = ts.combinePaths(program.getCommonSourceDirectory(), sourceMapDir);
                        sourceMapData.jsSourceMappingURL = ts.getRelativePathToDirectoryOrUrl(ts.getDirectoryPath(ts.normalizePath(jsFilePath)), ts.combinePaths(sourceMapDir, sourceMapData.jsSourceMappingURL), compilerHost.getCurrentDirectory(), true);
                    }
                    else {
                        sourceMapData.jsSourceMappingURL = ts.combinePaths(sourceMapDir, sourceMapData.jsSourceMappingURL);
                    }
                }
                else {
                    sourceMapDir = ts.getDirectoryPath(ts.normalizePath(jsFilePath));
                }
                function emitNodeWithMap(node) {
                    if (node) {
                        if (node.kind != 182 /* SourceFile */) {
                            recordEmitNodeStartSpan(node);
                            emitNode(node);
                            recordEmitNodeEndSpan(node);
                        }
                        else {
                            recordNewSourceFileStart(node);
                            emitNode(node);
                        }
                    }
                }
                writeEmittedFiles = writeJavaScriptAndSourceMapFile;
                emit = emitNodeWithMap;
                emitStart = recordEmitNodeStartSpan;
                emitEnd = recordEmitNodeEndSpan;
                emitToken = writeTextWithSpanRecord;
                scopeEmitStart = recordScopeNameOfNode;
                scopeEmitEnd = recordScopeNameEnd;
                writeComment = writeCommentRangeWithMap;
            }
            function writeJavaScriptFile(emitOutput, writeByteOrderMark) {
                writeFile(jsFilePath, emitOutput, writeByteOrderMark);
            }
            function emitTokenText(tokenKind, startPos, emitFn) {
                var tokenString = ts.tokenToString(tokenKind);
                if (emitFn) {
                    emitFn();
                }
                else {
                    write(tokenString);
                }
                return startPos + tokenString.length;
            }
            function emitOptional(prefix, node) {
                if (node) {
                    write(prefix);
                    emit(node);
                }
            }
            function emitCommaList(nodes, count) {
                if (!(count >= 0))
                    count = nodes.length;
                if (nodes) {
                    for (var i = 0; i < count; i++) {
                        if (i)
                            write(", ");
                        emit(nodes[i]);
                    }
                }
            }
            function emitMultiLineList(nodes) {
                if (nodes) {
                    for (var i = 0; i < nodes.length; i++) {
                        if (i)
                            write(",");
                        writeLine();
                        emit(nodes[i]);
                    }
                }
            }
            function emitLines(nodes) {
                emitLinesStartingAt(nodes, 0);
            }
            function emitLinesStartingAt(nodes, startIndex) {
                for (var i = startIndex; i < nodes.length; i++) {
                    writeLine();
                    emit(nodes[i]);
                }
            }
            function emitLiteral(node) {
                var text = getSourceTextOfLocalNode(node);
                if (node.kind === 7 /* StringLiteral */ && compilerOptions.sourceMap) {
                    writer.writeLiteral(text);
                }
                else {
                    write(text);
                }
            }
            // This function specifically handles numeric/string literals for enum and accessor 'identifiers'.
            // In a sense, it does not actually emit identifiers as much as it declares a name for a specific property.
            function emitQuotedIdentifier(node) {
                if (node.kind === 7 /* StringLiteral */) {
                    emitLiteral(node);
                }
                else {
                    write("\"");
                    if (node.kind === 6 /* NumericLiteral */) {
                        write(node.text);
                    }
                    else {
                        write(getSourceTextOfLocalNode(node));
                    }
                    write("\"");
                }
            }
            function isNonExpressionIdentifier(node) {
                var parent = node.parent;
                switch (parent.kind) {
                    case 118 /* Parameter */:
                    case 171 /* VariableDeclaration */:
                    case 119 /* Property */:
                    case 134 /* PropertyAssignment */:
                    case 181 /* EnumMember */:
                    case 120 /* Method */:
                    case 172 /* FunctionDeclaration */:
                    case 122 /* GetAccessor */:
                    case 123 /* SetAccessor */:
                    case 141 /* FunctionExpression */:
                    case 174 /* ClassDeclaration */:
                    case 175 /* InterfaceDeclaration */:
                    case 176 /* EnumDeclaration */:
                    case 177 /* ModuleDeclaration */:
                    case 179 /* ImportDeclaration */:
                        return parent.name === node;
                    case 158 /* BreakStatement */:
                    case 157 /* ContinueStatement */:
                    case 180 /* ExportAssignment */:
                        return false;
                    case 164 /* LabeledStatement */:
                        return node.parent.label === node;
                    case 168 /* CatchBlock */:
                        return node.parent.variable === node;
                }
            }
            function emitIdentifier(node) {
                if (!isNonExpressionIdentifier(node)) {
                    var prefix = resolver.getExpressionNamePrefix(node);
                    if (prefix) {
                        write(prefix);
                        write(".");
                    }
                }
                write(getSourceTextOfLocalNode(node));
            }
            function emitThis(node) {
                if (resolver.getNodeCheckFlags(node) & 2 /* LexicalThis */) {
                    write("_this");
                }
                else {
                    write("this");
                }
            }
            function emitSuper(node) {
                var flags = resolver.getNodeCheckFlags(node);
                if (flags & 16 /* SuperInstance */) {
                    write("_super.prototype");
                }
                else if (flags & 32 /* SuperStatic */) {
                    write("_super");
                }
                else {
                    write("super");
                }
            }
            function emitArrayLiteral(node) {
                if (node.flags & 256 /* MultiLine */) {
                    write("[");
                    increaseIndent();
                    emitMultiLineList(node.elements);
                    decreaseIndent();
                    writeLine();
                    write("]");
                }
                else {
                    write("[");
                    emitCommaList(node.elements);
                    write("]");
                }
            }
            function emitObjectLiteral(node) {
                if (!node.properties.length) {
                    write("{}");
                }
                else if (node.flags & 256 /* MultiLine */) {
                    write("{");
                    increaseIndent();
                    emitMultiLineList(node.properties);
                    decreaseIndent();
                    writeLine();
                    write("}");
                }
                else {
                    write("{ ");
                    emitCommaList(node.properties);
                    write(" }");
                }
            }
            function emitPropertyAssignment(node) {
                emitLeadingComments(node);
                emit(node.name);
                write(": ");
                emit(node.initializer);
                emitTrailingComments(node);
            }
            function emitPropertyAccess(node) {
                var constantValue = resolver.getConstantValue(node);
                if (constantValue !== undefined) {
                    write(constantValue.toString() + " /* " + ts.identifierToString(node.right) + " */");
                }
                else {
                    emit(node.left);
                    write(".");
                    emit(node.right);
                }
            }
            function emitIndexedAccess(node) {
                emit(node.object);
                write("[");
                emit(node.index);
                write("]");
            }
            function emitCallExpression(node) {
                var superCall = false;
                if (node.func.kind === 85 /* SuperKeyword */) {
                    write("_super");
                    superCall = true;
                }
                else {
                    emit(node.func);
                    superCall = node.func.kind === 135 /* PropertyAccess */ && node.func.left.kind === 85 /* SuperKeyword */;
                }
                if (superCall) {
                    write(".call(");
                    emitThis(node.func);
                    if (node.arguments.length) {
                        write(", ");
                        emitCommaList(node.arguments);
                    }
                    write(")");
                }
                else {
                    write("(");
                    emitCommaList(node.arguments);
                    write(")");
                }
            }
            function emitNewExpression(node) {
                write("new ");
                emit(node.func);
                if (node.arguments) {
                    write("(");
                    emitCommaList(node.arguments);
                    write(")");
                }
            }
            function emitParenExpression(node) {
                if (node.expression.kind === 139 /* TypeAssertion */) {
                    var operand = node.expression.operand;
                    while (operand.kind == 139 /* TypeAssertion */) {
                        operand = operand.operand;
                    }
                    // We have an expression of the form: (<Type>SubExpr)
                    // Emitting this as (SubExpr) is really not desirable. We would like to emit the subexpr as is.
                    // Omitting the parentheses, however, could cause change in the semantics of the generated
                    // code if the casted expression has a lower precedence than the rest of the expression, e.g.: 
                    //      (<any>new A).foo should be emitted as (new A).foo and not new A.foo
                    //      (<any>typeof A).toString() should be emitted as (typeof A).toString() and not typeof A.toString()
                    //      new (<any>A()) should be emitted as new (A()) and not new A()
                    //      (<any>function foo() { })() should be emitted as an IIF (function foo(){})() and not declaration function foo(){} ()
                    if (operand.kind !== 143 /* PrefixOperator */ && operand.kind !== 144 /* PostfixOperator */ && operand.kind !== 138 /* NewExpression */ && !(operand.kind === 137 /* CallExpression */ && node.parent.kind === 138 /* NewExpression */) && !(operand.kind === 141 /* FunctionExpression */ && node.parent.kind === 137 /* CallExpression */)) {
                        emit(operand);
                        return;
                    }
                }
                write("(");
                emit(node.expression);
                write(")");
            }
            function emitUnaryExpression(node) {
                if (node.kind === 143 /* PrefixOperator */) {
                    write(ts.tokenToString(node.operator));
                }
                // In some cases, we need to emit a space between the operator and the operand. One obvious case
                // is when the operator is an identifier, like delete or typeof. We also need to do this for plus
                // and minus expressions in certain cases. Specifically, consider the following two cases (parens
                // are just for clarity of exposition, and not part of the source code):
                //
                //  (+(+1))
                //  (+(++1))
                //
                // We need to emit a space in both cases. In the first case, the absence of a space will make
                // the resulting expression a prefix increment operation. And in the second, it will make the resulting
                // expression a prefix increment whose operand is a plus expression - (++(+x))
                // The same is true of minus of course.
                if (node.operator >= 59 /* Identifier */) {
                    write(" ");
                }
                else if (node.kind === 143 /* PrefixOperator */ && node.operand.kind === 143 /* PrefixOperator */) {
                    var operand = node.operand;
                    if (node.operator === 28 /* PlusToken */ && (operand.operator === 28 /* PlusToken */ || operand.operator === 33 /* PlusPlusToken */)) {
                        write(" ");
                    }
                    else if (node.operator === 29 /* MinusToken */ && (operand.operator === 29 /* MinusToken */ || operand.operator === 34 /* MinusMinusToken */)) {
                        write(" ");
                    }
                }
                emit(node.operand);
                if (node.kind === 144 /* PostfixOperator */) {
                    write(ts.tokenToString(node.operator));
                }
            }
            function emitBinaryExpression(node) {
                emit(node.left);
                if (node.operator !== 18 /* CommaToken */)
                    write(" ");
                write(ts.tokenToString(node.operator));
                write(" ");
                emit(node.right);
            }
            function emitConditionalExpression(node) {
                emit(node.condition);
                write(" ? ");
                emit(node.whenTrue);
                write(" : ");
                emit(node.whenFalse);
            }
            function emitBlock(node) {
                emitToken(9 /* OpenBraceToken */, node.pos);
                increaseIndent();
                scopeEmitStart(node.parent);
                if (node.kind === 178 /* ModuleBlock */) {
                    ts.Debug.assert(node.parent.kind === 177 /* ModuleDeclaration */);
                    emitCaptureThisForNodeIfNecessary(node.parent);
                }
                emitLines(node.statements);
                decreaseIndent();
                writeLine();
                emitToken(10 /* CloseBraceToken */, node.statements.end);
                scopeEmitEnd();
            }
            function emitEmbeddedStatement(node) {
                if (node.kind === 148 /* Block */) {
                    write(" ");
                    emit(node);
                }
                else {
                    increaseIndent();
                    writeLine();
                    emit(node);
                    decreaseIndent();
                }
            }
            function emitExpressionStatement(node) {
                var isArrowExpression = node.expression.kind === 142 /* ArrowFunction */;
                emitLeadingComments(node);
                if (isArrowExpression)
                    write("(");
                emit(node.expression);
                if (isArrowExpression)
                    write(")");
                write(";");
                emitTrailingComments(node);
            }
            function emitIfStatement(node) {
                emitLeadingComments(node);
                var endPos = emitToken(78 /* IfKeyword */, node.pos);
                write(" ");
                endPos = emitToken(11 /* OpenParenToken */, endPos);
                emit(node.expression);
                emitToken(12 /* CloseParenToken */, node.expression.end);
                emitEmbeddedStatement(node.thenStatement);
                if (node.elseStatement) {
                    writeLine();
                    emitToken(70 /* ElseKeyword */, node.thenStatement.end);
                    if (node.elseStatement.kind === 152 /* IfStatement */) {
                        write(" ");
                        emit(node.elseStatement);
                    }
                    else {
                        emitEmbeddedStatement(node.elseStatement);
                    }
                }
                emitTrailingComments(node);
            }
            function emitDoStatement(node) {
                write("do");
                emitEmbeddedStatement(node.statement);
                if (node.statement.kind === 148 /* Block */) {
                    write(" ");
                }
                else {
                    writeLine();
                }
                write("while (");
                emit(node.expression);
                write(");");
            }
            function emitWhileStatement(node) {
                write("while (");
                emit(node.expression);
                write(")");
                emitEmbeddedStatement(node.statement);
            }
            function emitForStatement(node) {
                var endPos = emitToken(76 /* ForKeyword */, node.pos);
                write(" ");
                endPos = emitToken(11 /* OpenParenToken */, endPos);
                if (node.declarations) {
                    emitToken(92 /* VarKeyword */, endPos);
                    write(" ");
                    emitCommaList(node.declarations);
                }
                if (node.initializer) {
                    emit(node.initializer);
                }
                write(";");
                emitOptional(" ", node.condition);
                write(";");
                emitOptional(" ", node.iterator);
                write(")");
                emitEmbeddedStatement(node.statement);
            }
            function emitForInStatement(node) {
                var endPos = emitToken(76 /* ForKeyword */, node.pos);
                write(" ");
                endPos = emitToken(11 /* OpenParenToken */, endPos);
                if (node.declaration) {
                    emitToken(92 /* VarKeyword */, endPos);
                    write(" ");
                    emit(node.declaration);
                }
                else {
                    emit(node.variable);
                }
                write(" in ");
                emit(node.expression);
                emitToken(12 /* CloseParenToken */, node.expression.end);
                emitEmbeddedStatement(node.statement);
            }
            function emitBreakOrContinueStatement(node) {
                emitToken(node.kind === 158 /* BreakStatement */ ? 60 /* BreakKeyword */ : 65 /* ContinueKeyword */, node.pos);
                emitOptional(" ", node.label);
                write(";");
            }
            function emitReturnStatement(node) {
                emitLeadingComments(node);
                emitToken(84 /* ReturnKeyword */, node.pos);
                emitOptional(" ", node.expression);
                write(";");
                emitTrailingComments(node);
            }
            function emitWithStatement(node) {
                write("with (");
                emit(node.expression);
                write(")");
                emitEmbeddedStatement(node.statement);
            }
            function emitSwitchStatement(node) {
                var endPos = emitToken(86 /* SwitchKeyword */, node.pos);
                write(" ");
                emitToken(11 /* OpenParenToken */, endPos);
                emit(node.expression);
                endPos = emitToken(12 /* CloseParenToken */, node.expression.end);
                write(" ");
                emitToken(9 /* OpenBraceToken */, endPos);
                increaseIndent();
                emitLines(node.clauses);
                decreaseIndent();
                writeLine();
                emitToken(10 /* CloseBraceToken */, node.clauses.end);
            }
            function emitCaseOrDefaultClause(node) {
                if (node.kind === 162 /* CaseClause */) {
                    write("case ");
                    emit(node.expression);
                    write(":");
                }
                else {
                    write("default:");
                }
                increaseIndent();
                emitLines(node.statements);
                decreaseIndent();
            }
            function emitThrowStatement(node) {
                write("throw ");
                emit(node.expression);
                write(";");
            }
            function emitTryStatement(node) {
                write("try ");
                emit(node.tryBlock);
                emit(node.catchBlock);
                if (node.finallyBlock) {
                    writeLine();
                    write("finally ");
                    emit(node.finallyBlock);
                }
            }
            function emitCatchBlock(node) {
                writeLine();
                var endPos = emitToken(62 /* CatchKeyword */, node.pos);
                write(" ");
                emitToken(11 /* OpenParenToken */, endPos);
                emit(node.variable);
                emitToken(12 /* CloseParenToken */, node.variable.end);
                write(" ");
                emitBlock(node);
            }
            function emitDebuggerStatement(node) {
                emitToken(66 /* DebuggerKeyword */, node.pos);
                write(";");
            }
            function emitLabelledStatement(node) {
                emit(node.label);
                write(": ");
                emit(node.statement);
            }
            function getContainingModule(node) {
                do {
                    node = node.parent;
                } while (node && node.kind !== 177 /* ModuleDeclaration */);
                return node;
            }
            function emitModuleMemberName(node) {
                emitStart(node.name);
                if (node.flags & 1 /* Export */) {
                    var container = getContainingModule(node);
                    write(container ? resolver.getLocalNameOfContainer(container) : "exports");
                    write(".");
                }
                emitNode(node.name);
                emitEnd(node.name);
            }
            function emitVariableDeclaration(node) {
                emitLeadingComments(node);
                emitModuleMemberName(node);
                emitOptional(" = ", node.initializer);
                emitTrailingComments(node);
            }
            function emitVariableStatement(node) {
                emitLeadingComments(node);
                if (!(node.flags & 1 /* Export */))
                    write("var ");
                emitCommaList(node.declarations);
                write(";");
                emitTrailingComments(node);
            }
            function emitParameter(node) {
                emitLeadingComments(node);
                emit(node.name);
                emitTrailingComments(node);
            }
            function emitDefaultValueAssignments(node) {
                ts.forEach(node.parameters, function (param) {
                    if (param.initializer) {
                        writeLine();
                        emitStart(param);
                        write("if (");
                        emitNode(param.name);
                        write(" === void 0)");
                        emitEnd(param);
                        write(" { ");
                        emitStart(param);
                        emitNode(param.name);
                        write(" = ");
                        emitNode(param.initializer);
                        emitEnd(param);
                        write("; }");
                    }
                });
            }
            function emitRestParameter(node) {
                if (ts.hasRestParameters(node)) {
                    var restIndex = node.parameters.length - 1;
                    var restParam = node.parameters[restIndex];
                    writeLine();
                    emitLeadingComments(restParam);
                    emitStart(restParam);
                    write("var ");
                    emitNode(restParam.name);
                    write(" = [];");
                    emitEnd(restParam);
                    emitTrailingComments(restParam);
                    writeLine();
                    write("for (");
                    emitStart(restParam);
                    write("var _i = " + restIndex + ";");
                    emitEnd(restParam);
                    write(" ");
                    emitStart(restParam);
                    write("_i < arguments.length;");
                    emitEnd(restParam);
                    write(" ");
                    emitStart(restParam);
                    write("_i++");
                    emitEnd(restParam);
                    write(") {");
                    increaseIndent();
                    writeLine();
                    emitStart(restParam);
                    emitNode(restParam.name);
                    write("[_i - " + restIndex + "] = arguments[_i];");
                    emitEnd(restParam);
                    decreaseIndent();
                    writeLine();
                    write("}");
                }
            }
            function emitAccessor(node) {
                emitLeadingComments(node);
                write(node.kind === 122 /* GetAccessor */ ? "get " : "set ");
                emit(node.name);
                emitSignatureAndBody(node);
                emitTrailingComments(node);
            }
            function emitFunctionDeclaration(node) {
                if (!node.body) {
                    return emitPinnedOrTripleSlashComments(node);
                }
                if (node.kind !== 120 /* Method */) {
                    // Methods will emit the comments as part of emitting method declaration
                    emitLeadingComments(node);
                }
                write("function ");
                if (node.kind === 172 /* FunctionDeclaration */ || (node.kind === 141 /* FunctionExpression */ && node.name)) {
                    emit(node.name);
                }
                emitSignatureAndBody(node);
                if (node.kind !== 120 /* Method */) {
                    emitTrailingComments(node);
                }
            }
            function emitCaptureThisForNodeIfNecessary(node) {
                if (resolver.getNodeCheckFlags(node) & 4 /* CaptureThis */) {
                    writeLine();
                    emitStart(node);
                    write("var _this = this;");
                    emitEnd(node);
                }
            }
            function emitSignatureParameters(node) {
                increaseIndent();
                write("(");
                if (node) {
                    emitCommaList(node.parameters, node.parameters.length - (ts.hasRestParameters(node) ? 1 : 0));
                }
                write(")");
                decreaseIndent();
            }
            function emitSignatureAndBody(node) {
                emitSignatureParameters(node);
                write(" {");
                scopeEmitStart(node);
                increaseIndent();
                emitDetachedComments(node.body.kind === 173 /* FunctionBlock */ ? node.body.statements : node.body);
                var startIndex = 0;
                if (node.body.kind === 173 /* FunctionBlock */) {
                    startIndex = emitDirectivePrologues(node.body.statements, true);
                }
                var outPos = writer.getTextPos();
                emitCaptureThisForNodeIfNecessary(node);
                emitDefaultValueAssignments(node);
                emitRestParameter(node);
                if (node.body.kind !== 173 /* FunctionBlock */ && outPos === writer.getTextPos()) {
                    decreaseIndent();
                    write(" ");
                    emitStart(node.body);
                    write("return ");
                    emitNode(node.body);
                    emitEnd(node.body);
                    write("; ");
                    emitStart(node.body);
                    write("}");
                    emitEnd(node.body);
                }
                else {
                    if (node.body.kind === 173 /* FunctionBlock */) {
                        emitLinesStartingAt(node.body.statements, startIndex);
                    }
                    else {
                        writeLine();
                        emitLeadingComments(node.body);
                        write("return ");
                        emit(node.body);
                        write(";");
                        emitTrailingComments(node.body);
                    }
                    writeLine();
                    if (node.body.kind === 173 /* FunctionBlock */) {
                        emitLeadingCommentsOfPosition(node.body.statements.end);
                        decreaseIndent();
                        emitToken(10 /* CloseBraceToken */, node.body.statements.end);
                    }
                    else {
                        decreaseIndent();
                        emitStart(node.body);
                        write("}");
                        emitEnd(node.body);
                    }
                }
                scopeEmitEnd();
                if (node.flags & 1 /* Export */) {
                    writeLine();
                    emitStart(node);
                    emitModuleMemberName(node);
                    write(" = ");
                    emit(node.name);
                    emitEnd(node);
                    write(";");
                }
            }
            function findInitialSuperCall(ctor) {
                if (ctor.body) {
                    var statement = ctor.body.statements[0];
                    if (statement && statement.kind === 151 /* ExpressionStatement */) {
                        var expr = statement.expression;
                        if (expr && expr.kind === 137 /* CallExpression */) {
                            var func = expr.func;
                            if (func && func.kind === 85 /* SuperKeyword */) {
                                return statement;
                            }
                        }
                    }
                }
            }
            function emitParameterPropertyAssignments(node) {
                ts.forEach(node.parameters, function (param) {
                    if (param.flags & ts.NodeFlags.AccessibilityModifier) {
                        writeLine();
                        emitStart(param);
                        emitStart(param.name);
                        write("this.");
                        emitNode(param.name);
                        emitEnd(param.name);
                        write(" = ");
                        emit(param.name);
                        write(";");
                        emitEnd(param);
                    }
                });
            }
            function emitMemberAccess(memberName) {
                if (memberName.kind === 7 /* StringLiteral */ || memberName.kind === 6 /* NumericLiteral */) {
                    write("[");
                    emitNode(memberName);
                    write("]");
                }
                else {
                    write(".");
                    emitNode(memberName);
                }
            }
            function emitMemberAssignments(node, staticFlag) {
                ts.forEach(node.members, function (member) {
                    if (member.kind === 119 /* Property */ && (member.flags & 128 /* Static */) === staticFlag && member.initializer) {
                        writeLine();
                        emitLeadingComments(member);
                        emitStart(member);
                        emitStart(member.name);
                        if (staticFlag) {
                            emitNode(node.name);
                        }
                        else {
                            write("this");
                        }
                        emitMemberAccess(member.name);
                        emitEnd(member.name);
                        write(" = ");
                        emit(member.initializer);
                        write(";");
                        emitEnd(member);
                        emitTrailingComments(member);
                    }
                });
            }
            function emitMemberFunctions(node) {
                ts.forEach(node.members, function (member) {
                    if (member.kind === 120 /* Method */) {
                        if (!member.body) {
                            return emitPinnedOrTripleSlashComments(member);
                        }
                        writeLine();
                        emitLeadingComments(member);
                        emitStart(member);
                        emitStart(member.name);
                        emitNode(node.name);
                        if (!(member.flags & 128 /* Static */)) {
                            write(".prototype");
                        }
                        emitMemberAccess(member.name);
                        emitEnd(member.name);
                        write(" = ");
                        emitStart(member);
                        emitFunctionDeclaration(member);
                        emitEnd(member);
                        emitEnd(member);
                        write(";");
                        emitTrailingComments(member);
                    }
                    else if (member.kind === 122 /* GetAccessor */ || member.kind === 123 /* SetAccessor */) {
                        var accessors = getAllAccessorDeclarations(node, member);
                        if (member === accessors.firstAccessor) {
                            writeLine();
                            emitStart(member);
                            write("Object.defineProperty(");
                            emitStart(member.name);
                            emitNode(node.name);
                            if (!(member.flags & 128 /* Static */)) {
                                write(".prototype");
                            }
                            write(", ");
                            emitQuotedIdentifier(member.name);
                            emitEnd(member.name);
                            write(", {");
                            increaseIndent();
                            if (accessors.getAccessor) {
                                writeLine();
                                emitLeadingComments(accessors.getAccessor);
                                write("get: ");
                                emitStart(accessors.getAccessor);
                                write("function ");
                                emitSignatureAndBody(accessors.getAccessor);
                                emitEnd(accessors.getAccessor);
                                emitTrailingComments(accessors.getAccessor);
                                write(",");
                            }
                            if (accessors.setAccessor) {
                                writeLine();
                                emitLeadingComments(accessors.setAccessor);
                                write("set: ");
                                emitStart(accessors.setAccessor);
                                write("function ");
                                emitSignatureAndBody(accessors.setAccessor);
                                emitEnd(accessors.setAccessor);
                                emitTrailingComments(accessors.setAccessor);
                                write(",");
                            }
                            writeLine();
                            write("enumerable: true,");
                            writeLine();
                            write("configurable: true");
                            decreaseIndent();
                            writeLine();
                            write("});");
                            emitEnd(member);
                        }
                    }
                });
            }
            function emitClassDeclaration(node) {
                emitLeadingComments(node);
                write("var ");
                emit(node.name);
                write(" = (function (");
                if (node.baseType) {
                    write("_super");
                }
                write(") {");
                increaseIndent();
                scopeEmitStart(node);
                if (node.baseType) {
                    writeLine();
                    emitStart(node.baseType);
                    write("__extends(");
                    emit(node.name);
                    write(", _super);");
                    emitEnd(node.baseType);
                }
                writeLine();
                emitConstructorOfClass();
                emitMemberFunctions(node);
                emitMemberAssignments(node, 128 /* Static */);
                writeLine();
                function emitClassReturnStatement() {
                    write("return ");
                    emitNode(node.name);
                }
                emitToken(10 /* CloseBraceToken */, node.members.end, emitClassReturnStatement);
                write(";");
                decreaseIndent();
                writeLine();
                emitToken(10 /* CloseBraceToken */, node.members.end);
                scopeEmitEnd();
                emitStart(node);
                write(")(");
                if (node.baseType) {
                    emit(node.baseType.typeName);
                }
                write(");");
                emitEnd(node);
                if (node.flags & 1 /* Export */) {
                    writeLine();
                    emitStart(node);
                    emitModuleMemberName(node);
                    write(" = ");
                    emit(node.name);
                    emitEnd(node);
                    write(";");
                }
                emitTrailingComments(node);
                function emitConstructorOfClass() {
                    // Emit the constructor overload pinned comments
                    ts.forEach(node.members, function (member) {
                        if (member.kind === 121 /* Constructor */ && !member.body) {
                            emitPinnedOrTripleSlashComments(member);
                        }
                    });
                    var ctor = getFirstConstructorWithBody(node);
                    if (ctor) {
                        emitLeadingComments(ctor);
                    }
                    emitStart(ctor || node);
                    write("function ");
                    emit(node.name);
                    emitSignatureParameters(ctor);
                    write(" {");
                    scopeEmitStart(node, "constructor");
                    increaseIndent();
                    if (ctor) {
                        emitDetachedComments(ctor.body.statements);
                    }
                    emitCaptureThisForNodeIfNecessary(node);
                    if (ctor) {
                        emitDefaultValueAssignments(ctor);
                        emitRestParameter(ctor);
                        if (node.baseType) {
                            var superCall = findInitialSuperCall(ctor);
                            if (superCall) {
                                writeLine();
                                emit(superCall);
                            }
                        }
                        emitParameterPropertyAssignments(ctor);
                    }
                    else {
                        if (node.baseType) {
                            writeLine();
                            emitStart(node.baseType);
                            write("_super.apply(this, arguments);");
                            emitEnd(node.baseType);
                        }
                    }
                    emitMemberAssignments(node, 0);
                    if (ctor) {
                        var statements = ctor.body.statements;
                        if (superCall)
                            statements = statements.slice(1);
                        emitLines(statements);
                    }
                    writeLine();
                    if (ctor) {
                        emitLeadingCommentsOfPosition(ctor.body.statements.end);
                    }
                    decreaseIndent();
                    emitToken(10 /* CloseBraceToken */, ctor ? ctor.body.statements.end : node.members.end);
                    scopeEmitEnd();
                    emitEnd(ctor || node);
                    if (ctor) {
                        emitTrailingComments(ctor);
                    }
                }
            }
            function emitInterfaceDeclaration(node) {
                emitPinnedOrTripleSlashComments(node);
            }
            function emitEnumDeclaration(node) {
                emitLeadingComments(node);
                if (!(node.flags & 1 /* Export */)) {
                    emitStart(node);
                    write("var ");
                    emit(node.name);
                    emitEnd(node);
                    write(";");
                }
                writeLine();
                emitStart(node);
                write("(function (");
                emitStart(node.name);
                write(resolver.getLocalNameOfContainer(node));
                emitEnd(node.name);
                write(") {");
                increaseIndent();
                scopeEmitStart(node);
                emitEnumMemberDeclarations();
                decreaseIndent();
                writeLine();
                emitToken(10 /* CloseBraceToken */, node.members.end);
                scopeEmitEnd();
                write(")(");
                emitModuleMemberName(node);
                write(" || (");
                emitModuleMemberName(node);
                write(" = {}));");
                emitEnd(node);
                if (node.flags & 1 /* Export */) {
                    writeLine();
                    emitStart(node);
                    write("var ");
                    emit(node.name);
                    write(" = ");
                    emitModuleMemberName(node);
                    emitEnd(node);
                    write(";");
                }
                emitTrailingComments(node);
                function emitEnumMemberDeclarations() {
                    ts.forEach(node.members, function (member) {
                        writeLine();
                        emitLeadingComments(member);
                        emitStart(member);
                        write(resolver.getLocalNameOfContainer(node));
                        write("[");
                        write(resolver.getLocalNameOfContainer(node));
                        write("[");
                        emitQuotedIdentifier(member.name);
                        write("] = ");
                        if (member.initializer) {
                            emit(member.initializer);
                        }
                        else {
                            write(resolver.getEnumMemberValue(member).toString());
                        }
                        write("] = ");
                        emitQuotedIdentifier(member.name);
                        emitEnd(member);
                        write(";");
                        emitTrailingComments(member);
                    });
                }
            }
            function getInnerMostModuleDeclarationFromDottedModule(moduleDeclaration) {
                if (moduleDeclaration.body.kind === 177 /* ModuleDeclaration */) {
                    var recursiveInnerModule = getInnerMostModuleDeclarationFromDottedModule(moduleDeclaration.body);
                    return recursiveInnerModule || moduleDeclaration.body;
                }
            }
            function emitModuleDeclaration(node) {
                if (!ts.isInstantiated(node)) {
                    return emitPinnedOrTripleSlashComments(node);
                }
                emitLeadingComments(node);
                emitStart(node);
                write("var ");
                emit(node.name);
                write(";");
                emitEnd(node);
                writeLine();
                emitStart(node);
                write("(function (");
                emitStart(node.name);
                write(resolver.getLocalNameOfContainer(node));
                emitEnd(node.name);
                write(") ");
                if (node.body.kind === 178 /* ModuleBlock */) {
                    emit(node.body);
                }
                else {
                    write("{");
                    increaseIndent();
                    scopeEmitStart(node);
                    emitCaptureThisForNodeIfNecessary(node);
                    writeLine();
                    emit(node.body);
                    decreaseIndent();
                    writeLine();
                    var moduleBlock = getInnerMostModuleDeclarationFromDottedModule(node).body;
                    emitToken(10 /* CloseBraceToken */, moduleBlock.statements.end);
                    scopeEmitEnd();
                }
                write(")(");
                if (node.flags & 1 /* Export */) {
                    emit(node.name);
                    write(" = ");
                }
                emitModuleMemberName(node);
                write(" || (");
                emitModuleMemberName(node);
                write(" = {}));");
                emitEnd(node);
                emitTrailingComments(node);
            }
            function emitImportDeclaration(node) {
                var emitImportDeclaration = resolver.isReferencedImportDeclaration(node);
                if (!emitImportDeclaration) {
                    // preserve old compiler's behavior: emit 'var' for import declaration (even if we do not consider them referenced) when
                    // - current file is not external module
                    // - import declaration is top level and target is value imported by entity name
                    emitImportDeclaration = !ts.isExternalModule(currentSourceFile) && resolver.isTopLevelValueImportedViaEntityName(node);
                }
                if (emitImportDeclaration) {
                    if (node.externalModuleName && node.parent.kind === 182 /* SourceFile */ && compilerOptions.module === 2 /* AMD */) {
                        if (node.flags & 1 /* Export */) {
                            writeLine();
                            emitLeadingComments(node);
                            emitStart(node);
                            emitModuleMemberName(node);
                            write(" = ");
                            emit(node.name);
                            write(";");
                            emitEnd(node);
                            emitTrailingComments(node);
                        }
                    }
                    else {
                        writeLine();
                        emitLeadingComments(node);
                        emitStart(node);
                        if (!(node.flags & 1 /* Export */))
                            write("var ");
                        emitModuleMemberName(node);
                        write(" = ");
                        if (node.entityName) {
                            emit(node.entityName);
                        }
                        else {
                            write("require(");
                            emitStart(node.externalModuleName);
                            emitLiteral(node.externalModuleName);
                            emitEnd(node.externalModuleName);
                            emitToken(12 /* CloseParenToken */, node.externalModuleName.end);
                        }
                        write(";");
                        emitEnd(node);
                        emitTrailingComments(node);
                    }
                }
            }
            function getExternalImportDeclarations(node) {
                var result = [];
                ts.forEach(node.statements, function (stat) {
                    if (stat.kind === 179 /* ImportDeclaration */ && stat.externalModuleName && resolver.isReferencedImportDeclaration(stat)) {
                        result.push(stat);
                    }
                });
                return result;
            }
            function getFirstExportAssignment(sourceFile) {
                return ts.forEach(sourceFile.statements, function (node) {
                    if (node.kind === 180 /* ExportAssignment */) {
                        return node;
                    }
                });
            }
            function emitAMDModule(node, startIndex) {
                var imports = getExternalImportDeclarations(node);
                writeLine();
                write("define([\"require\", \"exports\"");
                ts.forEach(imports, function (imp) {
                    write(", ");
                    emitLiteral(imp.externalModuleName);
                });
                ts.forEach(node.amdDependencies, function (amdDependency) {
                    var text = "\"" + amdDependency + "\"";
                    write(", ");
                    write(text);
                });
                write("], function (require, exports");
                ts.forEach(imports, function (imp) {
                    write(", ");
                    emit(imp.name);
                });
                write(") {");
                increaseIndent();
                emitCaptureThisForNodeIfNecessary(node);
                emitLinesStartingAt(node.statements, startIndex);
                var exportName = resolver.getExportAssignmentName(node);
                if (exportName) {
                    writeLine();
                    var exportAssignement = getFirstExportAssignment(node);
                    emitStart(exportAssignement);
                    write("return ");
                    emitStart(exportAssignement.exportName);
                    write(exportName);
                    emitEnd(exportAssignement.exportName);
                    write(";");
                    emitEnd(exportAssignement);
                }
                decreaseIndent();
                writeLine();
                write("});");
            }
            function emitCommonJSModule(node, startIndex) {
                emitCaptureThisForNodeIfNecessary(node);
                emitLinesStartingAt(node.statements, startIndex);
                var exportName = resolver.getExportAssignmentName(node);
                if (exportName) {
                    writeLine();
                    var exportAssignement = getFirstExportAssignment(node);
                    emitStart(exportAssignement);
                    write("module.exports = ");
                    emitStart(exportAssignement.exportName);
                    write(exportName);
                    emitEnd(exportAssignement.exportName);
                    write(";");
                    emitEnd(exportAssignement);
                }
            }
            function emitDirectivePrologues(statements, startWithNewLine) {
                for (var i = 0; i < statements.length; ++i) {
                    if (ts.isPrologueDirective(statements[i])) {
                        if (startWithNewLine || i > 0) {
                            writeLine();
                        }
                        emit(statements[i]);
                    }
                    else {
                        // return index of the first non prologue directive
                        return i;
                    }
                }
                return statements.length;
            }
            function emitSourceFile(node) {
                currentSourceFile = node;
                // Start new file on new line
                writeLine();
                emitDetachedComments(node);
                // emit prologue directives prior to __extends
                var startIndex = emitDirectivePrologues(node.statements, false);
                if (!extendsEmitted && resolver.getNodeCheckFlags(node) & 8 /* EmitExtends */) {
                    writeLine();
                    write("var __extends = this.__extends || function (d, b) {");
                    increaseIndent();
                    writeLine();
                    write("for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];");
                    writeLine();
                    write("function __() { this.constructor = d; }");
                    writeLine();
                    write("__.prototype = b.prototype;");
                    writeLine();
                    write("d.prototype = new __();");
                    decreaseIndent();
                    writeLine();
                    write("};");
                    extendsEmitted = true;
                }
                if (ts.isExternalModule(node)) {
                    if (compilerOptions.module === 2 /* AMD */) {
                        emitAMDModule(node, startIndex);
                    }
                    else {
                        emitCommonJSModule(node, startIndex);
                    }
                }
                else {
                    emitCaptureThisForNodeIfNecessary(node);
                    emitLinesStartingAt(node.statements, startIndex);
                }
            }
            function emitNode(node) {
                if (!node) {
                    return;
                }
                if (node.flags & 2 /* Ambient */) {
                    return emitPinnedOrTripleSlashComments(node);
                }
                switch (node.kind) {
                    case 59 /* Identifier */:
                        return emitIdentifier(node);
                    case 118 /* Parameter */:
                        return emitParameter(node);
                    case 122 /* GetAccessor */:
                    case 123 /* SetAccessor */:
                        return emitAccessor(node);
                    case 87 /* ThisKeyword */:
                        return emitThis(node);
                    case 85 /* SuperKeyword */:
                        return emitSuper(node);
                    case 83 /* NullKeyword */:
                        return write("null");
                    case 89 /* TrueKeyword */:
                        return write("true");
                    case 74 /* FalseKeyword */:
                        return write("false");
                    case 6 /* NumericLiteral */:
                    case 7 /* StringLiteral */:
                    case 8 /* RegularExpressionLiteral */:
                        return emitLiteral(node);
                    case 116 /* QualifiedName */:
                        return emitPropertyAccess(node);
                    case 132 /* ArrayLiteral */:
                        return emitArrayLiteral(node);
                    case 133 /* ObjectLiteral */:
                        return emitObjectLiteral(node);
                    case 134 /* PropertyAssignment */:
                        return emitPropertyAssignment(node);
                    case 135 /* PropertyAccess */:
                        return emitPropertyAccess(node);
                    case 136 /* IndexedAccess */:
                        return emitIndexedAccess(node);
                    case 137 /* CallExpression */:
                        return emitCallExpression(node);
                    case 138 /* NewExpression */:
                        return emitNewExpression(node);
                    case 139 /* TypeAssertion */:
                        return emit(node.operand);
                    case 140 /* ParenExpression */:
                        return emitParenExpression(node);
                    case 172 /* FunctionDeclaration */:
                    case 141 /* FunctionExpression */:
                    case 142 /* ArrowFunction */:
                        return emitFunctionDeclaration(node);
                    case 143 /* PrefixOperator */:
                    case 144 /* PostfixOperator */:
                        return emitUnaryExpression(node);
                    case 145 /* BinaryExpression */:
                        return emitBinaryExpression(node);
                    case 146 /* ConditionalExpression */:
                        return emitConditionalExpression(node);
                    case 147 /* OmittedExpression */:
                        return;
                    case 148 /* Block */:
                    case 167 /* TryBlock */:
                    case 169 /* FinallyBlock */:
                    case 173 /* FunctionBlock */:
                    case 178 /* ModuleBlock */:
                        return emitBlock(node);
                    case 149 /* VariableStatement */:
                        return emitVariableStatement(node);
                    case 150 /* EmptyStatement */:
                        return write(";");
                    case 151 /* ExpressionStatement */:
                        return emitExpressionStatement(node);
                    case 152 /* IfStatement */:
                        return emitIfStatement(node);
                    case 153 /* DoStatement */:
                        return emitDoStatement(node);
                    case 154 /* WhileStatement */:
                        return emitWhileStatement(node);
                    case 155 /* ForStatement */:
                        return emitForStatement(node);
                    case 156 /* ForInStatement */:
                        return emitForInStatement(node);
                    case 157 /* ContinueStatement */:
                    case 158 /* BreakStatement */:
                        return emitBreakOrContinueStatement(node);
                    case 159 /* ReturnStatement */:
                        return emitReturnStatement(node);
                    case 160 /* WithStatement */:
                        return emitWithStatement(node);
                    case 161 /* SwitchStatement */:
                        return emitSwitchStatement(node);
                    case 162 /* CaseClause */:
                    case 163 /* DefaultClause */:
                        return emitCaseOrDefaultClause(node);
                    case 164 /* LabeledStatement */:
                        return emitLabelledStatement(node);
                    case 165 /* ThrowStatement */:
                        return emitThrowStatement(node);
                    case 166 /* TryStatement */:
                        return emitTryStatement(node);
                    case 168 /* CatchBlock */:
                        return emitCatchBlock(node);
                    case 170 /* DebuggerStatement */:
                        return emitDebuggerStatement(node);
                    case 171 /* VariableDeclaration */:
                        return emitVariableDeclaration(node);
                    case 174 /* ClassDeclaration */:
                        return emitClassDeclaration(node);
                    case 175 /* InterfaceDeclaration */:
                        return emitInterfaceDeclaration(node);
                    case 176 /* EnumDeclaration */:
                        return emitEnumDeclaration(node);
                    case 177 /* ModuleDeclaration */:
                        return emitModuleDeclaration(node);
                    case 179 /* ImportDeclaration */:
                        return emitImportDeclaration(node);
                    case 182 /* SourceFile */:
                        return emitSourceFile(node);
                }
            }
            function hasDetachedComments(pos) {
                return detachedCommentsInfo !== undefined && detachedCommentsInfo[detachedCommentsInfo.length - 1].nodePos === pos;
            }
            function getLeadingCommentsWithoutDetachedComments() {
                // get the leading comments from detachedPos
                var leadingComments = ts.getLeadingCommentRanges(currentSourceFile.text, detachedCommentsInfo[detachedCommentsInfo.length - 1].detachedCommentEndPos);
                if (detachedCommentsInfo.length - 1) {
                    detachedCommentsInfo.pop();
                }
                else {
                    detachedCommentsInfo = undefined;
                }
                return leadingComments;
            }
            function getLeadingCommentsToEmit(node) {
                // Emit the leading comments only if the parent's pos doesn't match because parent should take care of emitting these comments
                if (node.parent.kind === 182 /* SourceFile */ || node.pos !== node.parent.pos) {
                    var leadingComments;
                    if (hasDetachedComments(node.pos)) {
                        // get comments without detached comments
                        leadingComments = getLeadingCommentsWithoutDetachedComments();
                    }
                    else {
                        // get the leading comments from the node
                        leadingComments = ts.getLeadingCommentRangesOfNode(node, currentSourceFile);
                    }
                    return leadingComments;
                }
            }
            function emitLeadingDeclarationComments(node) {
                var leadingComments = getLeadingCommentsToEmit(node);
                emitNewLineBeforeLeadingComments(node, leadingComments, writer);
                // Leading comments are emitted at /*leading comment1 */space/*leading comment*/space
                emitComments(leadingComments, true, writer, writeComment);
            }
            function emitTrailingDeclarationComments(node) {
                // Emit the trailing comments only if the parent's end doesn't match
                if (node.parent.kind === 182 /* SourceFile */ || node.end !== node.parent.end) {
                    var trailingComments = ts.getTrailingCommentRanges(currentSourceFile.text, node.end);
                    // trailing comments are emitted at space/*trailing comment1 */space/*trailing comment*/
                    emitComments(trailingComments, false, writer, writeComment);
                }
            }
            function emitLeadingCommentsOfLocalPosition(pos) {
                var leadingComments;
                if (hasDetachedComments(pos)) {
                    // get comments without detached comments
                    leadingComments = getLeadingCommentsWithoutDetachedComments();
                }
                else {
                    // get the leading comments from the node
                    leadingComments = ts.getLeadingCommentRanges(currentSourceFile.text, pos);
                }
                emitNewLineBeforeLeadingComments({ pos: pos, end: pos }, leadingComments, writer);
                // Leading comments are emitted at /*leading comment1 */space/*leading comment*/space
                emitComments(leadingComments, true, writer, writeComment);
            }
            function emitDetachedCommentsAtPosition(node) {
                var leadingComments = ts.getLeadingCommentRanges(currentSourceFile.text, node.pos);
                if (leadingComments) {
                    var detachedComments = [];
                    var lastComment;
                    ts.forEach(leadingComments, function (comment) {
                        if (lastComment) {
                            var lastCommentLine = getLineOfLocalPosition(lastComment.end);
                            var commentLine = getLineOfLocalPosition(comment.pos);
                            if (commentLine >= lastCommentLine + 2) {
                                // There was a blank line between the last comment and this comment.  This
                                // comment is not part of the copyright comments.  Return what we have so 
                                // far.
                                return detachedComments;
                            }
                        }
                        detachedComments.push(comment);
                        lastComment = comment;
                    });
                    if (detachedComments.length) {
                        // All comments look like they could have been part of the copyright header.  Make
                        // sure there is at least one blank line between it and the node.  If not, it's not
                        // a copyright header.
                        var lastCommentLine = getLineOfLocalPosition(detachedComments[detachedComments.length - 1].end);
                        var astLine = getLineOfLocalPosition(ts.skipTrivia(currentSourceFile.text, node.pos));
                        if (astLine >= lastCommentLine + 2) {
                            // Valid detachedComments
                            emitNewLineBeforeLeadingComments(node, leadingComments, writer);
                            emitComments(detachedComments, true, writer, writeComment);
                            var currentDetachedCommentInfo = { nodePos: node.pos, detachedCommentEndPos: detachedComments[detachedComments.length - 1].end };
                            if (detachedCommentsInfo) {
                                detachedCommentsInfo.push(currentDetachedCommentInfo);
                            }
                            else {
                                detachedCommentsInfo = [currentDetachedCommentInfo];
                            }
                        }
                    }
                }
            }
            function emitPinnedOrTripleSlashCommentsOfNode(node) {
                var pinnedComments = ts.filter(getLeadingCommentsToEmit(node), isPinnedOrTripleSlashComment);
                function isPinnedOrTripleSlashComment(comment) {
                    if (currentSourceFile.text.charCodeAt(comment.pos + 1) === 42 /* asterisk */) {
                        return currentSourceFile.text.charCodeAt(comment.pos + 2) === 33 /* exclamation */;
                    }
                    else if (currentSourceFile.text.charCodeAt(comment.pos + 1) === 47 /* slash */ && comment.pos + 2 < comment.end && currentSourceFile.text.charCodeAt(comment.pos + 2) === 47 /* slash */ && currentSourceFile.text.substring(comment.pos, comment.end).match(ts.fullTripleSlashReferencePathRegEx)) {
                        return true;
                    }
                }
                emitNewLineBeforeLeadingComments(node, pinnedComments, writer);
                // Leading comments are emitted at /*leading comment1 */space/*leading comment*/space
                emitComments(pinnedComments, true, writer, writeComment);
            }
            if (compilerOptions.sourceMap) {
                initializeEmitterWithSourceMaps();
            }
            if (root) {
                emit(root);
            }
            else {
                ts.forEach(program.getSourceFiles(), function (sourceFile) {
                    if (!isExternalModuleOrDeclarationFile(sourceFile)) {
                        emit(sourceFile);
                    }
                });
            }
            writeLine();
            writeEmittedFiles(writer.getText(), compilerOptions.emitBOM);
        }
        function emitDeclarations(jsFilePath, root) {
            var writer = createTextWriter(trackSymbol);
            var write = writer.write;
            var writeLine = writer.writeLine;
            var increaseIndent = writer.increaseIndent;
            var decreaseIndent = writer.decreaseIndent;
            var enclosingDeclaration;
            var reportedDeclarationError = false;
            var emitJsDocComments = compilerOptions.removeComments ? function (declaration) {
            } : writeJsDocComments;
            var aliasDeclarationEmitInfo = [];
            var getSymbolVisibilityDiagnosticMessage;
            function writeAsychronousImportDeclarations(importDeclarations) {
                var oldWriter = writer;
                ts.forEach(importDeclarations, function (aliasToWrite) {
                    var aliasEmitInfo = ts.forEach(aliasDeclarationEmitInfo, function (declEmitInfo) { return declEmitInfo.declaration === aliasToWrite ? declEmitInfo : undefined; });
                    writer = createTextWriter(trackSymbol);
                    for (var declarationIndent = aliasEmitInfo.indent; declarationIndent; declarationIndent--) {
                        writer.increaseIndent();
                    }
                    writeImportDeclaration(aliasToWrite);
                    aliasEmitInfo.asynchronousOutput = writer.getText();
                });
                writer = oldWriter;
            }
            function trackSymbol(symbol, enclosingDeclaration, meaning) {
                var symbolAccesibilityResult = resolver.isSymbolAccessible(symbol, enclosingDeclaration, meaning);
                if (symbolAccesibilityResult.accessibility === 0 /* Accessible */) {
                    // write the aliases
                    if (symbolAccesibilityResult && symbolAccesibilityResult.aliasesToMakeVisible) {
                        writeAsychronousImportDeclarations(symbolAccesibilityResult.aliasesToMakeVisible);
                    }
                }
                else {
                    // Report error
                    reportedDeclarationError = true;
                    var errorInfo = getSymbolVisibilityDiagnosticMessage(symbolAccesibilityResult);
                    if (errorInfo) {
                        if (errorInfo.typeName) {
                            diagnostics.push(ts.createDiagnosticForNode(errorInfo.errorNode, errorInfo.diagnosticMessage, getSourceTextOfLocalNode(errorInfo.typeName), symbolAccesibilityResult.errorSymbolName, symbolAccesibilityResult.errorModuleName));
                        }
                        else {
                            diagnostics.push(ts.createDiagnosticForNode(errorInfo.errorNode, errorInfo.diagnosticMessage, symbolAccesibilityResult.errorSymbolName, symbolAccesibilityResult.errorModuleName));
                        }
                    }
                }
            }
            function emitLines(nodes) {
                for (var i = 0, n = nodes.length; i < n; i++) {
                    emitNode(nodes[i]);
                }
            }
            function emitCommaList(nodes, eachNodeEmitFn) {
                var currentWriterPos = writer.getTextPos();
                for (var i = 0, n = nodes.length; i < n; i++) {
                    if (currentWriterPos !== writer.getTextPos()) {
                        write(", ");
                    }
                    currentWriterPos = writer.getTextPos();
                    eachNodeEmitFn(nodes[i]);
                }
            }
            function writeJsDocComments(declaration) {
                if (declaration) {
                    var jsDocComments = ts.getJsDocComments(declaration, currentSourceFile);
                    emitNewLineBeforeLeadingComments(declaration, jsDocComments, writer);
                    // jsDoc comments are emitted at /*leading comment1 */space/*leading comment*/space
                    emitComments(jsDocComments, true, writer, writeCommentRange);
                }
            }
            function emitSourceTextOfNode(node) {
                write(getSourceTextOfLocalNode(node));
            }
            function emitSourceFile(node) {
                currentSourceFile = node;
                enclosingDeclaration = node;
                emitLines(node.statements);
            }
            function emitExportAssignment(node) {
                write("export = ");
                emitSourceTextOfNode(node.exportName);
                write(";");
                writeLine();
            }
            function emitDeclarationFlags(node) {
                if (node.flags & 128 /* Static */) {
                    if (node.flags & 32 /* Private */) {
                        write("private ");
                    }
                    else if (node.flags & 64 /* Protected */) {
                        write("protected ");
                    }
                    write("static ");
                }
                else {
                    if (node.flags & 32 /* Private */) {
                        write("private ");
                    }
                    else if (node.flags & 64 /* Protected */) {
                        write("protected ");
                    }
                    else if (node.parent === currentSourceFile) {
                        // If the node is exported 
                        if (node.flags & 1 /* Export */) {
                            write("export ");
                        }
                        if (node.kind !== 175 /* InterfaceDeclaration */) {
                            write("declare ");
                        }
                    }
                }
            }
            function emitImportDeclaration(node) {
                var nodeEmitInfo = {
                    declaration: node,
                    outputPos: writer.getTextPos(),
                    indent: writer.getIndent(),
                    hasWritten: resolver.isDeclarationVisible(node)
                };
                aliasDeclarationEmitInfo.push(nodeEmitInfo);
                if (nodeEmitInfo.hasWritten) {
                    writeImportDeclaration(node);
                }
            }
            function writeImportDeclaration(node) {
                // note usage of writer. methods instead of aliases created, just to make sure we are using 
                // correct writer especially to handle asynchronous alias writing
                emitJsDocComments(node);
                if (node.flags & 1 /* Export */) {
                    writer.write("export ");
                }
                writer.write("import ");
                writer.write(getSourceTextOfLocalNode(node.name));
                writer.write(" = ");
                if (node.entityName) {
                    checkEntityNameAccessible();
                    writer.write(getSourceTextOfLocalNode(node.entityName));
                    writer.write(";");
                }
                else {
                    writer.write("require(");
                    writer.write(getSourceTextOfLocalNode(node.externalModuleName));
                    writer.write(");");
                }
                writer.writeLine();
                function checkEntityNameAccessible() {
                    var symbolAccesibilityResult = resolver.isImportDeclarationEntityNameReferenceDeclarationVisibile(node.entityName);
                    if (symbolAccesibilityResult.accessibility === 0 /* Accessible */) {
                        // write the aliases
                        if (symbolAccesibilityResult.aliasesToMakeVisible) {
                            writeAsychronousImportDeclarations(symbolAccesibilityResult.aliasesToMakeVisible);
                        }
                    }
                    else {
                        // Report error
                        reportedDeclarationError = true;
                        diagnostics.push(ts.createDiagnosticForNode(node, ts.Diagnostics.Import_declaration_0_is_using_private_name_1, getSourceTextOfLocalNode(node.name), symbolAccesibilityResult.errorSymbolName));
                    }
                }
            }
            function emitModuleDeclaration(node) {
                if (resolver.isDeclarationVisible(node)) {
                    emitJsDocComments(node);
                    emitDeclarationFlags(node);
                    write("module ");
                    emitSourceTextOfNode(node.name);
                    while (node.body.kind !== 178 /* ModuleBlock */) {
                        node = node.body;
                        write(".");
                        emitSourceTextOfNode(node.name);
                    }
                    var prevEnclosingDeclaration = enclosingDeclaration;
                    enclosingDeclaration = node;
                    write(" {");
                    writeLine();
                    increaseIndent();
                    emitLines(node.body.statements);
                    decreaseIndent();
                    write("}");
                    writeLine();
                    enclosingDeclaration = prevEnclosingDeclaration;
                }
            }
            function emitEnumDeclaration(node) {
                if (resolver.isDeclarationVisible(node)) {
                    emitJsDocComments(node);
                    emitDeclarationFlags(node);
                    write("enum ");
                    emitSourceTextOfNode(node.name);
                    write(" {");
                    writeLine();
                    increaseIndent();
                    emitLines(node.members);
                    decreaseIndent();
                    write("}");
                    writeLine();
                }
            }
            function emitEnumMemberDeclaration(node) {
                emitJsDocComments(node);
                emitSourceTextOfNode(node.name);
                var enumMemberValue = resolver.getEnumMemberValue(node);
                if (enumMemberValue !== undefined) {
                    write(" = ");
                    write(enumMemberValue.toString());
                }
                write(",");
                writeLine();
            }
            function emitTypeParameters(typeParameters) {
                function emitTypeParameter(node) {
                    function getTypeParameterConstraintVisibilityError(symbolAccesibilityResult) {
                        // Type parameter constraints are named by user so we should always be able to name it
                        var diagnosticMessage;
                        switch (node.parent.kind) {
                            case 174 /* ClassDeclaration */:
                                diagnosticMessage = symbolAccesibilityResult.errorModuleName ? ts.Diagnostics.Type_parameter_0_of_exported_class_has_or_is_using_name_1_from_private_module_2 : ts.Diagnostics.Type_parameter_0_of_exported_class_has_or_is_using_private_name_1;
                                break;
                            case 175 /* InterfaceDeclaration */:
                                diagnosticMessage = symbolAccesibilityResult.errorModuleName ? ts.Diagnostics.Type_parameter_0_of_exported_interface_has_or_is_using_name_1_from_private_module_2 : ts.Diagnostics.Type_parameter_0_of_exported_interface_has_or_is_using_private_name_1;
                                break;
                            case 125 /* ConstructSignature */:
                                diagnosticMessage = symbolAccesibilityResult.errorModuleName ? ts.Diagnostics.Type_parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_name_1_from_private_module_2 : ts.Diagnostics.Type_parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_private_name_1;
                                break;
                            case 124 /* CallSignature */:
                                diagnosticMessage = symbolAccesibilityResult.errorModuleName ? ts.Diagnostics.Type_parameter_0_of_call_signature_from_exported_interface_has_or_is_using_name_1_from_private_module_2 : ts.Diagnostics.Type_parameter_0_of_call_signature_from_exported_interface_has_or_is_using_private_name_1;
                                break;
                            case 120 /* Method */:
                                if (node.parent.flags & 128 /* Static */) {
                                    diagnosticMessage = symbolAccesibilityResult.errorModuleName ? ts.Diagnostics.Type_parameter_0_of_public_static_method_from_exported_class_has_or_is_using_name_1_from_private_module_2 : ts.Diagnostics.Type_parameter_0_of_public_static_method_from_exported_class_has_or_is_using_private_name_1;
                                }
                                else if (node.parent.parent.kind === 174 /* ClassDeclaration */) {
                                    diagnosticMessage = symbolAccesibilityResult.errorModuleName ? ts.Diagnostics.Type_parameter_0_of_public_method_from_exported_class_has_or_is_using_name_1_from_private_module_2 : ts.Diagnostics.Type_parameter_0_of_public_method_from_exported_class_has_or_is_using_private_name_1;
                                }
                                else {
                                    diagnosticMessage = symbolAccesibilityResult.errorModuleName ? ts.Diagnostics.Type_parameter_0_of_method_from_exported_interface_has_or_is_using_name_1_from_private_module_2 : ts.Diagnostics.Type_parameter_0_of_method_from_exported_interface_has_or_is_using_private_name_1;
                                }
                                break;
                            case 172 /* FunctionDeclaration */:
                                diagnosticMessage = symbolAccesibilityResult.errorModuleName ? ts.Diagnostics.Type_parameter_0_of_exported_function_has_or_is_using_name_1_from_private_module_2 : ts.Diagnostics.Type_parameter_0_of_exported_function_has_or_is_using_private_name_1;
                                break;
                            default:
                                ts.Debug.fail("This is unknown parent for type parameter: " + ts.SyntaxKind[node.parent.kind]);
                        }
                        return {
                            diagnosticMessage: diagnosticMessage,
                            errorNode: node,
                            typeName: node.name
                        };
                    }
                    increaseIndent();
                    emitJsDocComments(node);
                    decreaseIndent();
                    emitSourceTextOfNode(node.name);
                    // If there is constraint present and this is not a type parameter of the private method emit the constraint
                    if (node.constraint && (node.parent.kind !== 120 /* Method */ || !(node.parent.flags & 32 /* Private */))) {
                        write(" extends ");
                        getSymbolVisibilityDiagnosticMessage = getTypeParameterConstraintVisibilityError;
                        resolver.writeTypeAtLocation(node.constraint, enclosingDeclaration, 2 /* UseTypeOfFunction */, writer);
                    }
                }
                if (typeParameters) {
                    write("<");
                    emitCommaList(typeParameters, emitTypeParameter);
                    write(">");
                }
            }
            function emitHeritageClause(typeReferences, isImplementsList) {
                if (typeReferences) {
                    write(isImplementsList ? " implements " : " extends ");
                    emitCommaList(typeReferences, emitTypeOfTypeReference);
                }
                function emitTypeOfTypeReference(node) {
                    getSymbolVisibilityDiagnosticMessage = getHeritageClauseVisibilityError;
                    resolver.writeTypeAtLocation(node, enclosingDeclaration, 1 /* WriteArrayAsGenericType */ | 2 /* UseTypeOfFunction */, writer);
                    function getHeritageClauseVisibilityError(symbolAccesibilityResult) {
                        var diagnosticMessage;
                        // Heritage clause is written by user so it can always be named
                        if (node.parent.kind === 174 /* ClassDeclaration */) {
                            // Class
                            if (symbolAccesibilityResult.errorModuleName) {
                                // Module is inaccessible
                                diagnosticMessage = isImplementsList ? ts.Diagnostics.Implements_clause_of_exported_class_0_has_or_is_using_name_1_from_private_module_2 : ts.Diagnostics.Extends_clause_of_exported_class_0_has_or_is_using_name_1_from_private_module_2;
                            }
                            else {
                                // Class or Interface implemented/extended is inaccessible
                                diagnosticMessage = isImplementsList ? ts.Diagnostics.Implements_clause_of_exported_class_0_has_or_is_using_private_name_1 : ts.Diagnostics.Extends_clause_of_exported_class_0_has_or_is_using_private_name_1;
                            }
                        }
                        else {
                            if (symbolAccesibilityResult.errorModuleName) {
                                // Module is inaccessible
                                diagnosticMessage = ts.Diagnostics.Extends_clause_of_exported_interface_0_has_or_is_using_name_1_from_private_module_2;
                            }
                            else {
                                // interface is inaccessible
                                diagnosticMessage = ts.Diagnostics.Extends_clause_of_exported_interface_0_has_or_is_using_private_name_1;
                            }
                        }
                        return {
                            diagnosticMessage: diagnosticMessage,
                            errorNode: node,
                            typeName: node.parent.name
                        };
                    }
                }
            }
            function emitClassDeclaration(node) {
                function emitParameterProperties(constructorDeclaration) {
                    if (constructorDeclaration) {
                        ts.forEach(constructorDeclaration.parameters, function (param) {
                            if (param.flags & ts.NodeFlags.AccessibilityModifier) {
                                emitPropertyDeclaration(param);
                            }
                        });
                    }
                }
                if (resolver.isDeclarationVisible(node)) {
                    emitJsDocComments(node);
                    emitDeclarationFlags(node);
                    write("class ");
                    emitSourceTextOfNode(node.name);
                    var prevEnclosingDeclaration = enclosingDeclaration;
                    enclosingDeclaration = node;
                    emitTypeParameters(node.typeParameters);
                    if (node.baseType) {
                        emitHeritageClause([node.baseType], false);
                    }
                    emitHeritageClause(node.implementedTypes, true);
                    write(" {");
                    writeLine();
                    increaseIndent();
                    emitParameterProperties(getFirstConstructorWithBody(node));
                    emitLines(node.members);
                    decreaseIndent();
                    write("}");
                    writeLine();
                    enclosingDeclaration = prevEnclosingDeclaration;
                }
            }
            function emitInterfaceDeclaration(node) {
                if (resolver.isDeclarationVisible(node)) {
                    emitJsDocComments(node);
                    emitDeclarationFlags(node);
                    write("interface ");
                    emitSourceTextOfNode(node.name);
                    var prevEnclosingDeclaration = enclosingDeclaration;
                    enclosingDeclaration = node;
                    emitTypeParameters(node.typeParameters);
                    emitHeritageClause(node.baseTypes, false);
                    write(" {");
                    writeLine();
                    increaseIndent();
                    emitLines(node.members);
                    decreaseIndent();
                    write("}");
                    writeLine();
                    enclosingDeclaration = prevEnclosingDeclaration;
                }
            }
            function emitPropertyDeclaration(node) {
                emitJsDocComments(node);
                emitDeclarationFlags(node);
                emitVariableDeclaration(node);
                write(";");
                writeLine();
            }
            function emitVariableDeclaration(node) {
                // If we are emitting property it isn't moduleElement and hence we already know it needs to be emitted
                // so there is no check needed to see if declaration is visible
                if (node.kind !== 171 /* VariableDeclaration */ || resolver.isDeclarationVisible(node)) {
                    emitSourceTextOfNode(node.name);
                    // If optional property emit ?
                    if (node.kind === 119 /* Property */ && (node.flags & 4 /* QuestionMark */)) {
                        write("?");
                    }
                    if (!(node.flags & 32 /* Private */)) {
                        write(": ");
                        getSymbolVisibilityDiagnosticMessage = getVariableDeclarationTypeVisibilityError;
                        resolver.writeTypeAtLocation(node, enclosingDeclaration, 2 /* UseTypeOfFunction */, writer);
                    }
                }
                function getVariableDeclarationTypeVisibilityError(symbolAccesibilityResult) {
                    var diagnosticMessage;
                    if (node.kind === 171 /* VariableDeclaration */) {
                        diagnosticMessage = symbolAccesibilityResult.errorModuleName ? symbolAccesibilityResult.accessibility === 2 /* CannotBeNamed */ ? ts.Diagnostics.Exported_variable_0_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named : ts.Diagnostics.Exported_variable_0_has_or_is_using_name_1_from_private_module_2 : ts.Diagnostics.Exported_variable_0_has_or_is_using_private_name_1;
                    }
                    else if (node.kind === 119 /* Property */) {
                        if (node.flags & 128 /* Static */) {
                            diagnosticMessage = symbolAccesibilityResult.errorModuleName ? symbolAccesibilityResult.accessibility === 2 /* CannotBeNamed */ ? ts.Diagnostics.Public_static_property_0_of_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named : ts.Diagnostics.Public_static_property_0_of_exported_class_has_or_is_using_name_1_from_private_module_2 : ts.Diagnostics.Public_static_property_0_of_exported_class_has_or_is_using_private_name_1;
                        }
                        else if (node.parent.kind === 174 /* ClassDeclaration */) {
                            diagnosticMessage = symbolAccesibilityResult.errorModuleName ? symbolAccesibilityResult.accessibility === 2 /* CannotBeNamed */ ? ts.Diagnostics.Public_property_0_of_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named : ts.Diagnostics.Public_property_0_of_exported_class_has_or_is_using_name_1_from_private_module_2 : ts.Diagnostics.Public_property_0_of_exported_class_has_or_is_using_private_name_1;
                        }
                        else {
                            // Interfaces cannot have types that cannot be named
                            diagnosticMessage = symbolAccesibilityResult.errorModuleName ? ts.Diagnostics.Property_0_of_exported_interface_has_or_is_using_name_1_from_private_module_2 : ts.Diagnostics.Property_0_of_exported_interface_has_or_is_using_private_name_1;
                        }
                    }
                    return diagnosticMessage !== undefined ? {
                        diagnosticMessage: diagnosticMessage,
                        errorNode: node,
                        typeName: node.name
                    } : undefined;
                }
            }
            function emitVariableStatement(node) {
                var hasDeclarationWithEmit = ts.forEach(node.declarations, function (varDeclaration) { return resolver.isDeclarationVisible(varDeclaration); });
                if (hasDeclarationWithEmit) {
                    emitJsDocComments(node);
                    emitDeclarationFlags(node);
                    write("var ");
                    emitCommaList(node.declarations, emitVariableDeclaration);
                    write(";");
                    writeLine();
                }
            }
            function emitAccessorDeclaration(node) {
                var accessors = getAllAccessorDeclarations(node.parent, node);
                if (node === accessors.firstAccessor) {
                    emitJsDocComments(accessors.getAccessor);
                    emitJsDocComments(accessors.setAccessor);
                    emitDeclarationFlags(node);
                    emitSourceTextOfNode(node.name);
                    if (!(node.flags & 32 /* Private */)) {
                        write(": ");
                        getSymbolVisibilityDiagnosticMessage = getAccessorDeclarationTypeVisibilityError;
                        resolver.writeTypeAtLocation(node, enclosingDeclaration, 2 /* UseTypeOfFunction */, writer);
                    }
                    write(";");
                    writeLine();
                }
                function getAccessorDeclarationTypeVisibilityError(symbolAccesibilityResult) {
                    var diagnosticMessage;
                    if (node.kind === 123 /* SetAccessor */) {
                        // Setters have to have type named and cannot infer it so, the type should always be named
                        if (node.parent.flags & 128 /* Static */) {
                            diagnosticMessage = symbolAccesibilityResult.errorModuleName ? ts.Diagnostics.Parameter_0_of_public_static_property_setter_from_exported_class_has_or_is_using_name_1_from_private_module_2 : ts.Diagnostics.Parameter_0_of_public_static_property_setter_from_exported_class_has_or_is_using_private_name_1;
                        }
                        else {
                            diagnosticMessage = symbolAccesibilityResult.errorModuleName ? ts.Diagnostics.Parameter_0_of_public_property_setter_from_exported_class_has_or_is_using_name_1_from_private_module_2 : ts.Diagnostics.Parameter_0_of_public_property_setter_from_exported_class_has_or_is_using_private_name_1;
                        }
                        return {
                            diagnosticMessage: diagnosticMessage,
                            errorNode: node.parameters[0],
                            typeName: node.name
                        };
                    }
                    else {
                        if (node.flags & 128 /* Static */) {
                            diagnosticMessage = symbolAccesibilityResult.errorModuleName ? symbolAccesibilityResult.accessibility === 2 /* CannotBeNamed */ ? ts.Diagnostics.Return_type_of_public_static_property_getter_from_exported_class_has_or_is_using_name_0_from_external_module_1_but_cannot_be_named : ts.Diagnostics.Return_type_of_public_static_property_getter_from_exported_class_has_or_is_using_name_0_from_private_module_1 : ts.Diagnostics.Return_type_of_public_static_property_getter_from_exported_class_has_or_is_using_private_name_0;
                        }
                        else {
                            diagnosticMessage = symbolAccesibilityResult.errorModuleName ? symbolAccesibilityResult.accessibility === 2 /* CannotBeNamed */ ? ts.Diagnostics.Return_type_of_public_property_getter_from_exported_class_has_or_is_using_name_0_from_external_module_1_but_cannot_be_named : ts.Diagnostics.Return_type_of_public_property_getter_from_exported_class_has_or_is_using_name_0_from_private_module_1 : ts.Diagnostics.Return_type_of_public_property_getter_from_exported_class_has_or_is_using_private_name_0;
                        }
                        return {
                            diagnosticMessage: diagnosticMessage,
                            errorNode: node.name,
                            typeName: undefined
                        };
                    }
                }
            }
            function emitFunctionDeclaration(node) {
                // If we are emitting Method/Constructor it isn't moduleElement and hence already determined to be emitting
                // so no need to verify if the declaration is visible
                if ((node.kind !== 172 /* FunctionDeclaration */ || resolver.isDeclarationVisible(node)) && !resolver.isImplementationOfOverload(node)) {
                    emitJsDocComments(node);
                    emitDeclarationFlags(node);
                    if (node.kind === 172 /* FunctionDeclaration */) {
                        write("function ");
                        emitSourceTextOfNode(node.name);
                    }
                    else if (node.kind === 121 /* Constructor */) {
                        write("constructor");
                    }
                    else {
                        emitSourceTextOfNode(node.name);
                        if (node.flags & 4 /* QuestionMark */) {
                            write("?");
                        }
                    }
                    emitSignatureDeclaration(node);
                }
            }
            function emitConstructSignatureDeclaration(node) {
                emitJsDocComments(node);
                write("new ");
                emitSignatureDeclaration(node);
            }
            function emitSignatureDeclaration(node) {
                if (node.kind === 124 /* CallSignature */ || node.kind === 126 /* IndexSignature */) {
                    // Only index and call signatures are emitted directly, so emit their js doc comments, rest will do that in their own functions
                    emitJsDocComments(node);
                }
                emitTypeParameters(node.typeParameters);
                if (node.kind === 126 /* IndexSignature */) {
                    write("[");
                }
                else {
                    write("(");
                }
                // Parameters
                emitCommaList(node.parameters, emitParameterDeclaration);
                if (node.kind === 126 /* IndexSignature */) {
                    write("]");
                }
                else {
                    write(")");
                }
                // If this is not a constructor and is not private, emit the return type
                if (node.kind !== 121 /* Constructor */ && !(node.flags & 32 /* Private */)) {
                    write(": ");
                    getSymbolVisibilityDiagnosticMessage = getReturnTypeVisibilityError;
                    resolver.writeReturnTypeOfSignatureDeclaration(node, enclosingDeclaration, 2 /* UseTypeOfFunction */, writer);
                }
                write(";");
                writeLine();
                function getReturnTypeVisibilityError(symbolAccesibilityResult) {
                    var diagnosticMessage;
                    switch (node.kind) {
                        case 125 /* ConstructSignature */:
                            // Interfaces cannot have return types that cannot be named
                            diagnosticMessage = symbolAccesibilityResult.errorModuleName ? ts.Diagnostics.Return_type_of_constructor_signature_from_exported_interface_has_or_is_using_name_0_from_private_module_1 : ts.Diagnostics.Return_type_of_constructor_signature_from_exported_interface_has_or_is_using_private_name_0;
                            break;
                        case 124 /* CallSignature */:
                            // Interfaces cannot have return types that cannot be named
                            diagnosticMessage = symbolAccesibilityResult.errorModuleName ? ts.Diagnostics.Return_type_of_call_signature_from_exported_interface_has_or_is_using_name_0_from_private_module_1 : ts.Diagnostics.Return_type_of_call_signature_from_exported_interface_has_or_is_using_private_name_0;
                            break;
                        case 126 /* IndexSignature */:
                            // Interfaces cannot have return types that cannot be named
                            diagnosticMessage = symbolAccesibilityResult.errorModuleName ? ts.Diagnostics.Return_type_of_index_signature_from_exported_interface_has_or_is_using_name_0_from_private_module_1 : ts.Diagnostics.Return_type_of_index_signature_from_exported_interface_has_or_is_using_private_name_0;
                            break;
                        case 120 /* Method */:
                            if (node.flags & 128 /* Static */) {
                                diagnosticMessage = symbolAccesibilityResult.errorModuleName ? symbolAccesibilityResult.accessibility === 2 /* CannotBeNamed */ ? ts.Diagnostics.Return_type_of_public_static_method_from_exported_class_has_or_is_using_name_0_from_external_module_1_but_cannot_be_named : ts.Diagnostics.Return_type_of_public_static_method_from_exported_class_has_or_is_using_name_0_from_private_module_1 : ts.Diagnostics.Return_type_of_public_static_method_from_exported_class_has_or_is_using_private_name_0;
                            }
                            else if (node.parent.kind === 174 /* ClassDeclaration */) {
                                diagnosticMessage = symbolAccesibilityResult.errorModuleName ? symbolAccesibilityResult.accessibility === 2 /* CannotBeNamed */ ? ts.Diagnostics.Return_type_of_public_method_from_exported_class_has_or_is_using_name_0_from_external_module_1_but_cannot_be_named : ts.Diagnostics.Return_type_of_public_method_from_exported_class_has_or_is_using_name_0_from_private_module_1 : ts.Diagnostics.Return_type_of_public_method_from_exported_class_has_or_is_using_private_name_0;
                            }
                            else {
                                // Interfaces cannot have return types that cannot be named
                                diagnosticMessage = symbolAccesibilityResult.errorModuleName ? ts.Diagnostics.Return_type_of_method_from_exported_interface_has_or_is_using_name_0_from_private_module_1 : ts.Diagnostics.Return_type_of_method_from_exported_interface_has_or_is_using_private_name_0;
                            }
                            break;
                        case 172 /* FunctionDeclaration */:
                            diagnosticMessage = symbolAccesibilityResult.errorModuleName ? symbolAccesibilityResult.accessibility === 2 /* CannotBeNamed */ ? ts.Diagnostics.Return_type_of_exported_function_has_or_is_using_name_0_from_external_module_1_but_cannot_be_named : ts.Diagnostics.Return_type_of_exported_function_has_or_is_using_name_0_from_private_module_1 : ts.Diagnostics.Return_type_of_exported_function_has_or_is_using_private_name_0;
                            break;
                        default:
                            ts.Debug.fail("This is unknown kind for signature: " + ts.SyntaxKind[node.kind]);
                    }
                    return {
                        diagnosticMessage: diagnosticMessage,
                        errorNode: node.name || node
                    };
                }
            }
            function emitParameterDeclaration(node) {
                increaseIndent();
                emitJsDocComments(node);
                if (node.flags & 8 /* Rest */) {
                    write("...");
                }
                emitSourceTextOfNode(node.name);
                if (node.initializer || (node.flags & 4 /* QuestionMark */)) {
                    write("?");
                }
                decreaseIndent();
                if (!(node.parent.flags & 32 /* Private */)) {
                    write(": ");
                    getSymbolVisibilityDiagnosticMessage = getParameterDeclarationTypeVisibilityError;
                    resolver.writeTypeAtLocation(node, enclosingDeclaration, 2 /* UseTypeOfFunction */, writer);
                }
                function getParameterDeclarationTypeVisibilityError(symbolAccesibilityResult) {
                    var diagnosticMessage;
                    switch (node.parent.kind) {
                        case 121 /* Constructor */:
                            diagnosticMessage = symbolAccesibilityResult.errorModuleName ? symbolAccesibilityResult.accessibility === 2 /* CannotBeNamed */ ? ts.Diagnostics.Parameter_0_of_constructor_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named : ts.Diagnostics.Parameter_0_of_constructor_from_exported_class_has_or_is_using_name_1_from_private_module_2 : ts.Diagnostics.Parameter_0_of_constructor_from_exported_class_has_or_is_using_private_name_1;
                            break;
                        case 125 /* ConstructSignature */:
                            // Interfaces cannot have parameter types that cannot be named
                            diagnosticMessage = symbolAccesibilityResult.errorModuleName ? ts.Diagnostics.Parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_name_1_from_private_module_2 : ts.Diagnostics.Parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_private_name_1;
                            break;
                        case 124 /* CallSignature */:
                            // Interfaces cannot have parameter types that cannot be named
                            diagnosticMessage = symbolAccesibilityResult.errorModuleName ? ts.Diagnostics.Parameter_0_of_call_signature_from_exported_interface_has_or_is_using_name_1_from_private_module_2 : ts.Diagnostics.Parameter_0_of_call_signature_from_exported_interface_has_or_is_using_private_name_1;
                            break;
                        case 120 /* Method */:
                            if (node.parent.flags & 128 /* Static */) {
                                diagnosticMessage = symbolAccesibilityResult.errorModuleName ? symbolAccesibilityResult.accessibility === 2 /* CannotBeNamed */ ? ts.Diagnostics.Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named : ts.Diagnostics.Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_name_1_from_private_module_2 : ts.Diagnostics.Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_private_name_1;
                            }
                            else if (node.parent.parent.kind === 174 /* ClassDeclaration */) {
                                diagnosticMessage = symbolAccesibilityResult.errorModuleName ? symbolAccesibilityResult.accessibility === 2 /* CannotBeNamed */ ? ts.Diagnostics.Parameter_0_of_public_method_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named : ts.Diagnostics.Parameter_0_of_public_method_from_exported_class_has_or_is_using_name_1_from_private_module_2 : ts.Diagnostics.Parameter_0_of_public_method_from_exported_class_has_or_is_using_private_name_1;
                            }
                            else {
                                // Interfaces cannot have parameter types that cannot be named
                                diagnosticMessage = symbolAccesibilityResult.errorModuleName ? ts.Diagnostics.Parameter_0_of_method_from_exported_interface_has_or_is_using_name_1_from_private_module_2 : ts.Diagnostics.Parameter_0_of_method_from_exported_interface_has_or_is_using_private_name_1;
                            }
                            break;
                        case 172 /* FunctionDeclaration */:
                            diagnosticMessage = symbolAccesibilityResult.errorModuleName ? symbolAccesibilityResult.accessibility === 2 /* CannotBeNamed */ ? ts.Diagnostics.Parameter_0_of_exported_function_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named : ts.Diagnostics.Parameter_0_of_exported_function_has_or_is_using_name_1_from_private_module_2 : ts.Diagnostics.Parameter_0_of_exported_function_has_or_is_using_private_name_1;
                            break;
                        default:
                            ts.Debug.fail("This is unknown parent for parameter: " + ts.SyntaxKind[node.parent.kind]);
                    }
                    return {
                        diagnosticMessage: diagnosticMessage,
                        errorNode: node,
                        typeName: node.name
                    };
                }
            }
            function emitNode(node) {
                switch (node.kind) {
                    case 121 /* Constructor */:
                    case 172 /* FunctionDeclaration */:
                    case 120 /* Method */:
                        return emitFunctionDeclaration(node);
                    case 125 /* ConstructSignature */:
                        return emitConstructSignatureDeclaration(node);
                    case 124 /* CallSignature */:
                    case 126 /* IndexSignature */:
                        return emitSignatureDeclaration(node);
                    case 122 /* GetAccessor */:
                    case 123 /* SetAccessor */:
                        return emitAccessorDeclaration(node);
                    case 149 /* VariableStatement */:
                        return emitVariableStatement(node);
                    case 119 /* Property */:
                        return emitPropertyDeclaration(node);
                    case 175 /* InterfaceDeclaration */:
                        return emitInterfaceDeclaration(node);
                    case 174 /* ClassDeclaration */:
                        return emitClassDeclaration(node);
                    case 181 /* EnumMember */:
                        return emitEnumMemberDeclaration(node);
                    case 176 /* EnumDeclaration */:
                        return emitEnumDeclaration(node);
                    case 177 /* ModuleDeclaration */:
                        return emitModuleDeclaration(node);
                    case 179 /* ImportDeclaration */:
                        return emitImportDeclaration(node);
                    case 180 /* ExportAssignment */:
                        return emitExportAssignment(node);
                    case 182 /* SourceFile */:
                        return emitSourceFile(node);
                }
            }
            function resolveScriptReference(sourceFile, reference) {
                var referenceFileName = ts.normalizePath(ts.combinePaths(ts.getDirectoryPath(sourceFile.filename), reference.filename));
                return program.getSourceFile(referenceFileName);
            }
            // Contains the reference paths that needs to go in the declaration file. 
            // Collecting this separately because reference paths need to be first thing in the declaration file 
            // and we could be collecting these paths from multiple files into single one with --out option
            var referencePathsOutput = "";
            function writeReferencePath(referencedFile) {
                var declFileName = referencedFile.flags & 1024 /* DeclarationFile */ ? referencedFile.filename : shouldEmitToOwnFile(referencedFile, compilerOptions) ? getOwnEmitOutputFilePath(referencedFile, ".d.ts") : ts.getModuleNameFromFilename(compilerOptions.out) + ".d.ts"; // Global out file
                declFileName = ts.getRelativePathToDirectoryOrUrl(ts.getDirectoryPath(ts.normalizeSlashes(jsFilePath)), declFileName, compilerHost.getCurrentDirectory(), false);
                referencePathsOutput += "/// <reference path=\"" + declFileName + "\" />" + newLine;
            }
            if (root) {
                // Emitting just a single file, so emit references in this file only
                if (!compilerOptions.noResolve) {
                    var addedGlobalFileReference = false;
                    ts.forEach(root.referencedFiles, function (fileReference) {
                        var referencedFile = resolveScriptReference(root, fileReference);
                        // All the references that are not going to be part of same file
                        if ((referencedFile.flags & 1024 /* DeclarationFile */) || shouldEmitToOwnFile(referencedFile, compilerOptions) || !addedGlobalFileReference) {
                            writeReferencePath(referencedFile);
                            if (!isExternalModuleOrDeclarationFile(referencedFile)) {
                                addedGlobalFileReference = true;
                            }
                        }
                    });
                }
                emitNode(root);
            }
            else {
                // Emit references corresponding to this file
                var emittedReferencedFiles = [];
                ts.forEach(program.getSourceFiles(), function (sourceFile) {
                    if (!isExternalModuleOrDeclarationFile(sourceFile)) {
                        // Check what references need to be added
                        if (!compilerOptions.noResolve) {
                            ts.forEach(sourceFile.referencedFiles, function (fileReference) {
                                var referencedFile = resolveScriptReference(sourceFile, fileReference);
                                // If the reference file is a declaration file or an external module, emit that reference
                                if (isExternalModuleOrDeclarationFile(referencedFile) && !ts.contains(emittedReferencedFiles, referencedFile)) {
                                    writeReferencePath(referencedFile);
                                    emittedReferencedFiles.push(referencedFile);
                                }
                            });
                        }
                        emitNode(sourceFile);
                    }
                });
            }
            // TODO(shkamat): Should we not write any declaration file if any of them can produce error, 
            // or should we just not write this file like we are doing now
            if (!reportedDeclarationError) {
                var declarationOutput = referencePathsOutput;
                var synchronousDeclarationOutput = writer.getText();
                // apply additions
                var appliedSyncOutputPos = 0;
                ts.forEach(aliasDeclarationEmitInfo, function (aliasEmitInfo) {
                    if (aliasEmitInfo.asynchronousOutput) {
                        declarationOutput += synchronousDeclarationOutput.substring(appliedSyncOutputPos, aliasEmitInfo.outputPos);
                        declarationOutput += aliasEmitInfo.asynchronousOutput;
                        appliedSyncOutputPos = aliasEmitInfo.outputPos;
                    }
                });
                declarationOutput += synchronousDeclarationOutput.substring(appliedSyncOutputPos);
                writeFile(ts.getModuleNameFromFilename(jsFilePath) + ".d.ts", declarationOutput, compilerOptions.emitBOM);
            }
        }
        var hasSemanticErrors = resolver.hasSemanticErrors();
        function emitFile(jsFilePath, sourceFile) {
            emitJavaScript(jsFilePath, sourceFile);
            if (!hasSemanticErrors && compilerOptions.declaration) {
                emitDeclarations(jsFilePath, sourceFile);
            }
        }
        if (targetSourceFile === undefined) {
            ts.forEach(program.getSourceFiles(), function (sourceFile) {
                if (shouldEmitToOwnFile(sourceFile, compilerOptions)) {
                    var jsFilePath = getOwnEmitOutputFilePath(sourceFile, ".js");
                    emitFile(jsFilePath, sourceFile);
                }
            });
        }
        else {
            // Emit only one file specified in targetFilename. This is mainly used in compilerOnSave feature
            var jsFilePath = getOwnEmitOutputFilePath(targetSourceFile, ".js");
            emitFile(jsFilePath, targetSourceFile);
        }
        if (compilerOptions.out) {
            emitFile(compilerOptions.out);
        }
        // Sort and make the unique list of diagnostics
        diagnostics.sort(ts.compareDiagnostics);
        diagnostics = ts.deduplicateSortedDiagnostics(diagnostics);
        // Update returnCode if there is any EmitterError
        var hasEmitterError = ts.forEach(diagnostics, function (diagnostic) { return diagnostic.category === 1 /* Error */; });
        // Check and update returnCode for syntactic and semantic
        var returnCode;
        if (hasEmitterError) {
            returnCode = 4 /* EmitErrorsEncountered */;
        }
        else if (hasSemanticErrors && compilerOptions.declaration) {
            returnCode = 3 /* DeclarationGenerationSkipped */;
        }
        else if (hasSemanticErrors && !compilerOptions.declaration) {
            returnCode = 2 /* JSGeneratedWithSemanticErrors */;
        }
        else {
            returnCode = 0 /* Succeeded */;
        }
        return {
            emitResultStatus: returnCode,
            errors: diagnostics,
            sourceMaps: sourceMapDataList
        };
    }
    ts.emitFiles = emitFiles;
})(ts || (ts = {}));
/// <reference path="types.ts"/>
/// <reference path="core.ts"/>
/// <reference path="scanner.ts"/>
/// <reference path="parser.ts"/>
/// <reference path="binder.ts"/>
/// <reference path="emitter.ts"/>
var ts;
(function (ts) {
    var nextSymbolId = 1;
    var nextNodeId = 1;
    var nextMergeId = 1;
    function getDeclarationOfKind(symbol, kind) {
        var declarations = symbol.declarations;
        for (var i = 0; i < declarations.length; i++) {
            var declaration = declarations[i];
            if (declaration.kind === kind) {
                return declaration;
            }
        }
        return undefined;
    }
    ts.getDeclarationOfKind = getDeclarationOfKind;
    /// fullTypeCheck denotes if this instance of the typechecker will be used to get semantic diagnostics.
    /// If fullTypeCheck === true,  then the typechecker should do every possible check to produce all errors
    /// If fullTypeCheck === false, the typechecker can take shortcuts and skip checks that only produce errors.
    /// NOTE: checks that somehow affect decisions being made during typechecking should be executed in both cases.
    function createTypeChecker(program, fullTypeCheck) {
        var Symbol = ts.objectAllocator.getSymbolConstructor();
        var Type = ts.objectAllocator.getTypeConstructor();
        var Signature = ts.objectAllocator.getSignatureConstructor();
        var typeCount = 0;
        var emptyArray = [];
        var emptySymbols = {};
        var compilerOptions = program.getCompilerOptions();
        var checker = {
            getProgram: function () { return program; },
            getDiagnostics: getDiagnostics,
            getGlobalDiagnostics: getGlobalDiagnostics,
            getNodeCount: function () { return ts.sum(program.getSourceFiles(), "nodeCount"); },
            getIdentifierCount: function () { return ts.sum(program.getSourceFiles(), "identifierCount"); },
            getSymbolCount: function () { return ts.sum(program.getSourceFiles(), "symbolCount"); },
            getTypeCount: function () { return typeCount; },
            checkProgram: checkProgram,
            emitFiles: invokeEmitter,
            getParentOfSymbol: getParentOfSymbol,
            getTypeOfSymbol: getTypeOfSymbol,
            getPropertiesOfType: getPropertiesOfType,
            getPropertyOfType: getPropertyOfType,
            getSignaturesOfType: getSignaturesOfType,
            getIndexTypeOfType: getIndexTypeOfType,
            getReturnTypeOfSignature: getReturnTypeOfSignature,
            getSymbolsInScope: getSymbolsInScope,
            getSymbolInfo: getSymbolInfo,
            getTypeOfNode: getTypeOfNode,
            getApparentType: getApparentType,
            typeToString: typeToString,
            typeToDisplayParts: typeToDisplayParts,
            symbolToString: symbolToString,
            symbolToDisplayParts: symbolToDisplayParts,
            getAugmentedPropertiesOfApparentType: getAugmentedPropertiesOfApparentType,
            getRootSymbol: getRootSymbol,
            getContextualType: getContextualType,
            getFullyQualifiedName: getFullyQualifiedName,
            getEnumMemberValue: getEnumMemberValue
        };
        var undefinedSymbol = createSymbol(2 /* Property */ | 33554432 /* Transient */, "undefined");
        var argumentsSymbol = createSymbol(2 /* Property */ | 33554432 /* Transient */, "arguments");
        var unknownSymbol = createSymbol(2 /* Property */ | 33554432 /* Transient */, "unknown");
        var resolvingSymbol = createSymbol(33554432 /* Transient */, "__resolving__");
        var anyType = createIntrinsicType(1 /* Any */, "any");
        var stringType = createIntrinsicType(2 /* String */, "string");
        var numberType = createIntrinsicType(4 /* Number */, "number");
        var booleanType = createIntrinsicType(8 /* Boolean */, "boolean");
        var voidType = createIntrinsicType(16 /* Void */, "void");
        var undefinedType = createIntrinsicType(32 /* Undefined */, "undefined");
        var nullType = createIntrinsicType(64 /* Null */, "null");
        var unknownType = createIntrinsicType(1 /* Any */, "unknown");
        var resolvingType = createIntrinsicType(1 /* Any */, "__resolving__");
        var emptyObjectType = createAnonymousType(undefined, emptySymbols, emptyArray, emptyArray, undefined, undefined);
        var anyFunctionType = createAnonymousType(undefined, emptySymbols, emptyArray, emptyArray, undefined, undefined);
        var noConstraintType = createAnonymousType(undefined, emptySymbols, emptyArray, emptyArray, undefined, undefined);
        var anySignature = createSignature(undefined, undefined, emptyArray, anyType, 0, false, false);
        var unknownSignature = createSignature(undefined, undefined, emptyArray, unknownType, 0, false, false);
        var globals = {};
        var globalArraySymbol;
        var globalObjectType;
        var globalFunctionType;
        var globalArrayType;
        var globalStringType;
        var globalNumberType;
        var globalBooleanType;
        var globalRegExpType;
        var tupleTypes = {};
        var stringLiteralTypes = {};
        var emitExtends = false;
        var mergedSymbols = [];
        var symbolLinks = [];
        var nodeLinks = [];
        var potentialThisCollisions = [];
        var diagnostics = [];
        var diagnosticsModified = false;
        function addDiagnostic(diagnostic) {
            diagnostics.push(diagnostic);
            diagnosticsModified = true;
        }
        function error(location, message, arg0, arg1, arg2) {
            var diagnostic = location ? ts.createDiagnosticForNode(location, message, arg0, arg1, arg2) : ts.createCompilerDiagnostic(message, arg0, arg1, arg2);
            addDiagnostic(diagnostic);
        }
        function createSymbol(flags, name) {
            return new Symbol(flags, name);
        }
        function getExcludedSymbolFlags(flags) {
            var result = 0;
            if (flags & 1 /* Variable */)
                result |= ts.SymbolFlags.VariableExcludes;
            if (flags & 2 /* Property */)
                result |= ts.SymbolFlags.PropertyExcludes;
            if (flags & 4 /* EnumMember */)
                result |= ts.SymbolFlags.EnumMemberExcludes;
            if (flags & 8 /* Function */)
                result |= ts.SymbolFlags.FunctionExcludes;
            if (flags & 16 /* Class */)
                result |= ts.SymbolFlags.ClassExcludes;
            if (flags & 32 /* Interface */)
                result |= ts.SymbolFlags.InterfaceExcludes;
            if (flags & 64 /* Enum */)
                result |= ts.SymbolFlags.EnumExcludes;
            if (flags & 128 /* ValueModule */)
                result |= ts.SymbolFlags.ValueModuleExcludes;
            if (flags & 2048 /* Method */)
                result |= ts.SymbolFlags.MethodExcludes;
            if (flags & 8192 /* GetAccessor */)
                result |= ts.SymbolFlags.GetAccessorExcludes;
            if (flags & 16384 /* SetAccessor */)
                result |= ts.SymbolFlags.SetAccessorExcludes;
            if (flags & 262144 /* TypeParameter */)
                result |= ts.SymbolFlags.TypeParameterExcludes;
            if (flags & 4194304 /* Import */)
                result |= ts.SymbolFlags.ImportExcludes;
            return result;
        }
        function recordMergedSymbol(target, source) {
            if (!source.mergeId)
                source.mergeId = nextMergeId++;
            mergedSymbols[source.mergeId] = target;
        }
        function cloneSymbol(symbol) {
            var result = createSymbol(symbol.flags | 16777216 /* Merged */, symbol.name);
            result.declarations = symbol.declarations.slice(0);
            result.parent = symbol.parent;
            if (symbol.valueDeclaration)
                result.valueDeclaration = symbol.valueDeclaration;
            if (symbol.members)
                result.members = cloneSymbolTable(symbol.members);
            if (symbol.exports)
                result.exports = cloneSymbolTable(symbol.exports);
            recordMergedSymbol(result, symbol);
            return result;
        }
        function extendSymbol(target, source) {
            if (!(target.flags & getExcludedSymbolFlags(source.flags))) {
                target.flags |= source.flags;
                if (!target.valueDeclaration && source.valueDeclaration)
                    target.valueDeclaration = source.valueDeclaration;
                ts.forEach(source.declarations, function (node) {
                    target.declarations.push(node);
                });
                if (source.members) {
                    if (!target.members)
                        target.members = {};
                    extendSymbolTable(target.members, source.members);
                }
                if (source.exports) {
                    if (!target.exports)
                        target.exports = {};
                    extendSymbolTable(target.exports, source.exports);
                }
                recordMergedSymbol(target, source);
            }
            else {
                ts.forEach(source.declarations, function (node) {
                    error(node.name ? node.name : node, ts.Diagnostics.Duplicate_identifier_0, symbolToString(source));
                });
            }
        }
        function cloneSymbolTable(symbolTable) {
            var result = {};
            for (var id in symbolTable) {
                if (ts.hasProperty(symbolTable, id)) {
                    result[id] = symbolTable[id];
                }
            }
            return result;
        }
        function extendSymbolTable(target, source) {
            for (var id in source) {
                if (ts.hasProperty(source, id)) {
                    if (!ts.hasProperty(target, id)) {
                        target[id] = source[id];
                    }
                    else {
                        var symbol = target[id];
                        if (!(symbol.flags & 16777216 /* Merged */)) {
                            target[id] = symbol = cloneSymbol(symbol);
                        }
                        extendSymbol(symbol, source[id]);
                    }
                }
            }
        }
        function getSymbolLinks(symbol) {
            if (symbol.flags & 33554432 /* Transient */)
                return symbol;
            if (!symbol.id)
                symbol.id = nextSymbolId++;
            return symbolLinks[symbol.id] || (symbolLinks[symbol.id] = {});
        }
        function getNodeLinks(node) {
            if (!node.id)
                node.id = nextNodeId++;
            return nodeLinks[node.id] || (nodeLinks[node.id] = {});
        }
        function getSourceFile(node) {
            return ts.getAncestor(node, 182 /* SourceFile */);
        }
        function isGlobalSourceFile(node) {
            return node.kind === 182 /* SourceFile */ && !ts.isExternalModule(node);
        }
        function getSymbol(symbols, name, meaning) {
            if (meaning && ts.hasProperty(symbols, name)) {
                var symbol = symbols[name];
                ts.Debug.assert((symbol.flags & 8388608 /* Instantiated */) === 0, "Should never get an instantiated symbol here.");
                if (symbol.flags & meaning) {
                    return symbol;
                }
                if (symbol.flags & 4194304 /* Import */) {
                    var target = resolveImport(symbol);
                    // unknown symbol will mean that there were reported error during import resolution
                    // treat it as positive answer to avoid cascading errors
                    if (target === unknownSymbol || target.flags & meaning) {
                        return symbol;
                    }
                }
            }
            // return undefined if we can't find a symbol.
        }
        function resolveName(location, name, meaning, nameNotFoundMessage, nameArg) {
            var errorLocation = location;
            var result;
            var lastLocation;
            var memberWithInitializerThatReferencesIdentifierFromConstructor;
            function returnResolvedSymbol(s) {
                // we've seen member with initializer that references identifier defined in constructor during the search.
                // if this was the only result with given name then just report default 'nameNotFound' message.
                // however if we met something else that was 'shadowed' by the identifier in constructor - report more specific error
                if (s && memberWithInitializerThatReferencesIdentifierFromConstructor) {
                    var propertyName = memberWithInitializerThatReferencesIdentifierFromConstructor.name;
                    error(errorLocation, ts.Diagnostics.Initializer_of_instance_member_variable_0_cannot_reference_identifier_1_declared_in_the_constructor, ts.identifierToString(propertyName), nameArg);
                    return undefined;
                }
                if (!s && nameNotFoundMessage) {
                    error(errorLocation, nameNotFoundMessage, nameArg);
                }
                return s;
            }
            while (location) {
                // Locals of a source file are not in scope (because they get merged into the global symbol table)
                if (location.locals && !isGlobalSourceFile(location)) {
                    if (result = getSymbol(location.locals, name, meaning)) {
                        return returnResolvedSymbol(result);
                    }
                }
                switch (location.kind) {
                    case 182 /* SourceFile */:
                        if (!ts.isExternalModule(location))
                            break;
                    case 177 /* ModuleDeclaration */:
                        if (result = getSymbol(getSymbolOfNode(location).exports, name, meaning & ts.SymbolFlags.ModuleMember)) {
                            return returnResolvedSymbol(result);
                        }
                        break;
                    case 176 /* EnumDeclaration */:
                        if (result = getSymbol(getSymbolOfNode(location).exports, name, meaning & 4 /* EnumMember */)) {
                            return returnResolvedSymbol(result);
                        }
                        break;
                    case 119 /* Property */:
                        // TypeScript 1.0 spec (April 2014): 8.4.1
                        // Initializer expressions for instance member variables are evaluated in the scope 
                        // of the class constructor body but are not permitted to reference parameters or 
                        // local variables of the constructor.This effectively means that entities from outer scopes 
                        // by the same name as a constructor parameter or local variable are inaccessible 
                        // in initializer expressions for instance member variables.
                        if (location.parent.kind === 174 /* ClassDeclaration */ && !(location.flags & 128 /* Static */)) {
                            var ctor = findConstructorDeclaration(location.parent);
                            if (ctor && ctor.locals) {
                                if (getSymbol(ctor.locals, name, meaning & ts.SymbolFlags.Value)) {
                                    // save the property node - later it will be used by 'returnResolvedSymbol' to report appropriate error
                                    memberWithInitializerThatReferencesIdentifierFromConstructor = location;
                                }
                            }
                        }
                        break;
                    case 174 /* ClassDeclaration */:
                    case 175 /* InterfaceDeclaration */:
                        if (result = getSymbol(getSymbolOfNode(location).members, name, meaning & ts.SymbolFlags.Type)) {
                            if (lastLocation && lastLocation.flags & 128 /* Static */) {
                                // TypeScript 1.0 spec (April 2014): 3.4.1
                                // The scope of a type parameter extends over the entire declaration 
                                // with which the type parameter list is associated, with the exception of static member declarations in classes.
                                error(errorLocation, ts.Diagnostics.Static_members_cannot_reference_class_type_parameters);
                                return undefined;
                            }
                            else {
                                return returnResolvedSymbol(result);
                            }
                        }
                        break;
                    case 120 /* Method */:
                    case 121 /* Constructor */:
                    case 122 /* GetAccessor */:
                    case 123 /* SetAccessor */:
                    case 172 /* FunctionDeclaration */:
                    case 142 /* ArrowFunction */:
                        if (name === "arguments") {
                            return returnResolvedSymbol(argumentsSymbol);
                        }
                        break;
                    case 141 /* FunctionExpression */:
                        if (name === "arguments") {
                            return returnResolvedSymbol(argumentsSymbol);
                        }
                        var id = location.name;
                        if (id && name === id.text) {
                            return returnResolvedSymbol(location.symbol);
                        }
                        break;
                    case 168 /* CatchBlock */:
                        var id = location.variable;
                        if (name === id.text) {
                            return returnResolvedSymbol(location.symbol);
                        }
                        break;
                }
                lastLocation = location;
                location = location.parent;
            }
            if (result = getSymbol(globals, name, meaning)) {
                return returnResolvedSymbol(result);
            }
            return returnResolvedSymbol(undefined);
        }
        function resolveImport(symbol) {
            ts.Debug.assert((symbol.flags & 4194304 /* Import */) !== 0, "Should only get Imports here.");
            var links = getSymbolLinks(symbol);
            if (!links.target) {
                links.target = resolvingSymbol;
                var node = getDeclarationOfKind(symbol, 179 /* ImportDeclaration */);
                var target = node.externalModuleName ? resolveExternalModuleName(node, node.externalModuleName) : getSymbolOfPartOfRightHandSideOfImport(node.entityName, node);
                if (links.target === resolvingSymbol) {
                    links.target = target || unknownSymbol;
                }
                else {
                    error(node, ts.Diagnostics.Circular_definition_of_import_alias_0, symbolToString(symbol));
                }
            }
            else if (links.target === resolvingSymbol) {
                links.target = unknownSymbol;
            }
            return links.target;
        }
        // This function is only for imports with entity names
        function getSymbolOfPartOfRightHandSideOfImport(entityName, importDeclaration) {
            if (!importDeclaration) {
                importDeclaration = ts.getAncestor(entityName, 179 /* ImportDeclaration */);
                ts.Debug.assert(importDeclaration);
            }
            // There are three things we might try to look for. In the following examples,
            // the search term is enclosed in |...|:
            //
            //     import a = |b|; // Namespace
            //     import a = |b.c|; // Value, type, namespace
            //     import a = |b.c|.d; // Namespace
            if (entityName.kind === 59 /* Identifier */ && isRightSideOfQualifiedNameOrPropertyAccess(entityName)) {
                entityName = entityName.parent;
            }
            // Check for case 1 and 3 in the above example
            if (entityName.kind === 59 /* Identifier */ || entityName.parent.kind === 116 /* QualifiedName */) {
                return resolveEntityName(importDeclaration, entityName, ts.SymbolFlags.Namespace);
            }
            else {
                // Case 2 in above example
                // entityName.kind could be a QualifiedName or a Missing identifier
                ts.Debug.assert(entityName.parent.kind === 179 /* ImportDeclaration */);
                return resolveEntityName(importDeclaration, entityName, ts.SymbolFlags.Value | ts.SymbolFlags.Type | ts.SymbolFlags.Namespace);
            }
        }
        function getFullyQualifiedName(symbol) {
            return symbol.parent ? getFullyQualifiedName(symbol.parent) + "." + symbolToString(symbol) : symbolToString(symbol);
        }
        // Resolves a qualified name and any involved import aliases
        function resolveEntityName(location, name, meaning) {
            if (name.kind === 59 /* Identifier */) {
                // TODO: Investigate error recovery for symbols not found
                var symbol = resolveName(location, name.text, meaning, ts.Diagnostics.Cannot_find_name_0, ts.identifierToString(name));
                if (!symbol) {
                    return;
                }
            }
            else if (name.kind === 116 /* QualifiedName */) {
                var namespace = resolveEntityName(location, name.left, ts.SymbolFlags.Namespace);
                if (!namespace || namespace === unknownSymbol || name.right.kind === 115 /* Missing */)
                    return;
                var symbol = getSymbol(namespace.exports, name.right.text, meaning);
                if (!symbol) {
                    error(location, ts.Diagnostics.Module_0_has_no_exported_member_1, getFullyQualifiedName(namespace), ts.identifierToString(name.right));
                    return;
                }
            }
            else {
                // Missing identifier
                return;
            }
            ts.Debug.assert((symbol.flags & 8388608 /* Instantiated */) === 0, "Should never get an instantiated symbol here.");
            return symbol.flags & meaning ? symbol : resolveImport(symbol);
        }
        function isExternalModuleNameRelative(moduleName) {
            // TypeScript 1.0 spec (April 2014): 11.2.1
            // An external module name is "relative" if the first term is "." or "..".
            return moduleName.substr(0, 2) === "./" || moduleName.substr(0, 3) === "../" || moduleName.substr(0, 2) === ".\\" || moduleName.substr(0, 3) === "..\\";
        }
        function resolveExternalModuleName(location, moduleLiteral) {
            var searchPath = ts.getDirectoryPath(getSourceFile(location).filename);
            var moduleName = moduleLiteral.text;
            if (!moduleName)
                return;
            var isRelative = isExternalModuleNameRelative(moduleName);
            if (!isRelative) {
                var symbol = getSymbol(globals, '"' + moduleName + '"', 128 /* ValueModule */);
                if (symbol) {
                    return getResolvedExportSymbol(symbol);
                }
            }
            while (true) {
                var filename = ts.normalizePath(ts.combinePaths(searchPath, moduleName));
                var sourceFile = program.getSourceFile(filename + ".ts") || program.getSourceFile(filename + ".d.ts");
                if (sourceFile || isRelative)
                    break;
                var parentPath = ts.getDirectoryPath(searchPath);
                if (parentPath === searchPath)
                    break;
                searchPath = parentPath;
            }
            if (sourceFile) {
                if (sourceFile.symbol) {
                    return getResolvedExportSymbol(sourceFile.symbol);
                }
                error(moduleLiteral, ts.Diagnostics.File_0_is_not_an_external_module, sourceFile.filename);
                return;
            }
            error(moduleLiteral, ts.Diagnostics.Cannot_find_external_module_0, moduleName);
        }
        function getResolvedExportSymbol(moduleSymbol) {
            var symbol = getExportAssignmentSymbol(moduleSymbol);
            if (symbol) {
                if (symbol.flags & (ts.SymbolFlags.Value | ts.SymbolFlags.Type | ts.SymbolFlags.Namespace)) {
                    return symbol;
                }
                if (symbol.flags & 4194304 /* Import */) {
                    return resolveImport(symbol);
                }
            }
            return moduleSymbol;
        }
        function getExportAssignmentSymbol(symbol) {
            checkTypeOfExportAssignmentSymbol(symbol);
            var symbolLinks = getSymbolLinks(symbol);
            return symbolLinks.exportAssignSymbol === unknownSymbol ? undefined : symbolLinks.exportAssignSymbol;
        }
        function checkTypeOfExportAssignmentSymbol(containerSymbol) {
            var symbolLinks = getSymbolLinks(containerSymbol);
            if (!symbolLinks.exportAssignSymbol) {
                var exportInformation = collectExportInformationForSourceFileOrModule(containerSymbol);
                if (exportInformation.exportAssignments.length) {
                    if (exportInformation.exportAssignments.length > 1) {
                        // TypeScript 1.0 spec (April 2014): 11.2.4
                        // It is an error for an external module to contain more than one export assignment.
                        ts.forEach(exportInformation.exportAssignments, function (node) { return error(node, ts.Diagnostics.A_module_cannot_have_more_than_one_export_assignment); });
                    }
                    var node = exportInformation.exportAssignments[0];
                    if (exportInformation.hasExportedMember) {
                        // TypeScript 1.0 spec (April 2014): 11.2.3
                        // If an external module contains an export assignment it is an error 
                        // for the external module to also contain export declarations.
                        // The two types of exports are mutually exclusive.
                        error(node, ts.Diagnostics.An_export_assignment_cannot_be_used_in_a_module_with_other_exported_elements);
                    }
                    if (node.exportName.text) {
                        var meaning = ts.SymbolFlags.Value | ts.SymbolFlags.Type | ts.SymbolFlags.Namespace;
                        var exportSymbol = resolveName(node, node.exportName.text, meaning, ts.Diagnostics.Cannot_find_name_0, ts.identifierToString(node.exportName));
                    }
                }
                symbolLinks.exportAssignSymbol = exportSymbol || unknownSymbol;
            }
        }
        function collectExportInformationForSourceFileOrModule(symbol) {
            var seenExportedMember = false;
            var result = [];
            ts.forEach(symbol.declarations, function (declaration) {
                var block = (declaration.kind === 182 /* SourceFile */ ? declaration : declaration.body);
                ts.forEach(block.statements, function (node) {
                    if (node.kind === 180 /* ExportAssignment */) {
                        result.push(node);
                    }
                    else {
                        seenExportedMember = seenExportedMember || (node.flags & 1 /* Export */) !== 0;
                    }
                });
            });
            return {
                hasExportedMember: seenExportedMember,
                exportAssignments: result
            };
        }
        function getMergedSymbol(symbol) {
            var merged;
            return symbol && symbol.mergeId && (merged = mergedSymbols[symbol.mergeId]) ? merged : symbol;
        }
        function getSymbolOfNode(node) {
            return getMergedSymbol(node.symbol);
        }
        function getParentOfSymbol(symbol) {
            return getMergedSymbol(symbol.parent);
        }
        function getExportSymbolOfValueSymbolIfExported(symbol) {
            return symbol && (symbol.flags & 524288 /* ExportValue */) !== 0 ? getMergedSymbol(symbol.exportSymbol) : symbol;
        }
        function symbolIsValue(symbol) {
            // If the symbol has the value flag, it is trivially a value.
            if (symbol.flags & ts.SymbolFlags.Value) {
                return true;
            }
            // If it is an import, then it is a value if the symbol it resolves to is a value.
            if (symbol.flags & 4194304 /* Import */) {
                return (resolveImport(symbol).flags & ts.SymbolFlags.Value) !== 0;
            }
            // If it is an instantiated symbol, then it is a value if the symbol it is an
            // instantiation of is a value.
            if (symbol.flags & 8388608 /* Instantiated */) {
                return (getSymbolLinks(symbol).target.flags & ts.SymbolFlags.Value) !== 0;
            }
            return false;
        }
        function findConstructorDeclaration(node) {
            var members = node.members;
            for (var i = 0; i < members.length; i++) {
                var member = members[i];
                if (member.kind === 121 /* Constructor */ && member.body) {
                    return member;
                }
            }
        }
        function createType(flags) {
            var result = new Type(checker, flags);
            result.id = typeCount++;
            return result;
        }
        function createIntrinsicType(kind, intrinsicName) {
            var type = createType(kind);
            type.intrinsicName = intrinsicName;
            return type;
        }
        function createObjectType(kind, symbol) {
            var type = createType(kind);
            type.symbol = symbol;
            return type;
        }
        // A reserved member name starts with two underscores followed by a non-underscore
        function isReservedMemberName(name) {
            return name.charCodeAt(0) === 95 /* _ */ && name.charCodeAt(1) === 95 /* _ */ && name.charCodeAt(2) !== 95 /* _ */;
        }
        function getNamedMembers(members) {
            var result;
            for (var id in members) {
                if (ts.hasProperty(members, id)) {
                    if (!isReservedMemberName(id)) {
                        if (!result)
                            result = [];
                        var symbol = members[id];
                        if (symbolIsValue(symbol)) {
                            result.push(symbol);
                        }
                    }
                }
            }
            return result || emptyArray;
        }
        function setObjectTypeMembers(type, members, callSignatures, constructSignatures, stringIndexType, numberIndexType) {
            type.members = members;
            type.properties = getNamedMembers(members);
            type.callSignatures = callSignatures;
            type.constructSignatures = constructSignatures;
            if (stringIndexType)
                type.stringIndexType = stringIndexType;
            if (numberIndexType)
                type.numberIndexType = numberIndexType;
            return type;
        }
        function createAnonymousType(symbol, members, callSignatures, constructSignatures, stringIndexType, numberIndexType) {
            return setObjectTypeMembers(createObjectType(16384 /* Anonymous */, symbol), members, callSignatures, constructSignatures, stringIndexType, numberIndexType);
        }
        function isOptionalProperty(propertySymbol) {
            //  class C {
            //      constructor(public x?) { }
            //  }
            //
            // x is an optional parameter, but it is a required property.
            return propertySymbol.valueDeclaration && propertySymbol.valueDeclaration.flags & 4 /* QuestionMark */ && propertySymbol.valueDeclaration.kind !== 118 /* Parameter */;
        }
        function forEachSymbolTableInScope(enclosingDeclaration, callback) {
            var result;
            for (var location = enclosingDeclaration; location; location = location.parent) {
                // Locals of a source file are not in scope (because they get merged into the global symbol table)
                if (location.locals && !isGlobalSourceFile(location)) {
                    if (result = callback(location.locals)) {
                        return result;
                    }
                }
                switch (location.kind) {
                    case 182 /* SourceFile */:
                        if (!ts.isExternalModule(location)) {
                            break;
                        }
                    case 177 /* ModuleDeclaration */:
                        if (result = callback(getSymbolOfNode(location).exports)) {
                            return result;
                        }
                        break;
                    case 174 /* ClassDeclaration */:
                    case 175 /* InterfaceDeclaration */:
                        if (result = callback(getSymbolOfNode(location).members)) {
                            return result;
                        }
                        break;
                }
            }
            return callback(globals);
        }
        function getQualifiedLeftMeaning(rightMeaning) {
            // If we are looking in value space, the parent meaning is value, other wise it is namespace
            return rightMeaning === ts.SymbolFlags.Value ? ts.SymbolFlags.Value : ts.SymbolFlags.Namespace;
        }
        function getAccessibleSymbolChain(symbol, enclosingDeclaration, meaning) {
            function getAccessibleSymbolChainFromSymbolTable(symbols) {
                function canQualifySymbol(symbolFromSymbolTable, meaning) {
                    // If the symbol is equivalent and doesn't need further qualification, this symbol is accessible
                    if (!needsQualification(symbolFromSymbolTable, enclosingDeclaration, meaning)) {
                        return true;
                    }
                    // If symbol needs qualification, make sure that parent is accessible, if it is then this symbol is accessible too
                    var accessibleParent = getAccessibleSymbolChain(symbolFromSymbolTable.parent, enclosingDeclaration, getQualifiedLeftMeaning(meaning));
                    return !!accessibleParent;
                }
                function isAccessible(symbolFromSymbolTable, resolvedAliasSymbol) {
                    if (symbol === (resolvedAliasSymbol || symbolFromSymbolTable)) {
                        // if the symbolFromSymbolTable is not external module (it could be if it was determined as ambient external module and would be in globals table)
                        // and if symbolfrom symbolTable or alias resolution matches the symbol, 
                        // check the symbol can be qualified, it is only then this symbol is accessible
                        return !ts.forEach(symbolFromSymbolTable.declarations, function (declaration) { return hasExternalModuleSymbol(declaration); }) && canQualifySymbol(symbolFromSymbolTable, meaning);
                    }
                }
                // If symbol is directly available by its name in the symbol table
                if (isAccessible(ts.lookUp(symbols, symbol.name))) {
                    return [symbol];
                }
                // Check if symbol is any of the alias
                return ts.forEachValue(symbols, function (symbolFromSymbolTable) {
                    if (symbolFromSymbolTable.flags & 4194304 /* Import */) {
                        var resolvedImportedSymbol = resolveImport(symbolFromSymbolTable);
                        if (isAccessible(symbolFromSymbolTable, resolveImport(symbolFromSymbolTable))) {
                            return [symbolFromSymbolTable];
                        }
                        // Look in the exported members, if we can find accessibleSymbolChain, symbol is accessible using this chain
                        // but only if the symbolFromSymbolTable can be qualified
                        var accessibleSymbolsFromExports = resolvedImportedSymbol.exports ? getAccessibleSymbolChainFromSymbolTable(resolvedImportedSymbol.exports) : undefined;
                        if (accessibleSymbolsFromExports && canQualifySymbol(symbolFromSymbolTable, getQualifiedLeftMeaning(meaning))) {
                            return [symbolFromSymbolTable].concat(accessibleSymbolsFromExports);
                        }
                    }
                });
            }
            if (symbol) {
                return forEachSymbolTableInScope(enclosingDeclaration, getAccessibleSymbolChainFromSymbolTable);
            }
        }
        function needsQualification(symbol, enclosingDeclaration, meaning) {
            var qualify = false;
            forEachSymbolTableInScope(enclosingDeclaration, function (symbolTable) {
                // If symbol of this name is not available in the symbol table we are ok
                if (!ts.hasProperty(symbolTable, symbol.name)) {
                    // Continue to the next symbol table
                    return false;
                }
                // If the symbol with this name is present it should refer to the symbol
                var symbolFromSymbolTable = symbolTable[symbol.name];
                if (symbolFromSymbolTable === symbol) {
                    // No need to qualify
                    return true;
                }
                // Qualify if the symbol from symbol table has same meaning as expected
                symbolFromSymbolTable = (symbolFromSymbolTable.flags & 4194304 /* Import */) ? resolveImport(symbolFromSymbolTable) : symbolFromSymbolTable;
                if (symbolFromSymbolTable.flags & meaning) {
                    qualify = true;
                    return true;
                }
                // Continue to the next symbol table
                return false;
            });
            return qualify;
        }
        function isSymbolAccessible(symbol, enclosingDeclaration, meaning) {
            if (symbol && enclosingDeclaration && !(symbol.flags & 262144 /* TypeParameter */)) {
                var initialSymbol = symbol;
                var meaningToLook = meaning;
                while (symbol) {
                    // Symbol is accessible if it by itself is accessible
                    var accessibleSymbolChain = getAccessibleSymbolChain(symbol, enclosingDeclaration, meaningToLook);
                    if (accessibleSymbolChain) {
                        var hasAccessibleDeclarations = hasVisibleDeclarations(accessibleSymbolChain[0]);
                        if (!hasAccessibleDeclarations) {
                            return {
                                accessibility: 1 /* NotAccessible */,
                                errorSymbolName: symbolToString(initialSymbol, enclosingDeclaration, meaning),
                                errorModuleName: symbol !== initialSymbol ? symbolToString(symbol, enclosingDeclaration, ts.SymbolFlags.Namespace) : undefined
                            };
                        }
                        return { accessibility: 0 /* Accessible */, aliasesToMakeVisible: hasAccessibleDeclarations.aliasesToMakeVisible };
                    }
                    // If we haven't got the accessible symbol, it doesn't mean the symbol is actually inaccessible.
                    // It could be a qualified symbol and hence verify the path
                    // e.g.:
                    // module m {
                    //     export class c {
                    //     }
                    // }
                    // var x: typeof m.c
                    // In the above example when we start with checking if typeof m.c symbol is accessible,
                    // we are going to see if c can be accessed in scope directly. 
                    // But it can't, hence the accessible is going to be undefined, but that doesn't mean m.c is inaccessible
                    // It is accessible if the parent m is accessible because then m.c can be accessed through qualification
                    meaningToLook = getQualifiedLeftMeaning(meaning);
                    symbol = getParentOfSymbol(symbol);
                }
                // This could be a symbol that is not exported in the external module 
                // or it could be a symbol from different external module that is not aliased and hence cannot be named
                var symbolExternalModule = ts.forEach(initialSymbol.declarations, function (declaration) { return getExternalModuleContainer(declaration); });
                if (symbolExternalModule) {
                    var enclosingExternalModule = getExternalModuleContainer(enclosingDeclaration);
                    if (symbolExternalModule !== enclosingExternalModule) {
                        // name from different external module that is not visible
                        return {
                            accessibility: 2 /* CannotBeNamed */,
                            errorSymbolName: symbolToString(initialSymbol, enclosingDeclaration, meaning),
                            errorModuleName: symbolToString(symbolExternalModule)
                        };
                    }
                }
                // Just a local name that is not accessible
                return {
                    accessibility: 1 /* NotAccessible */,
                    errorSymbolName: symbolToString(initialSymbol, enclosingDeclaration, meaning)
                };
            }
            return { accessibility: 0 /* Accessible */ };
            function getExternalModuleContainer(declaration) {
                for (; declaration; declaration = declaration.parent) {
                    if (hasExternalModuleSymbol(declaration)) {
                        return getSymbolOfNode(declaration);
                    }
                }
            }
        }
        function hasExternalModuleSymbol(declaration) {
            return (declaration.kind === 177 /* ModuleDeclaration */ && declaration.name.kind === 7 /* StringLiteral */) || (declaration.kind === 182 /* SourceFile */ && ts.isExternalModule(declaration));
        }
        function hasVisibleDeclarations(symbol) {
            var aliasesToMakeVisible;
            if (ts.forEach(symbol.declarations, function (declaration) { return !getIsDeclarationVisible(declaration); })) {
                return undefined;
            }
            return { aliasesToMakeVisible: aliasesToMakeVisible };
            function getIsDeclarationVisible(declaration) {
                if (!isDeclarationVisible(declaration)) {
                    // Mark the unexported alias as visible if its parent is visible 
                    // because these kind of aliases can be used to name types in declaration file
                    if (declaration.kind === 179 /* ImportDeclaration */ && !(declaration.flags & 1 /* Export */) && isDeclarationVisible(declaration.parent)) {
                        getNodeLinks(declaration).isVisible = true;
                        if (aliasesToMakeVisible) {
                            if (!ts.contains(aliasesToMakeVisible, declaration)) {
                                aliasesToMakeVisible.push(declaration);
                            }
                        }
                        else {
                            aliasesToMakeVisible = [declaration];
                        }
                        return true;
                    }
                    // Declaration is not visible
                    return false;
                }
                return true;
            }
        }
        function isImportDeclarationEntityNameReferenceDeclarationVisibile(entityName) {
            var firstIdentifier = getFirstIdentifier(entityName);
            var firstIdentifierName = ts.identifierToString(firstIdentifier);
            var symbolOfNameSpace = resolveName(entityName.parent, firstIdentifier.text, ts.SymbolFlags.Namespace, ts.Diagnostics.Cannot_find_name_0, firstIdentifierName);
            // Verify if the symbol is accessible
            var hasNamespaceDeclarationsVisibile = hasVisibleDeclarations(symbolOfNameSpace);
            return hasNamespaceDeclarationsVisibile ? { accessibility: 0 /* Accessible */, aliasesToMakeVisible: hasNamespaceDeclarationsVisibile.aliasesToMakeVisible } : { accessibility: 1 /* NotAccessible */, errorSymbolName: firstIdentifierName };
        }
        // Pool writers to avoid needing to allocate them for every symbol we write.
        var displayPartWriters = [];
        var stringWriters = [];
        function displayPartKind(symbol) {
            var flags = symbol.flags;
            if (flags & 1 /* Variable */) {
                return symbol.declarations && symbol.declarations.length > 0 && symbol.declarations[0].kind === 118 /* Parameter */ ? 15 /* parameterName */ : 10 /* localName */;
            }
            else if (flags & 2 /* Property */) {
                return 16 /* propertyName */;
            }
            else if (flags & 4 /* EnumMember */) {
                return 22 /* enumMemberName */;
            }
            else if (flags & 8 /* Function */) {
                return 23 /* functionName */;
            }
            else if (flags & 16 /* Class */) {
                return 1 /* className */;
            }
            else if (flags & 32 /* Interface */) {
                return 4 /* interfaceName */;
            }
            else if (flags & 64 /* Enum */) {
                return 2 /* enumName */;
            }
            else if (flags & ts.SymbolFlags.Module) {
                return 12 /* moduleName */;
            }
            else if (flags & 2048 /* Method */) {
                return 11 /* methodName */;
            }
            else if (flags & 262144 /* TypeParameter */) {
                return 21 /* typeParameterName */;
            }
            return 20 /* text */;
        }
        function getDisplayPartWriter() {
            if (displayPartWriters.length == 0) {
                var displayParts = [];
                return {
                    displayParts: function () { return displayParts; },
                    writeKind: function (text, kind) { return displayParts.push(new ts.SymbolDisplayPart(text, kind, undefined)); },
                    writeSymbol: function (text, symbol) { return displayParts.push(new ts.SymbolDisplayPart(text, displayPartKind(symbol), symbol)); },
                    // Completely ignore indentation for display part writers.  And map newlines to
                    // a single space.
                    writeLine: function () { return displayParts.push(new ts.SymbolDisplayPart(" ", 18 /* space */, undefined)); },
                    increaseIndent: function () {
                    },
                    decreaseIndent: function () {
                    },
                    clear: function () { return displayParts = []; },
                    trackSymbol: function () {
                    }
                };
            }
            return displayPartWriters.pop();
        }
        function getStringWriter() {
            if (stringWriters.length == 0) {
                var str = "";
                return {
                    string: function () { return str; },
                    writeKind: function (text) { return str += text; },
                    writeSymbol: function (text) { return str += text; },
                    // Completely ignore indentation for string writers.  And map newlines to
                    // a single space.
                    writeLine: function () { return str += " "; },
                    increaseIndent: function () {
                    },
                    decreaseIndent: function () {
                    },
                    clear: function () { return str = ""; },
                    trackSymbol: function () {
                    }
                };
            }
            return stringWriters.pop();
        }
        function releaseDisplayPartWriter(writer) {
            writer.clear();
            displayPartWriters.push(writer);
        }
        function releaseStringWriter(writer) {
            writer.clear();
            stringWriters.push(writer);
        }
        function writeKeyword(writer, kind) {
            writer.writeKind(ts.tokenToString(kind), 5 /* keyword */);
        }
        function writePunctuation(writer, kind) {
            writer.writeKind(ts.tokenToString(kind), 17 /* punctuation */);
        }
        function writeOperator(writer, kind) {
            writer.writeKind(ts.tokenToString(kind), 14 /* operator */);
        }
        function writeSpace(writer) {
            writer.writeKind(" ", 18 /* space */);
        }
        function symbolToString(symbol, enclosingDeclaration, meaning) {
            var writer = getStringWriter();
            writeSymbol(symbol, writer, enclosingDeclaration, meaning);
            var result = writer.string();
            releaseStringWriter(writer);
            return result;
        }
        function symbolToDisplayParts(symbol, enclosingDeclaration, meaning) {
            var writer = getDisplayPartWriter();
            writeSymbol(symbol, writer, enclosingDeclaration, meaning);
            var result = writer.displayParts();
            releaseDisplayPartWriter(writer);
            return result;
        }
        // Enclosing declaration is optional when we don't want to get qualified name in the enclosing declaration scope
        // Meaning needs to be specified if the enclosing declaration is given
        function writeSymbol(symbol, writer, enclosingDeclaration, meaning) {
            function writeSymbolName(symbol) {
                if (symbol.declarations && symbol.declarations.length > 0) {
                    var declaration = symbol.declarations[0];
                    if (declaration.name) {
                        writer.writeSymbol(ts.identifierToString(declaration.name), symbol);
                        return;
                    }
                }
                writer.writeSymbol(symbol.name, symbol);
            }
            // Let the writer know we just wrote out a symbol.  The declarationemitter writer uses 
            // this to determine if an import it has previously seen (and not writter out) needs 
            // to be written to the file once the walk of the tree is complete.
            //
            // NOTE(cyrusn): This approach feels somewhat unfortunate.  A simple pass over the tree
            // up front (for example, during checking) could determien if we need to emit the imports
            // and we could then access that data during declaration emit.
            writer.trackSymbol(symbol, enclosingDeclaration, meaning);
            var needsDot = false;
            function walkSymbol(symbol, meaning) {
                if (symbol) {
                    var accessibleSymbolChain = getAccessibleSymbolChain(symbol, enclosingDeclaration, meaning);
                    if (!accessibleSymbolChain || needsQualification(accessibleSymbolChain[0], enclosingDeclaration, accessibleSymbolChain.length === 1 ? meaning : getQualifiedLeftMeaning(meaning))) {
                        // Go up and add our parent.
                        walkSymbol(getParentOfSymbol(accessibleSymbolChain ? accessibleSymbolChain[0] : symbol), getQualifiedLeftMeaning(meaning));
                    }
                    if (accessibleSymbolChain) {
                        for (var i = 0, n = accessibleSymbolChain.length; i < n; i++) {
                            if (needsDot) {
                                writePunctuation(writer, 15 /* DotToken */);
                            }
                            writeSymbolName(accessibleSymbolChain[i]);
                            needsDot = true;
                        }
                    }
                    else {
                        // If we didn't find accessible symbol chain for this symbol, break if this is external module
                        if (!needsDot && ts.forEach(symbol.declarations, function (declaration) { return hasExternalModuleSymbol(declaration); })) {
                            return;
                        }
                        if (needsDot) {
                            writePunctuation(writer, 15 /* DotToken */);
                        }
                        writeSymbolName(symbol);
                        needsDot = true;
                    }
                }
            }
            // Get qualified name 
            if (enclosingDeclaration && !(symbol.flags & 262144 /* TypeParameter */)) {
                walkSymbol(symbol, meaning);
                return;
            }
            return writeSymbolName(symbol);
        }
        function writeSymbolToTextWriter(symbol, enclosingDeclaration, meaning, writer) {
            writer.write(symbolToString(symbol, enclosingDeclaration, meaning));
        }
        function typeToString(type, enclosingDeclaration, flags) {
            var writer = getStringWriter();
            writeType(type, writer, enclosingDeclaration, flags);
            var result = writer.string();
            releaseStringWriter(writer);
            var maxLength = compilerOptions.noErrorTruncation || flags & 4 /* NoTruncation */ ? undefined : 100;
            if (maxLength && result.length >= maxLength) {
                result = result.substr(0, maxLength - "...".length) + "...";
            }
            return result;
        }
        function typeToDisplayParts(type, enclosingDeclaration, flags) {
            var writer = getDisplayPartWriter();
            writeType(type, writer, enclosingDeclaration, flags);
            var result = writer.displayParts();
            releaseDisplayPartWriter(writer);
            return result;
        }
        function writeType(type, writer, enclosingDeclaration, flags) {
            var typeStack;
            return writeType(type, true);
            function writeType(type, allowFunctionOrConstructorTypeLiteral) {
                if (type.flags & ts.TypeFlags.Intrinsic) {
                    writer.writeKind(type.intrinsicName, 5 /* keyword */);
                }
                else if (type.flags & 4096 /* Reference */) {
                    writeTypeReference(type);
                }
                else if (type.flags & (1024 /* Class */ | 2048 /* Interface */ | 128 /* Enum */ | 512 /* TypeParameter */)) {
                    writeSymbol(type.symbol, writer, enclosingDeclaration, ts.SymbolFlags.Type);
                }
                else if (type.flags & 8192 /* Tuple */) {
                    writeTupleType(type);
                }
                else if (type.flags & 16384 /* Anonymous */) {
                    writeAnonymousType(type, allowFunctionOrConstructorTypeLiteral);
                }
                else if (type.flags & 256 /* StringLiteral */) {
                    writer.writeKind(type.text, 9 /* stringLiteral */);
                }
                else {
                    // Should never get here
                    // { ... }
                    writePunctuation(writer, 9 /* OpenBraceToken */);
                    writeSpace(writer);
                    writePunctuation(writer, 16 /* DotDotDotToken */);
                    writeSpace(writer);
                    writePunctuation(writer, 10 /* CloseBraceToken */);
                }
            }
            function writeTypeList(types) {
                for (var i = 0; i < types.length; i++) {
                    if (i > 0) {
                        writePunctuation(writer, 18 /* CommaToken */);
                        writeSpace(writer);
                    }
                    writeType(types[i], true);
                }
            }
            function writeTypeReference(type) {
                if (type.target === globalArrayType && !(flags & 1 /* WriteArrayAsGenericType */)) {
                    // If we are writing array element type the arrow style signatures are not allowed as 
                    // we need to surround it by curlies, e.g. { (): T; }[]; as () => T[] would mean something different
                    writeType(type.typeArguments[0], false);
                    writePunctuation(writer, 13 /* OpenBracketToken */);
                    writePunctuation(writer, 14 /* CloseBracketToken */);
                }
                else {
                    writeSymbol(type.target.symbol, writer, enclosingDeclaration, ts.SymbolFlags.Type);
                    writePunctuation(writer, 19 /* LessThanToken */);
                    writeTypeList(type.typeArguments);
                    writePunctuation(writer, 20 /* GreaterThanToken */);
                }
            }
            function writeTupleType(type) {
                writePunctuation(writer, 13 /* OpenBracketToken */);
                writeTypeList(type.elementTypes);
                writePunctuation(writer, 14 /* CloseBracketToken */);
            }
            function writeAnonymousType(type, allowFunctionOrConstructorTypeLiteral) {
                // Always use 'typeof T' for type of class, enum, and module objects
                if (type.symbol && type.symbol.flags & (16 /* Class */ | 64 /* Enum */ | 128 /* ValueModule */)) {
                    writeTypeofSymbol(type);
                }
                else if (shouldWriteTypeOfFunctionSymbol()) {
                    writeTypeofSymbol(type);
                }
                else if (typeStack && ts.contains(typeStack, type)) {
                    // Recursive usage, use any
                    writeKeyword(writer, 105 /* AnyKeyword */);
                }
                else {
                    if (!typeStack) {
                        typeStack = [];
                    }
                    typeStack.push(type);
                    writeLiteralType(type, allowFunctionOrConstructorTypeLiteral);
                    typeStack.pop();
                }
                function shouldWriteTypeOfFunctionSymbol() {
                    if (type.symbol) {
                        var isStaticMethodSymbol = !!(type.symbol.flags & 2048 /* Method */ && ts.forEach(type.symbol.declarations, function (declaration) { return declaration.flags & 128 /* Static */; }));
                        var isNonLocalFunctionSymbol = !!(type.symbol.flags & 8 /* Function */) && (type.symbol.parent || ts.forEach(type.symbol.declarations, function (declaration) { return declaration.parent.kind === 182 /* SourceFile */ || declaration.parent.kind === 178 /* ModuleBlock */; }));
                        if (isStaticMethodSymbol || isNonLocalFunctionSymbol) {
                            // typeof is allowed only for static/non local functions
                            return !!(flags & 2 /* UseTypeOfFunction */) || (typeStack && ts.contains(typeStack, type)); // it is type of the symbol uses itself recursively
                        }
                    }
                }
            }
            function writeTypeofSymbol(type) {
                writeKeyword(writer, 91 /* TypeOfKeyword */);
                writeSpace(writer);
                writeSymbol(type.symbol, writer, enclosingDeclaration, ts.SymbolFlags.Value);
            }
            function writeLiteralType(type, allowFunctionOrConstructorTypeLiteral) {
                var resolved = resolveObjectTypeMembers(type);
                if (!resolved.properties.length && !resolved.stringIndexType && !resolved.numberIndexType) {
                    if (!resolved.callSignatures.length && !resolved.constructSignatures.length) {
                        writePunctuation(writer, 9 /* OpenBraceToken */);
                        writePunctuation(writer, 10 /* CloseBraceToken */);
                        return;
                    }
                    if (allowFunctionOrConstructorTypeLiteral) {
                        if (resolved.callSignatures.length === 1 && !resolved.constructSignatures.length) {
                            writeSignature(resolved.callSignatures[0], true);
                            return;
                        }
                        if (resolved.constructSignatures.length === 1 && !resolved.callSignatures.length) {
                            writeKeyword(writer, 82 /* NewKeyword */);
                            writeSpace(writer);
                            writeSignature(resolved.constructSignatures[0], true);
                            return;
                        }
                    }
                }
                writePunctuation(writer, 9 /* OpenBraceToken */);
                writer.writeLine();
                writer.increaseIndent();
                for (var i = 0; i < resolved.callSignatures.length; i++) {
                    writeSignature(resolved.callSignatures[i]);
                    writePunctuation(writer, 17 /* SemicolonToken */);
                    writer.writeLine();
                }
                for (var i = 0; i < resolved.constructSignatures.length; i++) {
                    writeKeyword(writer, 82 /* NewKeyword */);
                    writeSpace(writer);
                    writeSignature(resolved.constructSignatures[i]);
                    writePunctuation(writer, 17 /* SemicolonToken */);
                    writer.writeLine();
                }
                if (resolved.stringIndexType) {
                    // [x: string]: 
                    writePunctuation(writer, 13 /* OpenBracketToken */);
                    writer.writeKind("x", 15 /* parameterName */);
                    writePunctuation(writer, 46 /* ColonToken */);
                    writeSpace(writer);
                    writeKeyword(writer, 114 /* StringKeyword */);
                    writePunctuation(writer, 14 /* CloseBracketToken */);
                    writePunctuation(writer, 46 /* ColonToken */);
                    writeSpace(writer);
                    writeType(resolved.stringIndexType, true);
                    writePunctuation(writer, 17 /* SemicolonToken */);
                    writer.writeLine();
                }
                if (resolved.numberIndexType) {
                    // [x: number]: 
                    writePunctuation(writer, 13 /* OpenBracketToken */);
                    writer.writeKind("x", 15 /* parameterName */);
                    writePunctuation(writer, 46 /* ColonToken */);
                    writeSpace(writer);
                    writeKeyword(writer, 112 /* NumberKeyword */);
                    writePunctuation(writer, 14 /* CloseBracketToken */);
                    writePunctuation(writer, 46 /* ColonToken */);
                    writeSpace(writer);
                    writeType(resolved.numberIndexType, true);
                    writePunctuation(writer, 17 /* SemicolonToken */);
                    writer.writeLine();
                }
                for (var i = 0; i < resolved.properties.length; i++) {
                    var p = resolved.properties[i];
                    var t = getTypeOfSymbol(p);
                    if (p.flags & (8 /* Function */ | 2048 /* Method */) && !getPropertiesOfType(t).length) {
                        var signatures = getSignaturesOfType(t, 0 /* Call */);
                        for (var j = 0; j < signatures.length; j++) {
                            writeSymbol(p, writer);
                            if (isOptionalProperty(p)) {
                                writePunctuation(writer, 45 /* QuestionToken */);
                            }
                            writeSignature(signatures[j]);
                            writePunctuation(writer, 17 /* SemicolonToken */);
                            writer.writeLine();
                        }
                    }
                    else {
                        writeSymbol(p, writer);
                        if (isOptionalProperty(p)) {
                            writePunctuation(writer, 45 /* QuestionToken */);
                        }
                        writePunctuation(writer, 46 /* ColonToken */);
                        writeSpace(writer);
                        writeType(t, true);
                        writePunctuation(writer, 17 /* SemicolonToken */);
                        writer.writeLine();
                    }
                }
                writer.decreaseIndent();
                writePunctuation(writer, 10 /* CloseBraceToken */);
            }
            function writeSignature(signature, arrowStyle) {
                if (signature.typeParameters) {
                    writePunctuation(writer, 19 /* LessThanToken */);
                    for (var i = 0; i < signature.typeParameters.length; i++) {
                        if (i > 0) {
                            writePunctuation(writer, 18 /* CommaToken */);
                            writeSpace(writer);
                        }
                        var tp = signature.typeParameters[i];
                        writeSymbol(tp.symbol, writer);
                        var constraint = getConstraintOfTypeParameter(tp);
                        if (constraint) {
                            writeSpace(writer);
                            writeKeyword(writer, 73 /* ExtendsKeyword */);
                            writeSpace(writer);
                            writeType(constraint, true);
                        }
                    }
                    writePunctuation(writer, 20 /* GreaterThanToken */);
                }
                writePunctuation(writer, 11 /* OpenParenToken */);
                for (var i = 0; i < signature.parameters.length; i++) {
                    if (i > 0) {
                        writePunctuation(writer, 18 /* CommaToken */);
                        writeSpace(writer);
                    }
                    var p = signature.parameters[i];
                    if (getDeclarationFlagsFromSymbol(p) & 8 /* Rest */) {
                        writePunctuation(writer, 16 /* DotDotDotToken */);
                    }
                    writeSymbol(p, writer);
                    if (p.valueDeclaration.flags & 4 /* QuestionMark */ || p.valueDeclaration.initializer) {
                        writePunctuation(writer, 45 /* QuestionToken */);
                    }
                    writePunctuation(writer, 46 /* ColonToken */);
                    writeSpace(writer);
                    writeType(getTypeOfSymbol(p), true);
                }
                writePunctuation(writer, 12 /* CloseParenToken */);
                if (arrowStyle) {
                    writeSpace(writer);
                    writePunctuation(writer, 27 /* EqualsGreaterThanToken */);
                }
                else {
                    writePunctuation(writer, 46 /* ColonToken */);
                }
                writeSpace(writer);
                writeType(getReturnTypeOfSignature(signature), true);
            }
        }
        function isDeclarationVisible(node) {
            function getContainingExternalModule(node) {
                for (; node; node = node.parent) {
                    if (node.kind === 177 /* ModuleDeclaration */) {
                        if (node.name.kind === 7 /* StringLiteral */) {
                            return node;
                        }
                    }
                    else if (node.kind === 182 /* SourceFile */) {
                        return ts.isExternalModule(node) ? node : undefined;
                    }
                }
                ts.Debug.fail("getContainingModule cant reach here");
            }
            function isUsedInExportAssignment(node) {
                // Get source File and see if it is external module and has export assigned symbol
                var externalModule = getContainingExternalModule(node);
                if (externalModule) {
                    // This is export assigned symbol node
                    var externalModuleSymbol = getSymbolOfNode(externalModule);
                    var exportAssignmentSymbol = getExportAssignmentSymbol(externalModuleSymbol);
                    var resolvedExportSymbol;
                    var symbolOfNode = getSymbolOfNode(node);
                    if (isSymbolUsedInExportAssignment(symbolOfNode)) {
                        return true;
                    }
                    // if symbolOfNode is import declaration, resolve the symbol declaration and check
                    if (symbolOfNode.flags & 4194304 /* Import */) {
                        return isSymbolUsedInExportAssignment(resolveImport(symbolOfNode));
                    }
                }
                // Check if the symbol is used in export assignment
                function isSymbolUsedInExportAssignment(symbol) {
                    if (exportAssignmentSymbol === symbol) {
                        return true;
                    }
                    if (exportAssignmentSymbol && !!(exportAssignmentSymbol.flags & 4194304 /* Import */)) {
                        // if export assigned symbol is import declaration, resolve the import
                        resolvedExportSymbol = resolvedExportSymbol || resolveImport(exportAssignmentSymbol);
                        if (resolvedExportSymbol === symbol) {
                            return true;
                        }
                        // Container of resolvedExportSymbol is visible
                        return ts.forEach(resolvedExportSymbol.declarations, function (declaration) {
                            while (declaration) {
                                if (declaration === node) {
                                    return true;
                                }
                                declaration = declaration.parent;
                            }
                        });
                    }
                }
            }
            function determineIfDeclarationIsVisible() {
                switch (node.kind) {
                    case 171 /* VariableDeclaration */:
                    case 177 /* ModuleDeclaration */:
                    case 174 /* ClassDeclaration */:
                    case 175 /* InterfaceDeclaration */:
                    case 172 /* FunctionDeclaration */:
                    case 176 /* EnumDeclaration */:
                    case 179 /* ImportDeclaration */:
                        // In case of variable declaration, node.parent is variable statement so look at the variable statement's parent
                        var parent = node.kind === 171 /* VariableDeclaration */ ? node.parent.parent : node.parent;
                        // If the node is not exported or it is not ambient module element (except import declaration)
                        if (!(node.flags & 1 /* Export */) && !(node.kind !== 179 /* ImportDeclaration */ && parent.kind !== 182 /* SourceFile */ && ts.isInAmbientContext(parent))) {
                            return isGlobalSourceFile(parent) || isUsedInExportAssignment(node);
                        }
                        // Exported members/ambient module elements (exception import declaration) are visible if parent is visible
                        return isDeclarationVisible(parent);
                    case 119 /* Property */:
                    case 120 /* Method */:
                        if (node.flags & (32 /* Private */ | 64 /* Protected */)) {
                            // Private/protected properties/methods are not visible
                            return false;
                        }
                    case 121 /* Constructor */:
                    case 125 /* ConstructSignature */:
                    case 124 /* CallSignature */:
                    case 126 /* IndexSignature */:
                    case 118 /* Parameter */:
                    case 178 /* ModuleBlock */:
                        return isDeclarationVisible(node.parent);
                    case 182 /* SourceFile */:
                        return true;
                    default:
                        ts.Debug.fail("isDeclarationVisible unknown: SyntaxKind: " + ts.SyntaxKind[node.kind]);
                }
            }
            if (node) {
                var links = getNodeLinks(node);
                if (links.isVisible === undefined) {
                    links.isVisible = !!determineIfDeclarationIsVisible();
                }
                return links.isVisible;
            }
        }
        function getApparentType(type) {
            if (type.flags & 512 /* TypeParameter */) {
                do {
                    type = getConstraintOfTypeParameter(type);
                } while (type && type.flags & 512 /* TypeParameter */);
                if (!type)
                    type = emptyObjectType;
            }
            if (type.flags & ts.TypeFlags.StringLike) {
                type = globalStringType;
            }
            else if (type.flags & ts.TypeFlags.NumberLike) {
                type = globalNumberType;
            }
            else if (type.flags & 8 /* Boolean */) {
                type = globalBooleanType;
            }
            return type;
        }
        function getTypeOfPrototypeProperty(prototype) {
            // TypeScript 1.0 spec (April 2014): 8.4
            // Every class automatically contains a static property member named 'prototype', 
            // the type of which is an instantiation of the class type with type Any supplied as a type argument for each type parameter.
            // It is an error to explicitly declare a static property member with the name 'prototype'.
            var classType = getDeclaredTypeOfSymbol(prototype.parent);
            return classType.typeParameters ? createTypeReference(classType, ts.map(classType.typeParameters, function (_) { return anyType; })) : classType;
        }
        function getTypeOfVariableDeclaration(declaration) {
            // A variable declared in a for..in statement is always of type any
            if (declaration.parent.kind === 156 /* ForInStatement */) {
                return anyType;
            }
            // Use type from type annotation if one is present
            if (declaration.type) {
                return getTypeFromTypeNode(declaration.type);
            }
            if (declaration.kind === 118 /* Parameter */) {
                var func = declaration.parent;
                // For a parameter of a set accessor, use the type of the get accessor if one is present
                if (func.kind === 123 /* SetAccessor */) {
                    var getter = getDeclarationOfKind(declaration.parent.symbol, 122 /* GetAccessor */);
                    if (getter) {
                        return getReturnTypeOfSignature(getSignatureFromDeclaration(getter));
                    }
                }
                // Use contextual parameter type if one is available
                var type = getContextuallyTypedParameterType(declaration);
                if (type) {
                    return type;
                }
            }
            // Use the type of the initializer expression if one is present
            if (declaration.initializer) {
                var type = checkAndMarkExpression(declaration.initializer);
                // Widening of property assignments is handled by checkObjectLiteral, exclude them here
                if (declaration.kind !== 134 /* PropertyAssignment */) {
                    var unwidenedType = type;
                    type = getWidenedType(type);
                    if (type !== unwidenedType) {
                        checkImplicitAny(type);
                    }
                }
                return type;
            }
            // Rest parameters default to type any[], other parameters default to type any
            var type = declaration.flags & 8 /* Rest */ ? createArrayType(anyType) : anyType;
            checkImplicitAny(type);
            return type;
            function checkImplicitAny(type) {
                if (!fullTypeCheck || !compilerOptions.noImplicitAny) {
                    return;
                }
                // We need to have ended up with 'any', 'any[]', 'any[][]', etc.
                if (getInnermostTypeOfNestedArrayTypes(type) !== anyType) {
                    return;
                }
                // Ignore privates within ambient contexts; they exist purely for documentative purposes to avoid name clashing.
                // (e.g. privates within .d.ts files do not expose type information)
                if (isPrivateWithinAmbient(declaration) || (declaration.kind === 118 /* Parameter */ && isPrivateWithinAmbient(declaration.parent))) {
                    return;
                }
                switch (declaration.kind) {
                    case 119 /* Property */:
                        var diagnostic = ts.Diagnostics.Member_0_implicitly_has_an_1_type;
                        break;
                    case 118 /* Parameter */:
                        var diagnostic = declaration.flags & 8 /* Rest */ ? ts.Diagnostics.Rest_parameter_0_implicitly_has_an_any_type : ts.Diagnostics.Parameter_0_implicitly_has_an_1_type;
                        break;
                    default:
                        var diagnostic = ts.Diagnostics.Variable_0_implicitly_has_an_1_type;
                }
                error(declaration, diagnostic, ts.identifierToString(declaration.name), typeToString(type));
            }
        }
        function getTypeOfVariableOrParameterOrProperty(symbol) {
            var links = getSymbolLinks(symbol);
            if (!links.type) {
                // Handle prototype property
                if (symbol.flags & 67108864 /* Prototype */) {
                    return links.type = getTypeOfPrototypeProperty(symbol);
                }
                // Handle catch clause variables
                var declaration = symbol.valueDeclaration;
                if (declaration.kind === 168 /* CatchBlock */) {
                    return links.type = anyType;
                }
                // Handle variable, parameter or property
                links.type = resolvingType;
                var type = getTypeOfVariableDeclaration(declaration);
                if (links.type === resolvingType) {
                    links.type = type;
                }
            }
            else if (links.type === resolvingType) {
                links.type = anyType;
                if (compilerOptions.noImplicitAny) {
                    var diagnostic = symbol.valueDeclaration.type ? ts.Diagnostics._0_implicitly_has_type_any_because_it_is_referenced_directly_or_indirectly_in_its_own_type_annotation : ts.Diagnostics._0_implicitly_has_type_any_because_it_is_does_not_have_a_type_annotation_and_is_referenced_directly_or_indirectly_in_its_own_initializer;
                    error(symbol.valueDeclaration, diagnostic, symbolToString(symbol));
                }
            }
            return links.type;
        }
        function getSetAccessorTypeAnnotationNode(accessor) {
            return accessor && accessor.parameters.length > 0 && accessor.parameters[0].type;
        }
        function getAnnotatedAccessorType(accessor) {
            if (accessor) {
                if (accessor.kind === 122 /* GetAccessor */) {
                    return accessor.type && getTypeFromTypeNode(accessor.type);
                }
                else {
                    var setterTypeAnnotation = getSetAccessorTypeAnnotationNode(accessor);
                    return setterTypeAnnotation && getTypeFromTypeNode(setterTypeAnnotation);
                }
            }
            return undefined;
        }
        function getTypeOfAccessors(symbol) {
            var links = getSymbolLinks(symbol);
            checkAndStoreTypeOfAccessors(symbol, links);
            return links.type;
        }
        function checkAndStoreTypeOfAccessors(symbol, links) {
            links = links || getSymbolLinks(symbol);
            if (!links.type) {
                links.type = resolvingType;
                var getter = getDeclarationOfKind(symbol, 122 /* GetAccessor */);
                var setter = getDeclarationOfKind(symbol, 123 /* SetAccessor */);
                var type;
                // First try to see if the user specified a return type on the get-accessor.
                var getterReturnType = getAnnotatedAccessorType(getter);
                if (getterReturnType) {
                    type = getterReturnType;
                }
                else {
                    // If the user didn't specify a return type, try to use the set-accessor's parameter type.
                    var setterParameterType = getAnnotatedAccessorType(setter);
                    if (setterParameterType) {
                        type = setterParameterType;
                    }
                    else {
                        // If there are no specified types, try to infer it from the body of the get accessor if it exists.
                        if (getter) {
                            type = getReturnTypeFromBody(getter);
                        }
                        else {
                            if (compilerOptions.noImplicitAny) {
                                error(setter, ts.Diagnostics.Property_0_implicitly_has_type_any_because_its_set_accessor_lacks_a_type_annotation, symbolToString(symbol));
                            }
                            type = anyType;
                        }
                    }
                }
                if (links.type === resolvingType) {
                    links.type = type;
                }
            }
            else if (links.type === resolvingType) {
                links.type = anyType;
                if (compilerOptions.noImplicitAny) {
                    var getter = getDeclarationOfKind(symbol, 122 /* GetAccessor */);
                    error(getter, ts.Diagnostics._0_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_referenced_directly_or_indirectly_in_one_of_its_return_expressions, symbolToString(symbol));
                }
            }
        }
        function getTypeOfFuncClassEnumModule(symbol) {
            var links = getSymbolLinks(symbol);
            if (!links.type) {
                links.type = createObjectType(16384 /* Anonymous */, symbol);
            }
            return links.type;
        }
        function getTypeOfEnumMember(symbol) {
            var links = getSymbolLinks(symbol);
            if (!links.type) {
                links.type = getDeclaredTypeOfEnum(getParentOfSymbol(symbol));
            }
            return links.type;
        }
        function getTypeOfImport(symbol) {
            var links = getSymbolLinks(symbol);
            if (!links.type) {
                links.type = getTypeOfSymbol(resolveImport(symbol));
            }
            return links.type;
        }
        function getTypeOfInstantiatedSymbol(symbol) {
            var links = getSymbolLinks(symbol);
            if (!links.type) {
                links.type = instantiateType(getTypeOfSymbol(links.target), links.mapper);
            }
            return links.type;
        }
        function getTypeOfSymbol(symbol) {
            if (symbol.flags & (1 /* Variable */ | 2 /* Property */)) {
                return getTypeOfVariableOrParameterOrProperty(symbol);
            }
            if (symbol.flags & (8 /* Function */ | 2048 /* Method */ | 16 /* Class */ | 64 /* Enum */ | 128 /* ValueModule */)) {
                return getTypeOfFuncClassEnumModule(symbol);
            }
            if (symbol.flags & 4 /* EnumMember */) {
                return getTypeOfEnumMember(symbol);
            }
            if (symbol.flags & ts.SymbolFlags.Accessor) {
                return getTypeOfAccessors(symbol);
            }
            if (symbol.flags & 4194304 /* Import */) {
                return getTypeOfImport(symbol);
            }
            if (symbol.flags & 8388608 /* Instantiated */) {
                return getTypeOfInstantiatedSymbol(symbol);
            }
            return unknownType;
        }
        function getTargetType(type) {
            return type.flags & 4096 /* Reference */ ? type.target : type;
        }
        function hasBaseType(type, checkBase) {
            return check(type);
            function check(type) {
                var target = getTargetType(type);
                return target === checkBase || ts.forEach(target.baseTypes, check);
            }
        }
        // Return combined list of type parameters from all declarations of a class or interface. Elsewhere we check they're all
        // the same, but even if they're not we still need the complete list to ensure instantiations supply type arguments
        // for all type parameters.
        function getTypeParametersOfClassOrInterface(symbol) {
            var result;
            ts.forEach(symbol.declarations, function (node) {
                if (node.kind === 175 /* InterfaceDeclaration */ || node.kind === 174 /* ClassDeclaration */) {
                    var declaration = node;
                    if (declaration.typeParameters && declaration.typeParameters.length) {
                        ts.forEach(declaration.typeParameters, function (node) {
                            var tp = getDeclaredTypeOfTypeParameter(getSymbolOfNode(node));
                            if (!result) {
                                result = [tp];
                            }
                            else if (!ts.contains(result, tp)) {
                                result.push(tp);
                            }
                        });
                    }
                }
            });
            return result;
        }
        function getDeclaredTypeOfClass(symbol) {
            var links = getSymbolLinks(symbol);
            if (!links.declaredType) {
                var type = links.declaredType = createObjectType(1024 /* Class */, symbol);
                var typeParameters = getTypeParametersOfClassOrInterface(symbol);
                if (typeParameters) {
                    type.flags |= 4096 /* Reference */;
                    type.typeParameters = typeParameters;
                    type.instantiations = {};
                    type.instantiations[getTypeListId(type.typeParameters)] = type;
                    type.target = type;
                    type.typeArguments = type.typeParameters;
                }
                type.baseTypes = [];
                var declaration = getDeclarationOfKind(symbol, 174 /* ClassDeclaration */);
                if (declaration.baseType) {
                    var baseType = getTypeFromTypeReferenceNode(declaration.baseType);
                    if (baseType !== unknownType) {
                        if (getTargetType(baseType).flags & 1024 /* Class */) {
                            if (type !== baseType && !hasBaseType(baseType, type)) {
                                type.baseTypes.push(baseType);
                            }
                            else {
                                error(declaration, ts.Diagnostics.Type_0_recursively_references_itself_as_a_base_type, typeToString(type, undefined, 1 /* WriteArrayAsGenericType */));
                            }
                        }
                        else {
                            error(declaration.baseType, ts.Diagnostics.A_class_may_only_extend_another_class);
                        }
                    }
                }
                type.declaredProperties = getNamedMembers(symbol.members);
                type.declaredCallSignatures = emptyArray;
                type.declaredConstructSignatures = emptyArray;
                type.declaredStringIndexType = getIndexTypeOfSymbol(symbol, 0 /* String */);
                type.declaredNumberIndexType = getIndexTypeOfSymbol(symbol, 1 /* Number */);
            }
            return links.declaredType;
        }
        function getDeclaredTypeOfInterface(symbol) {
            var links = getSymbolLinks(symbol);
            if (!links.declaredType) {
                var type = links.declaredType = createObjectType(2048 /* Interface */, symbol);
                var typeParameters = getTypeParametersOfClassOrInterface(symbol);
                if (typeParameters) {
                    type.flags |= 4096 /* Reference */;
                    type.typeParameters = typeParameters;
                    type.instantiations = {};
                    type.instantiations[getTypeListId(type.typeParameters)] = type;
                    type.target = type;
                    type.typeArguments = type.typeParameters;
                }
                type.baseTypes = [];
                ts.forEach(symbol.declarations, function (declaration) {
                    if (declaration.kind === 175 /* InterfaceDeclaration */ && declaration.baseTypes) {
                        ts.forEach(declaration.baseTypes, function (node) {
                            var baseType = getTypeFromTypeReferenceNode(node);
                            if (baseType !== unknownType) {
                                if (getTargetType(baseType).flags & (1024 /* Class */ | 2048 /* Interface */)) {
                                    if (type !== baseType && !hasBaseType(baseType, type)) {
                                        type.baseTypes.push(baseType);
                                    }
                                    else {
                                        error(declaration, ts.Diagnostics.Type_0_recursively_references_itself_as_a_base_type, typeToString(type, undefined, 1 /* WriteArrayAsGenericType */));
                                    }
                                }
                                else {
                                    error(node, ts.Diagnostics.An_interface_may_only_extend_a_class_or_another_interface);
                                }
                            }
                        });
                    }
                });
                type.declaredProperties = getNamedMembers(symbol.members);
                type.declaredCallSignatures = getSignaturesOfSymbol(symbol.members["__call"]);
                type.declaredConstructSignatures = getSignaturesOfSymbol(symbol.members["__new"]);
                type.declaredStringIndexType = getIndexTypeOfSymbol(symbol, 0 /* String */);
                type.declaredNumberIndexType = getIndexTypeOfSymbol(symbol, 1 /* Number */);
            }
            return links.declaredType;
        }
        function getDeclaredTypeOfEnum(symbol) {
            var links = getSymbolLinks(symbol);
            if (!links.declaredType) {
                var type = createType(128 /* Enum */);
                type.symbol = symbol;
                links.declaredType = type;
            }
            return links.declaredType;
        }
        function getDeclaredTypeOfTypeParameter(symbol) {
            var links = getSymbolLinks(symbol);
            if (!links.declaredType) {
                var type = createType(512 /* TypeParameter */);
                type.symbol = symbol;
                if (!getDeclarationOfKind(symbol, 117 /* TypeParameter */).constraint) {
                    type.constraint = noConstraintType;
                }
                links.declaredType = type;
            }
            return links.declaredType;
        }
        function getDeclaredTypeOfImport(symbol) {
            var links = getSymbolLinks(symbol);
            if (!links.declaredType) {
                links.declaredType = getDeclaredTypeOfSymbol(resolveImport(symbol));
            }
            return links.declaredType;
        }
        function getDeclaredTypeOfSymbol(symbol) {
            if (symbol.flags & 16 /* Class */) {
                return getDeclaredTypeOfClass(symbol);
            }
            if (symbol.flags & 32 /* Interface */) {
                return getDeclaredTypeOfInterface(symbol);
            }
            if (symbol.flags & 64 /* Enum */) {
                return getDeclaredTypeOfEnum(symbol);
            }
            if (symbol.flags & 262144 /* TypeParameter */) {
                return getDeclaredTypeOfTypeParameter(symbol);
            }
            if (symbol.flags & 4194304 /* Import */) {
                return getDeclaredTypeOfImport(symbol);
            }
            ts.Debug.assert((symbol.flags & 8388608 /* Instantiated */) === 0);
            return unknownType;
        }
        function createSymbolTable(symbols) {
            var result = {};
            for (var i = 0; i < symbols.length; i++) {
                var symbol = symbols[i];
                result[symbol.name] = symbol;
            }
            return result;
        }
        function createInstantiatedSymbolTable(symbols, mapper) {
            var result = {};
            for (var i = 0; i < symbols.length; i++) {
                var symbol = symbols[i];
                result[symbol.name] = instantiateSymbol(symbol, mapper);
            }
            return result;
        }
        function addInheritedMembers(symbols, baseSymbols) {
            for (var i = 0; i < baseSymbols.length; i++) {
                var s = baseSymbols[i];
                if (!ts.hasProperty(symbols, s.name)) {
                    symbols[s.name] = s;
                }
            }
        }
        function addInheritedSignatures(signatures, baseSignatures) {
            if (baseSignatures) {
                for (var i = 0; i < baseSignatures.length; i++) {
                    signatures.push(baseSignatures[i]);
                }
            }
        }
        function resolveClassOrInterfaceMembers(type) {
            var members = type.symbol.members;
            var callSignatures = type.declaredCallSignatures;
            var constructSignatures = type.declaredConstructSignatures;
            var stringIndexType = type.declaredStringIndexType;
            var numberIndexType = type.declaredNumberIndexType;
            if (type.baseTypes.length) {
                members = createSymbolTable(type.declaredProperties);
                ts.forEach(type.baseTypes, function (baseType) {
                    addInheritedMembers(members, getPropertiesOfType(baseType));
                    callSignatures = ts.concatenate(callSignatures, getSignaturesOfType(baseType, 0 /* Call */));
                    constructSignatures = ts.concatenate(constructSignatures, getSignaturesOfType(baseType, 1 /* Construct */));
                    stringIndexType = stringIndexType || getIndexTypeOfType(baseType, 0 /* String */);
                    numberIndexType = numberIndexType || getIndexTypeOfType(baseType, 1 /* Number */);
                });
            }
            setObjectTypeMembers(type, members, callSignatures, constructSignatures, stringIndexType, numberIndexType);
        }
        function resolveTypeReferenceMembers(type) {
            var target = type.target;
            var mapper = createTypeMapper(target.typeParameters, type.typeArguments);
            var members = createInstantiatedSymbolTable(target.declaredProperties, mapper);
            var callSignatures = instantiateList(target.declaredCallSignatures, mapper, instantiateSignature);
            var constructSignatures = instantiateList(target.declaredConstructSignatures, mapper, instantiateSignature);
            var stringIndexType = target.declaredStringIndexType ? instantiateType(target.declaredStringIndexType, mapper) : undefined;
            var numberIndexType = target.declaredNumberIndexType ? instantiateType(target.declaredNumberIndexType, mapper) : undefined;
            ts.forEach(target.baseTypes, function (baseType) {
                var instantiatedBaseType = instantiateType(baseType, mapper);
                addInheritedMembers(members, getPropertiesOfType(instantiatedBaseType));
                callSignatures = ts.concatenate(callSignatures, getSignaturesOfType(instantiatedBaseType, 0 /* Call */));
                constructSignatures = ts.concatenate(constructSignatures, getSignaturesOfType(instantiatedBaseType, 1 /* Construct */));
                stringIndexType = stringIndexType || getIndexTypeOfType(instantiatedBaseType, 0 /* String */);
                numberIndexType = numberIndexType || getIndexTypeOfType(instantiatedBaseType, 1 /* Number */);
            });
            setObjectTypeMembers(type, members, callSignatures, constructSignatures, stringIndexType, numberIndexType);
        }
        function createSignature(declaration, typeParameters, parameters, resolvedReturnType, minArgumentCount, hasRestParameter, hasStringLiterals) {
            var sig = new Signature(checker);
            sig.declaration = declaration;
            sig.typeParameters = typeParameters;
            sig.parameters = parameters;
            sig.resolvedReturnType = resolvedReturnType;
            sig.minArgumentCount = minArgumentCount;
            sig.hasRestParameter = hasRestParameter;
            sig.hasStringLiterals = hasStringLiterals;
            return sig;
        }
        function cloneSignature(sig) {
            return createSignature(sig.declaration, sig.typeParameters, sig.parameters, sig.resolvedReturnType, sig.minArgumentCount, sig.hasRestParameter, sig.hasStringLiterals);
        }
        function getDefaultConstructSignatures(classType) {
            if (classType.baseTypes.length) {
                var baseType = classType.baseTypes[0];
                var baseSignatures = getSignaturesOfType(getTypeOfSymbol(baseType.symbol), 1 /* Construct */);
                return ts.map(baseSignatures, function (baseSignature) {
                    var signature = baseType.flags & 4096 /* Reference */ ? getSignatureInstantiation(baseSignature, baseType.typeArguments) : cloneSignature(baseSignature);
                    signature.typeParameters = classType.typeParameters;
                    signature.resolvedReturnType = classType;
                    return signature;
                });
            }
            return [createSignature(undefined, classType.typeParameters, emptyArray, classType, 0, false, false)];
        }
        function createTupleTypeMemberSymbols(memberTypes) {
            var members = {};
            for (var i = 0; i < memberTypes.length; i++) {
                var symbol = createSymbol(2 /* Property */ | 33554432 /* Transient */, "" + i);
                symbol.type = memberTypes[i];
                members[i] = symbol;
            }
            return members;
        }
        function resolveTupleTypeMembers(type) {
            var arrayType = resolveObjectTypeMembers(createArrayType(getBestCommonType(type.elementTypes)));
            var members = createTupleTypeMemberSymbols(type.elementTypes);
            addInheritedMembers(members, arrayType.properties);
            setObjectTypeMembers(type, members, arrayType.callSignatures, arrayType.constructSignatures, arrayType.stringIndexType, arrayType.numberIndexType);
        }
        function resolveAnonymousTypeMembers(type) {
            var symbol = type.symbol;
            if (symbol.flags & 512 /* TypeLiteral */) {
                var members = symbol.members;
                var callSignatures = getSignaturesOfSymbol(members["__call"]);
                var constructSignatures = getSignaturesOfSymbol(members["__new"]);
                var stringIndexType = getIndexTypeOfSymbol(symbol, 0 /* String */);
                var numberIndexType = getIndexTypeOfSymbol(symbol, 1 /* Number */);
            }
            else {
                // Combinations of function, class, enum and module
                var members = emptySymbols;
                var callSignatures = emptyArray;
                var constructSignatures = emptyArray;
                if (symbol.flags & ts.SymbolFlags.HasExports) {
                    members = symbol.exports;
                }
                if (symbol.flags & (8 /* Function */ | 2048 /* Method */)) {
                    callSignatures = getSignaturesOfSymbol(symbol);
                }
                if (symbol.flags & 16 /* Class */) {
                    var classType = getDeclaredTypeOfClass(symbol);
                    constructSignatures = getSignaturesOfSymbol(symbol.members["__constructor"]);
                    if (!constructSignatures.length) {
                        constructSignatures = getDefaultConstructSignatures(classType);
                    }
                    if (classType.baseTypes.length) {
                        members = createSymbolTable(getNamedMembers(members));
                        addInheritedMembers(members, getPropertiesOfType(getTypeOfSymbol(classType.baseTypes[0].symbol)));
                    }
                }
                var stringIndexType = undefined;
                var numberIndexType = (symbol.flags & 64 /* Enum */) ? stringType : undefined;
            }
            setObjectTypeMembers(type, members, callSignatures, constructSignatures, stringIndexType, numberIndexType);
        }
        function resolveObjectTypeMembers(type) {
            if (!type.members) {
                if (type.flags & (1024 /* Class */ | 2048 /* Interface */)) {
                    resolveClassOrInterfaceMembers(type);
                }
                else if (type.flags & 16384 /* Anonymous */) {
                    resolveAnonymousTypeMembers(type);
                }
                else if (type.flags & 8192 /* Tuple */) {
                    resolveTupleTypeMembers(type);
                }
                else {
                    resolveTypeReferenceMembers(type);
                }
            }
            return type;
        }
        function getPropertiesOfType(type) {
            if (type.flags & ts.TypeFlags.ObjectType) {
                return resolveObjectTypeMembers(type).properties;
            }
            return emptyArray;
        }
        function getPropertyOfType(type, name) {
            if (type.flags & ts.TypeFlags.ObjectType) {
                var resolved = resolveObjectTypeMembers(type);
                if (ts.hasProperty(resolved.members, name)) {
                    var symbol = resolved.members[name];
                    if (symbolIsValue(symbol)) {
                        return symbol;
                    }
                }
            }
        }
        function getPropertyOfApparentType(type, name) {
            if (type.flags & ts.TypeFlags.ObjectType) {
                var resolved = resolveObjectTypeMembers(type);
                if (ts.hasProperty(resolved.members, name)) {
                    var symbol = resolved.members[name];
                    if (symbolIsValue(symbol)) {
                        return symbol;
                    }
                }
                if (resolved === anyFunctionType || resolved.callSignatures.length || resolved.constructSignatures.length) {
                    var symbol = getPropertyOfType(globalFunctionType, name);
                    if (symbol)
                        return symbol;
                }
                return getPropertyOfType(globalObjectType, name);
            }
        }
        function getSignaturesOfType(type, kind) {
            if (type.flags & ts.TypeFlags.ObjectType) {
                var resolved = resolveObjectTypeMembers(type);
                return kind === 0 /* Call */ ? resolved.callSignatures : resolved.constructSignatures;
            }
            return emptyArray;
        }
        function getIndexTypeOfType(type, kind) {
            if (type.flags & ts.TypeFlags.ObjectType) {
                var resolved = resolveObjectTypeMembers(type);
                return kind === 0 /* String */ ? resolved.stringIndexType : resolved.numberIndexType;
            }
        }
        // Return list of type parameters with duplicates removed (duplicate identifier errors are generated in the actual
        // type checking functions).
        function getTypeParametersFromDeclaration(typeParameterDeclarations) {
            var result = [];
            ts.forEach(typeParameterDeclarations, function (node) {
                var tp = getDeclaredTypeOfTypeParameter(node.symbol);
                if (!ts.contains(result, tp)) {
                    result.push(tp);
                }
            });
            return result;
        }
        function getSignatureFromDeclaration(declaration) {
            var links = getNodeLinks(declaration);
            if (!links.resolvedSignature) {
                var classType = declaration.kind === 121 /* Constructor */ ? getDeclaredTypeOfClass(declaration.parent.symbol) : undefined;
                var typeParameters = classType ? classType.typeParameters : declaration.typeParameters ? getTypeParametersFromDeclaration(declaration.typeParameters) : undefined;
                var parameters = [];
                var hasStringLiterals = false;
                var minArgumentCount = -1;
                for (var i = 0, n = declaration.parameters.length; i < n; i++) {
                    var param = declaration.parameters[i];
                    parameters.push(param.symbol);
                    if (param.type && param.type.kind === 7 /* StringLiteral */) {
                        hasStringLiterals = true;
                    }
                    if (minArgumentCount < 0) {
                        if (param.initializer || param.flags & (4 /* QuestionMark */ | 8 /* Rest */)) {
                            minArgumentCount = i;
                        }
                    }
                }
                if (minArgumentCount < 0) {
                    minArgumentCount = declaration.parameters.length;
                }
                var returnType;
                if (classType) {
                    returnType = classType;
                }
                else if (declaration.type) {
                    returnType = getTypeFromTypeNode(declaration.type);
                }
                else {
                    // TypeScript 1.0 spec (April 2014):
                    // If only one accessor includes a type annotation, the other behaves as if it had the same type annotation.
                    if (declaration.kind === 122 /* GetAccessor */) {
                        var setter = getDeclarationOfKind(declaration.symbol, 123 /* SetAccessor */);
                        returnType = getAnnotatedAccessorType(setter);
                    }
                    if (!returnType && !declaration.body) {
                        returnType = anyType;
                    }
                }
                links.resolvedSignature = createSignature(declaration, typeParameters, parameters, returnType, minArgumentCount, ts.hasRestParameters(declaration), hasStringLiterals);
            }
            return links.resolvedSignature;
        }
        function getSignaturesOfSymbol(symbol) {
            if (!symbol)
                return emptyArray;
            var result = [];
            for (var i = 0, len = symbol.declarations.length; i < len; i++) {
                var node = symbol.declarations[i];
                switch (node.kind) {
                    case 172 /* FunctionDeclaration */:
                    case 120 /* Method */:
                    case 121 /* Constructor */:
                    case 124 /* CallSignature */:
                    case 125 /* ConstructSignature */:
                    case 126 /* IndexSignature */:
                    case 122 /* GetAccessor */:
                    case 123 /* SetAccessor */:
                    case 141 /* FunctionExpression */:
                    case 142 /* ArrowFunction */:
                        // Don't include signature if node is the implementation of an overloaded function. A node is considered
                        // an implementation node if it has a body and the previous node is of the same kind and immediately
                        // precedes the implementation node (i.e. has the same parent and ends where the implementation starts).
                        if (i > 0 && node.body) {
                            var previous = symbol.declarations[i - 1];
                            if (node.parent === previous.parent && node.kind === previous.kind && node.pos === previous.end) {
                                break;
                            }
                        }
                        result.push(getSignatureFromDeclaration(node));
                }
            }
            return result;
        }
        function getReturnTypeOfSignature(signature) {
            if (!signature.resolvedReturnType) {
                signature.resolvedReturnType = resolvingType;
                if (signature.target) {
                    var type = instantiateType(getReturnTypeOfSignature(signature.target), signature.mapper);
                }
                else {
                    var type = getReturnTypeFromBody(signature.declaration);
                }
                if (signature.resolvedReturnType === resolvingType) {
                    signature.resolvedReturnType = type;
                }
            }
            else if (signature.resolvedReturnType === resolvingType) {
                signature.resolvedReturnType = anyType;
                if (compilerOptions.noImplicitAny) {
                    var declaration = signature.declaration;
                    if (declaration.name) {
                        error(declaration.name, ts.Diagnostics._0_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_referenced_directly_or_indirectly_in_one_of_its_return_expressions, ts.identifierToString(declaration.name));
                    }
                    else {
                        error(declaration, ts.Diagnostics.Function_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_referenced_directly_or_indirectly_in_one_of_its_return_expressions);
                    }
                }
            }
            return signature.resolvedReturnType;
        }
        function getRestTypeOfSignature(signature) {
            if (signature.hasRestParameter) {
                var type = getTypeOfSymbol(signature.parameters[signature.parameters.length - 1]);
                if (type.flags & 4096 /* Reference */ && type.target === globalArrayType) {
                    return type.typeArguments[0];
                }
            }
            return anyType;
        }
        function getSignatureInstantiation(signature, typeArguments) {
            return instantiateSignature(signature, createTypeMapper(signature.typeParameters, typeArguments), true);
        }
        function getErasedSignature(signature) {
            if (!signature.typeParameters)
                return signature;
            if (!signature.erasedSignatureCache) {
                if (signature.target) {
                    signature.erasedSignatureCache = instantiateSignature(getErasedSignature(signature.target), signature.mapper);
                }
                else {
                    signature.erasedSignatureCache = instantiateSignature(signature, createTypeEraser(signature.typeParameters), true);
                }
            }
            return signature.erasedSignatureCache;
        }
        function getOrCreateTypeFromSignature(signature) {
            // There are two ways to declare a construct signature, one is by declaring a class constructor
            // using the constructor keyword, and the other is declaring a bare construct signature in an
            // object type literal or interface (using the new keyword). Each way of declaring a constructor
            // will result in a different declaration kind.
            if (!signature.isolatedSignatureType) {
                var isConstructor = signature.declaration.kind === 121 /* Constructor */ || signature.declaration.kind === 125 /* ConstructSignature */;
                var type = createObjectType(16384 /* Anonymous */ | 32768 /* FromSignature */);
                type.members = emptySymbols;
                type.properties = emptyArray;
                type.callSignatures = !isConstructor ? [signature] : emptyArray;
                type.constructSignatures = isConstructor ? [signature] : emptyArray;
                signature.isolatedSignatureType = type;
            }
            return signature.isolatedSignatureType;
        }
        function getIndexSymbol(symbol) {
            return symbol.members["__index"];
        }
        function getIndexDeclarationOfSymbol(symbol, kind) {
            var syntaxKind = kind === 1 /* Number */ ? 112 /* NumberKeyword */ : 114 /* StringKeyword */;
            var indexSymbol = getIndexSymbol(symbol);
            if (indexSymbol) {
                var len = indexSymbol.declarations.length;
                for (var i = 0; i < len; i++) {
                    var node = indexSymbol.declarations[i];
                    if (node.parameters.length === 1) {
                        var parameter = node.parameters[0];
                        if (parameter && parameter.type && parameter.type.kind === syntaxKind) {
                            return node;
                        }
                    }
                }
            }
            return undefined;
        }
        function getIndexTypeOfSymbol(symbol, kind) {
            var declaration = getIndexDeclarationOfSymbol(symbol, kind);
            return declaration ? declaration.type ? getTypeFromTypeNode(declaration.type) : anyType : undefined;
        }
        function getConstraintOfTypeParameter(type) {
            if (!type.constraint) {
                if (type.target) {
                    var targetConstraint = getConstraintOfTypeParameter(type.target);
                    type.constraint = targetConstraint ? instantiateType(targetConstraint, type.mapper) : noConstraintType;
                }
                else {
                    type.constraint = getTypeFromTypeNode(getDeclarationOfKind(type.symbol, 117 /* TypeParameter */).constraint);
                }
            }
            return type.constraint === noConstraintType ? undefined : type.constraint;
        }
        function getTypeListId(types) {
            switch (types.length) {
                case 1:
                    return "" + types[0].id;
                case 2:
                    return types[0].id + "," + types[1].id;
                default:
                    var result = "";
                    for (var i = 0; i < types.length; i++) {
                        if (i > 0)
                            result += ",";
                        result += types[i].id;
                    }
                    return result;
            }
        }
        function createTypeReference(target, typeArguments) {
            var id = getTypeListId(typeArguments);
            var type = target.instantiations[id];
            if (!type) {
                type = target.instantiations[id] = createObjectType(4096 /* Reference */, target.symbol);
                type.target = target;
                type.typeArguments = typeArguments;
            }
            return type;
        }
        function isTypeParameterReferenceIllegalInConstraint(typeReferenceNode, typeParameterSymbol) {
            var links = getNodeLinks(typeReferenceNode);
            if (links.isIllegalTypeReferenceInConstraint !== undefined) {
                return links.isIllegalTypeReferenceInConstraint;
            }
            // bubble up to the declaration
            var currentNode = typeReferenceNode;
            while (!ts.forEach(typeParameterSymbol.declarations, function (d) { return d.parent === currentNode.parent; })) {
                currentNode = currentNode.parent;
            }
            // if last step was made from the type parameter this means that path has started somewhere in constraint which is illegal
            links.isIllegalTypeReferenceInConstraint = currentNode.kind === 117 /* TypeParameter */;
            return links.isIllegalTypeReferenceInConstraint;
        }
        function checkTypeParameterHasIllegalReferencesInConstraint(typeParameter) {
            var typeParameterSymbol;
            function check(n) {
                if (n.kind === 127 /* TypeReference */ && n.typeName.kind === 59 /* Identifier */) {
                    var links = getNodeLinks(n);
                    if (links.isIllegalTypeReferenceInConstraint === undefined) {
                        var symbol = resolveName(typeParameter, n.typeName.text, ts.SymbolFlags.Type, undefined, undefined);
                        if (symbol && (symbol.flags & 262144 /* TypeParameter */)) {
                            // TypeScript 1.0 spec (April 2014): 3.4.1
                            // Type parameters declared in a particular type parameter list 
                            // may not be referenced in constraints in that type parameter list
                            // symbol.declaration.parent === typeParameter.parent
                            // -> typeParameter and symbol.declaration originate from the same type parameter list 
                            // -> illegal for all declarations in symbol
                            // forEach === exists
                            links.isIllegalTypeReferenceInConstraint = ts.forEach(symbol.declarations, function (d) { return d.parent == typeParameter.parent; });
                        }
                    }
                    if (links.isIllegalTypeReferenceInConstraint) {
                        error(typeParameter, ts.Diagnostics.Constraint_of_a_type_parameter_cannot_reference_any_type_parameter_from_the_same_type_parameter_list);
                    }
                }
                ts.forEachChild(n, check);
            }
            if (typeParameter.constraint) {
                typeParameterSymbol = getSymbolOfNode(typeParameter);
                check(typeParameter.constraint);
            }
        }
        function getTypeFromTypeReferenceNode(node) {
            var links = getNodeLinks(node);
            if (!links.resolvedType) {
                var symbol = resolveEntityName(node, node.typeName, ts.SymbolFlags.Type);
                if (symbol) {
                    var type;
                    if ((symbol.flags & 262144 /* TypeParameter */) && isTypeParameterReferenceIllegalInConstraint(node, symbol)) {
                        // TypeScript 1.0 spec (April 2014): 3.4.1
                        // Type parameters declared in a particular type parameter list 
                        // may not be referenced in constraints in that type parameter list
                        // Implementation: such type references are resolved to 'unknown' type that usually denotes error
                        type = unknownType;
                    }
                    else {
                        type = getDeclaredTypeOfSymbol(symbol);
                        if (type.flags & (1024 /* Class */ | 2048 /* Interface */) && type.flags & 4096 /* Reference */) {
                            var typeParameters = type.typeParameters;
                            if (node.typeArguments && node.typeArguments.length === typeParameters.length) {
                                type = createTypeReference(type, ts.map(node.typeArguments, getTypeFromTypeNode));
                            }
                            else {
                                error(node, ts.Diagnostics.Generic_type_0_requires_1_type_argument_s, typeToString(type, undefined, 1 /* WriteArrayAsGenericType */), typeParameters.length);
                                type = undefined;
                            }
                        }
                        else {
                            if (node.typeArguments) {
                                error(node, ts.Diagnostics.Type_0_is_not_generic, typeToString(type));
                                type = undefined;
                            }
                        }
                    }
                }
                links.resolvedType = type || unknownType;
            }
            return links.resolvedType;
        }
        function getTypeFromTypeQueryNode(node) {
            var links = getNodeLinks(node);
            if (!links.resolvedType) {
                // TypeScript 1.0 spec (April 2014): 3.6.3
                // The expression is processed as an identifier expression (section 4.3)
                // or property access expression(section 4.10),
                // the widened type(section 3.9) of which becomes the result. 
                links.resolvedType = getWidenedType(checkExpression(node.exprName));
            }
            return links.resolvedType;
        }
        function getTypeOfGlobalSymbol(symbol, arity) {
            function getTypeDeclaration(symbol) {
                var declarations = symbol.declarations;
                for (var i = 0; i < declarations.length; i++) {
                    var declaration = declarations[i];
                    switch (declaration.kind) {
                        case 174 /* ClassDeclaration */:
                        case 175 /* InterfaceDeclaration */:
                        case 176 /* EnumDeclaration */:
                            return declaration;
                    }
                }
            }
            if (!symbol) {
                return emptyObjectType;
            }
            var type = getDeclaredTypeOfSymbol(symbol);
            if (!(type.flags & ts.TypeFlags.ObjectType)) {
                error(getTypeDeclaration(symbol), ts.Diagnostics.Global_type_0_must_be_a_class_or_interface_type, symbol.name);
                return emptyObjectType;
            }
            if ((type.typeParameters ? type.typeParameters.length : 0) !== arity) {
                error(getTypeDeclaration(symbol), ts.Diagnostics.Global_type_0_must_have_1_type_parameter_s, symbol.name, arity);
                return emptyObjectType;
            }
            return type;
        }
        function getGlobalSymbol(name) {
            return resolveName(undefined, name, ts.SymbolFlags.Type, ts.Diagnostics.Cannot_find_global_type_0, name);
        }
        function getGlobalType(name) {
            return getTypeOfGlobalSymbol(getGlobalSymbol(name), 0);
        }
        function createArrayType(elementType) {
            // globalArrayType will be undefined if we get here during creation of the Array type. This for example happens if
            // user code augments the Array type with call or construct signatures that have an array type as the return type.
            // We instead use globalArraySymbol to obtain the (not yet fully constructed) Array type.
            var arrayType = globalArrayType || getDeclaredTypeOfSymbol(globalArraySymbol);
            return arrayType !== emptyObjectType ? createTypeReference(arrayType, [elementType]) : emptyObjectType;
        }
        function getTypeFromArrayTypeNode(node) {
            var links = getNodeLinks(node);
            if (!links.resolvedType) {
                links.resolvedType = createArrayType(getTypeFromTypeNode(node.elementType));
            }
            return links.resolvedType;
        }
        function createTupleType(elementTypes) {
            var id = getTypeListId(elementTypes);
            var type = tupleTypes[id];
            if (!type) {
                type = tupleTypes[id] = createObjectType(8192 /* Tuple */);
                type.elementTypes = elementTypes;
            }
            return type;
        }
        function getTypeFromTupleTypeNode(node) {
            var links = getNodeLinks(node);
            if (!links.resolvedType) {
                links.resolvedType = createTupleType(ts.map(node.elementTypes, getTypeFromTypeNode));
            }
            return links.resolvedType;
        }
        function getTypeFromTypeLiteralNode(node) {
            var links = getNodeLinks(node);
            if (!links.resolvedType) {
                // Deferred resolution of members is handled by resolveObjectTypeMembers
                links.resolvedType = createObjectType(16384 /* Anonymous */, node.symbol);
            }
            return links.resolvedType;
        }
        function getStringLiteralType(node) {
            if (ts.hasProperty(stringLiteralTypes, node.text))
                return stringLiteralTypes[node.text];
            var type = stringLiteralTypes[node.text] = createType(256 /* StringLiteral */);
            type.text = ts.getSourceTextOfNode(node);
            return type;
        }
        function getTypeFromStringLiteral(node) {
            var links = getNodeLinks(node);
            if (!links.resolvedType) {
                links.resolvedType = getStringLiteralType(node);
            }
            return links.resolvedType;
        }
        function getTypeFromTypeNode(node) {
            switch (node.kind) {
                case 105 /* AnyKeyword */:
                    return anyType;
                case 114 /* StringKeyword */:
                    return stringType;
                case 112 /* NumberKeyword */:
                    return numberType;
                case 106 /* BooleanKeyword */:
                    return booleanType;
                case 93 /* VoidKeyword */:
                    return voidType;
                case 7 /* StringLiteral */:
                    return getTypeFromStringLiteral(node);
                case 127 /* TypeReference */:
                    return getTypeFromTypeReferenceNode(node);
                case 128 /* TypeQuery */:
                    return getTypeFromTypeQueryNode(node);
                case 130 /* ArrayType */:
                    return getTypeFromArrayTypeNode(node);
                case 131 /* TupleType */:
                    return getTypeFromTupleTypeNode(node);
                case 129 /* TypeLiteral */:
                    return getTypeFromTypeLiteralNode(node);
                case 59 /* Identifier */:
                case 116 /* QualifiedName */:
                    var symbol = getSymbolInfo(node);
                    return symbol && getDeclaredTypeOfSymbol(symbol);
                default:
                    return unknownType;
            }
        }
        function instantiateList(items, mapper, instantiator) {
            if (items && items.length) {
                var result = [];
                for (var i = 0; i < items.length; i++) {
                    result.push(instantiator(items[i], mapper));
                }
                return result;
            }
            return items;
        }
        function createUnaryTypeMapper(source, target) {
            return function (t) { return t === source ? target : t; };
        }
        function createBinaryTypeMapper(source1, target1, source2, target2) {
            return function (t) { return t === source1 ? target1 : t === source2 ? target2 : t; };
        }
        function createTypeMapper(sources, targets) {
            switch (sources.length) {
                case 1:
                    return createUnaryTypeMapper(sources[0], targets[0]);
                case 2:
                    return createBinaryTypeMapper(sources[0], targets[0], sources[1], targets[1]);
            }
            return function (t) {
                for (var i = 0; i < sources.length; i++) {
                    if (t === sources[i])
                        return targets[i];
                }
                return t;
            };
        }
        function createUnaryTypeEraser(source) {
            return function (t) { return t === source ? anyType : t; };
        }
        function createBinaryTypeEraser(source1, source2) {
            return function (t) { return t === source1 || t === source2 ? anyType : t; };
        }
        function createTypeEraser(sources) {
            switch (sources.length) {
                case 1:
                    return createUnaryTypeEraser(sources[0]);
                case 2:
                    return createBinaryTypeEraser(sources[0], sources[1]);
            }
            return function (t) {
                for (var i = 0; i < sources.length; i++) {
                    if (t === sources[i])
                        return anyType;
                }
                return t;
            };
        }
        function createInferenceMapper(context) {
            return function (t) {
                for (var i = 0; i < context.typeParameters.length; i++) {
                    if (t === context.typeParameters[i]) {
                        return getInferredType(context, i);
                    }
                }
                return t;
            };
        }
        function identityMapper(type) {
            return type;
        }
        function combineTypeMappers(mapper1, mapper2) {
            return function (t) { return mapper2(mapper1(t)); };
        }
        function instantiateTypeParameter(typeParameter, mapper) {
            var result = createType(512 /* TypeParameter */);
            result.symbol = typeParameter.symbol;
            if (typeParameter.constraint) {
                result.constraint = instantiateType(typeParameter.constraint, mapper);
            }
            else {
                result.target = typeParameter;
                result.mapper = mapper;
            }
            return result;
        }
        function instantiateSignature(signature, mapper, eraseTypeParameters) {
            if (signature.typeParameters && !eraseTypeParameters) {
                var freshTypeParameters = instantiateList(signature.typeParameters, mapper, instantiateTypeParameter);
                mapper = combineTypeMappers(createTypeMapper(signature.typeParameters, freshTypeParameters), mapper);
            }
            var result = createSignature(signature.declaration, freshTypeParameters, instantiateList(signature.parameters, mapper, instantiateSymbol), signature.resolvedReturnType ? instantiateType(signature.resolvedReturnType, mapper) : undefined, signature.minArgumentCount, signature.hasRestParameter, signature.hasStringLiterals);
            result.target = signature;
            result.mapper = mapper;
            return result;
        }
        function instantiateSymbol(symbol, mapper) {
            if (symbol.flags & 8388608 /* Instantiated */) {
                var links = getSymbolLinks(symbol);
                // If symbol being instantiated is itself a instantiation, fetch the original target and combine the
                // type mappers. This ensures that original type identities are properly preserved and that aliases
                // always reference a non-aliases.
                symbol = links.target;
                mapper = combineTypeMappers(links.mapper, mapper);
            }
            // Keep the flags from the symbol we're instantiating.  Mark that is instantiated, and 
            // also transient so that we can just store data on it directly.
            var result = createSymbol(8388608 /* Instantiated */ | 33554432 /* Transient */, symbol.name);
            result.declarations = symbol.declarations;
            result.parent = symbol.parent;
            result.target = symbol;
            result.mapper = mapper;
            if (symbol.valueDeclaration) {
                result.valueDeclaration = symbol.valueDeclaration;
            }
            return result;
        }
        function instantiateAnonymousType(type, mapper) {
            var result = createObjectType(16384 /* Anonymous */, type.symbol);
            result.properties = instantiateList(getPropertiesOfType(type), mapper, instantiateSymbol);
            result.members = createSymbolTable(result.properties);
            result.callSignatures = instantiateList(getSignaturesOfType(type, 0 /* Call */), mapper, instantiateSignature);
            result.constructSignatures = instantiateList(getSignaturesOfType(type, 1 /* Construct */), mapper, instantiateSignature);
            var stringIndexType = getIndexTypeOfType(type, 0 /* String */);
            var numberIndexType = getIndexTypeOfType(type, 1 /* Number */);
            if (stringIndexType)
                result.stringIndexType = instantiateType(stringIndexType, mapper);
            if (numberIndexType)
                result.numberIndexType = instantiateType(numberIndexType, mapper);
            return result;
        }
        function instantiateType(type, mapper) {
            if (mapper !== identityMapper) {
                if (type.flags & 512 /* TypeParameter */) {
                    return mapper(type);
                }
                if (type.flags & 16384 /* Anonymous */) {
                    return type.symbol && type.symbol.flags & (8 /* Function */ | 2048 /* Method */ | 512 /* TypeLiteral */ | 1024 /* ObjectLiteral */) ? instantiateAnonymousType(type, mapper) : type;
                }
                if (type.flags & 4096 /* Reference */) {
                    return createTypeReference(type.target, instantiateList(type.typeArguments, mapper, instantiateType));
                }
                if (type.flags & 8192 /* Tuple */) {
                    return createTupleType(instantiateList(type.elementTypes, mapper, instantiateType));
                }
            }
            return type;
        }
        // Returns true if the given expression contains (at any level of nesting) a function or arrow expression
        // that is subject to contextual typing.
        function isContextSensitiveExpression(node) {
            switch (node.kind) {
                case 141 /* FunctionExpression */:
                case 142 /* ArrowFunction */:
                    return !node.typeParameters && !ts.forEach(node.parameters, function (p) { return p.type; });
                case 133 /* ObjectLiteral */:
                    return ts.forEach(node.properties, function (p) { return p.kind === 134 /* PropertyAssignment */ && isContextSensitiveExpression(p.initializer); });
                case 132 /* ArrayLiteral */:
                    return ts.forEach(node.elements, function (e) { return isContextSensitiveExpression(e); });
                case 146 /* ConditionalExpression */:
                    return isContextSensitiveExpression(node.whenTrue) || isContextSensitiveExpression(node.whenFalse);
                case 145 /* BinaryExpression */:
                    return node.operator === 44 /* BarBarToken */ && (isContextSensitiveExpression(node.left) || isContextSensitiveExpression(node.right));
            }
            return false;
        }
        function getTypeWithoutConstructors(type) {
            if (type.flags & ts.TypeFlags.ObjectType) {
                var resolved = resolveObjectTypeMembers(type);
                if (resolved.constructSignatures.length) {
                    var result = createObjectType(16384 /* Anonymous */, type.symbol);
                    result.members = resolved.members;
                    result.properties = resolved.properties;
                    result.callSignatures = resolved.callSignatures;
                    result.constructSignatures = emptyArray;
                    type = result;
                }
            }
            return type;
        }
        // TYPE CHECKING
        var subtypeRelation = {};
        var assignableRelation = {};
        var identityRelation = {};
        function isTypeIdenticalTo(source, target) {
            return checkTypeRelatedTo(source, target, identityRelation, undefined, undefined, undefined);
        }
        function isTypeSubtypeOf(source, target) {
            return checkTypeSubtypeOf(source, target, undefined, undefined, undefined);
        }
        function checkTypeSubtypeOf(source, target, errorNode, chainedMessage, terminalMessage) {
            return checkTypeRelatedTo(source, target, subtypeRelation, errorNode, chainedMessage, terminalMessage);
        }
        function isTypeAssignableTo(source, target) {
            return checkTypeAssignableTo(source, target, undefined, undefined, undefined);
        }
        function checkTypeAssignableTo(source, target, errorNode, chainedMessage, terminalMessage) {
            return checkTypeRelatedTo(source, target, assignableRelation, errorNode, chainedMessage, terminalMessage);
        }
        function isTypeRelatedTo(source, target, relation) {
            return checkTypeRelatedTo(source, target, relation, undefined, undefined, undefined);
        }
        function isSignatureAssignableTo(source, target) {
            var sourceType = getOrCreateTypeFromSignature(source);
            var targetType = getOrCreateTypeFromSignature(target);
            return checkTypeRelatedTo(sourceType, targetType, assignableRelation, undefined, undefined, undefined);
        }
        function isPropertyIdenticalTo(sourceProp, targetProp) {
            return isPropertyIdenticalToRecursive(sourceProp, targetProp, false, function (s, t, _reportErrors) { return isTypeIdenticalTo(s, t); });
        }
        function checkInheritedPropertiesAreIdentical(type, typeNode) {
            if (!type.baseTypes.length || type.baseTypes.length === 1) {
                return true;
            }
            var seen = {};
            ts.forEach(type.declaredProperties, function (p) {
                seen[p.name] = { prop: p, containingType: type };
            });
            var ok = true;
            for (var i = 0, len = type.baseTypes.length; i < len; ++i) {
                var base = type.baseTypes[i];
                var properties = getPropertiesOfType(base);
                for (var j = 0, proplen = properties.length; j < proplen; ++j) {
                    var prop = properties[j];
                    if (!ts.hasProperty(seen, prop.name)) {
                        seen[prop.name] = { prop: prop, containingType: base };
                    }
                    else {
                        var existing = seen[prop.name];
                        var isInheritedProperty = existing.containingType !== type;
                        if (isInheritedProperty && !isPropertyIdenticalTo(existing.prop, prop)) {
                            ok = false;
                            var typeName1 = typeToString(existing.containingType);
                            var typeName2 = typeToString(base);
                            var errorInfo = ts.chainDiagnosticMessages(undefined, ts.Diagnostics.Named_properties_0_of_types_1_and_2_are_not_identical, prop.name, typeName1, typeName2);
                            errorInfo = ts.chainDiagnosticMessages(errorInfo, ts.Diagnostics.Interface_0_cannot_simultaneously_extend_types_1_and_2_Colon, typeToString(type), typeName1, typeName2);
                            addDiagnostic(ts.createDiagnosticForNodeFromMessageChain(typeNode, errorInfo, program.getCompilerHost().getNewLine()));
                        }
                    }
                }
            }
            return ok;
        }
        function isPropertyIdenticalToRecursive(sourceProp, targetProp, reportErrors, relate) {
            // Two members are considered identical when
            // - they are public properties with identical names, optionality, and types,
            // - they are private or protected properties originating in the same declaration and having identical types
            if (sourceProp === targetProp) {
                return true;
            }
            var sourcePropAccessibility = getDeclarationFlagsFromSymbol(sourceProp) & (32 /* Private */ | 64 /* Protected */);
            var targetPropAccessibility = getDeclarationFlagsFromSymbol(targetProp) & (32 /* Private */ | 64 /* Protected */);
            if (sourcePropAccessibility !== targetPropAccessibility) {
                return false;
            }
            if (sourcePropAccessibility) {
                return getTargetSymbol(sourceProp) === getTargetSymbol(targetProp) && relate(getTypeOfSymbol(sourceProp), getTypeOfSymbol(targetProp), reportErrors);
            }
            else {
                return isOptionalProperty(sourceProp) === isOptionalProperty(targetProp) && relate(getTypeOfSymbol(sourceProp), getTypeOfSymbol(targetProp), reportErrors);
            }
        }
        function checkTypeRelatedTo(source, target, relation, errorNode, chainedMessage, terminalMessage) {
            var errorInfo;
            var sourceStack;
            var targetStack;
            var expandingFlags;
            var depth = 0;
            var overflow = false;
            ts.Debug.assert(relation !== identityRelation || !errorNode, "no error reporting in identity checking");
            var result = isRelatedToWithCustomErrors(source, target, errorNode !== undefined, chainedMessage, terminalMessage);
            if (overflow) {
                error(errorNode, ts.Diagnostics.Excessive_stack_depth_comparing_types_0_and_1, typeToString(source), typeToString(target));
            }
            else if (errorInfo) {
                addDiagnostic(ts.createDiagnosticForNodeFromMessageChain(errorNode, errorInfo, program.getCompilerHost().getNewLine()));
            }
            return result;
            function reportError(message, arg0, arg1, arg2) {
                errorInfo = ts.chainDiagnosticMessages(errorInfo, message, arg0, arg1, arg2);
            }
            function isRelatedTo(source, target, reportErrors) {
                return isRelatedToWithCustomErrors(source, target, reportErrors, undefined, undefined);
            }
            function isRelatedToWithCustomErrors(source, target, reportErrors, chainedMessage, terminalMessage) {
                if (relation === identityRelation) {
                    // both types are the same - covers 'they are the same primitive type or both are Any' or the same type parameter cases
                    if (source === target)
                        return true;
                }
                else {
                    if (source === target)
                        return true;
                    if (target.flags & 1 /* Any */)
                        return true;
                    if (source === undefinedType)
                        return true;
                    if (source === nullType && target !== undefinedType)
                        return true;
                    if (source.flags & 128 /* Enum */ && target === numberType)
                        return true;
                    if (source.flags & 256 /* StringLiteral */ && target === stringType)
                        return true;
                    if (relation === assignableRelation) {
                        if (source.flags & 1 /* Any */)
                            return true;
                        if (source === numberType && target.flags & 128 /* Enum */)
                            return true;
                    }
                }
                if (source.flags & 512 /* TypeParameter */ && target.flags & 512 /* TypeParameter */) {
                    if (typeParameterRelatedTo(source, target, reportErrors)) {
                        return true;
                    }
                }
                else {
                    var saveErrorInfo = errorInfo;
                    if (source.flags & 4096 /* Reference */ && target.flags & 4096 /* Reference */ && source.target === target.target) {
                        // We have type references to same target type, see if relationship holds for all type arguments
                        if (typesRelatedTo(source.typeArguments, target.typeArguments, reportErrors)) {
                            return true;
                        }
                    }
                    // Even if relationship doesn't hold for type arguments, it may hold in a structural comparison
                    // Report structural errors only if we haven't reported any errors yet
                    var reportStructuralErrors = reportErrors && errorInfo === saveErrorInfo;
                    // identity relation does not use apparent type
                    var sourceOrApparentType = relation === identityRelation ? source : getApparentType(source);
                    if (sourceOrApparentType.flags & ts.TypeFlags.ObjectType && target.flags & ts.TypeFlags.ObjectType && objectTypeRelatedTo(sourceOrApparentType, target, reportStructuralErrors)) {
                        errorInfo = saveErrorInfo;
                        return true;
                    }
                }
                if (reportErrors) {
                    // The error should end in a period when this is the deepest error in the chain
                    // (when errorInfo is undefined). Otherwise, it has a colon before the nested
                    // error.
                    chainedMessage = chainedMessage || ts.Diagnostics.Type_0_is_not_assignable_to_type_1_Colon;
                    terminalMessage = terminalMessage || ts.Diagnostics.Type_0_is_not_assignable_to_type_1;
                    var diagnosticKey = errorInfo ? chainedMessage : terminalMessage;
                    ts.Debug.assert(diagnosticKey);
                    reportError(diagnosticKey, typeToString(source), typeToString(target));
                }
                return false;
            }
            function typesRelatedTo(sources, targets, reportErrors) {
                for (var i = 0, len = sources.length; i < len; i++) {
                    if (!isRelatedTo(sources[i], targets[i], reportErrors))
                        return false;
                }
                return true;
            }
            function typeParameterRelatedTo(source, target, reportErrors) {
                if (relation === identityRelation) {
                    if (source.symbol.name !== target.symbol.name) {
                        return false;
                    }
                    // covers case when both type parameters does not have constraint (both equal to noConstraintType)
                    if (source.constraint === target.constraint) {
                        return true;
                    }
                    if (source.constraint === noConstraintType || target.constraint === noConstraintType) {
                        return false;
                    }
                    return isRelatedTo(source.constraint, target.constraint, reportErrors);
                }
                else {
                    while (true) {
                        var constraint = getConstraintOfTypeParameter(source);
                        if (constraint === target)
                            return true;
                        if (!(constraint && constraint.flags & 512 /* TypeParameter */))
                            break;
                        source = constraint;
                    }
                    return false;
                }
            }
            // Determine if two object types are related by structure. First, check if the result is already available in the global cache.
            // Second, check if we have already started a comparison of the given two types in which case we assume the result to be true.
            // Third, check if both types are part of deeply nested chains of generic type instantiations and if so assume the types are
            // equal and infinitely expanding. Fourth, if we have reached a depth of 100 nested comparisons, assume we have runaway recursion
            // and issue an error. Otherwise, actually compare the structure of the two types.
            function objectTypeRelatedTo(source, target, reportErrors) {
                if (overflow)
                    return false;
                var result;
                var id = source.id + "," + target.id;
                if ((result = relation[id]) !== undefined)
                    return result;
                if (depth > 0) {
                    for (var i = 0; i < depth; i++) {
                        if (source === sourceStack[i] && target === targetStack[i])
                            return true;
                    }
                    if (depth === 100) {
                        overflow = true;
                        return false;
                    }
                }
                else {
                    sourceStack = [];
                    targetStack = [];
                    expandingFlags = 0;
                }
                sourceStack[depth] = source;
                targetStack[depth] = target;
                depth++;
                var saveExpandingFlags = expandingFlags;
                if (!(expandingFlags & 1) && isDeeplyNestedGeneric(source, sourceStack))
                    expandingFlags |= 1;
                if (!(expandingFlags & 2) && isDeeplyNestedGeneric(target, targetStack))
                    expandingFlags |= 2;
                result = expandingFlags === 3 || propertiesRelatedTo(source, target, reportErrors) && signaturesRelatedTo(source, target, 0 /* Call */, reportErrors) && signaturesRelatedTo(source, target, 1 /* Construct */, reportErrors) && stringIndexTypesRelatedTo(source, target, reportErrors) && numberIndexTypesRelatedTo(source, target, reportErrors);
                expandingFlags = saveExpandingFlags;
                depth--;
                if (depth === 0) {
                    relation[id] = result;
                }
                return result;
            }
            // Return true if the given type is part of a deeply nested chain of generic instantiations. We consider this to be the case
            // when structural type comparisons have been started for 10 or more instantiations of the same generic type. It is possible,
            // though highly unlikely, for this test to be true in a situation where a chain of instantiations is not infinitely expanding.
            // Effectively, we will generate a false positive when two types are structurally equal to at least 10 levels, but unequal at
            // some level beyond that.
            function isDeeplyNestedGeneric(type, stack) {
                if (type.flags & 4096 /* Reference */ && depth >= 10) {
                    var target = type.target;
                    var count = 0;
                    for (var i = 0; i < depth; i++) {
                        var t = stack[i];
                        if (t.flags & 4096 /* Reference */ && t.target === target) {
                            count++;
                            if (count >= 10)
                                return true;
                        }
                    }
                }
                return false;
            }
            function propertiesRelatedTo(source, target, reportErrors) {
                if (relation === identityRelation) {
                    return propertiesAreIdenticalTo(source, target, reportErrors);
                }
                else {
                    return propertiesAreSubtypeOrAssignableTo(source, target, reportErrors);
                }
            }
            function propertiesAreIdenticalTo(source, target, reportErrors) {
                var sourceProperties = getPropertiesOfType(source);
                var targetProperties = getPropertiesOfType(target);
                if (sourceProperties.length !== targetProperties.length) {
                    return false;
                }
                for (var i = 0, len = sourceProperties.length; i < len; ++i) {
                    var sourceProp = sourceProperties[i];
                    var targetProp = getPropertyOfType(target, sourceProp.name);
                    if (!targetProp || !isPropertyIdenticalToRecursive(sourceProp, targetProp, reportErrors, isRelatedTo)) {
                        return false;
                    }
                }
                return true;
            }
            function propertiesAreSubtypeOrAssignableTo(source, target, reportErrors) {
                var properties = getPropertiesOfType(target);
                for (var i = 0; i < properties.length; i++) {
                    var targetProp = properties[i];
                    var sourceProp = getPropertyOfApparentType(source, targetProp.name);
                    if (sourceProp !== targetProp) {
                        if (!sourceProp) {
                            if (!isOptionalProperty(targetProp)) {
                                if (reportErrors) {
                                    reportError(ts.Diagnostics.Property_0_is_missing_in_type_1, symbolToString(targetProp), typeToString(source));
                                }
                                return false;
                            }
                        }
                        else if (!(targetProp.flags & 67108864 /* Prototype */)) {
                            var sourceFlags = getDeclarationFlagsFromSymbol(sourceProp);
                            var targetFlags = getDeclarationFlagsFromSymbol(targetProp);
                            if (sourceFlags & 32 /* Private */ || targetFlags & 32 /* Private */) {
                                if (sourceProp.valueDeclaration !== targetProp.valueDeclaration) {
                                    if (reportErrors) {
                                        if (sourceFlags & 32 /* Private */ && targetFlags & 32 /* Private */) {
                                            reportError(ts.Diagnostics.Types_have_separate_declarations_of_a_private_property_0, symbolToString(targetProp));
                                        }
                                        else {
                                            reportError(ts.Diagnostics.Property_0_is_private_in_type_1_but_not_in_type_2, symbolToString(targetProp), typeToString(sourceFlags & 32 /* Private */ ? source : target), typeToString(sourceFlags & 32 /* Private */ ? target : source));
                                        }
                                    }
                                    return false;
                                }
                            }
                            else if (targetFlags & 64 /* Protected */) {
                                var sourceDeclaredInClass = sourceProp.parent && sourceProp.parent.flags & 16 /* Class */;
                                var sourceClass = sourceDeclaredInClass ? getDeclaredTypeOfSymbol(sourceProp.parent) : undefined;
                                var targetClass = getDeclaredTypeOfSymbol(targetProp.parent);
                                if (!sourceClass || !hasBaseType(sourceClass, targetClass)) {
                                    if (reportErrors) {
                                        reportError(ts.Diagnostics.Property_0_is_protected_but_type_1_is_not_a_class_derived_from_2, symbolToString(targetProp), typeToString(sourceClass || source), typeToString(targetClass));
                                    }
                                    return false;
                                }
                            }
                            else if (sourceFlags & 64 /* Protected */) {
                                if (reportErrors) {
                                    reportError(ts.Diagnostics.Property_0_is_protected_in_type_1_but_public_in_type_2, symbolToString(targetProp), typeToString(source), typeToString(target));
                                }
                                return false;
                            }
                            if (!isRelatedTo(getTypeOfSymbol(sourceProp), getTypeOfSymbol(targetProp), reportErrors)) {
                                if (reportErrors) {
                                    reportError(ts.Diagnostics.Types_of_property_0_are_incompatible_Colon, symbolToString(targetProp));
                                }
                                return false;
                            }
                            if (isOptionalProperty(sourceProp) && !isOptionalProperty(targetProp)) {
                                // TypeScript 1.0 spec (April 2014): 3.8.3
                                // S is a subtype of a type T, and T is a supertype of S if ...
                                // S' and T are object types and, for each member M in T..
                                // M is a property and S' contains a property N where
                                // if M is a required property, N is also a required property 
                                // (M - property in T)
                                // (N - property in S)
                                if (reportErrors) {
                                    reportError(ts.Diagnostics.Property_0_is_optional_in_type_1_but_required_in_type_2, symbolToString(targetProp), typeToString(source), typeToString(target));
                                }
                                return false;
                            }
                        }
                    }
                }
                return true;
            }
            function signaturesRelatedTo(source, target, kind, reportErrors) {
                if (relation === identityRelation) {
                    return areSignaturesIdenticalTo(source, target, kind, reportErrors);
                }
                else {
                    return areSignaturesSubtypeOrAssignableTo(source, target, kind, reportErrors);
                }
            }
            function areSignaturesIdenticalTo(source, target, kind, reportErrors) {
                var sourceSignatures = getSignaturesOfType(source, kind);
                var targetSignatures = getSignaturesOfType(target, kind);
                if (sourceSignatures.length !== targetSignatures.length) {
                    return false;
                }
                for (var i = 0, len = sourceSignatures.length; i < len; ++i) {
                    if (!isSignatureIdenticalTo(sourceSignatures[i], targetSignatures[i], reportErrors)) {
                        return false;
                    }
                }
                return true;
            }
            function isSignatureIdenticalTo(source, target, reportErrors) {
                if (source === target) {
                    return true;
                }
                if (source.hasRestParameter !== target.hasRestParameter) {
                    return false;
                }
                if (source.parameters.length !== target.parameters.length) {
                    return false;
                }
                if (source.minArgumentCount !== target.minArgumentCount) {
                    return false;
                }
                if (source.typeParameters && target.typeParameters) {
                    if (source.typeParameters.length !== target.typeParameters.length) {
                        return false;
                    }
                    for (var i = 0, len = source.typeParameters.length; i < len; ++i) {
                        if (!isRelatedTo(source.typeParameters[i], target.typeParameters[i], reportErrors)) {
                            return false;
                        }
                    }
                }
                else if (source.typeParameters || source.typeParameters) {
                    return false;
                }
                // Spec 1.0 Section 3.8.3 & 3.8.4:
                // M and N (the signatures) are instantiated using type Any as the type argument for all type parameters declared by M and N
                source = getErasedSignature(source);
                target = getErasedSignature(target);
                for (var i = 0, len = source.parameters.length; i < len; i++) {
                    var s = source.hasRestParameter && i === len - 1 ? getRestTypeOfSignature(source) : getTypeOfSymbol(source.parameters[i]);
                    var t = target.hasRestParameter && i === len - 1 ? getRestTypeOfSignature(target) : getTypeOfSymbol(target.parameters[i]);
                    if (!isRelatedTo(s, t, reportErrors)) {
                        return false;
                    }
                }
                var t = getReturnTypeOfSignature(target);
                var s = getReturnTypeOfSignature(source);
                return isRelatedTo(s, t, reportErrors);
            }
            function areSignaturesSubtypeOrAssignableTo(source, target, kind, reportErrors) {
                if (target === anyFunctionType || source === anyFunctionType)
                    return true;
                var sourceSignatures = getSignaturesOfType(source, kind);
                var targetSignatures = getSignaturesOfType(target, kind);
                var saveErrorInfo = errorInfo;
                outer: for (var i = 0; i < targetSignatures.length; i++) {
                    var t = targetSignatures[i];
                    if (!t.hasStringLiterals || target.flags & 32768 /* FromSignature */) {
                        var localErrors = reportErrors;
                        for (var j = 0; j < sourceSignatures.length; j++) {
                            var s = sourceSignatures[j];
                            if (!s.hasStringLiterals || source.flags & 32768 /* FromSignature */) {
                                if (isSignatureSubtypeOrAssignableTo(s, t, localErrors)) {
                                    errorInfo = saveErrorInfo;
                                    continue outer;
                                }
                                // Only report errors from the first failure
                                localErrors = false;
                            }
                        }
                        return false;
                    }
                }
                return true;
            }
            function isSignatureSubtypeOrAssignableTo(source, target, reportErrors) {
                if (source === target) {
                    return true;
                }
                if (!target.hasRestParameter && source.minArgumentCount > target.parameters.length) {
                    return false;
                }
                var sourceMax = source.parameters.length;
                var targetMax = target.parameters.length;
                var checkCount;
                if (source.hasRestParameter && target.hasRestParameter) {
                    checkCount = sourceMax > targetMax ? sourceMax : targetMax;
                    sourceMax--;
                    targetMax--;
                }
                else if (source.hasRestParameter) {
                    sourceMax--;
                    checkCount = targetMax;
                }
                else if (target.hasRestParameter) {
                    targetMax--;
                    checkCount = sourceMax;
                }
                else {
                    checkCount = sourceMax < targetMax ? sourceMax : targetMax;
                }
                // Spec 1.0 Section 3.8.3 & 3.8.4:
                // M and N (the signatures) are instantiated using type Any as the type argument for all type parameters declared by M and N
                source = getErasedSignature(source);
                target = getErasedSignature(target);
                for (var i = 0; i < checkCount; i++) {
                    var s = i < sourceMax ? getTypeOfSymbol(source.parameters[i]) : getRestTypeOfSignature(source);
                    var t = i < targetMax ? getTypeOfSymbol(target.parameters[i]) : getRestTypeOfSignature(target);
                    var saveErrorInfo = errorInfo;
                    if (!isRelatedTo(s, t, reportErrors)) {
                        if (!isRelatedTo(t, s, false)) {
                            if (reportErrors) {
                                reportError(ts.Diagnostics.Types_of_parameters_0_and_1_are_incompatible_Colon, source.parameters[i < sourceMax ? i : sourceMax].name, target.parameters[i < targetMax ? i : targetMax].name);
                            }
                            return false;
                        }
                        errorInfo = saveErrorInfo;
                    }
                }
                var t = getReturnTypeOfSignature(target);
                if (t === voidType)
                    return true;
                var s = getReturnTypeOfSignature(source);
                return isRelatedTo(s, t, reportErrors);
            }
            function stringIndexTypesRelatedTo(source, target, reportErrors) {
                if (relation === identityRelation) {
                    return areIndexTypesIdenticalTo(0 /* String */, source, target, reportErrors);
                }
                else {
                    var targetType = getIndexTypeOfType(target, 0 /* String */);
                    if (targetType) {
                        var sourceType = getIndexTypeOfType(source, 0 /* String */);
                        if (!sourceType) {
                            if (reportErrors) {
                                reportError(ts.Diagnostics.Index_signature_is_missing_in_type_0, typeToString(source));
                            }
                            return false;
                        }
                        if (!isRelatedTo(sourceType, targetType, reportErrors)) {
                            if (reportErrors) {
                                reportError(ts.Diagnostics.Index_signatures_are_incompatible_Colon);
                            }
                            return false;
                        }
                    }
                    return true;
                }
            }
            function numberIndexTypesRelatedTo(source, target, reportErrors) {
                if (relation === identityRelation) {
                    return areIndexTypesIdenticalTo(1 /* Number */, source, target, reportErrors);
                }
                else {
                    var targetType = getIndexTypeOfType(target, 1 /* Number */);
                    if (targetType) {
                        var sourceStringType = getIndexTypeOfType(source, 0 /* String */);
                        var sourceNumberType = getIndexTypeOfType(source, 1 /* Number */);
                        if (!(sourceStringType || sourceNumberType)) {
                            if (reportErrors) {
                                reportError(ts.Diagnostics.Index_signature_is_missing_in_type_0, typeToString(source));
                            }
                            return false;
                        }
                        if (sourceStringType && sourceNumberType) {
                            // If we know for sure we're testing both string and numeric index types then only report errors from the second one
                            var compatible = isRelatedTo(sourceStringType, targetType, false) || isRelatedTo(sourceNumberType, targetType, reportErrors);
                        }
                        else {
                            var compatible = isRelatedTo(sourceStringType || sourceNumberType, targetType, reportErrors);
                        }
                        if (!compatible) {
                            if (reportErrors) {
                                reportError(ts.Diagnostics.Index_signatures_are_incompatible_Colon);
                            }
                            return false;
                        }
                    }
                    return true;
                }
            }
            function areIndexTypesIdenticalTo(indexKind, source, target, reportErrors) {
                var targetType = getIndexTypeOfType(target, indexKind);
                var sourceType = getIndexTypeOfType(source, indexKind);
                return (!sourceType && !targetType) || (sourceType && targetType && isRelatedTo(sourceType, targetType, reportErrors));
            }
        }
        function isSupertypeOfEach(candidate, types) {
            for (var i = 0, len = types.length; i < len; i++) {
                if (candidate !== types[i] && !isTypeSubtypeOf(types[i], candidate))
                    return false;
            }
            return true;
        }
        function getBestCommonType(types, contextualType, candidatesOnly) {
            if (contextualType && isSupertypeOfEach(contextualType, types))
                return contextualType;
            return ts.forEach(types, function (t) { return isSupertypeOfEach(t, types) ? t : undefined; }) || (candidatesOnly ? undefined : emptyObjectType);
        }
        function isTypeOfObjectLiteral(type) {
            return (type.flags & 16384 /* Anonymous */) && type.symbol && (type.symbol.flags & 1024 /* ObjectLiteral */) ? true : false;
        }
        function isArrayType(type) {
            return type.flags & 4096 /* Reference */ && type.target === globalArrayType;
        }
        function getInnermostTypeOfNestedArrayTypes(type) {
            while (isArrayType(type)) {
                type = type.typeArguments[0];
            }
            return type;
        }
        /* If we are widening on a literal, then we may need to the 'node' parameter for reporting purposes */
        function getWidenedType(type, supressNoImplicitAnyErrors) {
            if (type.flags & (32 /* Undefined */ | 64 /* Null */)) {
                return anyType;
            }
            if (isTypeOfObjectLiteral(type)) {
                return getWidenedTypeOfObjectLiteral(type);
            }
            if (isArrayType(type)) {
                return getWidenedTypeOfArrayLiteral(type);
            }
            return type;
            function getWidenedTypeOfObjectLiteral(type) {
                var properties = getPropertiesOfType(type);
                if (properties.length) {
                    var widenedTypes = [];
                    var propTypeWasWidened = false;
                    ts.forEach(properties, function (p) {
                        var propType = getTypeOfSymbol(p);
                        var widenedType = getWidenedType(propType);
                        if (propType !== widenedType) {
                            propTypeWasWidened = true;
                            if (!supressNoImplicitAnyErrors && program.getCompilerOptions().noImplicitAny && getInnermostTypeOfNestedArrayTypes(widenedType) === anyType) {
                                error(p.valueDeclaration, ts.Diagnostics.Object_literal_s_property_0_implicitly_has_an_1_type, p.name, typeToString(widenedType));
                            }
                        }
                        widenedTypes.push(widenedType);
                    });
                    if (propTypeWasWidened) {
                        var members = {};
                        var index = 0;
                        ts.forEach(properties, function (p) {
                            var symbol = createSymbol(2 /* Property */ | 33554432 /* Transient */, p.name);
                            symbol.declarations = p.declarations;
                            symbol.parent = p.parent;
                            symbol.type = widenedTypes[index++];
                            symbol.target = p;
                            if (p.valueDeclaration)
                                symbol.valueDeclaration = p.valueDeclaration;
                            members[symbol.name] = symbol;
                        });
                        var stringIndexType = getIndexTypeOfType(type, 0 /* String */);
                        var numberIndexType = getIndexTypeOfType(type, 1 /* Number */);
                        if (stringIndexType)
                            stringIndexType = getWidenedType(stringIndexType);
                        if (numberIndexType)
                            numberIndexType = getWidenedType(numberIndexType);
                        type = createAnonymousType(type.symbol, members, emptyArray, emptyArray, stringIndexType, numberIndexType);
                    }
                }
                return type;
            }
            function getWidenedTypeOfArrayLiteral(type) {
                var elementType = type.typeArguments[0];
                var widenedType = getWidenedType(elementType, supressNoImplicitAnyErrors);
                type = elementType !== widenedType ? createArrayType(widenedType) : type;
                return type;
            }
        }
        function forEachMatchingParameterType(source, target, callback) {
            var sourceMax = source.parameters.length;
            var targetMax = target.parameters.length;
            var count;
            if (source.hasRestParameter && target.hasRestParameter) {
                count = sourceMax > targetMax ? sourceMax : targetMax;
                sourceMax--;
                targetMax--;
            }
            else if (source.hasRestParameter) {
                sourceMax--;
                count = targetMax;
            }
            else if (target.hasRestParameter) {
                targetMax--;
                count = sourceMax;
            }
            else {
                count = sourceMax < targetMax ? sourceMax : targetMax;
            }
            for (var i = 0; i < count; i++) {
                var s = i < sourceMax ? getTypeOfSymbol(source.parameters[i]) : getRestTypeOfSignature(source);
                var t = i < targetMax ? getTypeOfSymbol(target.parameters[i]) : getRestTypeOfSignature(target);
                callback(s, t);
            }
        }
        function createInferenceContext(typeParameters) {
            var inferences = [];
            for (var i = 0; i < typeParameters.length; i++)
                inferences.push([]);
            return {
                typeParameters: typeParameters,
                inferences: inferences,
                inferredTypes: new Array(typeParameters.length)
            };
        }
        function inferTypes(context, source, target) {
            var sourceStack;
            var targetStack;
            var depth = 0;
            inferFromTypes(source, target);
            function isInProcess(source, target) {
                for (var i = 0; i < depth; i++) {
                    if (source === sourceStack[i] && target === targetStack[i])
                        return true;
                }
                return false;
            }
            function isWithinDepthLimit(type, stack) {
                if (depth >= 5) {
                    var target = type.target;
                    var count = 0;
                    for (var i = 0; i < depth; i++) {
                        var t = stack[i];
                        if (t.flags & 4096 /* Reference */ && t.target === target)
                            count++;
                    }
                    return count < 5;
                }
                return true;
            }
            function inferFromTypes(source, target) {
                if (target.flags & 512 /* TypeParameter */) {
                    // If target is a type parameter, make an inference
                    var typeParameters = context.typeParameters;
                    for (var i = 0; i < typeParameters.length; i++) {
                        if (target === typeParameters[i]) {
                            var inferences = context.inferences[i];
                            if (!ts.contains(inferences, source))
                                inferences.push(source);
                            break;
                        }
                    }
                }
                else if (source.flags & 4096 /* Reference */ && target.flags & 4096 /* Reference */ && source.target === target.target) {
                    // If source and target are references to the same generic type, infer from type arguments
                    var sourceTypes = source.typeArguments;
                    var targetTypes = target.typeArguments;
                    for (var i = 0; i < sourceTypes.length; i++) {
                        inferFromTypes(sourceTypes[i], targetTypes[i]);
                    }
                }
                else if (source.flags & ts.TypeFlags.ObjectType && (target.flags & (4096 /* Reference */ | 8192 /* Tuple */) || (target.flags & 16384 /* Anonymous */) && target.symbol && target.symbol.flags & (2048 /* Method */ | 512 /* TypeLiteral */))) {
                    // If source is an object type, and target is a type reference, a tuple type, the type of a method, or a type literal, infer from members
                    if (!isInProcess(source, target) && isWithinDepthLimit(source, sourceStack) && isWithinDepthLimit(target, targetStack)) {
                        if (depth === 0) {
                            sourceStack = [];
                            targetStack = [];
                        }
                        sourceStack[depth] = source;
                        targetStack[depth] = target;
                        depth++;
                        inferFromProperties(source, target);
                        inferFromSignatures(source, target, 0 /* Call */);
                        inferFromSignatures(source, target, 1 /* Construct */);
                        inferFromIndexTypes(source, target, 0 /* String */, 0 /* String */);
                        inferFromIndexTypes(source, target, 1 /* Number */, 1 /* Number */);
                        inferFromIndexTypes(source, target, 0 /* String */, 1 /* Number */);
                        depth--;
                    }
                }
            }
            function inferFromProperties(source, target) {
                var properties = getPropertiesOfType(target);
                for (var i = 0; i < properties.length; i++) {
                    var targetProp = properties[i];
                    var sourceProp = getPropertyOfType(source, targetProp.name);
                    if (sourceProp) {
                        inferFromTypes(getTypeOfSymbol(sourceProp), getTypeOfSymbol(targetProp));
                    }
                }
            }
            function inferFromSignatures(source, target, kind) {
                var sourceSignatures = getSignaturesOfType(source, kind);
                var targetSignatures = getSignaturesOfType(target, kind);
                var sourceLen = sourceSignatures.length;
                var targetLen = targetSignatures.length;
                var len = sourceLen < targetLen ? sourceLen : targetLen;
                for (var i = 0; i < len; i++) {
                    inferFromSignature(getErasedSignature(sourceSignatures[sourceLen - len + i]), getErasedSignature(targetSignatures[targetLen - len + i]));
                }
            }
            function inferFromSignature(source, target) {
                forEachMatchingParameterType(source, target, inferFromTypes);
                inferFromTypes(getReturnTypeOfSignature(source), getReturnTypeOfSignature(target));
            }
            function inferFromIndexTypes(source, target, sourceKind, targetKind) {
                var targetIndexType = getIndexTypeOfType(target, targetKind);
                if (targetIndexType) {
                    var sourceIndexType = getIndexTypeOfType(source, sourceKind);
                    if (sourceIndexType) {
                        inferFromTypes(sourceIndexType, targetIndexType);
                    }
                }
            }
        }
        function getInferredType(context, index) {
            var result = context.inferredTypes[index];
            if (!result) {
                var commonType = getWidenedType(getBestCommonType(context.inferences[index]));
                var constraint = getConstraintOfTypeParameter(context.typeParameters[index]);
                var result = constraint && !isTypeAssignableTo(commonType, constraint) ? constraint : commonType;
                context.inferredTypes[index] = result;
            }
            return result;
        }
        function getInferredTypes(context) {
            for (var i = 0; i < context.inferredTypes.length; i++) {
                getInferredType(context, i);
            }
            context.inferences = undefined;
            return context.inferredTypes;
        }
        function hasAncestor(node, kind) {
            return ts.getAncestor(node, kind) !== undefined;
        }
        // EXPRESSION TYPE CHECKING
        function checkIdentifier(node) {
            function isInTypeQuery(node) {
                while (node) {
                    switch (node.kind) {
                        case 128 /* TypeQuery */:
                            return true;
                        case 59 /* Identifier */:
                        case 116 /* QualifiedName */:
                            node = node.parent;
                            continue;
                        default:
                            return false;
                    }
                }
                ts.Debug.fail("should not get here");
            }
            var symbol = resolveName(node, node.text, ts.SymbolFlags.Value | 524288 /* ExportValue */, ts.Diagnostics.Cannot_find_name_0, ts.identifierToString(node));
            if (!symbol) {
                symbol = unknownSymbol;
            }
            if (symbol.flags & 4194304 /* Import */) {
                // Mark the import as referenced so that we emit it in the final .js file.
                // exception: identifiers that appear in type queries
                getSymbolLinks(symbol).referenced = !isInTypeQuery(node);
            }
            getNodeLinks(node).resolvedSymbol = symbol;
            checkCollisionWithCapturedSuperVariable(node, node);
            checkCollisionWithCapturedThisVariable(node, node);
            checkCollisionWithIndexVariableInGeneratedCode(node, node);
            return getTypeOfSymbol(getExportSymbolOfValueSymbolIfExported(symbol));
        }
        function captureLexicalThis(node, container) {
            var classNode = container.parent && container.parent.kind === 174 /* ClassDeclaration */ ? container.parent : undefined;
            getNodeLinks(node).flags |= 2 /* LexicalThis */;
            if (container.kind === 119 /* Property */ || container.kind === 121 /* Constructor */) {
                getNodeLinks(classNode).flags |= 4 /* CaptureThis */;
            }
            else {
                getNodeLinks(container).flags |= 4 /* CaptureThis */;
            }
        }
        function checkThisExpression(node) {
            // Stop at the first arrow function so that we can
            // tell whether 'this' needs to be captured.
            var container = ts.getThisContainer(node, true);
            var needToCaptureLexicalThis = false;
            // Now skip arrow functions to get the "real" owner of 'this'.
            if (container.kind === 142 /* ArrowFunction */) {
                container = ts.getThisContainer(container, false);
                needToCaptureLexicalThis = true;
            }
            switch (container.kind) {
                case 177 /* ModuleDeclaration */:
                    error(node, ts.Diagnostics.this_cannot_be_referenced_in_a_module_body);
                    break;
                case 176 /* EnumDeclaration */:
                    error(node, ts.Diagnostics.this_cannot_be_referenced_in_current_location);
                    break;
                case 121 /* Constructor */:
                    if (isInConstructorArgumentInitializer(node, container)) {
                        error(node, ts.Diagnostics.this_cannot_be_referenced_in_constructor_arguments);
                    }
                    break;
                case 119 /* Property */:
                    if (container.flags & 128 /* Static */) {
                        error(node, ts.Diagnostics.this_cannot_be_referenced_in_a_static_property_initializer);
                    }
                    break;
            }
            if (needToCaptureLexicalThis) {
                captureLexicalThis(node, container);
            }
            var classNode = container.parent && container.parent.kind === 174 /* ClassDeclaration */ ? container.parent : undefined;
            if (classNode) {
                var symbol = getSymbolOfNode(classNode);
                return container.flags & 128 /* Static */ ? getTypeOfSymbol(symbol) : getDeclaredTypeOfSymbol(symbol);
            }
            return anyType;
        }
        function getSuperContainer(node) {
            while (true) {
                node = node.parent;
                if (!node)
                    return node;
                switch (node.kind) {
                    case 172 /* FunctionDeclaration */:
                    case 141 /* FunctionExpression */:
                    case 142 /* ArrowFunction */:
                    case 119 /* Property */:
                    case 120 /* Method */:
                    case 121 /* Constructor */:
                    case 122 /* GetAccessor */:
                    case 123 /* SetAccessor */:
                        return node;
                }
            }
        }
        function isInConstructorArgumentInitializer(node, constructorDecl) {
            for (var n = node; n && n !== constructorDecl; n = n.parent) {
                if (n.kind === 118 /* Parameter */) {
                    return true;
                }
            }
            return false;
        }
        function checkSuperExpression(node) {
            var isCallExpression = node.parent.kind === 137 /* CallExpression */ && node.parent.func === node;
            var enclosingClass = ts.getAncestor(node, 174 /* ClassDeclaration */);
            var baseClass;
            if (enclosingClass && enclosingClass.baseType) {
                var classType = getDeclaredTypeOfSymbol(getSymbolOfNode(enclosingClass));
                baseClass = classType.baseTypes.length && classType.baseTypes[0];
            }
            if (!baseClass) {
                error(node, ts.Diagnostics.super_can_only_be_referenced_in_a_derived_class);
                return unknownType;
            }
            var container = getSuperContainer(node);
            if (container) {
                var canUseSuperExpression = false;
                if (isCallExpression) {
                    // TS 1.0 SPEC (April 2014): 4.8.1
                    // Super calls are only permitted in constructors of derived classes
                    canUseSuperExpression = container.kind === 121 /* Constructor */;
                }
                else {
                    // TS 1.0 SPEC (April 2014)
                    // 'super' property access is allowed
                    // - In a constructor, instance member function, instance member accessor, or instance member variable initializer where this references a derived class instance
                    // - In a static member function or static member accessor
                    // super property access might appear in arrow functions with arbitrary deep nesting
                    var needToCaptureLexicalThis = false;
                    while (container && container.kind === 142 /* ArrowFunction */) {
                        container = getSuperContainer(container);
                        needToCaptureLexicalThis = true;
                    }
                    // topmost container must be something that is directly nested in the class declaration
                    if (container && container.parent && container.parent.kind === 174 /* ClassDeclaration */) {
                        if (container.flags & 128 /* Static */) {
                            canUseSuperExpression = container.kind === 120 /* Method */ || container.kind === 122 /* GetAccessor */ || container.kind === 123 /* SetAccessor */;
                        }
                        else {
                            canUseSuperExpression = container.kind === 120 /* Method */ || container.kind === 122 /* GetAccessor */ || container.kind === 123 /* SetAccessor */ || container.kind === 119 /* Property */ || container.kind === 121 /* Constructor */;
                        }
                    }
                }
                if (canUseSuperExpression) {
                    var returnType;
                    if ((container.flags & 128 /* Static */) || isCallExpression) {
                        getNodeLinks(node).flags |= 32 /* SuperStatic */;
                        returnType = getTypeOfSymbol(baseClass.symbol);
                    }
                    else {
                        getNodeLinks(node).flags |= 16 /* SuperInstance */;
                        returnType = baseClass;
                    }
                    if (container.kind === 121 /* Constructor */ && isInConstructorArgumentInitializer(node, container)) {
                        // issue custom error message for super property access in constructor arguments (to be aligned with old compiler)
                        error(node, ts.Diagnostics.super_cannot_be_referenced_in_constructor_arguments);
                        returnType = unknownType;
                    }
                    if (!isCallExpression && needToCaptureLexicalThis) {
                        // call expressions are allowed only in constructors so they should always capture correct 'this'
                        // super property access expressions can also appear in arrow functions -
                        // in this case they should also use correct lexical this
                        captureLexicalThis(node.parent, container);
                    }
                    return returnType;
                }
            }
            if (isCallExpression) {
                error(node, ts.Diagnostics.Super_calls_are_not_permitted_outside_constructors_or_in_nested_functions_inside_constructors);
            }
            else {
                error(node, ts.Diagnostics.super_property_access_is_permitted_only_in_a_constructor_member_function_or_member_accessor_of_a_derived_class);
            }
            return unknownType;
        }
        // Return contextual type of parameter or undefined if no contextual type is available
        function getContextuallyTypedParameterType(parameter) {
            var func = parameter.parent;
            if (func.kind === 141 /* FunctionExpression */ || func.kind === 142 /* ArrowFunction */) {
                if (isContextSensitiveExpression(func)) {
                    var signature = getContextualSignature(func);
                    if (signature) {
                        return getTypeAtPosition(signature, ts.indexOf(func.parameters, parameter));
                    }
                }
            }
            return undefined;
        }
        // In a variable, parameter or property declaration with a type annotation, the contextual type of an initializer
        // expression is the type of the variable, parameter or property. In a parameter declaration of a contextually
        // typed function expression, the contextual type of an initializer expression is the contextual type of the
        // parameter.
        function getContextualTypeForInitializerExpression(node) {
            var declaration = node.parent;
            if (node === declaration.initializer) {
                if (declaration.type) {
                    return getTypeFromTypeNode(declaration.type);
                }
                if (declaration.kind === 118 /* Parameter */) {
                    return getContextuallyTypedParameterType(declaration);
                }
            }
            return undefined;
        }
        function getContextualTypeForReturnExpression(node) {
            var func = ts.getContainingFunction(node);
            if (func) {
                // If the containing function has a return type annotation, is a constructor, or is a get accessor whose
                // corresponding set accessor has a type annotation, return statements in the function are contextually typed
                if (func.type || func.kind === 121 /* Constructor */ || func.kind === 122 /* GetAccessor */ && getSetAccessorTypeAnnotationNode(getDeclarationOfKind(func.symbol, 123 /* SetAccessor */))) {
                    return getReturnTypeOfSignature(getSignatureFromDeclaration(func));
                }
                // Otherwise, if the containing function is contextually typed by a function type with exactly one call signature
                // and that call signature is non-generic, return statements are contextually typed by the return type of the signature
                var signature = getContextualSignature(func);
                if (signature) {
                    return getReturnTypeOfSignature(signature);
                }
            }
            return undefined;
        }
        // In a typed function call, an argument expression is contextually typed by the type of the corresponding parameter.
        function getContextualTypeForArgument(node) {
            var callExpression = node.parent;
            var argIndex = ts.indexOf(callExpression.arguments, node);
            if (argIndex >= 0) {
                var signature = getResolvedSignature(callExpression);
                return getTypeAtPosition(signature, argIndex);
            }
            return undefined;
        }
        function getContextualTypeForBinaryOperand(node) {
            var binaryExpression = node.parent;
            var operator = binaryExpression.operator;
            if (operator >= ts.SyntaxKind.FirstAssignment && operator <= ts.SyntaxKind.LastAssignment) {
                // In an assignment expression, the right operand is contextually typed by the type of the left operand.
                if (node === binaryExpression.right) {
                    return checkExpression(binaryExpression.left);
                }
            }
            else if (operator === 44 /* BarBarToken */) {
                // When an || expression has a contextual type, the operands are contextually typed by that type. When an ||
                // expression has no contextual type, the right operand is contextually typed by the type of the left operand.
                var type = getContextualType(binaryExpression);
                if (!type && node === binaryExpression.right) {
                    type = checkExpression(binaryExpression.left);
                }
                return type;
            }
            return undefined;
        }
        // In an object literal contextually typed by a type T, the contextual type of a property assignment is the type of
        // the matching property in T, if one exists. Otherwise, it is the type of the numeric index signature in T, if one
        // exists. Otherwise, it is the type of the string index signature in T, if one exists.
        function getContextualTypeForPropertyExpression(node) {
            var declaration = node.parent;
            var objectLiteral = declaration.parent;
            var type = getContextualType(objectLiteral);
            var name = declaration.name.text;
            if (type && name) {
                var prop = getPropertyOfType(type, name);
                if (prop) {
                    return getTypeOfSymbol(prop);
                }
                return isNumericName(name) && getIndexTypeOfType(type, 1 /* Number */) || getIndexTypeOfType(type, 0 /* String */);
            }
            return undefined;
        }
        // In an array literal contextually typed by a type T, the contextual type of an element expression at index N is
        // the type of the property with the numeric name N in T, if one exists. Otherwise, it is the type of the numeric
        // index signature in T, if one exists.
        function getContextualTypeForElementExpression(node) {
            var arrayLiteral = node.parent;
            var type = getContextualType(arrayLiteral);
            if (type) {
                var index = ts.indexOf(arrayLiteral.elements, node);
                var prop = getPropertyOfType(type, "" + index);
                if (prop) {
                    return getTypeOfSymbol(prop);
                }
                return getIndexTypeOfType(type, 1 /* Number */);
            }
            return undefined;
        }
        // In a contextually typed conditional expression, the true/false expressions are contextually typed by the same type.
        function getContextualTypeForConditionalOperand(node) {
            var conditional = node.parent;
            return node === conditional.whenTrue || node === conditional.whenFalse ? getContextualType(conditional) : undefined;
        }
        // Return the contextual type for a given expression node. During overload resolution, a contextual type may temporarily
        // be "pushed" onto a node using the contextualType property.
        function getContextualType(node) {
            if (isInsideWithStatementBody(node)) {
                // We cannot answer semantic questions within a with block, do not proceed any further
                return undefined;
            }
            if (node.contextualType) {
                return node.contextualType;
            }
            var parent = node.parent;
            switch (parent.kind) {
                case 171 /* VariableDeclaration */:
                case 118 /* Parameter */:
                case 119 /* Property */:
                    return getContextualTypeForInitializerExpression(node);
                case 142 /* ArrowFunction */:
                case 159 /* ReturnStatement */:
                    return getContextualTypeForReturnExpression(node);
                case 137 /* CallExpression */:
                case 138 /* NewExpression */:
                    return getContextualTypeForArgument(node);
                case 139 /* TypeAssertion */:
                    return getTypeFromTypeNode(parent.type);
                case 145 /* BinaryExpression */:
                    return getContextualTypeForBinaryOperand(node);
                case 134 /* PropertyAssignment */:
                    return getContextualTypeForPropertyExpression(node);
                case 132 /* ArrayLiteral */:
                    return getContextualTypeForElementExpression(node);
                case 146 /* ConditionalExpression */:
                    return getContextualTypeForConditionalOperand(node);
            }
            return undefined;
        }
        function getContextualSignature(node) {
            var type = getContextualType(node);
            if (type) {
                var signatures = getSignaturesOfType(type, 0 /* Call */);
                if (signatures.length === 1) {
                    var signature = signatures[0];
                    if (!signature.typeParameters) {
                        return signature;
                    }
                }
            }
            return undefined;
        }
        // Presence of a contextual type mapper indicates inferential typing, except the identityMapper object is
        // used as a special marker for other purposes.
        function isInferentialContext(mapper) {
            return mapper && mapper !== identityMapper;
        }
        function checkArrayLiteral(node, contextualMapper) {
            var contextualType = getContextualType(node);
            var elements = node.elements;
            var elementTypes = [];
            var isTupleLiteral = false;
            for (var i = 0; i < elements.length; i++) {
                if (contextualType && getPropertyOfType(contextualType, "" + i)) {
                    isTupleLiteral = true;
                }
                var element = elements[i];
                var type = element.kind !== 147 /* OmittedExpression */ ? checkExpression(element, contextualMapper) : undefinedType;
                elementTypes.push(type);
            }
            if (isTupleLiteral) {
                return createTupleType(elementTypes);
            }
            var contextualElementType = contextualType && !isInferentialContext(contextualMapper) ? getIndexTypeOfType(contextualType, 1 /* Number */) : undefined;
            var elementType = getBestCommonType(ts.uniqueElements(elementTypes), contextualElementType, true);
            if (!elementType) {
                elementType = elements.length ? emptyObjectType : undefinedType;
            }
            return createArrayType(elementType);
        }
        function isNumericName(name) {
            return !isNaN(name);
        }
        function checkObjectLiteral(node, contextualMapper) {
            var members = node.symbol.members;
            var properties = {};
            var contextualType = getContextualType(node);
            for (var id in members) {
                if (ts.hasProperty(members, id)) {
                    var member = members[id];
                    if (member.flags & 2 /* Property */) {
                        var type = checkExpression(member.declarations[0].initializer, contextualMapper);
                        var prop = createSymbol(2 /* Property */ | 33554432 /* Transient */, member.name);
                        prop.declarations = member.declarations;
                        prop.parent = member.parent;
                        if (member.valueDeclaration)
                            prop.valueDeclaration = member.valueDeclaration;
                        prop.type = type;
                        prop.target = member;
                        member = prop;
                    }
                    else {
                        // TypeScript 1.0 spec (April 2014)
                        // A get accessor declaration is processed in the same manner as 
                        // an ordinary function declaration(section 6.1) with no parameters.
                        // A set accessor declaration is processed in the same manner 
                        // as an ordinary function declaration with a single parameter and a Void return type.
                        var getAccessor = getDeclarationOfKind(member, 122 /* GetAccessor */);
                        if (getAccessor) {
                            checkAccessorDeclaration(getAccessor);
                        }
                        var setAccessor = getDeclarationOfKind(member, 123 /* SetAccessor */);
                        if (setAccessor) {
                            checkAccessorDeclaration(setAccessor);
                        }
                    }
                    properties[member.name] = member;
                }
            }
            var stringIndexType = getIndexType(0 /* String */);
            var numberIndexType = getIndexType(1 /* Number */);
            return createAnonymousType(node.symbol, properties, emptyArray, emptyArray, stringIndexType, numberIndexType);
            function getIndexType(kind) {
                if (contextualType) {
                    var indexType = getIndexTypeOfType(contextualType, kind);
                    if (indexType) {
                        var propTypes = [];
                        for (var id in properties) {
                            if (ts.hasProperty(properties, id)) {
                                if (kind === 0 /* String */ || isNumericName(id)) {
                                    var type = getTypeOfSymbol(properties[id]);
                                    if (!ts.contains(propTypes, type))
                                        propTypes.push(type);
                                }
                            }
                        }
                        return getBestCommonType(propTypes, isInferentialContext(contextualMapper) ? undefined : indexType);
                    }
                }
            }
        }
        // If a symbol is a synthesized symbol with no value declaration, we assume it is a property. Example of this are the synthesized
        // '.prototype' property as well as synthesized tuple index properties.
        function getDeclarationKindFromSymbol(s) {
            return s.valueDeclaration ? s.valueDeclaration.kind : 119 /* Property */;
        }
        function getDeclarationFlagsFromSymbol(s) {
            return s.valueDeclaration ? s.valueDeclaration.flags : s.flags & 67108864 /* Prototype */ ? 16 /* Public */ | 128 /* Static */ : 0;
        }
        function checkClassPropertyAccess(node, type, prop) {
            var flags = getDeclarationFlagsFromSymbol(prop);
            // Public properties are always accessible
            if (!(flags & (32 /* Private */ | 64 /* Protected */))) {
                return;
            }
            // Property is known to be private or protected at this point
            // Get the declaring and enclosing class instance types
            var enclosingClassDeclaration = ts.getAncestor(node, 174 /* ClassDeclaration */);
            var enclosingClass = enclosingClassDeclaration ? getDeclaredTypeOfSymbol(getSymbolOfNode(enclosingClassDeclaration)) : undefined;
            var declaringClass = getDeclaredTypeOfSymbol(prop.parent);
            // Private property is accessible if declaring and enclosing class are the same
            if (flags & 32 /* Private */) {
                if (declaringClass !== enclosingClass) {
                    error(node, ts.Diagnostics.Property_0_is_private_and_only_accessible_within_class_1, symbolToString(prop), typeToString(declaringClass));
                }
                return;
            }
            // Property is known to be protected at this point
            // All protected properties of a supertype are accessible in a super access
            if (node.left.kind === 85 /* SuperKeyword */) {
                return;
            }
            // A protected property is accessible in the declaring class and classes derived from it
            if (!enclosingClass || !hasBaseType(enclosingClass, declaringClass)) {
                error(node, ts.Diagnostics.Property_0_is_protected_and_only_accessible_within_class_1_and_its_subclasses, symbolToString(prop), typeToString(declaringClass));
                return;
            }
            // No further restrictions for static properties
            if (flags & 128 /* Static */) {
                return;
            }
            // An instance property must be accessed through an instance of the enclosing class
            if (!(getTargetType(type).flags & (1024 /* Class */ | 2048 /* Interface */) && hasBaseType(type, enclosingClass))) {
                error(node, ts.Diagnostics.Property_0_is_protected_and_only_accessible_through_an_instance_of_class_1, symbolToString(prop), typeToString(enclosingClass));
            }
        }
        function checkPropertyAccess(node) {
            var type = checkExpression(node.left);
            if (type === unknownType)
                return type;
            if (type !== anyType) {
                var apparentType = getApparentType(getWidenedType(type));
                if (apparentType === unknownType) {
                    // handle cases when type is Type parameter with invalid constraint
                    return unknownType;
                }
                var prop = getPropertyOfApparentType(apparentType, node.right.text);
                if (!prop) {
                    if (node.right.text) {
                        error(node.right, ts.Diagnostics.Property_0_does_not_exist_on_type_1, ts.identifierToString(node.right), typeToString(type));
                    }
                    return unknownType;
                }
                getNodeLinks(node).resolvedSymbol = prop;
                if (prop.parent && prop.parent.flags & 16 /* Class */) {
                    // TS 1.0 spec (April 2014): 4.8.2
                    // - In a constructor, instance member function, instance member accessor, or 
                    //   instance member variable initializer where this references a derived class instance, 
                    //   a super property access is permitted and must specify a public instance member function of the base class.
                    // - In a static member function or static member accessor 
                    //   where this references the constructor function object of a derived class, 
                    //   a super property access is permitted and must specify a public static member function of the base class.
                    if (node.left.kind === 85 /* SuperKeyword */ && getDeclarationKindFromSymbol(prop) !== 120 /* Method */) {
                        error(node.right, ts.Diagnostics.Only_public_and_protected_methods_of_the_base_class_are_accessible_via_the_super_keyword);
                    }
                    else {
                        checkClassPropertyAccess(node, type, prop);
                    }
                }
                return getTypeOfSymbol(prop);
            }
            return anyType;
        }
        function checkIndexedAccess(node) {
            var objectType = checkExpression(node.object);
            var indexType = checkExpression(node.index);
            if (objectType === unknownType)
                return unknownType;
            // TypeScript 1.0 spec (April 2014): 4.10 Property Access
            // - If IndexExpr is a string literal or a numeric literal and ObjExpr's apparent type has a property with the name 
            //    given by that literal(converted to its string representation in the case of a numeric literal), the property access is of the type of that property.
            // - Otherwise, if ObjExpr's apparent type has a numeric index signature and IndexExpr is of type Any, the Number primitive type, or an enum type, 
            //    the property access is of the type of that index signature.
            // - Otherwise, if ObjExpr's apparent type has a string index signature and IndexExpr is of type Any, the String or Number primitive type, or an enum type, 
            //    the property access is of the type of that index signature.
            // - Otherwise, if IndexExpr is of type Any, the String or Number primitive type, or an enum type, the property access is of type Any.
            // See if we can index as a property.
            var apparentType = getApparentType(objectType);
            if (apparentType === unknownType) {
                // handle cases when objectType is type parameter with invalid type
                return unknownType;
            }
            if (node.index.kind === 7 /* StringLiteral */ || node.index.kind === 6 /* NumericLiteral */) {
                var name = node.index.text;
                var prop = getPropertyOfApparentType(apparentType, name);
                if (prop) {
                    return getTypeOfSymbol(prop);
                }
            }
            // Check for compatible indexer types.
            if (indexType.flags & (1 /* Any */ | ts.TypeFlags.StringLike | ts.TypeFlags.NumberLike)) {
                // Try to use a number indexer.
                if (indexType.flags & (1 /* Any */ | ts.TypeFlags.NumberLike)) {
                    var numberIndexType = getIndexTypeOfType(apparentType, 1 /* Number */);
                    if (numberIndexType) {
                        return numberIndexType;
                    }
                }
                // Try to use string indexing.
                var stringIndexType = getIndexTypeOfType(apparentType, 0 /* String */);
                if (stringIndexType) {
                    return stringIndexType;
                }
                // Fall back to any.
                if (compilerOptions.noImplicitAny && objectType !== anyType) {
                    error(node, ts.Diagnostics.Index_signature_of_object_type_implicitly_has_an_any_type);
                }
                return anyType;
            }
            // REVIEW: Users should know the type that was actually used.
            error(node, ts.Diagnostics.An_index_expression_argument_must_be_of_type_string_number_or_any);
            return unknownType;
        }
        function resolveUntypedCall(node) {
            ts.forEach(node.arguments, function (argument) {
                checkExpression(argument);
            });
            return anySignature;
        }
        function resolveErrorCall(node) {
            resolveUntypedCall(node);
            return unknownSignature;
        }
        function isCandidateSignature(node, signature) {
            var args = node.arguments || emptyArray;
            return args.length >= signature.minArgumentCount && (signature.hasRestParameter || args.length <= signature.parameters.length) && (!node.typeArguments || signature.typeParameters && node.typeArguments.length === signature.typeParameters.length);
        }
        // The candidate list orders groups in reverse, but within a group signatures are kept in declaration order
        // A nit here is that we reorder only signatures that belong to the same symbol,
        // so order how inherited signatures are processed is still preserved.
        // interface A { (x: string): void }
        // interface B extends A { (x: 'foo'): string }
        // var b: B;
        // b('foo') // <- here overloads should be processed as [(x:'foo'): string, (x: string): void]
        function collectCandidates(node, signatures) {
            var result = [];
            var lastParent;
            var lastSymbol;
            var cutoffPos = 0;
            var pos;
            for (var i = 0; i < signatures.length; i++) {
                var signature = signatures[i];
                if (isCandidateSignature(node, signature)) {
                    var symbol = signature.declaration && getSymbolOfNode(signature.declaration);
                    var parent = signature.declaration && signature.declaration.parent;
                    if (!lastSymbol || symbol === lastSymbol) {
                        if (lastParent && parent === lastParent) {
                            pos++;
                        }
                        else {
                            lastParent = parent;
                            pos = cutoffPos;
                        }
                    }
                    else {
                        // current declaration belongs to a different symbol
                        // set cutoffPos so re-orderings in the future won't change result set from 0 to cutoffPos
                        pos = cutoffPos = result.length;
                        lastParent = parent;
                    }
                    lastSymbol = symbol;
                    for (var j = result.length; j > pos; j--) {
                        result[j] = result[j - 1];
                    }
                    result[pos] = signature;
                }
            }
            return result;
        }
        // If type has a single call signature and no other members, return that signature. Otherwise, return undefined.
        function getSingleCallSignature(type) {
            if (type.flags & ts.TypeFlags.ObjectType) {
                var resolved = resolveObjectTypeMembers(type);
                if (resolved.callSignatures.length === 1 && resolved.constructSignatures.length === 0 && resolved.properties.length === 0 && !resolved.stringIndexType && !resolved.numberIndexType) {
                    return resolved.callSignatures[0];
                }
            }
            return undefined;
        }
        // Instantiate a generic signature in the context of a non-generic signature (section 3.8.5 in TypeScript spec)
        function instantiateSignatureInContextOf(signature, contextualSignature, contextualMapper) {
            var context = createInferenceContext(signature.typeParameters);
            forEachMatchingParameterType(contextualSignature, signature, function (source, target) {
                // Type parameters from outer context referenced by source type are fixed by instantiation of the source type
                inferTypes(context, instantiateType(source, contextualMapper), target);
            });
            return getSignatureInstantiation(signature, getInferredTypes(context));
        }
        function inferTypeArguments(signature, args, excludeArgument) {
            var typeParameters = signature.typeParameters;
            var context = createInferenceContext(typeParameters);
            var mapper = createInferenceMapper(context);
            for (var i = 0; i < args.length; i++) {
                if (!excludeArgument || excludeArgument[i] === undefined) {
                    var parameterType = getTypeAtPosition(signature, i);
                    inferTypes(context, checkExpressionWithContextualType(args[i], parameterType, mapper), parameterType);
                }
            }
            // Next, infer from those context sensitive arguments that are no longer excluded
            if (excludeArgument) {
                for (var i = 0; i < args.length; i++) {
                    if (excludeArgument[i] === false) {
                        var parameterType = getTypeAtPosition(signature, i);
                        inferTypes(context, checkExpressionWithContextualType(args[i], parameterType, mapper), parameterType);
                    }
                }
            }
            return getInferredTypes(context);
        }
        function checkTypeArguments(signature, typeArguments) {
            var typeParameters = signature.typeParameters;
            var result = [];
            for (var i = 0; i < typeParameters.length; i++) {
                var typeArgNode = typeArguments[i];
                var typeArgument = getTypeFromTypeNode(typeArgNode);
                var constraint = getConstraintOfTypeParameter(typeParameters[i]);
                if (constraint && fullTypeCheck) {
                    checkTypeAssignableTo(typeArgument, constraint, typeArgNode, ts.Diagnostics.Type_0_does_not_satisfy_the_constraint_1_Colon, ts.Diagnostics.Type_0_does_not_satisfy_the_constraint_1);
                }
                result.push(typeArgument);
            }
            return result;
        }
        function checkApplicableSignature(node, signature, relation, excludeArgument, reportErrors) {
            if (node.arguments) {
                for (var i = 0; i < node.arguments.length; i++) {
                    var arg = node.arguments[i];
                    var paramType = getTypeAtPosition(signature, i);
                    // String literals get string literal types unless we're reporting errors
                    var argType = arg.kind === 7 /* StringLiteral */ && !reportErrors ? getStringLiteralType(arg) : checkExpressionWithContextualType(arg, paramType, excludeArgument && excludeArgument[i] ? identityMapper : undefined);
                    // Use argument expression as error location when reporting errors
                    var isValidArgument = checkTypeRelatedTo(argType, paramType, relation, reportErrors ? arg : undefined, ts.Diagnostics.Argument_of_type_0_is_not_assignable_to_parameter_of_type_1, ts.Diagnostics.Argument_of_type_0_is_not_assignable_to_parameter_of_type_1);
                    if (!isValidArgument) {
                        return false;
                    }
                }
            }
            return true;
        }
        function resolveCall(node, signatures) {
            ts.forEach(node.typeArguments, checkSourceElement);
            var candidates = collectCandidates(node, signatures);
            if (!candidates.length) {
                error(node, ts.Diagnostics.Supplied_parameters_do_not_match_any_signature_of_call_target);
                return resolveErrorCall(node);
            }
            var args = node.arguments || emptyArray;
            var excludeArgument;
            for (var i = 0; i < args.length; i++) {
                if (isContextSensitiveExpression(args[i])) {
                    if (!excludeArgument)
                        excludeArgument = new Array(args.length);
                    excludeArgument[i] = true;
                }
            }
            var relation = candidates.length === 1 ? assignableRelation : subtypeRelation;
            while (true) {
                for (var i = 0; i < candidates.length; i++) {
                    while (true) {
                        var candidate = candidates[i];
                        if (candidate.typeParameters) {
                            var typeArguments = node.typeArguments ? checkTypeArguments(candidate, node.typeArguments) : inferTypeArguments(candidate, args, excludeArgument);
                            candidate = getSignatureInstantiation(candidate, typeArguments);
                        }
                        if (!checkApplicableSignature(node, candidate, relation, excludeArgument, false)) {
                            break;
                        }
                        var index = excludeArgument ? ts.indexOf(excludeArgument, true) : -1;
                        if (index < 0) {
                            return candidate;
                        }
                        excludeArgument[index] = false;
                    }
                }
                if (relation === assignableRelation) {
                    break;
                }
                relation = assignableRelation;
            }
            // No signatures were applicable. Now report errors based on the last applicable signature with
            // no arguments excluded from assignability checks.
            checkApplicableSignature(node, candidate, relation, undefined, true);
            return resolveErrorCall(node);
        }
        function resolveCallExpression(node) {
            if (node.func.kind === 85 /* SuperKeyword */) {
                var superType = checkSuperExpression(node.func);
                if (superType !== unknownType) {
                    return resolveCall(node, getSignaturesOfType(superType, 1 /* Construct */));
                }
                return resolveUntypedCall(node);
            }
            var funcType = checkExpression(node.func);
            if (funcType === unknownType) {
                // Another error has already been reported
                return resolveErrorCall(node);
            }
            var apparentType = getApparentType(funcType);
            if (apparentType === unknownType) {
                // handler cases when funcType is type parameter with invalid constraint
                // Another error was already reported
                return resolveErrorCall(node);
            }
            // Technically, this signatures list may be incomplete. We are taking the apparent type,
            // but we are not including call signatures that may have been added to the Object or
            // Function interface, since they have none by default. This is a bit of a leap of faith
            // that the user will not add any.
            var callSignatures = getSignaturesOfType(apparentType, 0 /* Call */);
            var constructSignatures = getSignaturesOfType(apparentType, 1 /* Construct */);
            // TS 1.0 spec: 4.12
            // If FuncExpr is of type Any, or of an object type that has no call or construct signatures
            // but is a subtype of the Function interface, the call is an untyped function call. In an
            // untyped function call no TypeArgs are permitted, Args can be any argument list, no contextual
            // types are provided for the argument expressions, and the result is always of type Any.
            if ((funcType === anyType) || (!callSignatures.length && !constructSignatures.length && isTypeAssignableTo(funcType, globalFunctionType))) {
                if (node.typeArguments) {
                    error(node, ts.Diagnostics.Untyped_function_calls_may_not_accept_type_arguments);
                }
                return resolveUntypedCall(node);
            }
            // If FuncExpr's apparent type(section 3.8.1) is a function type, the call is a typed function call.
            // TypeScript employs overload resolution in typed function calls in order to support functions
            // with multiple call signatures.
            if (!callSignatures.length) {
                if (constructSignatures.length) {
                    error(node, ts.Diagnostics.Value_of_type_0_is_not_callable_Did_you_mean_to_include_new, typeToString(funcType));
                }
                else {
                    error(node, ts.Diagnostics.Cannot_invoke_an_expression_whose_type_lacks_a_call_signature);
                }
                return resolveErrorCall(node);
            }
            return resolveCall(node, callSignatures);
        }
        function resolveNewExpression(node) {
            var expressionType = checkExpression(node.func);
            if (expressionType === unknownType) {
                // Another error has already been reported
                return resolveErrorCall(node);
            }
            // TS 1.0 spec: 4.11
            // If ConstructExpr is of type Any, Args can be any argument
            // list and the result of the operation is of type Any.
            if (expressionType === anyType) {
                if (node.typeArguments) {
                    error(node, ts.Diagnostics.Untyped_function_calls_may_not_accept_type_arguments);
                }
                return resolveUntypedCall(node);
            }
            // If ConstructExpr's apparent type(section 3.8.1) is an object type with one or
            // more construct signatures, the expression is processed in the same manner as a
            // function call, but using the construct signatures as the initial set of candidate
            // signatures for overload resolution.The result type of the function call becomes
            // the result type of the operation.
            expressionType = getApparentType(expressionType);
            if (expressionType === unknownType) {
                // handler cases when original expressionType is a type parameter with invalid constraint
                // another error has already been reported
                return resolveErrorCall(node);
            }
            // Technically, this signatures list may be incomplete. We are taking the apparent type,
            // but we are not including construct signatures that may have been added to the Object or
            // Function interface, since they have none by default. This is a bit of a leap of faith
            // that the user will not add any.
            var constructSignatures = getSignaturesOfType(expressionType, 1 /* Construct */);
            if (constructSignatures.length) {
                return resolveCall(node, constructSignatures);
            }
            // If ConstructExpr's apparent type is an object type with no construct signatures but
            // one or more call signatures, the expression is processed as a function call. A compile-time
            // error occurs if the result of the function call is not Void. The type of the result of the
            // operation is Any.
            var callSignatures = getSignaturesOfType(expressionType, 0 /* Call */);
            if (callSignatures.length) {
                var signature = resolveCall(node, callSignatures);
                if (getReturnTypeOfSignature(signature) !== voidType) {
                    error(node, ts.Diagnostics.Only_a_void_function_can_be_called_with_the_new_keyword);
                }
                return signature;
            }
            error(node, ts.Diagnostics.Cannot_use_new_with_an_expression_whose_type_lacks_a_call_or_construct_signature);
            return resolveErrorCall(node);
        }
        function getResolvedSignature(node) {
            var links = getNodeLinks(node);
            if (!links.resolvedSignature) {
                links.resolvedSignature = anySignature;
                links.resolvedSignature = node.kind === 137 /* CallExpression */ ? resolveCallExpression(node) : resolveNewExpression(node);
            }
            return links.resolvedSignature;
        }
        function checkCallExpression(node) {
            var signature = getResolvedSignature(node);
            if (node.func.kind === 85 /* SuperKeyword */) {
                return voidType;
            }
            if (node.kind === 138 /* NewExpression */) {
                var declaration = signature.declaration;
                if (declaration && (declaration.kind !== 121 /* Constructor */ && declaration.kind !== 125 /* ConstructSignature */)) {
                    // When resolved signature is a call signature (and not a construct signature) the result type is any
                    if (compilerOptions.noImplicitAny) {
                        error(node, ts.Diagnostics.new_expression_whose_target_lacks_a_construct_signature_implicitly_has_an_any_type);
                    }
                    return anyType;
                }
            }
            return getReturnTypeOfSignature(signature);
        }
        function checkTypeAssertion(node) {
            var exprType = checkExpression(node.operand);
            var targetType = getTypeFromTypeNode(node.type);
            if (fullTypeCheck && targetType !== unknownType) {
                var widenedType = getWidenedType(exprType, true);
                if (!(isTypeAssignableTo(targetType, widenedType))) {
                    checkTypeAssignableTo(exprType, targetType, node, ts.Diagnostics.Neither_type_0_nor_type_1_is_assignable_to_the_other_Colon, ts.Diagnostics.Neither_type_0_nor_type_1_is_assignable_to_the_other);
                }
            }
            return targetType;
        }
        function getTypeAtPosition(signature, pos) {
            return signature.hasRestParameter ? pos < signature.parameters.length - 1 ? getTypeOfSymbol(signature.parameters[pos]) : getRestTypeOfSignature(signature) : pos < signature.parameters.length ? getTypeOfSymbol(signature.parameters[pos]) : anyType;
        }
        function assignContextualParameterTypes(signature, context, mapper) {
            var len = signature.parameters.length - (signature.hasRestParameter ? 1 : 0);
            for (var i = 0; i < len; i++) {
                var parameter = signature.parameters[i];
                var links = getSymbolLinks(parameter);
                links.type = instantiateType(getTypeAtPosition(context, i), mapper);
            }
            if (signature.hasRestParameter && context.hasRestParameter && signature.parameters.length >= context.parameters.length) {
                var parameter = signature.parameters[signature.parameters.length - 1];
                var links = getSymbolLinks(parameter);
                links.type = instantiateType(getTypeOfSymbol(context.parameters[context.parameters.length - 1]), mapper);
            }
        }
        function getReturnTypeFromBody(func, contextualMapper) {
            if (func.body.kind !== 173 /* FunctionBlock */) {
                var unwidenedType = checkAndMarkExpression(func.body, contextualMapper);
                var widenedType = getWidenedType(unwidenedType);
                if (fullTypeCheck && compilerOptions.noImplicitAny && widenedType !== unwidenedType && getInnermostTypeOfNestedArrayTypes(widenedType) === anyType) {
                    error(func, ts.Diagnostics.Function_expression_which_lacks_return_type_annotation_implicitly_has_an_0_return_type, typeToString(widenedType));
                }
                return widenedType;
            }
            // Aggregate the types of expressions within all the return statements.
            var types = checkAndAggregateReturnExpressionTypes(func.body, contextualMapper);
            // Try to return the best common type if we have any return expressions.
            if (types.length > 0) {
                var commonType = getBestCommonType(types, undefined, true);
                if (!commonType) {
                    error(func, ts.Diagnostics.No_best_common_type_exists_among_return_expressions);
                    return unknownType;
                }
                var widenedType = getWidenedType(commonType);
                // Check and report for noImplicitAny if the best common type implicitly gets widened to an 'any'/arrays-of-'any' type.
                if (fullTypeCheck && compilerOptions.noImplicitAny && widenedType !== commonType && getInnermostTypeOfNestedArrayTypes(widenedType) === anyType) {
                    var typeName = typeToString(widenedType);
                    if (func.name) {
                        error(func, ts.Diagnostics._0_which_lacks_return_type_annotation_implicitly_has_an_1_return_type, ts.identifierToString(func.name), typeName);
                    }
                    else {
                        error(func, ts.Diagnostics.Function_expression_which_lacks_return_type_annotation_implicitly_has_an_0_return_type, typeName);
                    }
                }
                return widenedType;
            }
            return voidType;
        }
        /// Returns a set of types relating to every return expression relating to a function block.
        function checkAndAggregateReturnExpressionTypes(body, contextualMapper) {
            var aggregatedTypes = [];
            ts.forEachReturnStatement(body, function (returnStatement) {
                var expr = returnStatement.expression;
                if (expr) {
                    var type = checkAndMarkExpression(expr, contextualMapper);
                    if (!ts.contains(aggregatedTypes, type)) {
                        aggregatedTypes.push(type);
                    }
                }
            });
            return aggregatedTypes;
        }
        function bodyContainsAReturnStatement(funcBody) {
            return ts.forEachReturnStatement(funcBody, function (returnStatement) {
                return true;
            });
        }
        function bodyContainsSingleThrowStatement(body) {
            return (body.statements.length === 1) && (body.statements[0].kind === 165 /* ThrowStatement */);
        }
        // TypeScript Specification 1.0 (6.3) - July 2014
        // An explicitly typed function whose return type isn't the Void or the Any type
        // must have at least one return statement somewhere in its body.
        // An exception to this rule is if the function implementation consists of a single 'throw' statement.
        function checkIfNonVoidFunctionHasReturnExpressionsOrSingleThrowStatment(func, returnType) {
            if (!fullTypeCheck) {
                return;
            }
            // Functions that return 'void' or 'any' don't need any return expressions.
            if (returnType === voidType || returnType === anyType) {
                return;
            }
            // If all we have is a function signature, or an arrow function with an expression body, then there is nothing to check.
            if (!func.body || func.body.kind !== 173 /* FunctionBlock */) {
                return;
            }
            var bodyBlock = func.body;
            // Ensure the body has at least one return expression.
            if (bodyContainsAReturnStatement(bodyBlock)) {
                return;
            }
            // If there are no return expressions, then we need to check if
            // the function body consists solely of a throw statement;
            // this is to make an exception for unimplemented functions.
            if (bodyContainsSingleThrowStatement(bodyBlock)) {
                return;
            }
            // This function does not conform to the specification.
            error(func.type, ts.Diagnostics.A_function_whose_declared_type_is_neither_void_nor_any_must_return_a_value_or_consist_of_a_single_throw_statement);
        }
        function checkFunctionExpression(node, contextualMapper) {
            // The identityMapper object is used to indicate that function expressions are wildcards
            if (contextualMapper === identityMapper) {
                return anyFunctionType;
            }
            var links = getNodeLinks(node);
            var type = getTypeOfSymbol(node.symbol);
            // Check if function expression is contextually typed and assign parameter types if so
            if (!(links.flags & 64 /* ContextChecked */)) {
                var contextualSignature = getContextualSignature(node);
                // If a type check is started at a function expression that is an argument of a function call, obtaining the
                // contextual type may recursively get back to here during overload resolution of the call. If so, we will have
                // already assigned contextual types.
                if (!(links.flags & 64 /* ContextChecked */)) {
                    links.flags |= 64 /* ContextChecked */;
                    if (contextualSignature) {
                        var signature = getSignaturesOfType(type, 0 /* Call */)[0];
                        if (isContextSensitiveExpression(node)) {
                            assignContextualParameterTypes(signature, contextualSignature, contextualMapper || identityMapper);
                        }
                        if (!node.type) {
                            signature.resolvedReturnType = resolvingType;
                            var returnType = getReturnTypeFromBody(node, contextualMapper);
                            if (signature.resolvedReturnType === resolvingType) {
                                signature.resolvedReturnType = returnType;
                            }
                        }
                    }
                    checkSignatureDeclaration(node);
                }
            }
            return type;
        }
        function checkFunctionExpressionBody(node) {
            if (node.type) {
                checkIfNonVoidFunctionHasReturnExpressionsOrSingleThrowStatment(node, getTypeFromTypeNode(node.type));
            }
            if (node.body.kind === 173 /* FunctionBlock */) {
                checkSourceElement(node.body);
            }
            else {
                var exprType = checkExpression(node.body);
                if (node.type) {
                    checkTypeAssignableTo(exprType, getTypeFromTypeNode(node.type), node.body, undefined, undefined);
                }
                checkFunctionExpressionBodies(node.body);
            }
        }
        function checkArithmeticOperandType(operand, type, diagnostic) {
            if (!(type.flags & (1 /* Any */ | ts.TypeFlags.NumberLike))) {
                error(operand, diagnostic);
                return false;
            }
            return true;
        }
        function checkReferenceExpression(n, message) {
            function findSymbol(n) {
                var symbol = getNodeLinks(n).resolvedSymbol;
                // Because we got the symbol from the resolvedSymbol property, it might be of kind
                // SymbolFlags.ExportValue. In this case it is necessary to get the actual export
                // symbol, which will have the correct flags set on it.
                return symbol && getExportSymbolOfValueSymbolIfExported(symbol);
            }
            function isReferenceOrErrorExpression(n) {
                switch (n.kind) {
                    case 59 /* Identifier */:
                        var symbol = findSymbol(n);
                        // TypeScript 1.0 spec (April 2014): 4.3
                        // An identifier expression that references a variable or parameter is classified as a reference. 
                        // An identifier expression that references any other kind of entity is classified as a value(and therefore cannot be the target of an assignment).
                        return !symbol || symbol === unknownSymbol || symbol === argumentsSymbol || (symbol.flags & 1 /* Variable */) !== 0;
                    case 135 /* PropertyAccess */:
                        var symbol = findSymbol(n);
                        // TypeScript 1.0 spec (April 2014): 4.10
                        // A property access expression is always classified as a reference.
                        // NOTE (not in spec): assignment to enum members should not be allowed
                        return !symbol || symbol === unknownSymbol || (symbol.flags & ~4 /* EnumMember */) !== 0;
                    case 136 /* IndexedAccess */:
                        //  old compiler doesn't check indexed assess
                        return true;
                    case 140 /* ParenExpression */:
                        return isReferenceOrErrorExpression(n.expression);
                    default:
                        return false;
                }
            }
            if (!isReferenceOrErrorExpression(n)) {
                error(n, message);
                return false;
            }
            return true;
        }
        function checkPrefixExpression(node) {
            var operandType = checkExpression(node.operand);
            switch (node.operator) {
                case 28 /* PlusToken */:
                case 29 /* MinusToken */:
                case 42 /* TildeToken */:
                    return numberType;
                case 41 /* ExclamationToken */:
                case 68 /* DeleteKeyword */:
                    return booleanType;
                case 91 /* TypeOfKeyword */:
                    return stringType;
                case 93 /* VoidKeyword */:
                    return undefinedType;
                case 33 /* PlusPlusToken */:
                case 34 /* MinusMinusToken */:
                    var ok = checkArithmeticOperandType(node.operand, operandType, ts.Diagnostics.An_arithmetic_operand_must_be_of_type_any_number_or_an_enum_type);
                    if (ok) {
                        // run check only if former checks succeeded to avoid reporting cascading errors
                        checkReferenceExpression(node.operand, ts.Diagnostics.The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_property_or_indexer);
                    }
                    return numberType;
            }
            return unknownType;
        }
        function checkPostfixExpression(node) {
            var operandType = checkExpression(node.operand);
            var ok = checkArithmeticOperandType(node.operand, operandType, ts.Diagnostics.An_arithmetic_operand_must_be_of_type_any_number_or_an_enum_type);
            if (ok) {
                // run check only if former checks succeeded to avoid reporting cascading errors
                checkReferenceExpression(node.operand, ts.Diagnostics.The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_property_or_indexer);
            }
            return numberType;
        }
        function isTypeAnyTypeObjectTypeOrTypeParameter(type) {
            return type === anyType || ((type.flags & (ts.TypeFlags.ObjectType | 512 /* TypeParameter */)) !== 0);
        }
        function checkInstanceOfExpression(node, leftType, rightType) {
            // TypeScript 1.0 spec (April 2014): 4.15.4
            // The instanceof operator requires the left operand to be of type Any, an object type, or a type parameter type,
            // and the right operand to be of type Any or a subtype of the 'Function' interface type. 
            // The result is always of the Boolean primitive type.
            if (!isTypeAnyTypeObjectTypeOrTypeParameter(leftType)) {
                error(node.left, ts.Diagnostics.The_left_hand_side_of_an_instanceof_expression_must_be_of_type_any_an_object_type_or_a_type_parameter);
            }
            if (rightType !== anyType && !isTypeSubtypeOf(rightType, globalFunctionType)) {
                error(node.right, ts.Diagnostics.The_right_hand_side_of_an_instanceof_expression_must_be_of_type_any_or_of_a_type_assignable_to_the_Function_interface_type);
            }
            return booleanType;
        }
        function checkInExpression(node, leftType, rightType) {
            // TypeScript 1.0 spec (April 2014): 4.15.5
            // The in operator requires the left operand to be of type Any, the String primitive type, or the Number primitive type,
            // and the right operand to be of type Any, an object type, or a type parameter type.
            // The result is always of the Boolean primitive type.
            if (leftType !== anyType && leftType !== stringType && leftType !== numberType) {
                error(node.left, ts.Diagnostics.The_left_hand_side_of_an_in_expression_must_be_of_types_any_string_or_number);
            }
            if (!isTypeAnyTypeObjectTypeOrTypeParameter(rightType)) {
                error(node.right, ts.Diagnostics.The_right_hand_side_of_an_in_expression_must_be_of_type_any_an_object_type_or_a_type_parameter);
            }
            return booleanType;
        }
        function checkBinaryExpression(node, contextualMapper) {
            var operator = node.operator;
            var leftType = checkExpression(node.left, contextualMapper);
            var rightType = checkExpression(node.right, contextualMapper);
            switch (operator) {
                case 30 /* AsteriskToken */:
                case 50 /* AsteriskEqualsToken */:
                case 31 /* SlashToken */:
                case 51 /* SlashEqualsToken */:
                case 32 /* PercentToken */:
                case 52 /* PercentEqualsToken */:
                case 29 /* MinusToken */:
                case 49 /* MinusEqualsToken */:
                case 35 /* LessThanLessThanToken */:
                case 53 /* LessThanLessThanEqualsToken */:
                case 36 /* GreaterThanGreaterThanToken */:
                case 54 /* GreaterThanGreaterThanEqualsToken */:
                case 37 /* GreaterThanGreaterThanGreaterThanToken */:
                case 55 /* GreaterThanGreaterThanGreaterThanEqualsToken */:
                case 39 /* BarToken */:
                case 57 /* BarEqualsToken */:
                case 40 /* CaretToken */:
                case 58 /* CaretEqualsToken */:
                case 38 /* AmpersandToken */:
                case 56 /* AmpersandEqualsToken */:
                    // TypeScript 1.0 spec (April 2014): 4.15.1
                    // These operators require their operands to be of type Any, the Number primitive type,
                    // or an enum type. Operands of an enum type are treated 
                    // as having the primitive type Number. If one operand is the null or undefined value,
                    // it is treated as having the type of the other operand.
                    // The result is always of the Number primitive type.
                    if (leftType.flags & (32 /* Undefined */ | 64 /* Null */))
                        leftType = rightType;
                    if (rightType.flags & (32 /* Undefined */ | 64 /* Null */))
                        rightType = leftType;
                    var leftOk = checkArithmeticOperandType(node.left, leftType, ts.Diagnostics.The_left_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_or_an_enum_type);
                    var rightOk = checkArithmeticOperandType(node.right, rightType, ts.Diagnostics.The_right_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_or_an_enum_type);
                    if (leftOk && rightOk) {
                        checkAssignmentOperator(numberType);
                    }
                    return numberType;
                case 28 /* PlusToken */:
                case 48 /* PlusEqualsToken */:
                    // TypeScript 1.0 spec (April 2014): 4.15.2
                    // The binary + operator requires both operands to be of the Number primitive type or an enum type,
                    // or at least one of the operands to be of type Any or the String primitive type.
                    // If one operand is the null or undefined value, it is treated as having the type of the other operand.
                    if (leftType.flags & (32 /* Undefined */ | 64 /* Null */))
                        leftType = rightType;
                    if (rightType.flags & (32 /* Undefined */ | 64 /* Null */))
                        rightType = leftType;
                    var resultType;
                    if (leftType.flags & ts.TypeFlags.NumberLike && rightType.flags & ts.TypeFlags.NumberLike) {
                        // Operands of an enum type are treated as having the primitive type Number.
                        // If both operands are of the Number primitive type, the result is of the Number primitive type.
                        resultType = numberType;
                    }
                    else if (leftType.flags & ts.TypeFlags.StringLike || rightType.flags & ts.TypeFlags.StringLike) {
                        // If one or both operands are of the String primitive type, the result is of the String primitive type.
                        resultType = stringType;
                    }
                    else if (leftType.flags & 1 /* Any */ || leftType === unknownType || rightType.flags & 1 /* Any */ || rightType === unknownType) {
                        // Otherwise, the result is of type Any.
                        // NOTE: unknown type here denotes error type. Old compiler treated this case as any type so do we.
                        resultType = anyType;
                    }
                    if (!resultType) {
                        reportOperatorError();
                        return anyType;
                    }
                    if (operator === 48 /* PlusEqualsToken */) {
                        checkAssignmentOperator(resultType);
                    }
                    return resultType;
                case 23 /* EqualsEqualsToken */:
                case 24 /* ExclamationEqualsToken */:
                case 25 /* EqualsEqualsEqualsToken */:
                case 26 /* ExclamationEqualsEqualsToken */:
                case 19 /* LessThanToken */:
                case 20 /* GreaterThanToken */:
                case 21 /* LessThanEqualsToken */:
                case 22 /* GreaterThanEqualsToken */:
                    if (!isTypeSubtypeOf(leftType, rightType) && !isTypeSubtypeOf(rightType, leftType)) {
                        reportOperatorError();
                    }
                    return booleanType;
                case 81 /* InstanceOfKeyword */:
                    return checkInstanceOfExpression(node, leftType, rightType);
                case 80 /* InKeyword */:
                    return checkInExpression(node, leftType, rightType);
                case 43 /* AmpersandAmpersandToken */:
                    return rightType;
                case 44 /* BarBarToken */:
                    return getBestCommonType([leftType, rightType], isInferentialContext(contextualMapper) ? undefined : getContextualType(node));
                case 47 /* EqualsToken */:
                    checkAssignmentOperator(rightType);
                    return rightType;
                case 18 /* CommaToken */:
                    return rightType;
            }
            function checkAssignmentOperator(valueType) {
                if (fullTypeCheck && operator >= ts.SyntaxKind.FirstAssignment && operator <= ts.SyntaxKind.LastAssignment) {
                    // TypeScript 1.0 spec (April 2014): 4.17
                    // An assignment of the form
                    //    VarExpr = ValueExpr
                    // requires VarExpr to be classified as a reference
                    // A compound assignment furthermore requires VarExpr to be classified as a reference (section 4.1) 
                    // and the type of the non - compound operation to be assignable to the type of VarExpr.
                    var ok = checkReferenceExpression(node.left, ts.Diagnostics.Invalid_left_hand_side_of_assignment_expression);
                    // Use default messages
                    if (ok) {
                        // to avoid cascading errors check assignability only if 'isReference' check succeeded and no errors were reported
                        checkTypeAssignableTo(valueType, leftType, node.left, undefined, undefined);
                    }
                }
            }
            function reportOperatorError() {
                error(node, ts.Diagnostics.Operator_0_cannot_be_applied_to_types_1_and_2, ts.tokenToString(node.operator), typeToString(leftType), typeToString(rightType));
            }
        }
        function checkConditionalExpression(node, contextualMapper) {
            checkExpression(node.condition);
            var type1 = checkExpression(node.whenTrue, contextualMapper);
            var type2 = checkExpression(node.whenFalse, contextualMapper);
            var contextualType = isInferentialContext(contextualMapper) ? undefined : getContextualType(node);
            var resultType = getBestCommonType([type1, type2], contextualType, true);
            if (!resultType) {
                if (contextualType) {
                    error(node, ts.Diagnostics.No_best_common_type_exists_between_0_1_and_2, typeToString(contextualType), typeToString(type1), typeToString(type2));
                }
                else {
                    error(node, ts.Diagnostics.No_best_common_type_exists_between_0_and_1, typeToString(type1), typeToString(type2));
                }
                resultType = emptyObjectType;
            }
            return resultType;
        }
        function checkExpressionWithContextualType(node, contextualType, contextualMapper) {
            var saveContextualType = node.contextualType;
            node.contextualType = contextualType;
            var result = checkExpression(node, contextualMapper);
            node.contextualType = saveContextualType;
            return result;
        }
        function checkAndMarkExpression(node, contextualMapper) {
            var result = checkExpression(node, contextualMapper);
            getNodeLinks(node).flags |= 1 /* TypeChecked */;
            return result;
        }
        // Checks an expression and returns its type. The contextualMapper parameter serves two purposes: When
        // contextualMapper is not undefined and not equal to the identityMapper function object it indicates that the
        // expression is being inferentially typed (section 4.12.2 in spec) and provides the type mapper to use in
        // conjunction with the generic contextual type. When contextualMapper is equal to the identityMapper function
        // object, it serves as an indicator that all contained function and arrow expressions should be considered to
        // have the wildcard function type; this form of type check is used during overload resolution to exclude
        // contextually typed function and arrow expressions in the initial phase.
        function checkExpression(node, contextualMapper) {
            var type = checkExpressionNode(node, contextualMapper);
            if (contextualMapper && contextualMapper !== identityMapper) {
                var signature = getSingleCallSignature(type);
                if (signature && signature.typeParameters) {
                    var contextualType = getContextualType(node);
                    if (contextualType) {
                        var contextualSignature = getSingleCallSignature(contextualType);
                        if (contextualSignature && !contextualSignature.typeParameters) {
                            type = getOrCreateTypeFromSignature(instantiateSignatureInContextOf(signature, contextualSignature, contextualMapper));
                        }
                    }
                }
            }
            return type;
        }
        function checkExpressionNode(node, contextualMapper) {
            switch (node.kind) {
                case 59 /* Identifier */:
                    return checkIdentifier(node);
                case 87 /* ThisKeyword */:
                    return checkThisExpression(node);
                case 85 /* SuperKeyword */:
                    return checkSuperExpression(node);
                case 83 /* NullKeyword */:
                    return nullType;
                case 89 /* TrueKeyword */:
                case 74 /* FalseKeyword */:
                    return booleanType;
                case 6 /* NumericLiteral */:
                    return numberType;
                case 7 /* StringLiteral */:
                    return stringType;
                case 8 /* RegularExpressionLiteral */:
                    return globalRegExpType;
                case 116 /* QualifiedName */:
                    return checkPropertyAccess(node);
                case 132 /* ArrayLiteral */:
                    return checkArrayLiteral(node, contextualMapper);
                case 133 /* ObjectLiteral */:
                    return checkObjectLiteral(node, contextualMapper);
                case 135 /* PropertyAccess */:
                    return checkPropertyAccess(node);
                case 136 /* IndexedAccess */:
                    return checkIndexedAccess(node);
                case 137 /* CallExpression */:
                case 138 /* NewExpression */:
                    return checkCallExpression(node);
                case 139 /* TypeAssertion */:
                    return checkTypeAssertion(node);
                case 140 /* ParenExpression */:
                    return checkExpression(node.expression);
                case 141 /* FunctionExpression */:
                case 142 /* ArrowFunction */:
                    return checkFunctionExpression(node, contextualMapper);
                case 143 /* PrefixOperator */:
                    return checkPrefixExpression(node);
                case 144 /* PostfixOperator */:
                    return checkPostfixExpression(node);
                case 145 /* BinaryExpression */:
                    return checkBinaryExpression(node, contextualMapper);
                case 146 /* ConditionalExpression */:
                    return checkConditionalExpression(node, contextualMapper);
            }
            return unknownType;
        }
        // DECLARATION AND STATEMENT TYPE CHECKING
        function checkTypeParameter(node) {
            checkSourceElement(node.constraint);
            if (fullTypeCheck) {
                checkTypeParameterHasIllegalReferencesInConstraint(node);
                checkTypeNameIsReserved(node.name, ts.Diagnostics.Type_parameter_name_cannot_be_0);
            }
            // TODO: Check multiple declarations are identical
        }
        function checkParameter(parameterDeclaration) {
            checkVariableDeclaration(parameterDeclaration);
            if (fullTypeCheck) {
                checkCollisionWithIndexVariableInGeneratedCode(parameterDeclaration, parameterDeclaration.name);
                if (parameterDeclaration.flags & (16 /* Public */ | 32 /* Private */ | 64 /* Protected */) && !(parameterDeclaration.parent.kind === 121 /* Constructor */ && parameterDeclaration.parent.body)) {
                    error(parameterDeclaration, ts.Diagnostics.A_parameter_property_is_only_allowed_in_a_constructor_implementation);
                }
                if (parameterDeclaration.flags & 8 /* Rest */) {
                    if (!isArrayType(getTypeOfSymbol(parameterDeclaration.symbol))) {
                        error(parameterDeclaration, ts.Diagnostics.A_rest_parameter_must_be_of_an_array_type);
                    }
                }
                else {
                    if (parameterDeclaration.initializer && !parameterDeclaration.parent.body) {
                        error(parameterDeclaration, ts.Diagnostics.A_parameter_initializer_is_only_allowed_in_a_function_or_constructor_implementation);
                    }
                }
            }
            function checkReferencesInInitializer(n) {
                if (n.kind === 59 /* Identifier */) {
                    var referencedSymbol = getNodeLinks(n).resolvedSymbol;
                    // check FunctionDeclaration.locals (stores parameters\function local variable) 
                    // if it contains entry with a specified name and if this entry matches the resolved symbol
                    if (referencedSymbol && referencedSymbol !== unknownSymbol && getSymbol(parameterDeclaration.parent.locals, referencedSymbol.name, ts.SymbolFlags.Value) === referencedSymbol) {
                        if (referencedSymbol.valueDeclaration.kind === 118 /* Parameter */) {
                            if (referencedSymbol.valueDeclaration === parameterDeclaration) {
                                error(n, ts.Diagnostics.Parameter_0_cannot_be_referenced_in_its_initializer, ts.identifierToString(parameterDeclaration.name));
                                return;
                            }
                            var enclosingOrReferencedParameter = ts.forEach(parameterDeclaration.parent.parameters, function (p) { return p === parameterDeclaration || p === referencedSymbol.valueDeclaration ? p : undefined; });
                            if (enclosingOrReferencedParameter === referencedSymbol.valueDeclaration) {
                                // legal case - parameter initializer references some parameter strictly on left of current parameter declaration
                                return;
                            }
                        }
                        error(n, ts.Diagnostics.Initializer_of_parameter_0_cannot_reference_identifier_1_declared_after_it, ts.identifierToString(parameterDeclaration.name), ts.identifierToString(n));
                    }
                }
                else {
                    ts.forEachChild(n, checkReferencesInInitializer);
                }
            }
            if (parameterDeclaration.initializer) {
                checkReferencesInInitializer(parameterDeclaration.initializer);
            }
        }
        function checkSignatureDeclaration(node) {
            checkTypeParameters(node.typeParameters);
            ts.forEach(node.parameters, checkParameter);
            if (node.type) {
                checkSourceElement(node.type);
            }
            if (fullTypeCheck) {
                checkCollisionWithCapturedSuperVariable(node, node.name);
                checkCollisionWithCapturedThisVariable(node, node.name);
                checkCollistionWithRequireExportsInGeneratedCode(node, node.name);
                checkCollisionWithArgumentsInGeneratedCode(node);
                if (compilerOptions.noImplicitAny && !node.type) {
                    switch (node.kind) {
                        case 125 /* ConstructSignature */:
                            error(node, ts.Diagnostics.Construct_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type);
                            break;
                        case 124 /* CallSignature */:
                            error(node, ts.Diagnostics.Call_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type);
                            break;
                    }
                }
            }
            checkSpecializedSignatureDeclaration(node);
        }
        function checkTypeForDuplicateIndexSignatures(node) {
            if (node.kind === 175 /* InterfaceDeclaration */) {
                var nodeSymbol = getSymbolOfNode(node);
                // in case of merging interface declaration it is possible that we'll enter this check procedure several times for every declaration
                // to prevent this run check only for the first declaration of a given kind
                if (nodeSymbol.declarations.length > 0 && nodeSymbol.declarations[0] !== node) {
                    return;
                }
            }
            // TypeScript 1.0 spec (April 2014)
            // 3.7.4: An object type can contain at most one string index signature and one numeric index signature.
            // 8.5: A class declaration can have at most one string index member declaration and one numeric index member declaration
            var indexSymbol = getIndexSymbol(getSymbolOfNode(node));
            if (indexSymbol) {
                var seenNumericIndexer = false;
                var seenStringIndexer = false;
                for (var i = 0, len = indexSymbol.declarations.length; i < len; ++i) {
                    var declaration = indexSymbol.declarations[i];
                    if (declaration.parameters.length == 1 && declaration.parameters[0].type) {
                        switch (declaration.parameters[0].type.kind) {
                            case 114 /* StringKeyword */:
                                if (!seenStringIndexer) {
                                    seenStringIndexer = true;
                                }
                                else {
                                    error(declaration, ts.Diagnostics.Duplicate_string_index_signature);
                                }
                                break;
                            case 112 /* NumberKeyword */:
                                if (!seenNumericIndexer) {
                                    seenNumericIndexer = true;
                                }
                                else {
                                    error(declaration, ts.Diagnostics.Duplicate_number_index_signature);
                                }
                                break;
                        }
                    }
                }
            }
        }
        function checkPropertyDeclaration(node) {
            // TODO
            checkVariableDeclaration(node);
        }
        function checkMethodDeclaration(node) {
            // TODO
            checkFunctionDeclaration(node);
        }
        function checkConstructorDeclaration(node) {
            // TODO
            checkSignatureDeclaration(node);
            checkSourceElement(node.body);
            var symbol = getSymbolOfNode(node);
            var firstDeclaration = getDeclarationOfKind(symbol, node.kind);
            // Only type check the symbol once
            if (node === firstDeclaration) {
                checkFunctionOrConstructorSymbol(symbol);
            }
            // exit early in the case of signature - super checks are not relevant to them
            if (!node.body) {
                return;
            }
            if (!fullTypeCheck) {
                return;
            }
            function isSuperCallExpression(n) {
                return n.kind === 137 /* CallExpression */ && n.func.kind === 85 /* SuperKeyword */;
            }
            function containsSuperCall(n) {
                if (isSuperCallExpression(n)) {
                    return true;
                }
                switch (n.kind) {
                    case 141 /* FunctionExpression */:
                    case 172 /* FunctionDeclaration */:
                    case 142 /* ArrowFunction */:
                    case 133 /* ObjectLiteral */:
                        return false;
                    default:
                        return ts.forEachChild(n, containsSuperCall);
                }
            }
            function markThisReferencesAsErrors(n) {
                if (n.kind === 87 /* ThisKeyword */) {
                    error(n, ts.Diagnostics.this_cannot_be_referenced_in_current_location);
                }
                else if (n.kind !== 141 /* FunctionExpression */ && n.kind !== 172 /* FunctionDeclaration */) {
                    ts.forEachChild(n, markThisReferencesAsErrors);
                }
            }
            function isInstancePropertyWithInitializer(n) {
                return n.kind === 119 /* Property */ && !(n.flags & 128 /* Static */) && !!n.initializer;
            }
            // TS 1.0 spec (April 2014): 8.3.2
            // Constructors of classes with no extends clause may not contain super calls, whereas 
            // constructors of derived classes must contain at least one super call somewhere in their function body.
            if (node.parent.baseType) {
                if (containsSuperCall(node.body)) {
                    // The first statement in the body of a constructor must be a super call if both of the following are true:
                    // - The containing class is a derived class.
                    // - The constructor declares parameter properties 
                    //   or the containing class declares instance member variables with initializers.
                    var superCallShouldBeFirst = ts.forEach(node.parent.members, isInstancePropertyWithInitializer) || ts.forEach(node.parameters, function (p) { return p.flags & (16 /* Public */ | 32 /* Private */ | 64 /* Protected */); });
                    if (superCallShouldBeFirst) {
                        var statements = node.body.statements;
                        if (!statements.length || statements[0].kind !== 151 /* ExpressionStatement */ || !isSuperCallExpression(statements[0].expression)) {
                            error(node, ts.Diagnostics.A_super_call_must_be_the_first_statement_in_the_constructor_when_a_class_contains_initialized_properties_or_has_parameter_properties);
                        }
                        else {
                            // In such a required super call, it is a compile-time error for argument expressions to reference this.
                            markThisReferencesAsErrors(statements[0].expression);
                        }
                    }
                }
                else {
                    error(node, ts.Diagnostics.Constructors_for_derived_classes_must_contain_a_super_call);
                }
            }
        }
        function checkAccessorDeclaration(node) {
            if (fullTypeCheck) {
                if (node.kind === 122 /* GetAccessor */) {
                    if (!ts.isInAmbientContext(node) && node.body && !(bodyContainsAReturnStatement(node.body) || bodyContainsSingleThrowStatement(node.body))) {
                        error(node.name, ts.Diagnostics.A_get_accessor_must_return_a_value_or_consist_of_a_single_throw_statement);
                    }
                }
                // TypeScript 1.0 spec (April 2014): 8.4.3
                // Accessors for the same member name must specify the same accessibility.
                var otherKind = node.kind === 122 /* GetAccessor */ ? 123 /* SetAccessor */ : 122 /* GetAccessor */;
                var otherAccessor = getDeclarationOfKind(node.symbol, otherKind);
                if (otherAccessor) {
                    if (((node.flags & ts.NodeFlags.AccessibilityModifier) !== (otherAccessor.flags & ts.NodeFlags.AccessibilityModifier))) {
                        error(node.name, ts.Diagnostics.Getter_and_setter_accessors_do_not_agree_in_visibility);
                    }
                    var thisType = getAnnotatedAccessorType(node);
                    var otherType = getAnnotatedAccessorType(otherAccessor);
                    // TypeScript 1.0 spec (April 2014): 4.5
                    // If both accessors include type annotations, the specified types must be identical.
                    if (thisType && otherType) {
                        if (!isTypeIdenticalTo(thisType, otherType)) {
                            error(node, ts.Diagnostics.get_and_set_accessor_must_have_the_same_type);
                        }
                    }
                }
            }
            checkFunctionDeclaration(node);
            checkAndStoreTypeOfAccessors(getSymbolOfNode(node));
        }
        function checkTypeReference(node) {
            var type = getTypeFromTypeReferenceNode(node);
            if (type !== unknownType && node.typeArguments) {
                // Do type argument local checks only if referenced type is successfully resolved
                var len = node.typeArguments.length;
                for (var i = 0; i < len; i++) {
                    checkSourceElement(node.typeArguments[i]);
                    var constraint = getConstraintOfTypeParameter(type.target.typeParameters[i]);
                    if (fullTypeCheck && constraint) {
                        var typeArgument = type.typeArguments[i];
                        checkTypeAssignableTo(typeArgument, constraint, node, ts.Diagnostics.Type_0_does_not_satisfy_the_constraint_1_Colon, ts.Diagnostics.Type_0_does_not_satisfy_the_constraint_1);
                    }
                }
            }
        }
        function checkTypeQuery(node) {
            getTypeFromTypeQueryNode(node);
        }
        function checkTypeLiteral(node) {
            ts.forEach(node.members, checkSourceElement);
            if (fullTypeCheck) {
                var type = getTypeFromTypeLiteralNode(node);
                checkIndexConstraints(type);
                checkTypeForDuplicateIndexSignatures(node);
            }
        }
        function checkArrayType(node) {
            checkSourceElement(node.elementType);
        }
        function checkTupleType(node) {
            ts.forEach(node.elementTypes, checkSourceElement);
        }
        function isPrivateWithinAmbient(node) {
            return (node.flags & 32 /* Private */) && ts.isInAmbientContext(node);
        }
        function checkSpecializedSignatureDeclaration(signatureDeclarationNode) {
            if (!fullTypeCheck) {
                return;
            }
            var signature = getSignatureFromDeclaration(signatureDeclarationNode);
            if (!signature.hasStringLiterals) {
                return;
            }
            // TypeScript 1.0 spec (April 2014): 3.7.2.2
            // Specialized signatures are not permitted in conjunction with a function body
            if (signatureDeclarationNode.body) {
                error(signatureDeclarationNode, ts.Diagnostics.A_signature_with_an_implementation_cannot_use_a_string_literal_type);
                return;
            }
            var symbol = getSymbolOfNode(signatureDeclarationNode);
            // TypeScript 1.0 spec (April 2014): 3.7.2.4
            // Every specialized call or construct signature in an object type must be assignable
            // to at least one non-specialized call or construct signature in the same object type
            var signaturesToCheck;
            // Unnamed (call\construct) signatures in interfaces are inherited and not shadowed so examining just node symbol won't give complete answer.
            // Use declaring type to obtain full list of signatures.
            if (!signatureDeclarationNode.name && signatureDeclarationNode.parent && signatureDeclarationNode.parent.kind === 175 /* InterfaceDeclaration */) {
                ts.Debug.assert(signatureDeclarationNode.kind === 124 /* CallSignature */ || signatureDeclarationNode.kind === 125 /* ConstructSignature */);
                var signatureKind = signatureDeclarationNode.kind === 124 /* CallSignature */ ? 0 /* Call */ : 1 /* Construct */;
                var containingSymbol = getSymbolOfNode(signatureDeclarationNode.parent);
                var containingType = getDeclaredTypeOfSymbol(containingSymbol);
                signaturesToCheck = getSignaturesOfType(containingType, signatureKind);
            }
            else {
                signaturesToCheck = getSignaturesOfSymbol(getSymbolOfNode(signatureDeclarationNode));
            }
            for (var i = 0; i < signaturesToCheck.length; i++) {
                var otherSignature = signaturesToCheck[i];
                if (!otherSignature.hasStringLiterals && isSignatureAssignableTo(signature, otherSignature)) {
                    return;
                }
            }
            error(signatureDeclarationNode, ts.Diagnostics.Specialized_overload_signature_is_not_assignable_to_any_non_specialized_signature);
        }
        function getEffectiveDeclarationFlags(n, flagsToCheck) {
            var flags = n.flags;
            if (n.parent.kind !== 175 /* InterfaceDeclaration */ && ts.isInAmbientContext(n)) {
                if (!(flags & 2 /* Ambient */)) {
                    // It is nested in an ambient context, which means it is automatically exported
                    flags |= 1 /* Export */;
                }
                flags |= 2 /* Ambient */;
            }
            return flags & flagsToCheck;
        }
        function checkFunctionOrConstructorSymbol(symbol) {
            if (!fullTypeCheck) {
                return;
            }
            function checkFlagAgreementBetweenOverloads(overloads, implementation, flagsToCheck, someOverloadFlags, allOverloadFlags) {
                // Error if some overloads have a flag that is not shared by all overloads. To find the
                // deviations, we XOR someOverloadFlags with allOverloadFlags
                var someButNotAllOverloadFlags = someOverloadFlags ^ allOverloadFlags;
                if (someButNotAllOverloadFlags !== 0) {
                    // Consider the canonical set of flags to be the flags of the bodyDeclaration or the first declaration
                    // Error on all deviations from this canonical set of flags
                    // The caveat is that if some overloads are defined in lib.d.ts, we don't want to
                    // report the errors on those. To achieve this, we will say that the implementation is
                    // the canonical signature only if it is in the same container as the first overload
                    var implementationSharesContainerWithFirstOverload = implementation !== undefined && implementation.parent === overloads[0].parent;
                    var canonicalFlags = implementationSharesContainerWithFirstOverload ? getEffectiveDeclarationFlags(implementation, flagsToCheck) : getEffectiveDeclarationFlags(overloads[0], flagsToCheck);
                    ts.forEach(overloads, function (o) {
                        var deviation = getEffectiveDeclarationFlags(o, flagsToCheck) ^ canonicalFlags;
                        if (deviation & 1 /* Export */) {
                            error(o.name, ts.Diagnostics.Overload_signatures_must_all_be_exported_or_not_exported);
                        }
                        else if (deviation & 2 /* Ambient */) {
                            error(o.name, ts.Diagnostics.Overload_signatures_must_all_be_ambient_or_non_ambient);
                        }
                        else if (deviation & (32 /* Private */ | 64 /* Protected */)) {
                            error(o.name, ts.Diagnostics.Overload_signatures_must_all_be_public_private_or_protected);
                        }
                        else if (deviation & 4 /* QuestionMark */) {
                            error(o.name, ts.Diagnostics.Overload_signatures_must_all_be_optional_or_required);
                        }
                    });
                }
            }
            var flagsToCheck = 1 /* Export */ | 2 /* Ambient */ | 32 /* Private */ | 64 /* Protected */ | 4 /* QuestionMark */;
            var someNodeFlags = 0;
            var allNodeFlags = flagsToCheck;
            var hasOverloads = false;
            var bodyDeclaration;
            var lastSeenNonAmbientDeclaration;
            var previousDeclaration;
            var declarations = symbol.declarations;
            var isConstructor = (symbol.flags & 4096 /* Constructor */) !== 0;
            function reportImplementationExpectedError(node) {
                var seen = false;
                var subsequentNode = ts.forEachChild(node.parent, function (c) {
                    if (seen) {
                        return c;
                    }
                    else {
                        seen = c === node;
                    }
                });
                if (subsequentNode) {
                    if (subsequentNode.kind === node.kind) {
                        var errorNode = subsequentNode.name || subsequentNode;
                        if (node.name && subsequentNode.name && node.name.text === subsequentNode.name.text) {
                            // the only situation when this is possible (same kind\same name but different symbol) - mixed static and instance class members
                            ts.Debug.assert(node.kind === 120 /* Method */);
                            ts.Debug.assert((node.flags & 128 /* Static */) !== (subsequentNode.flags & 128 /* Static */));
                            var diagnostic = node.flags & 128 /* Static */ ? ts.Diagnostics.Function_overload_must_be_static : ts.Diagnostics.Function_overload_must_not_be_static;
                            error(errorNode, diagnostic);
                            return;
                        }
                        else if (subsequentNode.body) {
                            error(errorNode, ts.Diagnostics.Function_implementation_name_must_be_0, ts.identifierToString(node.name));
                            return;
                        }
                    }
                }
                var errorNode = node.name || node;
                if (isConstructor) {
                    error(errorNode, ts.Diagnostics.Constructor_implementation_is_missing);
                }
                else {
                    error(errorNode, ts.Diagnostics.Function_implementation_is_missing_or_not_immediately_following_the_declaration);
                }
            }
            // when checking exported function declarations across modules check only duplicate implementations
            // names and consistency of modifiers are verified when we check local symbol
            var isExportSymbolInsideModule = symbol.parent && symbol.parent.flags & ts.SymbolFlags.Module;
            for (var i = 0; i < declarations.length; i++) {
                var node = declarations[i];
                var inAmbientContext = ts.isInAmbientContext(node);
                var inAmbientContextOrInterface = node.parent.kind === 175 /* InterfaceDeclaration */ || node.parent.kind === 129 /* TypeLiteral */ || inAmbientContext;
                if (inAmbientContextOrInterface) {
                    // check if declarations are consecutive only if they are non-ambient
                    // 1. ambient declarations can be interleaved
                    // i.e. this is legal
                    //     declare function foo();
                    //     declare function bar();
                    //     declare function foo();
                    // 2. mixing ambient and non-ambient declarations is a separate error that will be reported - do not want to report an extra one
                    previousDeclaration = undefined;
                }
                if (node.kind === 172 /* FunctionDeclaration */ || node.kind === 120 /* Method */ || node.kind === 121 /* Constructor */) {
                    var currentNodeFlags = getEffectiveDeclarationFlags(node, flagsToCheck);
                    someNodeFlags |= currentNodeFlags;
                    allNodeFlags &= currentNodeFlags;
                    if (node.body && bodyDeclaration) {
                        if (isConstructor) {
                            error(node, ts.Diagnostics.Multiple_constructor_implementations_are_not_allowed);
                        }
                        else {
                            error(node, ts.Diagnostics.Duplicate_function_implementation);
                        }
                    }
                    else if (!isExportSymbolInsideModule && previousDeclaration && previousDeclaration.parent === node.parent && previousDeclaration.end !== node.pos) {
                        reportImplementationExpectedError(previousDeclaration);
                    }
                    if (node.body) {
                        if (!bodyDeclaration) {
                            bodyDeclaration = node;
                        }
                    }
                    else {
                        hasOverloads = true;
                    }
                    previousDeclaration = node;
                    if (!inAmbientContextOrInterface) {
                        lastSeenNonAmbientDeclaration = node;
                    }
                }
            }
            if (!isExportSymbolInsideModule && lastSeenNonAmbientDeclaration && !lastSeenNonAmbientDeclaration.body) {
                reportImplementationExpectedError(lastSeenNonAmbientDeclaration);
            }
            if (hasOverloads) {
                checkFlagAgreementBetweenOverloads(declarations, bodyDeclaration, flagsToCheck, someNodeFlags, allNodeFlags);
                if (bodyDeclaration) {
                    var signatures = getSignaturesOfSymbol(symbol);
                    var bodySignature = getSignatureFromDeclaration(bodyDeclaration);
                    // If the implementation signature has string literals, we will have reported an error in
                    // checkSpecializedSignatureDeclaration
                    if (!bodySignature.hasStringLiterals) {
                        for (var i = 0, len = signatures.length; i < len; ++i) {
                            if (!signatures[i].hasStringLiterals && !isSignatureAssignableTo(bodySignature, signatures[i])) {
                                error(signatures[i].declaration, ts.Diagnostics.Overload_signature_is_not_compatible_with_function_implementation);
                                break;
                            }
                        }
                    }
                }
            }
        }
        function checkExportsOnMergedDeclarations(node) {
            if (!fullTypeCheck) {
                return;
            }
            var symbol;
            // Exports should be checked only if enclosing module contains both exported and non exported declarations.
            // In case if all declarations are non-exported check is unnecessary.
            // if localSymbol is defined on node then node itself is exported - check is required
            var symbol = node.localSymbol;
            if (!symbol) {
                // local symbol is undefined => this declaration is non-exported.
                // however symbol might contain other declarations that are exported
                symbol = getSymbolOfNode(node);
                if (!(symbol.flags & ts.SymbolFlags.Export)) {
                    // this is a pure local symbol (all declarations are non-exported) - no need to check anything
                    return;
                }
            }
            // run the check only for the first declaration in the list
            if (getDeclarationOfKind(symbol, node.kind) !== node) {
                return;
            }
            // we use SymbolFlags.ExportValue, SymbolFlags.ExportType and SymbolFlags.ExportNamespace 
            // to denote disjoint declarationSpaces (without making new enum type).
            var exportedDeclarationSpaces = 0;
            var nonExportedDeclarationSpaces = 0;
            ts.forEach(symbol.declarations, function (d) {
                var declarationSpaces = getDeclarationSpaces(d);
                if (getEffectiveDeclarationFlags(d, 1 /* Export */)) {
                    exportedDeclarationSpaces |= declarationSpaces;
                }
                else {
                    nonExportedDeclarationSpaces |= declarationSpaces;
                }
            });
            var commonDeclarationSpace = exportedDeclarationSpaces & nonExportedDeclarationSpaces;
            if (commonDeclarationSpace) {
                // declaration spaces for exported and non-exported declarations intersect
                ts.forEach(symbol.declarations, function (d) {
                    if (getDeclarationSpaces(d) & commonDeclarationSpace) {
                        error(d.name, ts.Diagnostics.Individual_declarations_in_merged_declaration_0_must_be_all_exported_or_all_local, ts.identifierToString(d.name));
                    }
                });
            }
            function getDeclarationSpaces(d) {
                switch (d.kind) {
                    case 175 /* InterfaceDeclaration */:
                        return 1048576 /* ExportType */;
                    case 177 /* ModuleDeclaration */:
                        return d.name.kind === 7 /* StringLiteral */ || ts.isInstantiated(d) ? 2097152 /* ExportNamespace */ | 524288 /* ExportValue */ : 2097152 /* ExportNamespace */;
                    case 174 /* ClassDeclaration */:
                    case 176 /* EnumDeclaration */:
                        return 1048576 /* ExportType */ | 524288 /* ExportValue */;
                    case 179 /* ImportDeclaration */:
                        var result = 0;
                        var target = resolveImport(getSymbolOfNode(d));
                        ts.forEach(target.declarations, function (d) {
                            result |= getDeclarationSpaces(d);
                        });
                        return result;
                    default:
                        return 524288 /* ExportValue */;
                }
            }
        }
        function checkFunctionDeclaration(node) {
            checkSignatureDeclaration(node);
            var symbol = getSymbolOfNode(node);
            // first we want to check the local symbol that contain this declaration
            // - if node.localSymbol !== undefined - this is current declaration is exported and localSymbol points to the local symbol
            // - if node.localSymbol === undefined - this node is non-exported so we can just pick the result of getSymbolOfNode
            var localSymbol = node.localSymbol || symbol;
            var firstDeclaration = getDeclarationOfKind(localSymbol, node.kind);
            // Only type check the symbol once
            if (node === firstDeclaration) {
                checkFunctionOrConstructorSymbol(localSymbol);
            }
            if (symbol.parent) {
                // run check once for the first declaration
                if (getDeclarationOfKind(symbol, node.kind) === node) {
                    // run check on export symbol to check that modifiers agree across all exported declarations
                    checkFunctionOrConstructorSymbol(symbol);
                }
            }
            checkSourceElement(node.body);
            if (node.type && !isAccessor(node.kind)) {
                checkIfNonVoidFunctionHasReturnExpressionsOrSingleThrowStatment(node, getTypeFromTypeNode(node.type));
            }
            // If there is no body and no explicit return type, then report an error.
            if (fullTypeCheck && compilerOptions.noImplicitAny && !node.body && !node.type) {
                // Ignore privates within ambient contexts; they exist purely for documentative purposes to avoid name clashing.
                // (e.g. privates within .d.ts files do not expose type information)
                if (!isPrivateWithinAmbient(node)) {
                    var typeName = typeToString(anyType);
                    if (node.name) {
                        error(node, ts.Diagnostics._0_which_lacks_return_type_annotation_implicitly_has_an_1_return_type, ts.identifierToString(node.name), typeName);
                    }
                    else {
                        error(node, ts.Diagnostics.Function_expression_which_lacks_return_type_annotation_implicitly_has_an_0_return_type, typeName);
                    }
                }
            }
        }
        function checkBlock(node) {
            ts.forEach(node.statements, checkSourceElement);
        }
        function checkCollisionWithArgumentsInGeneratedCode(node) {
            // no rest parameters \ declaration context \ overload - no codegen impact
            if (!ts.hasRestParameters(node) || ts.isInAmbientContext(node) || !node.body) {
                return;
            }
            ts.forEach(node.parameters, function (p) {
                if (p.name && p.name.text === argumentsSymbol.name) {
                    error(p, ts.Diagnostics.Duplicate_identifier_arguments_Compiler_uses_arguments_to_initialize_rest_parameters);
                }
            });
        }
        function checkCollisionWithIndexVariableInGeneratedCode(node, name) {
            if (!(name && name.text === "_i")) {
                return;
            }
            if (node.kind === 118 /* Parameter */) {
                // report error if parameter has name '_i' when:
                // - function has implementation (not a signature)
                // - function has rest parameters
                // - context is not ambient (otherwise no codegen impact)
                if (node.parent.body && ts.hasRestParameters(node.parent) && !ts.isInAmbientContext(node)) {
                    error(node, ts.Diagnostics.Duplicate_identifier_i_Compiler_uses_i_to_initialize_rest_parameter);
                }
                return;
            }
            var symbol = getNodeLinks(node).resolvedSymbol;
            if (symbol === unknownSymbol) {
                return;
            }
            // we would like to discover cases like one below:
            //
            // var _i = "!";
            // function foo(...a) {
            //    function bar() {
            //        var x = { get baz() { return _i; } }
            //    }
            // }
            // 
            // at runtime '_i' referenced in getter will be resolved to the generated index variable '_i' used to initialize rest parameters.
            // legitimate case: when '_i' is defined inside the function declaration with rest parameters.
            // 
            // function foo(...a) {
            //    var _i = "!";
            //    function bar() {
            //        var x = { get baz() { return _i; } }
            //    }
            // }
            ////  if resolved symbol for node has more than one declaration - this is definitely an error
            ////  (there is nothing value-like in the language that can be nested in function and consists of multiple declarations)
            //if (symbol.declarations.length > 1) {
            //    error(node, Diagnostics.Expression_resolves_to_variable_declaration_i_that_compiler_uses_to_initialize_rest_parameter);
            //    return;
            //}
            // short gist of the check:
            // - otherwise
            // - walk to the top of the tree starting from the 'node'
            // - at every step check if 'current' node contains any declaration of original node
            //   yes - return
            //   no - check if current declaration is function with rest parameters
            //        yes - report error since '_i' from this function will shadow '_i' defined in the outer scope
            //        no - go up to the next level
            var current = node;
            while (current) {
                var definedOnCurrentLevel = ts.forEach(symbol.declarations, function (d) { return d.parent === current ? d : undefined; });
                if (definedOnCurrentLevel) {
                    return;
                }
                switch (current.kind) {
                    case 172 /* FunctionDeclaration */:
                    case 141 /* FunctionExpression */:
                    case 120 /* Method */:
                    case 142 /* ArrowFunction */:
                    case 121 /* Constructor */:
                        if (ts.hasRestParameters(current)) {
                            error(node, ts.Diagnostics.Expression_resolves_to_variable_declaration_i_that_compiler_uses_to_initialize_rest_parameter);
                            return;
                        }
                        break;
                }
                current = current.parent;
            }
        }
        function needCollisionCheckForIdentifier(node, identifier, name) {
            if (!(identifier && identifier.text === name)) {
                return false;
            }
            if (node.kind === 119 /* Property */ || node.kind === 120 /* Method */ || node.kind === 122 /* GetAccessor */ || node.kind === 123 /* SetAccessor */) {
                // it is ok to have member named '_super' or '_this' - member access is always qualified
                return false;
            }
            if (ts.isInAmbientContext(node)) {
                // ambient context - no codegen impact
                return false;
            }
            if (node.kind === 118 /* Parameter */ && !node.parent.body) {
                // just an overload - no codegen impact
                return false;
            }
            return true;
        }
        function checkCollisionWithCapturedThisVariable(node, name) {
            if (!needCollisionCheckForIdentifier(node, name, "_this")) {
                return;
            }
            potentialThisCollisions.push(node);
        }
        // this function will run after checking the source file so 'CaptureThis' is correct for all nodes
        function checkIfThisIsCapturedInEnclosingScope(node) {
            var current = node;
            while (current) {
                if (getNodeCheckFlags(current) & 4 /* CaptureThis */) {
                    var isDeclaration = node.kind !== 59 /* Identifier */;
                    if (isDeclaration) {
                        error(node.name, ts.Diagnostics.Duplicate_identifier_this_Compiler_uses_variable_declaration_this_to_capture_this_reference);
                    }
                    else {
                        error(node, ts.Diagnostics.Expression_resolves_to_variable_declaration_this_that_compiler_uses_to_capture_this_reference);
                    }
                    return;
                }
                current = current.parent;
            }
        }
        function checkCollisionWithCapturedSuperVariable(node, name) {
            if (!needCollisionCheckForIdentifier(node, name, "_super")) {
                return;
            }
            // bubble up and find containing type
            var enclosingClass = ts.getAncestor(node, 174 /* ClassDeclaration */);
            // if containing type was not found or it is ambient - exit (no codegen)
            if (!enclosingClass || ts.isInAmbientContext(enclosingClass)) {
                return;
            }
            if (enclosingClass.baseType) {
                var isDeclaration = node.kind !== 59 /* Identifier */;
                if (isDeclaration) {
                    error(node, ts.Diagnostics.Duplicate_identifier_super_Compiler_uses_super_to_capture_base_class_reference);
                }
                else {
                    error(node, ts.Diagnostics.Expression_resolves_to_super_that_compiler_uses_to_capture_base_class_reference);
                }
            }
        }
        function checkCollistionWithRequireExportsInGeneratedCode(node, name) {
            if (!needCollisionCheckForIdentifier(node, name, "require") && !needCollisionCheckForIdentifier(node, name, "exports")) {
                return;
            }
            // Uninstantiated modules shouldnt do this check
            if (node.kind === 177 /* ModuleDeclaration */ && !ts.isInstantiated(node)) {
                return;
            }
            // In case of variable declaration, node.parent is variable statement so look at the variable statement's parent
            var parent = node.kind === 171 /* VariableDeclaration */ ? node.parent.parent : node.parent;
            if (parent.kind === 182 /* SourceFile */ && ts.isExternalModule(parent)) {
                // If the declaration happens to be in external module, report error that require and exports are reserved keywords
                error(name, ts.Diagnostics.Duplicate_identifier_0_Compiler_reserves_name_1_in_top_level_scope_of_an_external_module, name.text, name.text);
            }
        }
        function checkVariableDeclaration(node) {
            checkSourceElement(node.type);
            checkExportsOnMergedDeclarations(node);
            if (fullTypeCheck) {
                var symbol = getSymbolOfNode(node);
                var typeOfValueDeclaration = getTypeOfVariableOrParameterOrProperty(symbol);
                var type;
                var useTypeFromValueDeclaration = node === symbol.valueDeclaration;
                if (useTypeFromValueDeclaration) {
                    type = typeOfValueDeclaration;
                }
                else {
                    type = getTypeOfVariableDeclaration(node);
                }
                if (node.initializer) {
                    if (!(getNodeLinks(node.initializer).flags & 1 /* TypeChecked */)) {
                        // Use default messages
                        checkTypeAssignableTo(checkAndMarkExpression(node.initializer), type, node, undefined, undefined);
                    }
                }
                checkCollisionWithCapturedSuperVariable(node, node.name);
                checkCollisionWithCapturedThisVariable(node, node.name);
                checkCollistionWithRequireExportsInGeneratedCode(node, node.name);
                if (!useTypeFromValueDeclaration) {
                    // TypeScript 1.0 spec (April 2014): 5.1
                    // Multiple declarations for the same variable name in the same declaration space are permitted,
                    // provided that each declaration associates the same type with the variable.
                    if (typeOfValueDeclaration !== unknownType && type !== unknownType && !isTypeIdenticalTo(typeOfValueDeclaration, type)) {
                        error(node.name, ts.Diagnostics.Subsequent_variable_declarations_must_have_the_same_type_Variable_0_must_be_of_type_1_but_here_has_type_2, ts.identifierToString(node.name), typeToString(typeOfValueDeclaration), typeToString(type));
                    }
                }
            }
        }
        function checkVariableStatement(node) {
            ts.forEach(node.declarations, checkVariableDeclaration);
        }
        function checkExpressionStatement(node) {
            checkExpression(node.expression);
        }
        function checkIfStatement(node) {
            checkExpression(node.expression);
            checkSourceElement(node.thenStatement);
            checkSourceElement(node.elseStatement);
        }
        function checkDoStatement(node) {
            checkSourceElement(node.statement);
            checkExpression(node.expression);
        }
        function checkWhileStatement(node) {
            checkExpression(node.expression);
            checkSourceElement(node.statement);
        }
        function checkForStatement(node) {
            if (node.declarations)
                ts.forEach(node.declarations, checkVariableDeclaration);
            if (node.initializer)
                checkExpression(node.initializer);
            if (node.condition)
                checkExpression(node.condition);
            if (node.iterator)
                checkExpression(node.iterator);
            checkSourceElement(node.statement);
        }
        function checkForInStatement(node) {
            // TypeScript 1.0 spec  (April 2014): 5.4
            // In a 'for-in' statement of the form
            // for (var VarDecl in Expr) Statement
            //   VarDecl must be a variable declaration without a type annotation that declares a variable of type Any,
            //   and Expr must be an expression of type Any, an object type, or a type parameter type.                        
            if (node.declaration) {
                checkVariableDeclaration(node.declaration);
                if (node.declaration.type) {
                    error(node.declaration, ts.Diagnostics.The_left_hand_side_of_a_for_in_statement_cannot_use_a_type_annotation);
                }
            }
            // In a 'for-in' statement of the form
            // for (Var in Expr) Statement
            //   Var must be an expression classified as a reference of type Any or the String primitive type,
            //   and Expr must be an expression of type Any, an object type, or a type parameter type.
            if (node.variable) {
                var exprType = checkExpression(node.variable);
                if (exprType !== anyType && exprType !== stringType) {
                    error(node.variable, ts.Diagnostics.The_left_hand_side_of_a_for_in_statement_must_be_of_type_string_or_any);
                }
                else {
                    // run check only former check succeeded to avoid cascading errors
                    checkReferenceExpression(node.variable, ts.Diagnostics.Invalid_left_hand_side_in_for_in_statement);
                }
            }
            var exprType = checkExpression(node.expression);
            // unknownType is returned i.e. if node.expression is identifier whose name cannot be resolved
            // in this case error about missing name is already reported - do not report extra one
            if (!isTypeAnyTypeObjectTypeOrTypeParameter(exprType) && exprType !== unknownType) {
                error(node.expression, ts.Diagnostics.The_right_hand_side_of_a_for_in_statement_must_be_of_type_any_an_object_type_or_a_type_parameter);
            }
            checkSourceElement(node.statement);
        }
        function checkBreakOrContinueStatement(node) {
            // TODO: Check that target label is valid
        }
        function checkReturnStatement(node) {
            if (node.expression && !(getNodeLinks(node.expression).flags & 1 /* TypeChecked */)) {
                var func = ts.getContainingFunction(node);
                if (func) {
                    if (func.kind === 123 /* SetAccessor */) {
                        if (node.expression) {
                            error(node.expression, ts.Diagnostics.Setters_cannot_return_a_value);
                        }
                    }
                    else {
                        var returnType = getReturnTypeOfSignature(getSignatureFromDeclaration(func));
                        // do assignability check only if we short circuited in determining return type
                        // - function has explicit type annotation
                        // - function is getter with no type annotation and setter parameter type is used
                        // - function is a constructor (will be special cased below)
                        var checkAssignability = func.type || (func.kind === 122 /* GetAccessor */ && getSetAccessorTypeAnnotationNode(getDeclarationOfKind(func.symbol, 123 /* SetAccessor */)));
                        if (checkAssignability) {
                            checkTypeAssignableTo(checkExpression(node.expression), returnType, node.expression, undefined, undefined);
                        }
                        else if (func.kind == 121 /* Constructor */) {
                            // constructor doesn't have explicit return type annotation and yet its return type is known - declaring type
                            // handle constructors and issue specialized error message for them.
                            if (!isTypeAssignableTo(checkExpression(node.expression), returnType)) {
                                error(node.expression, ts.Diagnostics.Return_type_of_constructor_signature_must_be_assignable_to_the_instance_type_of_the_class);
                            }
                        }
                    }
                }
            }
        }
        function checkWithStatement(node) {
            checkExpression(node.expression);
            error(node.expression, ts.Diagnostics.All_symbols_within_a_with_block_will_be_resolved_to_any);
        }
        function checkSwitchStatement(node) {
            var expressionType = checkExpression(node.expression);
            ts.forEach(node.clauses, function (clause) {
                if (fullTypeCheck && clause.expression) {
                    // TypeScript 1.0 spec (April 2014):5.9
                    // In a 'switch' statement, each 'case' expression must be of a type that is assignable to or from the type of the 'switch' expression.
                    var caseType = checkExpression(clause.expression);
                    if (!isTypeAssignableTo(expressionType, caseType)) {
                        // check 'expressionType isAssignableTo caseType' failed, try the reversed check and report errors if it fails
                        checkTypeAssignableTo(caseType, expressionType, clause.expression, undefined, undefined);
                    }
                }
                checkBlock(clause);
            });
        }
        function checkLabeledStatement(node) {
            checkSourceElement(node.statement);
        }
        function checkThrowStatement(node) {
            checkExpression(node.expression);
        }
        function checkTryStatement(node) {
            checkBlock(node.tryBlock);
            if (node.catchBlock)
                checkBlock(node.catchBlock);
            if (node.finallyBlock)
                checkBlock(node.finallyBlock);
        }
        function checkIndexConstraints(type) {
            function checkIndexConstraintForProperty(prop, propertyType, indexDeclaration, indexType, indexKind) {
                if (!indexType) {
                    return;
                }
                // index is numeric and property name is not valid numeric literal
                if (indexKind === 1 /* Number */ && !isNumericName(prop.name)) {
                    return;
                }
                // perform property check if property or indexer is declared in 'type'
                // this allows to rule out cases when both property and indexer are inherited from the base class
                var errorNode;
                if (prop.parent === type.symbol) {
                    errorNode = prop.valueDeclaration;
                }
                else if (indexDeclaration) {
                    errorNode = indexDeclaration;
                }
                else if (type.flags & 2048 /* Interface */) {
                    // for interfaces property and indexer might be inherited from different bases
                    // check if any base class already has both property and indexer.
                    // check should be performed only if 'type' is the first type that brings property\indexer together
                    var someBaseClassHasBothPropertyAndIndexer = ts.forEach(type.baseTypes, function (base) { return getPropertyOfType(base, prop.name) && getIndexTypeOfType(base, indexKind); });
                    errorNode = someBaseClassHasBothPropertyAndIndexer ? undefined : type.symbol.declarations[0];
                }
                if (errorNode && !isTypeAssignableTo(propertyType, indexType)) {
                    var errorMessage = indexKind === 0 /* String */ ? ts.Diagnostics.Property_0_of_type_1_is_not_assignable_to_string_index_type_2 : ts.Diagnostics.Property_0_of_type_1_is_not_assignable_to_numeric_index_type_2;
                    error(errorNode, errorMessage, symbolToString(prop), typeToString(propertyType), typeToString(indexType));
                }
            }
            var declaredNumberIndexer = getIndexDeclarationOfSymbol(type.symbol, 1 /* Number */);
            var declaredStringIndexer = getIndexDeclarationOfSymbol(type.symbol, 0 /* String */);
            var stringIndexType = getIndexTypeOfType(type, 0 /* String */);
            var numberIndexType = getIndexTypeOfType(type, 1 /* Number */);
            if (stringIndexType || numberIndexType) {
                ts.forEach(getPropertiesOfType(type), function (prop) {
                    var propType = getTypeOfSymbol(prop);
                    checkIndexConstraintForProperty(prop, propType, declaredStringIndexer, stringIndexType, 0 /* String */);
                    checkIndexConstraintForProperty(prop, propType, declaredNumberIndexer, numberIndexType, 1 /* Number */);
                });
            }
            var errorNode;
            if (stringIndexType && numberIndexType) {
                errorNode = declaredNumberIndexer || declaredStringIndexer;
                // condition 'errorNode === undefined' may appear if types does not declare nor string neither number indexer
                if (!errorNode && (type.flags & 2048 /* Interface */)) {
                    var someBaseTypeHasBothIndexers = ts.forEach(type.baseTypes, function (base) { return getIndexTypeOfType(base, 0 /* String */) && getIndexTypeOfType(base, 1 /* Number */); });
                    errorNode = someBaseTypeHasBothIndexers ? undefined : type.symbol.declarations[0];
                }
            }
            if (errorNode && !isTypeAssignableTo(numberIndexType, stringIndexType)) {
                error(errorNode, ts.Diagnostics.Numeric_index_type_0_is_not_assignable_to_string_index_type_1, typeToString(numberIndexType), typeToString(stringIndexType));
            }
        }
        function checkTypeNameIsReserved(name, message) {
            switch (name.text) {
                case "any":
                case "number":
                case "boolean":
                case "string":
                case "void":
                    error(name, message, name.text);
            }
        }
        // Check each type parameter and check that list has no duplicate type parameter declarations
        function checkTypeParameters(typeParameterDeclarations) {
            if (typeParameterDeclarations) {
                for (var i = 0; i < typeParameterDeclarations.length; i++) {
                    var node = typeParameterDeclarations[i];
                    checkTypeParameter(node);
                    if (fullTypeCheck) {
                        for (var j = 0; j < i; j++) {
                            if (typeParameterDeclarations[j].symbol === node.symbol) {
                                error(node.name, ts.Diagnostics.Duplicate_identifier_0, ts.identifierToString(node.name));
                            }
                        }
                    }
                }
            }
        }
        function checkClassDeclaration(node) {
            checkTypeNameIsReserved(node.name, ts.Diagnostics.Class_name_cannot_be_0);
            checkTypeParameters(node.typeParameters);
            checkCollisionWithCapturedThisVariable(node, node.name);
            checkCollistionWithRequireExportsInGeneratedCode(node, node.name);
            checkExportsOnMergedDeclarations(node);
            var symbol = getSymbolOfNode(node);
            var type = getDeclaredTypeOfSymbol(symbol);
            var staticType = getTypeOfSymbol(symbol);
            if (node.baseType) {
                emitExtends = emitExtends || !ts.isInAmbientContext(node);
                checkTypeReference(node.baseType);
            }
            if (type.baseTypes.length) {
                if (fullTypeCheck) {
                    var baseType = type.baseTypes[0];
                    checkTypeAssignableTo(type, baseType, node.name, ts.Diagnostics.Class_0_incorrectly_extends_base_class_1_Colon, ts.Diagnostics.Class_0_incorrectly_extends_base_class_1);
                    var staticBaseType = getTypeOfSymbol(baseType.symbol);
                    checkTypeAssignableTo(staticType, getTypeWithoutConstructors(staticBaseType), node.name, ts.Diagnostics.Class_static_side_0_incorrectly_extends_base_class_static_side_1_Colon, ts.Diagnostics.Class_static_side_0_incorrectly_extends_base_class_static_side_1);
                    if (baseType.symbol !== resolveEntityName(node, node.baseType.typeName, ts.SymbolFlags.Value)) {
                        error(node.baseType, ts.Diagnostics.Type_name_0_in_extends_clause_does_not_reference_constructor_function_for_0, typeToString(baseType));
                    }
                    checkKindsOfPropertyMemberOverrides(type, baseType);
                }
                // Check that base type can be evaluated as expression
                checkExpression(node.baseType.typeName);
            }
            if (node.implementedTypes) {
                ts.forEach(node.implementedTypes, function (typeRefNode) {
                    checkTypeReference(typeRefNode);
                    if (fullTypeCheck) {
                        var t = getTypeFromTypeReferenceNode(typeRefNode);
                        if (t !== unknownType) {
                            var declaredType = (t.flags & 4096 /* Reference */) ? t.target : t;
                            if (declaredType.flags & (1024 /* Class */ | 2048 /* Interface */)) {
                                checkTypeAssignableTo(type, t, node.name, ts.Diagnostics.Class_0_incorrectly_implements_interface_1_Colon, ts.Diagnostics.Class_0_incorrectly_implements_interface_1);
                            }
                            else {
                                error(typeRefNode, ts.Diagnostics.A_class_may_only_implement_another_class_or_interface);
                            }
                        }
                    }
                });
            }
            ts.forEach(node.members, checkSourceElement);
            if (fullTypeCheck) {
                checkIndexConstraints(type);
                checkTypeForDuplicateIndexSignatures(node);
            }
        }
        function getTargetSymbol(s) {
            // if symbol is instantiated its flags are not copied from the 'target'
            // so we'll need to get back original 'target' symbol to work with correct set of flags
            return s.flags & 8388608 /* Instantiated */ ? getSymbolLinks(s).target : s;
        }
        function checkKindsOfPropertyMemberOverrides(type, baseType) {
            // TypeScript 1.0 spec (April 2014): 8.2.3
            // A derived class inherits all members from its base class it doesn't override.
            // Inheritance means that a derived class implicitly contains all non - overridden members of the base class.
            // Both public and private property members are inherited, but only public property members can be overridden.
            // A property member in a derived class is said to override a property member in a base class
            // when the derived class property member has the same name and kind(instance or static) 
            // as the base class property member.
            // The type of an overriding property member must be assignable(section 3.8.4)
            // to the type of the overridden property member, or otherwise a compile - time error occurs.
            // Base class instance member functions can be overridden by derived class instance member functions,
            // but not by other kinds of members.
            // Base class instance member variables and accessors can be overridden by 
            // derived class instance member variables and accessors, but not by other kinds of members.
            // NOTE: assignability is checked in checkClassDeclaration
            var baseProperties = getPropertiesOfType(baseType);
            for (var i = 0, len = baseProperties.length; i < len; ++i) {
                var base = getTargetSymbol(baseProperties[i]);
                if (base.flags & 67108864 /* Prototype */) {
                    continue;
                }
                var derived = getTargetSymbol(getPropertyOfType(type, base.name));
                if (derived) {
                    var baseDeclarationFlags = getDeclarationFlagsFromSymbol(base);
                    var derivedDeclarationFlags = getDeclarationFlagsFromSymbol(derived);
                    if ((baseDeclarationFlags & 32 /* Private */) || (derivedDeclarationFlags & 32 /* Private */)) {
                        continue;
                    }
                    if ((baseDeclarationFlags & 128 /* Static */) !== (derivedDeclarationFlags & 128 /* Static */)) {
                        continue;
                    }
                    if ((base.flags & derived.flags & 2048 /* Method */) || ((base.flags & ts.SymbolFlags.PropertyOrAccessor) && (derived.flags & ts.SymbolFlags.PropertyOrAccessor))) {
                        continue;
                    }
                    var errorMessage;
                    if (base.flags & 2048 /* Method */) {
                        if (derived.flags & ts.SymbolFlags.Accessor) {
                            errorMessage = ts.Diagnostics.Class_0_defines_instance_member_function_1_but_extended_class_2_defines_it_as_instance_member_accessor;
                        }
                        else {
                            ts.Debug.assert(derived.flags & 2 /* Property */);
                            errorMessage = ts.Diagnostics.Class_0_defines_instance_member_function_1_but_extended_class_2_defines_it_as_instance_member_property;
                        }
                    }
                    else if (base.flags & 2 /* Property */) {
                        ts.Debug.assert(derived.flags & 2048 /* Method */);
                        errorMessage = ts.Diagnostics.Class_0_defines_instance_member_property_1_but_extended_class_2_defines_it_as_instance_member_function;
                    }
                    else {
                        ts.Debug.assert(base.flags & ts.SymbolFlags.Accessor);
                        ts.Debug.assert(derived.flags & 2048 /* Method */);
                        errorMessage = ts.Diagnostics.Class_0_defines_instance_member_accessor_1_but_extended_class_2_defines_it_as_instance_member_function;
                    }
                    error(derived.valueDeclaration.name, errorMessage, typeToString(baseType), symbolToString(base), typeToString(type));
                }
            }
        }
        function isAccessor(kind) {
            return kind === 122 /* GetAccessor */ || kind === 123 /* SetAccessor */;
        }
        function areTypeParametersIdentical(list1, list2) {
            if (!list1 && !list2) {
                return true;
            }
            if (!list1 || !list2 || list1.length !== list2.length) {
                return false;
            }
            for (var i = 0, len = list1.length; i < len; i++) {
                var tp1 = list1[i];
                var tp2 = list2[i];
                if (tp1.name.text !== tp2.name.text) {
                    return false;
                }
                if (!tp1.constraint && !tp2.constraint) {
                    continue;
                }
                if (!tp1.constraint || !tp2.constraint) {
                    return false;
                }
                if (!isTypeIdenticalTo(getTypeFromTypeNode(tp1.constraint), getTypeFromTypeNode(tp2.constraint))) {
                    return false;
                }
            }
            return true;
        }
        function checkInterfaceDeclaration(node) {
            checkTypeParameters(node.typeParameters);
            if (fullTypeCheck) {
                checkTypeNameIsReserved(node.name, ts.Diagnostics.Interface_name_cannot_be_0);
                checkExportsOnMergedDeclarations(node);
                var symbol = getSymbolOfNode(node);
                var firstInterfaceDecl = getDeclarationOfKind(symbol, 175 /* InterfaceDeclaration */);
                if (symbol.declarations.length > 1) {
                    if (node !== firstInterfaceDecl && !areTypeParametersIdentical(firstInterfaceDecl.typeParameters, node.typeParameters)) {
                        error(node.name, ts.Diagnostics.All_declarations_of_an_interface_must_have_identical_type_parameters);
                    }
                }
                // Only check this symbol once
                if (node === firstInterfaceDecl) {
                    var type = getDeclaredTypeOfSymbol(symbol);
                    // run subsequent checks only if first set succeeded
                    if (checkInheritedPropertiesAreIdentical(type, node.name)) {
                        ts.forEach(type.baseTypes, function (baseType) {
                            checkTypeAssignableTo(type, baseType, node.name, ts.Diagnostics.Interface_0_incorrectly_extends_interface_1_Colon, ts.Diagnostics.Interface_0_incorrectly_extends_interface_1);
                        });
                        checkIndexConstraints(type);
                    }
                }
            }
            ts.forEach(node.baseTypes, checkTypeReference);
            ts.forEach(node.members, checkSourceElement);
            if (fullTypeCheck) {
                checkTypeForDuplicateIndexSignatures(node);
            }
        }
        function getConstantValueForExpression(node) {
            var isNegative = false;
            if (node.kind === 143 /* PrefixOperator */) {
                var unaryExpression = node;
                if (unaryExpression.operator === 29 /* MinusToken */ || unaryExpression.operator === 28 /* PlusToken */) {
                    node = unaryExpression.operand;
                    isNegative = unaryExpression.operator === 29 /* MinusToken */;
                }
            }
            if (node.kind === 6 /* NumericLiteral */) {
                var literalText = node.text;
                return isNegative ? -literalText : +literalText;
            }
            return undefined;
        }
        function computeEnumMemberValues(node) {
            var nodeLinks = getNodeLinks(node);
            if (!(nodeLinks.flags & 128 /* EnumValuesComputed */)) {
                var enumSymbol = getSymbolOfNode(node);
                var enumType = getDeclaredTypeOfSymbol(enumSymbol);
                var autoValue = 0;
                var ambient = ts.isInAmbientContext(node);
                ts.forEach(node.members, function (member) {
                    var initializer = member.initializer;
                    if (initializer) {
                        autoValue = getConstantValueForExpression(initializer);
                        if (autoValue === undefined && !ambient) {
                            // Only here do we need to check that the initializer is assignable to the enum type.
                            // If it is a constant value (not undefined), it is syntactically constrained to be a number. 
                            // Also, we do not need to check this for ambients because there is already
                            // a syntax error if it is not a constant.
                            checkTypeAssignableTo(checkExpression(initializer), enumType, initializer, undefined, undefined);
                        }
                    }
                    else if (ambient) {
                        autoValue = undefined;
                    }
                    if (autoValue !== undefined) {
                        getNodeLinks(member).enumMemberValue = autoValue++;
                    }
                });
                nodeLinks.flags |= 128 /* EnumValuesComputed */;
            }
        }
        function checkEnumDeclaration(node) {
            if (!fullTypeCheck) {
                return;
            }
            checkTypeNameIsReserved(node.name, ts.Diagnostics.Enum_name_cannot_be_0);
            checkCollisionWithCapturedThisVariable(node, node.name);
            checkCollistionWithRequireExportsInGeneratedCode(node, node.name);
            checkExportsOnMergedDeclarations(node);
            computeEnumMemberValues(node);
            // Spec 2014 - Section 9.3:
            // It isn't possible for one enum declaration to continue the automatic numbering sequence of another,
            // and when an enum type has multiple declarations, only one declaration is permitted to omit a value
            // for the first member.
            //
            // Only perform this check once per symbol
            var enumSymbol = getSymbolOfNode(node);
            var firstDeclaration = getDeclarationOfKind(enumSymbol, node.kind);
            if (node === firstDeclaration) {
                var seenEnumMissingInitialInitializer = false;
                ts.forEach(enumSymbol.declarations, function (declaration) {
                    // return true if we hit a violation of the rule, false otherwise
                    if (declaration.kind !== 176 /* EnumDeclaration */) {
                        return false;
                    }
                    var enumDeclaration = declaration;
                    if (!enumDeclaration.members.length) {
                        return false;
                    }
                    var firstEnumMember = enumDeclaration.members[0];
                    if (!firstEnumMember.initializer) {
                        if (seenEnumMissingInitialInitializer) {
                            error(firstEnumMember.name, ts.Diagnostics.In_an_enum_with_multiple_declarations_only_one_declaration_can_omit_an_initializer_for_its_first_enum_element);
                        }
                        else {
                            seenEnumMissingInitialInitializer = true;
                        }
                    }
                });
            }
        }
        function getFirstNonAmbientClassOrFunctionDeclaration(symbol) {
            var declarations = symbol.declarations;
            for (var i = 0; i < declarations.length; i++) {
                var declaration = declarations[i];
                if ((declaration.kind === 174 /* ClassDeclaration */ || (declaration.kind === 172 /* FunctionDeclaration */ && declaration.body)) && !ts.isInAmbientContext(declaration)) {
                    return declaration;
                }
            }
            return undefined;
        }
        function checkModuleDeclaration(node) {
            if (fullTypeCheck) {
                checkCollisionWithCapturedThisVariable(node, node.name);
                checkCollistionWithRequireExportsInGeneratedCode(node, node.name);
                checkExportsOnMergedDeclarations(node);
                var symbol = getSymbolOfNode(node);
                if (symbol.flags & 128 /* ValueModule */ && symbol.declarations.length > 1 && !ts.isInAmbientContext(node)) {
                    var classOrFunc = getFirstNonAmbientClassOrFunctionDeclaration(symbol);
                    if (classOrFunc) {
                        if (ts.getSourceFileOfNode(node) !== ts.getSourceFileOfNode(classOrFunc)) {
                            error(node.name, ts.Diagnostics.A_module_declaration_cannot_be_in_a_different_file_from_a_class_or_function_with_which_it_is_merged);
                        }
                        else if (node.pos < classOrFunc.pos) {
                            error(node.name, ts.Diagnostics.A_module_declaration_cannot_be_located_prior_to_a_class_or_function_with_which_it_is_merged);
                        }
                    }
                }
                if (node.name.kind === 7 /* StringLiteral */) {
                    if (!isGlobalSourceFile(node.parent)) {
                        error(node.name, ts.Diagnostics.Ambient_external_modules_cannot_be_nested_in_other_modules);
                    }
                    if (isExternalModuleNameRelative(node.name.text)) {
                        error(node.name, ts.Diagnostics.Ambient_external_module_declaration_cannot_specify_relative_module_name);
                    }
                }
            }
            checkSourceElement(node.body);
        }
        function getFirstIdentifier(node) {
            while (node.kind === 116 /* QualifiedName */) {
                node = node.left;
            }
            return node;
        }
        function checkImportDeclaration(node) {
            checkCollisionWithCapturedThisVariable(node, node.name);
            checkCollistionWithRequireExportsInGeneratedCode(node, node.name);
            var symbol = getSymbolOfNode(node);
            var target;
            if (node.entityName) {
                target = resolveImport(symbol);
                // Import declaration for an internal module
                if (target !== unknownSymbol) {
                    if (target.flags & ts.SymbolFlags.Value) {
                        // Target is a value symbol, check that it is not hidden by a local declaration with the same name and
                        // ensure it can be evaluated as an expression
                        var moduleName = getFirstIdentifier(node.entityName);
                        if (resolveEntityName(node, moduleName, ts.SymbolFlags.Value | ts.SymbolFlags.Namespace).flags & ts.SymbolFlags.Namespace) {
                            checkExpression(node.entityName);
                        }
                        else {
                            error(moduleName, ts.Diagnostics.Module_0_is_hidden_by_a_local_declaration_with_the_same_name, ts.identifierToString(moduleName));
                        }
                    }
                    if (target.flags & ts.SymbolFlags.Type) {
                        checkTypeNameIsReserved(node.name, ts.Diagnostics.Import_name_cannot_be_0);
                    }
                }
            }
            else {
                // Import declaration for an external module
                if (node.parent.kind === 182 /* SourceFile */) {
                    target = resolveImport(symbol);
                }
                else if (node.parent.kind === 178 /* ModuleBlock */ && node.parent.parent.name.kind === 7 /* StringLiteral */) {
                    // TypeScript 1.0 spec (April 2013): 12.1.6
                    // An ExternalImportDeclaration in an AmbientExternalModuleDeclaration may reference 
                    // other external modules only through top - level external module names.
                    // Relative external module names are not permitted.
                    if (isExternalModuleNameRelative(node.externalModuleName.text)) {
                        error(node, ts.Diagnostics.Import_declaration_in_an_ambient_external_module_declaration_cannot_reference_external_module_through_relative_external_module_name);
                        target = unknownSymbol;
                    }
                    else {
                        target = resolveImport(symbol);
                    }
                }
                else {
                    // Parent is an internal module (syntax error is already reported)
                    target = unknownSymbol;
                }
            }
            if (target !== unknownSymbol) {
                var excludedMeanings = (symbol.flags & ts.SymbolFlags.Value ? ts.SymbolFlags.Value : 0) | (symbol.flags & ts.SymbolFlags.Type ? ts.SymbolFlags.Type : 0) | (symbol.flags & ts.SymbolFlags.Namespace ? ts.SymbolFlags.Namespace : 0);
                if (target.flags & excludedMeanings) {
                    error(node, ts.Diagnostics.Import_declaration_conflicts_with_local_declaration_of_0, symbolToString(symbol));
                }
            }
        }
        function checkExportAssignment(node) {
            var container = node.parent;
            if (container.kind !== 182 /* SourceFile */) {
                // In a module, the immediate parent will be a block, so climb up one more parent
                container = container.parent;
            }
            checkTypeOfExportAssignmentSymbol(getSymbolOfNode(container));
        }
        function checkSourceElement(node) {
            if (!node)
                return;
            switch (node.kind) {
                case 117 /* TypeParameter */:
                    return checkTypeParameter(node);
                case 118 /* Parameter */:
                    return checkParameter(node);
                case 119 /* Property */:
                    return checkPropertyDeclaration(node);
                case 124 /* CallSignature */:
                case 125 /* ConstructSignature */:
                case 126 /* IndexSignature */:
                    return checkSignatureDeclaration(node);
                case 120 /* Method */:
                    return checkMethodDeclaration(node);
                case 121 /* Constructor */:
                    return checkConstructorDeclaration(node);
                case 122 /* GetAccessor */:
                case 123 /* SetAccessor */:
                    return checkAccessorDeclaration(node);
                case 127 /* TypeReference */:
                    return checkTypeReference(node);
                case 128 /* TypeQuery */:
                    return checkTypeQuery(node);
                case 129 /* TypeLiteral */:
                    return checkTypeLiteral(node);
                case 130 /* ArrayType */:
                    return checkArrayType(node);
                case 131 /* TupleType */:
                    return checkTupleType(node);
                case 172 /* FunctionDeclaration */:
                    return checkFunctionDeclaration(node);
                case 148 /* Block */:
                    return checkBlock(node);
                case 173 /* FunctionBlock */:
                case 178 /* ModuleBlock */:
                    return checkBody(node);
                case 149 /* VariableStatement */:
                    return checkVariableStatement(node);
                case 151 /* ExpressionStatement */:
                    return checkExpressionStatement(node);
                case 152 /* IfStatement */:
                    return checkIfStatement(node);
                case 153 /* DoStatement */:
                    return checkDoStatement(node);
                case 154 /* WhileStatement */:
                    return checkWhileStatement(node);
                case 155 /* ForStatement */:
                    return checkForStatement(node);
                case 156 /* ForInStatement */:
                    return checkForInStatement(node);
                case 157 /* ContinueStatement */:
                case 158 /* BreakStatement */:
                    return checkBreakOrContinueStatement(node);
                case 159 /* ReturnStatement */:
                    return checkReturnStatement(node);
                case 160 /* WithStatement */:
                    return checkWithStatement(node);
                case 161 /* SwitchStatement */:
                    return checkSwitchStatement(node);
                case 164 /* LabeledStatement */:
                    return checkLabeledStatement(node);
                case 165 /* ThrowStatement */:
                    return checkThrowStatement(node);
                case 166 /* TryStatement */:
                    return checkTryStatement(node);
                case 171 /* VariableDeclaration */:
                    return ts.Debug.fail("Checker encountered variable declaration");
                case 174 /* ClassDeclaration */:
                    return checkClassDeclaration(node);
                case 175 /* InterfaceDeclaration */:
                    return checkInterfaceDeclaration(node);
                case 176 /* EnumDeclaration */:
                    return checkEnumDeclaration(node);
                case 177 /* ModuleDeclaration */:
                    return checkModuleDeclaration(node);
                case 179 /* ImportDeclaration */:
                    return checkImportDeclaration(node);
                case 180 /* ExportAssignment */:
                    return checkExportAssignment(node);
            }
        }
        // Function expression bodies are checked after all statements in the enclosing body. This is to ensure
        // constructs like the following are permitted:
        //     var foo = function () {
        //        var s = foo();
        //        return "hello";
        //     }
        // Here, performing a full type check of the body of the function expression whilst in the process of
        // determining the type of foo would cause foo to be given type any because of the recursive reference.
        // Delaying the type check of the body ensures foo has been assigned a type.
        function checkFunctionExpressionBodies(node) {
            switch (node.kind) {
                case 141 /* FunctionExpression */:
                case 142 /* ArrowFunction */:
                    ts.forEach(node.parameters, checkFunctionExpressionBodies);
                    checkFunctionExpressionBody(node);
                    break;
                case 120 /* Method */:
                case 121 /* Constructor */:
                case 122 /* GetAccessor */:
                case 123 /* SetAccessor */:
                case 172 /* FunctionDeclaration */:
                    ts.forEach(node.parameters, checkFunctionExpressionBodies);
                    break;
                case 160 /* WithStatement */:
                    checkFunctionExpressionBodies(node.expression);
                    break;
                case 118 /* Parameter */:
                case 119 /* Property */:
                case 132 /* ArrayLiteral */:
                case 133 /* ObjectLiteral */:
                case 134 /* PropertyAssignment */:
                case 135 /* PropertyAccess */:
                case 136 /* IndexedAccess */:
                case 137 /* CallExpression */:
                case 138 /* NewExpression */:
                case 139 /* TypeAssertion */:
                case 140 /* ParenExpression */:
                case 143 /* PrefixOperator */:
                case 144 /* PostfixOperator */:
                case 145 /* BinaryExpression */:
                case 146 /* ConditionalExpression */:
                case 148 /* Block */:
                case 173 /* FunctionBlock */:
                case 178 /* ModuleBlock */:
                case 149 /* VariableStatement */:
                case 151 /* ExpressionStatement */:
                case 152 /* IfStatement */:
                case 153 /* DoStatement */:
                case 154 /* WhileStatement */:
                case 155 /* ForStatement */:
                case 156 /* ForInStatement */:
                case 157 /* ContinueStatement */:
                case 158 /* BreakStatement */:
                case 159 /* ReturnStatement */:
                case 161 /* SwitchStatement */:
                case 162 /* CaseClause */:
                case 163 /* DefaultClause */:
                case 164 /* LabeledStatement */:
                case 165 /* ThrowStatement */:
                case 166 /* TryStatement */:
                case 167 /* TryBlock */:
                case 168 /* CatchBlock */:
                case 169 /* FinallyBlock */:
                case 171 /* VariableDeclaration */:
                case 174 /* ClassDeclaration */:
                case 176 /* EnumDeclaration */:
                case 181 /* EnumMember */:
                case 182 /* SourceFile */:
                    ts.forEachChild(node, checkFunctionExpressionBodies);
                    break;
            }
        }
        function checkBody(node) {
            checkBlock(node);
            checkFunctionExpressionBodies(node);
        }
        // Fully type check a source file and collect the relevant diagnostics.
        function checkSourceFile(node) {
            var links = getNodeLinks(node);
            if (!(links.flags & 1 /* TypeChecked */)) {
                emitExtends = false;
                potentialThisCollisions.length = 0;
                checkBody(node);
                if (ts.isExternalModule(node)) {
                    var symbol = getExportAssignmentSymbol(node.symbol);
                    if (symbol && symbol.flags & 4194304 /* Import */) {
                        // Mark the import as referenced so that we emit it in the final .js file.
                        getSymbolLinks(symbol).referenced = true;
                    }
                }
                if (potentialThisCollisions.length) {
                    ts.forEach(potentialThisCollisions, checkIfThisIsCapturedInEnclosingScope);
                    potentialThisCollisions.length = 0;
                }
                if (emitExtends)
                    links.flags |= 8 /* EmitExtends */;
                links.flags |= 1 /* TypeChecked */;
            }
        }
        function checkProgram() {
            ts.forEach(program.getSourceFiles(), checkSourceFile);
        }
        function getSortedDiagnostics() {
            ts.Debug.assert(fullTypeCheck, "diagnostics are available only in the full typecheck mode");
            if (diagnosticsModified) {
                diagnostics.sort(ts.compareDiagnostics);
                diagnostics = ts.deduplicateSortedDiagnostics(diagnostics);
                diagnosticsModified = false;
            }
            return diagnostics;
        }
        function getDiagnostics(sourceFile) {
            if (sourceFile) {
                checkSourceFile(sourceFile);
                return ts.filter(getSortedDiagnostics(), function (d) { return d.file === sourceFile; });
            }
            checkProgram();
            return getSortedDiagnostics();
        }
        function getGlobalDiagnostics() {
            return ts.filter(getSortedDiagnostics(), function (d) { return !d.file; });
        }
        // Language service support
        function getNodeAtPosition(sourceFile, position) {
            function findChildAtPosition(parent) {
                var child = ts.forEachChild(parent, function (node) {
                    if (position >= node.pos && position <= node.end && position >= ts.getTokenPosOfNode(node)) {
                        return findChildAtPosition(node);
                    }
                });
                return child || parent;
            }
            if (position < sourceFile.pos)
                position = sourceFile.pos;
            if (position > sourceFile.end)
                position = sourceFile.end;
            return findChildAtPosition(sourceFile);
        }
        function isInsideWithStatementBody(node) {
            if (node) {
                while (node.parent) {
                    if (node.parent.kind === 160 /* WithStatement */ && node.parent.statement === node) {
                        return true;
                    }
                    node = node.parent;
                }
            }
            return false;
        }
        function getSymbolsInScope(location, meaning) {
            var symbols = {};
            var memberFlags = 0;
            function copySymbol(symbol, meaning) {
                if (symbol.flags & meaning) {
                    var id = symbol.name;
                    if (!isReservedMemberName(id) && !ts.hasProperty(symbols, id)) {
                        symbols[id] = symbol;
                    }
                }
            }
            function copySymbols(source, meaning) {
                if (meaning) {
                    for (var id in source) {
                        if (ts.hasProperty(source, id)) {
                            copySymbol(source[id], meaning);
                        }
                    }
                }
            }
            if (isInsideWithStatementBody(location)) {
                // We cannot answer semantic questions within a with block, do not proceed any further
                return [];
            }
            while (location) {
                if (location.locals && !isGlobalSourceFile(location)) {
                    copySymbols(location.locals, meaning);
                }
                switch (location.kind) {
                    case 182 /* SourceFile */:
                        if (!ts.isExternalModule(location))
                            break;
                    case 177 /* ModuleDeclaration */:
                        copySymbols(getSymbolOfNode(location).exports, meaning & ts.SymbolFlags.ModuleMember);
                        break;
                    case 176 /* EnumDeclaration */:
                        copySymbols(getSymbolOfNode(location).exports, meaning & 4 /* EnumMember */);
                        break;
                    case 174 /* ClassDeclaration */:
                    case 175 /* InterfaceDeclaration */:
                        if (!(memberFlags & 128 /* Static */)) {
                            copySymbols(getSymbolOfNode(location).members, meaning & ts.SymbolFlags.Type);
                        }
                        break;
                    case 141 /* FunctionExpression */:
                        if (location.name) {
                            copySymbol(location.symbol, meaning);
                        }
                        break;
                    case 168 /* CatchBlock */:
                        if (location.variable.text) {
                            copySymbol(location.symbol, meaning);
                        }
                        break;
                }
                memberFlags = location.flags;
                location = location.parent;
            }
            copySymbols(globals, meaning);
            return ts.mapToArray(symbols);
        }
        // True if the given identifier is the name of a type declaration node (class, interface, enum, type parameter, etc)
        function isTypeDeclarationName(name) {
            return name.kind == 59 /* Identifier */ && isTypeDeclaration(name.parent) && name.parent.name === name;
        }
        function isTypeDeclaration(node) {
            switch (node.kind) {
                case 117 /* TypeParameter */:
                case 174 /* ClassDeclaration */:
                case 175 /* InterfaceDeclaration */:
                case 176 /* EnumDeclaration */:
                    return true;
            }
        }
        // True if the given identifier is part of a type reference
        function isTypeReferenceIdentifier(entityName) {
            var node = entityName;
            while (node.parent && node.parent.kind === 116 /* QualifiedName */)
                node = node.parent;
            return node.parent && node.parent.kind === 127 /* TypeReference */;
        }
        function isExpression(node) {
            switch (node.kind) {
                case 87 /* ThisKeyword */:
                case 85 /* SuperKeyword */:
                case 83 /* NullKeyword */:
                case 89 /* TrueKeyword */:
                case 74 /* FalseKeyword */:
                case 8 /* RegularExpressionLiteral */:
                case 132 /* ArrayLiteral */:
                case 133 /* ObjectLiteral */:
                case 135 /* PropertyAccess */:
                case 136 /* IndexedAccess */:
                case 137 /* CallExpression */:
                case 138 /* NewExpression */:
                case 139 /* TypeAssertion */:
                case 140 /* ParenExpression */:
                case 141 /* FunctionExpression */:
                case 142 /* ArrowFunction */:
                case 143 /* PrefixOperator */:
                case 144 /* PostfixOperator */:
                case 145 /* BinaryExpression */:
                case 146 /* ConditionalExpression */:
                case 147 /* OmittedExpression */:
                    return true;
                case 116 /* QualifiedName */:
                    while (node.parent.kind === 116 /* QualifiedName */)
                        node = node.parent;
                    return node.parent.kind === 128 /* TypeQuery */;
                case 59 /* Identifier */:
                    if (node.parent.kind === 128 /* TypeQuery */) {
                        return true;
                    }
                case 6 /* NumericLiteral */:
                case 7 /* StringLiteral */:
                    var parent = node.parent;
                    switch (parent.kind) {
                        case 171 /* VariableDeclaration */:
                        case 118 /* Parameter */:
                        case 119 /* Property */:
                        case 181 /* EnumMember */:
                        case 134 /* PropertyAssignment */:
                            return parent.initializer === node;
                        case 151 /* ExpressionStatement */:
                        case 152 /* IfStatement */:
                        case 153 /* DoStatement */:
                        case 154 /* WhileStatement */:
                        case 159 /* ReturnStatement */:
                        case 160 /* WithStatement */:
                        case 161 /* SwitchStatement */:
                        case 162 /* CaseClause */:
                        case 165 /* ThrowStatement */:
                        case 161 /* SwitchStatement */:
                            return parent.expression === node;
                        case 155 /* ForStatement */:
                            return parent.initializer === node || parent.condition === node || parent.iterator === node;
                        case 156 /* ForInStatement */:
                            return parent.variable === node || parent.expression === node;
                        case 139 /* TypeAssertion */:
                            return node === parent.operand;
                        default:
                            if (isExpression(parent)) {
                                return true;
                            }
                    }
            }
            return false;
        }
        function isTypeNode(node) {
            if (node.kind >= ts.SyntaxKind.FirstTypeNode && node.kind <= ts.SyntaxKind.LastTypeNode) {
                return true;
            }
            switch (node.kind) {
                case 105 /* AnyKeyword */:
                case 112 /* NumberKeyword */:
                case 114 /* StringKeyword */:
                case 106 /* BooleanKeyword */:
                    return true;
                case 93 /* VoidKeyword */:
                    return node.parent.kind !== 143 /* PrefixOperator */;
                case 7 /* StringLiteral */:
                    // Specialized signatures can have string literals as their parameters' type names
                    return node.parent.kind === 118 /* Parameter */;
                case 59 /* Identifier */:
                    // If the identifier is the RHS of a qualified name, then it's a type iff its parent is.
                    if (node.parent.kind === 116 /* QualifiedName */) {
                        node = node.parent;
                    }
                case 116 /* QualifiedName */:
                    // At this point, node is either a qualified name or an identifier
                    var parent = node.parent;
                    if (parent.kind === 128 /* TypeQuery */) {
                        return false;
                    }
                    // Do not recursively call isTypeNode on the parent. In the example:
                    //
                    //     var a: A.B.C;
                    //
                    // Calling isTypeNode would consider the qualified name A.B a type node. Only C or
                    // A.B.C is a type node.
                    if (parent.kind >= ts.SyntaxKind.FirstTypeNode && parent.kind <= ts.SyntaxKind.LastTypeNode) {
                        return true;
                    }
                    switch (parent.kind) {
                        case 117 /* TypeParameter */:
                            return node === parent.constraint;
                        case 119 /* Property */:
                        case 118 /* Parameter */:
                        case 171 /* VariableDeclaration */:
                            return node === parent.type;
                        case 172 /* FunctionDeclaration */:
                        case 141 /* FunctionExpression */:
                        case 142 /* ArrowFunction */:
                        case 121 /* Constructor */:
                        case 120 /* Method */:
                        case 122 /* GetAccessor */:
                        case 123 /* SetAccessor */:
                            return node === parent.type;
                        case 124 /* CallSignature */:
                        case 125 /* ConstructSignature */:
                        case 126 /* IndexSignature */:
                            return node === parent.type;
                        case 139 /* TypeAssertion */:
                            return node === parent.type;
                        case 137 /* CallExpression */:
                        case 138 /* NewExpression */:
                            return parent.typeArguments.indexOf(node) >= 0;
                    }
            }
            return false;
        }
        function isInRightSideOfImportOrExportAssignment(node) {
            while (node.parent.kind === 116 /* QualifiedName */) {
                node = node.parent;
            }
            if (node.parent.kind === 179 /* ImportDeclaration */) {
                return node.parent.entityName === node;
            }
            if (node.parent.kind === 180 /* ExportAssignment */) {
                return node.parent.exportName === node;
            }
            return false;
        }
        function isRightSideOfQualifiedNameOrPropertyAccess(node) {
            return (node.parent.kind === 116 /* QualifiedName */ || node.parent.kind === 135 /* PropertyAccess */) && node.parent.right === node;
        }
        function getSymbolOfEntityName(entityName) {
            if (ts.isDeclarationOrFunctionExpressionOrCatchVariableName(entityName)) {
                return getSymbolOfNode(entityName.parent);
            }
            if (entityName.parent.kind === 180 /* ExportAssignment */) {
                return resolveEntityName(entityName.parent.parent, entityName, ts.SymbolFlags.Value | ts.SymbolFlags.Type | ts.SymbolFlags.Namespace | 4194304 /* Import */);
            }
            if (isInRightSideOfImportOrExportAssignment(entityName)) {
                // Since we already checked for ExportAssignment, this really could only be an Import
                return getSymbolOfPartOfRightHandSideOfImport(entityName);
            }
            if (isRightSideOfQualifiedNameOrPropertyAccess(entityName)) {
                entityName = entityName.parent;
            }
            if (isExpression(entityName)) {
                if (entityName.kind === 59 /* Identifier */) {
                    // Include Import in the meaning, this ensures that we do not follow aliases to where they point and instead
                    // return the alias symbol.
                    var meaning = ts.SymbolFlags.Value | 4194304 /* Import */;
                    return resolveEntityName(entityName, entityName, meaning);
                }
                else if (entityName.kind === 116 /* QualifiedName */ || entityName.kind === 135 /* PropertyAccess */) {
                    var symbol = getNodeLinks(entityName).resolvedSymbol;
                    if (!symbol) {
                        checkPropertyAccess(entityName);
                    }
                    return getNodeLinks(entityName).resolvedSymbol;
                }
                else {
                    // Missing identifier
                    return;
                }
            }
            else if (isTypeReferenceIdentifier(entityName)) {
                var meaning = entityName.parent.kind === 127 /* TypeReference */ ? ts.SymbolFlags.Type : ts.SymbolFlags.Namespace;
                // Include Import in the meaning, this ensures that we do not follow aliases to where they point and instead
                // return the alias symbol.
                meaning |= 4194304 /* Import */;
                return resolveEntityName(entityName, entityName, meaning);
            }
            // Do we want to return undefined here?
            return undefined;
        }
        function getSymbolInfo(node) {
            if (isInsideWithStatementBody(node)) {
                // We cannot answer semantic questions within a with block, do not proceed any further
                return undefined;
            }
            if (ts.isDeclarationOrFunctionExpressionOrCatchVariableName(node)) {
                // This is a declaration, call getSymbolOfNode
                return getSymbolOfNode(node.parent);
            }
            if (node.kind === 59 /* Identifier */ && isInRightSideOfImportOrExportAssignment(node)) {
                return node.parent.kind === 180 /* ExportAssignment */ ? getSymbolOfEntityName(node) : getSymbolOfPartOfRightHandSideOfImport(node);
            }
            switch (node.kind) {
                case 59 /* Identifier */:
                case 135 /* PropertyAccess */:
                case 116 /* QualifiedName */:
                    return getSymbolOfEntityName(node);
                case 87 /* ThisKeyword */:
                case 85 /* SuperKeyword */:
                    var type = checkExpression(node);
                    return type.symbol;
                case 107 /* ConstructorKeyword */:
                    // constructor keyword for an overload, should take us to the definition if it exist
                    var constructorDeclaration = node.parent;
                    if (constructorDeclaration && constructorDeclaration.kind === 121 /* Constructor */) {
                        return constructorDeclaration.parent.symbol;
                    }
                    return undefined;
                case 7 /* StringLiteral */:
                    // External module name in an import declaration
                    if (node.parent.kind === 179 /* ImportDeclaration */ && node.parent.externalModuleName === node) {
                        var importSymbol = getSymbolOfNode(node.parent);
                        var moduleType = getTypeOfSymbol(importSymbol);
                        return moduleType ? moduleType.symbol : undefined;
                    }
                case 6 /* NumericLiteral */:
                    // index access
                    if (node.parent.kind == 136 /* IndexedAccess */ && node.parent.index === node) {
                        var objectType = checkExpression(node.parent.object);
                        if (objectType === unknownType)
                            return undefined;
                        var apparentType = getApparentType(objectType);
                        if (apparentType === unknownType)
                            return undefined;
                        return getPropertyOfApparentType(apparentType, node.text);
                    }
                    break;
            }
            return undefined;
        }
        function getTypeOfNode(node) {
            if (isInsideWithStatementBody(node)) {
                // We cannot answer semantic questions within a with block, do not proceed any further
                return unknownType;
            }
            if (isExpression(node)) {
                return getTypeOfExpression(node);
            }
            if (isTypeNode(node)) {
                return getTypeFromTypeNode(node);
            }
            if (isTypeDeclaration(node)) {
                // In this case, we call getSymbolOfNode instead of getSymbolInfo because it is a declaration
                var symbol = getSymbolOfNode(node);
                return getDeclaredTypeOfSymbol(symbol);
            }
            if (isTypeDeclarationName(node)) {
                var symbol = getSymbolInfo(node);
                return symbol && getDeclaredTypeOfSymbol(symbol);
            }
            if (ts.isDeclaration(node)) {
                // In this case, we call getSymbolOfNode instead of getSymbolInfo because it is a declaration
                var symbol = getSymbolOfNode(node);
                return getTypeOfSymbol(symbol);
            }
            if (ts.isDeclarationOrFunctionExpressionOrCatchVariableName(node)) {
                var symbol = getSymbolInfo(node);
                return symbol && getTypeOfSymbol(symbol);
            }
            if (isInRightSideOfImportOrExportAssignment(node)) {
                var symbol = getSymbolInfo(node);
                var declaredType = symbol && getDeclaredTypeOfSymbol(symbol);
                return declaredType !== unknownType ? declaredType : getTypeOfSymbol(symbol);
            }
            return unknownType;
        }
        function getTypeOfExpression(expr) {
            if (isRightSideOfQualifiedNameOrPropertyAccess(expr)) {
                expr = expr.parent;
            }
            return checkExpression(expr);
        }
        function getAugmentedPropertiesOfApparentType(type) {
            var apparentType = getApparentType(type);
            if (apparentType.flags & ts.TypeFlags.ObjectType) {
                // Augment the apparent type with Function and Object members as applicable
                var propertiesByName = {};
                var results = [];
                ts.forEach(getPropertiesOfType(apparentType), function (s) {
                    propertiesByName[s.name] = s;
                    results.push(s);
                });
                var resolved = resolveObjectTypeMembers(type);
                ts.forEachValue(resolved.members, function (s) {
                    if (symbolIsValue(s) && !propertiesByName[s.name]) {
                        propertiesByName[s.name] = s;
                        results.push(s);
                    }
                });
                if (resolved === anyFunctionType || resolved.callSignatures.length || resolved.constructSignatures.length) {
                    ts.forEach(getPropertiesOfType(globalFunctionType), function (s) {
                        if (!propertiesByName[s.name]) {
                            propertiesByName[s.name] = s;
                            results.push(s);
                        }
                    });
                }
                return results;
            }
            else {
                return getPropertiesOfType(apparentType);
            }
        }
        function getRootSymbol(symbol) {
            return ((symbol.flags & 33554432 /* Transient */) && getSymbolLinks(symbol).target) || symbol;
        }
        // Emitter support
        function isExternalModuleSymbol(symbol) {
            return symbol.flags & 128 /* ValueModule */ && symbol.declarations.length === 1 && symbol.declarations[0].kind === 182 /* SourceFile */;
        }
        function isNodeDescendentOf(node, ancestor) {
            while (node) {
                if (node === ancestor)
                    return true;
                node = node.parent;
            }
            return false;
        }
        function isUniqueLocalName(name, container) {
            for (var node = container; isNodeDescendentOf(node, container); node = node.nextContainer) {
                if (node.locals && ts.hasProperty(node.locals, name) && node.locals[name].flags & (ts.SymbolFlags.Value | 524288 /* ExportValue */)) {
                    return false;
                }
            }
            return true;
        }
        function getLocalNameOfContainer(container) {
            var links = getNodeLinks(container);
            if (!links.localModuleName) {
                var prefix = "";
                var name = ts.unescapeIdentifier(container.name.text);
                while (!isUniqueLocalName(ts.escapeIdentifier(prefix + name), container)) {
                    prefix += "_";
                }
                links.localModuleName = prefix + ts.getSourceTextOfNode(container.name);
            }
            return links.localModuleName;
        }
        function getLocalNameForSymbol(symbol, location) {
            var node = location;
            while (node) {
                if ((node.kind === 177 /* ModuleDeclaration */ || node.kind === 176 /* EnumDeclaration */) && getSymbolOfNode(node) === symbol) {
                    return getLocalNameOfContainer(node);
                }
                node = node.parent;
            }
            ts.Debug.fail("getLocalNameForSymbol failed");
        }
        function getExpressionNamePrefix(node) {
            var symbol = getNodeLinks(node).resolvedSymbol;
            if (symbol) {
                // In general, we need to prefix an identifier with its parent name if it references
                // an exported entity from another module declaration. If we reference an exported
                // entity within the same module declaration, then whether we prefix depends on the
                // kind of entity. SymbolFlags.ExportHasLocal encompasses all the kinds that we
                // do NOT prefix.
                var exportSymbol = getExportSymbolOfValueSymbolIfExported(symbol);
                if (symbol !== exportSymbol && !(exportSymbol.flags & ts.SymbolFlags.ExportHasLocal)) {
                    symbol = exportSymbol;
                }
                if (symbol.parent) {
                    return isExternalModuleSymbol(symbol.parent) ? "exports" : getLocalNameForSymbol(getParentOfSymbol(symbol), node.parent);
                }
            }
        }
        function getExportAssignmentName(node) {
            var symbol = getExportAssignmentSymbol(getSymbolOfNode(node));
            return symbol && symbolIsValue(symbol) ? symbolToString(symbol) : undefined;
        }
        function isTopLevelValueImportedViaEntityName(node) {
            if (node.parent.kind !== 182 /* SourceFile */ || !node.entityName) {
                // parent is not source file or it is not reference to internal module
                return false;
            }
            var symbol = getSymbolOfNode(node);
            var target = resolveImport(symbol);
            return target !== unknownSymbol && ((target.flags & ts.SymbolFlags.Value) !== 0);
        }
        function hasSemanticErrors() {
            // Return true if there is any semantic error in a file or globally
            return getDiagnostics().length > 0 || getGlobalDiagnostics().length > 0;
        }
        function isReferencedImportDeclaration(node) {
            var symbol = getSymbolOfNode(node);
            if (getSymbolLinks(symbol).referenced) {
                return true;
            }
            // logic below will answer 'true' for exported import declaration in a nested module that itself is not exported.
            // As a consequence this might cause emitting extra.
            if (node.flags & 1 /* Export */) {
                var target = resolveImport(symbol);
                if (target !== unknownSymbol && target.flags & ts.SymbolFlags.Value) {
                    return true;
                }
            }
            return false;
        }
        function isImplementationOfOverload(node) {
            if (node.body) {
                var symbol = getSymbolOfNode(node);
                var signaturesOfSymbol = getSignaturesOfSymbol(symbol);
                // If this function body corresponds to function with multiple signature, it is implementation of overload
                // e.g.: function foo(a: string): string;
                //       function foo(a: number): number;
                //       function foo(a: any) { // This is implementation of the overloads
                //           return a;
                //       }
                return signaturesOfSymbol.length > 1 || (signaturesOfSymbol.length === 1 && signaturesOfSymbol[0].declaration !== node);
            }
            return false;
        }
        function getNodeCheckFlags(node) {
            return getNodeLinks(node).flags;
        }
        function getEnumMemberValue(node) {
            computeEnumMemberValues(node.parent);
            return getNodeLinks(node).enumMemberValue;
        }
        function getConstantValue(node) {
            var symbol = getNodeLinks(node).resolvedSymbol;
            if (symbol && (symbol.flags & 4 /* EnumMember */)) {
                var declaration = symbol.valueDeclaration;
                var constantValue;
                if (declaration.kind === 181 /* EnumMember */ && (constantValue = getNodeLinks(declaration).enumMemberValue) !== undefined) {
                    return constantValue;
                }
            }
            return undefined;
        }
        // Create a single instance that we can wrap the underlying emitter TextWriter with.  That
        // way we don't have to allocate a new wrapper every time writeTypeAtLocation and 
        // writeReturnTypeOfSignatureDeclaration are called.
        var emitSymbolWriter = {
            writer: undefined,
            writeKind: function (text) {
                this.writer.write(text);
            },
            writeSymbol: function (text) {
                this.writer.write(text);
            },
            writeLine: function () {
                this.writer.writeLine();
            },
            increaseIndent: function () {
                this.writer.increaseIndent();
            },
            decreaseIndent: function () {
                this.writer.decreaseIndent();
            },
            clear: function () {
            },
            trackSymbol: function (symbol, declaration, meaning) {
                this.writer.trackSymbol(symbol, declaration, meaning);
            }
        };
        function writeTypeAtLocation(location, enclosingDeclaration, flags, writer) {
            // Get type of the symbol if this is the valid symbol otherwise get type at location
            var symbol = getSymbolOfNode(location);
            var type = symbol && !(symbol.flags & 512 /* TypeLiteral */) ? getTypeOfSymbol(symbol) : getTypeFromTypeNode(location);
            emitSymbolWriter.writer = writer;
            writeType(type, emitSymbolWriter, enclosingDeclaration, flags);
        }
        function writeReturnTypeOfSignatureDeclaration(signatureDeclaration, enclosingDeclaration, flags, writer) {
            var signature = getSignatureFromDeclaration(signatureDeclaration);
            emitSymbolWriter.writer = writer;
            writeType(getReturnTypeOfSignature(signature), emitSymbolWriter, enclosingDeclaration, flags);
        }
        function invokeEmitter(targetSourceFile) {
            var resolver = {
                getProgram: function () { return program; },
                getLocalNameOfContainer: getLocalNameOfContainer,
                getExpressionNamePrefix: getExpressionNamePrefix,
                getExportAssignmentName: getExportAssignmentName,
                isReferencedImportDeclaration: isReferencedImportDeclaration,
                getNodeCheckFlags: getNodeCheckFlags,
                getEnumMemberValue: getEnumMemberValue,
                isTopLevelValueImportedViaEntityName: isTopLevelValueImportedViaEntityName,
                hasSemanticErrors: hasSemanticErrors,
                isDeclarationVisible: isDeclarationVisible,
                isImplementationOfOverload: isImplementationOfOverload,
                writeTypeAtLocation: writeTypeAtLocation,
                writeReturnTypeOfSignatureDeclaration: writeReturnTypeOfSignatureDeclaration,
                isSymbolAccessible: isSymbolAccessible,
                isImportDeclarationEntityNameReferenceDeclarationVisibile: isImportDeclarationEntityNameReferenceDeclarationVisibile,
                getConstantValue: getConstantValue
            };
            checkProgram();
            return ts.emitFiles(resolver, targetSourceFile);
        }
        function initializeTypeChecker() {
            // Bind all source files and propagate errors
            ts.forEach(program.getSourceFiles(), function (file) {
                ts.bindSourceFile(file);
                ts.forEach(file.semanticErrors, addDiagnostic);
            });
            // Initialize global symbol table
            ts.forEach(program.getSourceFiles(), function (file) {
                if (!ts.isExternalModule(file)) {
                    extendSymbolTable(globals, file.locals);
                }
            });
            // Initialize special symbols
            getSymbolLinks(undefinedSymbol).type = undefinedType;
            getSymbolLinks(argumentsSymbol).type = getGlobalType("IArguments");
            getSymbolLinks(unknownSymbol).type = unknownType;
            globals[undefinedSymbol.name] = undefinedSymbol;
            // Initialize special types
            globalArraySymbol = getGlobalSymbol("Array");
            globalArrayType = getTypeOfGlobalSymbol(globalArraySymbol, 1);
            globalObjectType = getGlobalType("Object");
            globalFunctionType = getGlobalType("Function");
            globalStringType = getGlobalType("String");
            globalNumberType = getGlobalType("Number");
            globalBooleanType = getGlobalType("Boolean");
            globalRegExpType = getGlobalType("RegExp");
        }
        initializeTypeChecker();
        return checker;
    }
    ts.createTypeChecker = createTypeChecker;
})(ts || (ts = {}));
// <auto-generated />
var TypeScript;
(function (TypeScript) {
    TypeScript.DiagnosticCode = {
        error_TS_0_1: "error TS{0}: {1}",
        warning_TS_0_1: "warning TS{0}: {1}",
        Unrecognized_escape_sequence: "Unrecognized escape sequence.",
        Unexpected_character_0: "Unexpected character {0}.",
        Missing_close_quote_character: "Missing close quote character.",
        Identifier_expected: "Identifier expected.",
        _0_keyword_expected: "'{0}' keyword expected.",
        _0_expected: "'{0}' expected.",
        Identifier_expected_0_is_a_keyword: "Identifier expected; '{0}' is a keyword.",
        Automatic_semicolon_insertion_not_allowed: "Automatic semicolon insertion not allowed.",
        Unexpected_token_0_expected: "Unexpected token; '{0}' expected.",
        Trailing_comma_not_allowed: "Trailing comma not allowed.",
        AsteriskSlash_expected: "'*/' expected.",
        public_or_private_modifier_must_precede_static: "'public' or 'private' modifier must precede 'static'.",
        Unexpected_token: "Unexpected token.",
        Catch_clause_parameter_cannot_have_a_type_annotation: "Catch clause parameter cannot have a type annotation.",
        A_rest_parameter_must_be_last_in_a_parameter_list: "A rest parameter must be last in a parameter list.",
        Parameter_cannot_have_question_mark_and_initializer: "Parameter cannot have question mark and initializer.",
        A_required_parameter_cannot_follow_an_optional_parameter: "A required parameter cannot follow an optional parameter.",
        Index_signatures_cannot_have_rest_parameters: "Index signatures cannot have rest parameters.",
        Index_signature_parameter_cannot_have_accessibility_modifiers: "Index signature parameter cannot have accessibility modifiers.",
        Index_signature_parameter_cannot_have_a_question_mark: "Index signature parameter cannot have a question mark.",
        Index_signature_parameter_cannot_have_an_initializer: "Index signature parameter cannot have an initializer.",
        Index_signature_must_have_a_type_annotation: "Index signature must have a type annotation.",
        Index_signature_parameter_must_have_a_type_annotation: "Index signature parameter must have a type annotation.",
        Index_signature_parameter_type_must_be_string_or_number: "Index signature parameter type must be 'string' or 'number'.",
        extends_clause_already_seen: "'extends' clause already seen.",
        extends_clause_must_precede_implements_clause: "'extends' clause must precede 'implements' clause.",
        Classes_can_only_extend_a_single_class: "Classes can only extend a single class.",
        implements_clause_already_seen: "'implements' clause already seen.",
        Accessibility_modifier_already_seen: "Accessibility modifier already seen.",
        _0_modifier_must_precede_1_modifier: "'{0}' modifier must precede '{1}' modifier.",
        _0_modifier_already_seen: "'{0}' modifier already seen.",
        _0_modifier_cannot_appear_on_a_class_element: "'{0}' modifier cannot appear on a class element.",
        Interface_declaration_cannot_have_implements_clause: "Interface declaration cannot have 'implements' clause.",
        super_invocation_cannot_have_type_arguments: "'super' invocation cannot have type arguments.",
        Only_ambient_modules_can_use_quoted_names: "Only ambient modules can use quoted names.",
        Statements_are_not_allowed_in_ambient_contexts: "Statements are not allowed in ambient contexts.",
        A_function_implementation_cannot_be_declared_in_an_ambient_context: "A function implementation cannot be declared in an ambient context.",
        A_declare_modifier_cannot_be_used_in_an_already_ambient_context: "A 'declare' modifier cannot be used in an already ambient context.",
        Initializers_are_not_allowed_in_ambient_contexts: "Initializers are not allowed in ambient contexts.",
        _0_modifier_cannot_appear_on_a_module_element: "'{0}' modifier cannot appear on a module element.",
        A_declare_modifier_cannot_be_used_with_an_interface_declaration: "A 'declare' modifier cannot be used with an interface declaration.",
        A_declare_modifier_is_required_for_a_top_level_declaration_in_a_d_ts_file: "A 'declare' modifier is required for a top level declaration in a .d.ts file.",
        A_rest_parameter_cannot_be_optional: "A rest parameter cannot be optional.",
        A_rest_parameter_cannot_have_an_initializer: "A rest parameter cannot have an initializer.",
        set_accessor_must_have_exactly_one_parameter: "'set' accessor must have exactly one parameter.",
        set_accessor_parameter_cannot_be_optional: "'set' accessor parameter cannot be optional.",
        set_accessor_parameter_cannot_have_an_initializer: "'set' accessor parameter cannot have an initializer.",
        set_accessor_cannot_have_rest_parameter: "'set' accessor cannot have rest parameter.",
        get_accessor_cannot_have_parameters: "'get' accessor cannot have parameters.",
        Modifiers_cannot_appear_here: "Modifiers cannot appear here.",
        Accessors_are_only_available_when_targeting_ECMAScript_5_and_higher: "Accessors are only available when targeting ECMAScript 5 and higher.",
        Enum_member_must_have_initializer: "Enum member must have initializer.",
        Export_assignment_cannot_be_used_in_internal_modules: "Export assignment cannot be used in internal modules.",
        Ambient_enum_elements_can_only_have_integer_literal_initializers: "Ambient enum elements can only have integer literal initializers.",
        module_class_interface_enum_import_or_statement: "module, class, interface, enum, import or statement",
        constructor_function_accessor_or_variable: "constructor, function, accessor or variable",
        statement: "statement",
        case_or_default_clause: "case or default clause",
        identifier: "identifier",
        call_construct_index_property_or_function_signature: "call, construct, index, property or function signature",
        expression: "expression",
        type_name: "type name",
        property_or_accessor: "property or accessor",
        parameter: "parameter",
        type: "type",
        type_parameter: "type parameter",
        A_declare_modifier_cannot_be_used_with_an_import_declaration: "A 'declare' modifier cannot be used with an import declaration.",
        Invalid_reference_directive_syntax: "Invalid 'reference' directive syntax.",
        Octal_literals_are_not_available_when_targeting_ECMAScript_5_and_higher: "Octal literals are not available when targeting ECMAScript 5 and higher.",
        Accessors_are_not_allowed_in_ambient_contexts: "Accessors are not allowed in ambient contexts.",
        _0_modifier_cannot_appear_on_a_constructor_declaration: "'{0}' modifier cannot appear on a constructor declaration.",
        _0_modifier_cannot_appear_on_a_parameter: "'{0}' modifier cannot appear on a parameter.",
        Only_a_single_variable_declaration_is_allowed_in_a_for_in_statement: "Only a single variable declaration is allowed in a 'for...in' statement.",
        Type_parameters_cannot_appear_on_a_constructor_declaration: "Type parameters cannot appear on a constructor declaration.",
        Type_annotation_cannot_appear_on_a_constructor_declaration: "Type annotation cannot appear on a constructor declaration.",
        Type_parameters_cannot_appear_on_an_accessor: "Type parameters cannot appear on an accessor.",
        Type_annotation_cannot_appear_on_a_set_accessor: "Type annotation cannot appear on a 'set' accessor.",
        Index_signature_must_have_exactly_one_parameter: "Index signature must have exactly one parameter.",
        _0_list_cannot_be_empty: "'{0}' list cannot be empty.",
        variable_declaration: "variable declaration",
        type_argument: "type argument",
        Invalid_use_of_0_in_strict_mode: "Invalid use of '{0}' in strict mode.",
        with_statements_are_not_allowed_in_strict_mode: "'with' statements are not allowed in strict mode.",
        delete_cannot_be_called_on_an_identifier_in_strict_mode: "'delete' cannot be called on an identifier in strict mode.",
        Invalid_left_hand_side_in_for_in_statement: "Invalid left-hand side in 'for...in' statement.",
        continue_statement_can_only_be_used_within_an_enclosing_iteration_statement: "'continue' statement can only be used within an enclosing iteration statement.",
        break_statement_can_only_be_used_within_an_enclosing_iteration_or_switch_statement: "'break' statement can only be used within an enclosing iteration or switch statement.",
        Jump_target_not_found: "Jump target not found.",
        Jump_target_cannot_cross_function_boundary: "Jump target cannot cross function boundary.",
        return_statement_must_be_contained_within_a_function_body: "'return' statement must be contained within a function body.",
        Expression_expected: "Expression expected.",
        Type_expected: "Type expected.",
        Duplicate_identifier_0: "Duplicate identifier '{0}'.",
        The_name_0_does_not_exist_in_the_current_scope: "The name '{0}' does not exist in the current scope.",
        The_name_0_does_not_refer_to_a_value: "The name '{0}' does not refer to a value.",
        super_can_only_be_used_inside_a_class_instance_method: "'super' can only be used inside a class instance method.",
        The_left_hand_side_of_an_assignment_expression_must_be_a_variable_property_or_indexer: "The left-hand side of an assignment expression must be a variable, property or indexer.",
        Value_of_type_0_is_not_callable_Did_you_mean_to_include_new: "Value of type '{0}' is not callable. Did you mean to include 'new'?",
        Value_of_type_0_is_not_callable: "Value of type '{0}' is not callable.",
        Value_of_type_0_is_not_newable: "Value of type '{0}' is not newable.",
        An_index_expression_argument_must_be_string_number_or_any: "An index expression argument must be 'string', 'number', or 'any'.",
        Operator_0_cannot_be_applied_to_types_1_and_2: "Operator '{0}' cannot be applied to types '{1}' and '{2}'.",
        Type_0_is_not_assignable_to_type_1: "Type '{0}' is not assignable to type '{1}'.",
        Type_0_is_not_assignable_to_type_1_NL_2: "Type '{0}' is not assignable to type '{1}':{NL}{2}",
        Expected_var_class_interface_or_module: "Expected var, class, interface, or module.",
        Getter_0_already_declared: "Getter '{0}' already declared.",
        Setter_0_already_declared: "Setter '{0}' already declared.",
        Exported_class_0_extends_private_class_1: "Exported class '{0}' extends private class '{1}'.",
        Exported_class_0_implements_private_interface_1: "Exported class '{0}' implements private interface '{1}'.",
        Exported_interface_0_extends_private_interface_1: "Exported interface '{0}' extends private interface '{1}'.",
        Exported_class_0_extends_class_from_inaccessible_module_1: "Exported class '{0}' extends class from inaccessible module {1}.",
        Exported_class_0_implements_interface_from_inaccessible_module_1: "Exported class '{0}' implements interface from inaccessible module {1}.",
        Exported_interface_0_extends_interface_from_inaccessible_module_1: "Exported interface '{0}' extends interface from inaccessible module {1}.",
        Public_static_property_0_of_exported_class_has_or_is_using_private_type_1: "Public static property '{0}' of exported class has or is using private type '{1}'.",
        Public_property_0_of_exported_class_has_or_is_using_private_type_1: "Public property '{0}' of exported class has or is using private type '{1}'.",
        Property_0_of_exported_interface_has_or_is_using_private_type_1: "Property '{0}' of exported interface has or is using private type '{1}'.",
        Exported_variable_0_has_or_is_using_private_type_1: "Exported variable '{0}' has or is using private type '{1}'.",
        Public_static_property_0_of_exported_class_is_using_inaccessible_module_1: "Public static property '{0}' of exported class is using inaccessible module {1}.",
        Public_property_0_of_exported_class_is_using_inaccessible_module_1: "Public property '{0}' of exported class is using inaccessible module {1}.",
        Property_0_of_exported_interface_is_using_inaccessible_module_1: "Property '{0}' of exported interface is using inaccessible module {1}.",
        Exported_variable_0_is_using_inaccessible_module_1: "Exported variable '{0}' is using inaccessible module {1}.",
        Parameter_0_of_constructor_from_exported_class_has_or_is_using_private_type_1: "Parameter '{0}' of constructor from exported class has or is using private type '{1}'.",
        Parameter_0_of_public_static_property_setter_from_exported_class_has_or_is_using_private_type_1: "Parameter '{0}' of public static property setter from exported class has or is using private type '{1}'.",
        Parameter_0_of_public_property_setter_from_exported_class_has_or_is_using_private_type_1: "Parameter '{0}' of public property setter from exported class has or is using private type '{1}'.",
        Parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_private_type_1: "Parameter '{0}' of constructor signature from exported interface has or is using private type '{1}'.",
        Parameter_0_of_call_signature_from_exported_interface_has_or_is_using_private_type_1: "Parameter '{0}' of call signature from exported interface has or is using private type '{1}'.",
        Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_private_type_1: "Parameter '{0}' of public static method from exported class has or is using private type '{1}'.",
        Parameter_0_of_public_method_from_exported_class_has_or_is_using_private_type_1: "Parameter '{0}' of public method from exported class has or is using private type '{1}'.",
        Parameter_0_of_method_from_exported_interface_has_or_is_using_private_type_1: "Parameter '{0}' of method from exported interface has or is using private type '{1}'.",
        Parameter_0_of_exported_function_has_or_is_using_private_type_1: "Parameter '{0}' of exported function has or is using private type '{1}'.",
        Parameter_0_of_constructor_from_exported_class_is_using_inaccessible_module_1: "Parameter '{0}' of constructor from exported class is using inaccessible module {1}.",
        Parameter_0_of_public_static_property_setter_from_exported_class_is_using_inaccessible_module_1: "Parameter '{0}' of public static property setter from exported class is using inaccessible module {1}.",
        Parameter_0_of_public_property_setter_from_exported_class_is_using_inaccessible_module_1: "Parameter '{0}' of public property setter from exported class is using inaccessible module {1}.",
        Parameter_0_of_constructor_signature_from_exported_interface_is_using_inaccessible_module_1: "Parameter '{0}' of constructor signature from exported interface is using inaccessible module {1}.",
        Parameter_0_of_call_signature_from_exported_interface_is_using_inaccessible_module_1: "Parameter '{0}' of call signature from exported interface is using inaccessible module {1}",
        Parameter_0_of_public_static_method_from_exported_class_is_using_inaccessible_module_1: "Parameter '{0}' of public static method from exported class is using inaccessible module {1}.",
        Parameter_0_of_public_method_from_exported_class_is_using_inaccessible_module_1: "Parameter '{0}' of public method from exported class is using inaccessible module {1}.",
        Parameter_0_of_method_from_exported_interface_is_using_inaccessible_module_1: "Parameter '{0}' of method from exported interface is using inaccessible module {1}.",
        Parameter_0_of_exported_function_is_using_inaccessible_module_1: "Parameter '{0}' of exported function is using inaccessible module {1}.",
        Return_type_of_public_static_property_getter_from_exported_class_has_or_is_using_private_type_0: "Return type of public static property getter from exported class has or is using private type '{0}'.",
        Return_type_of_public_property_getter_from_exported_class_has_or_is_using_private_type_0: "Return type of public property getter from exported class has or is using private type '{0}'.",
        Return_type_of_constructor_signature_from_exported_interface_has_or_is_using_private_type_0: "Return type of constructor signature from exported interface has or is using private type '{0}'.",
        Return_type_of_call_signature_from_exported_interface_has_or_is_using_private_type_0: "Return type of call signature from exported interface has or is using private type '{0}'.",
        Return_type_of_index_signature_from_exported_interface_has_or_is_using_private_type_0: "Return type of index signature from exported interface has or is using private type '{0}'.",
        Return_type_of_public_static_method_from_exported_class_has_or_is_using_private_type_0: "Return type of public static method from exported class has or is using private type '{0}'.",
        Return_type_of_public_method_from_exported_class_has_or_is_using_private_type_0: "Return type of public method from exported class has or is using private type '{0}'.",
        Return_type_of_method_from_exported_interface_has_or_is_using_private_type_0: "Return type of method from exported interface has or is using private type '{0}'.",
        Return_type_of_exported_function_has_or_is_using_private_type_0: "Return type of exported function has or is using private type '{0}'.",
        Return_type_of_public_static_property_getter_from_exported_class_is_using_inaccessible_module_0: "Return type of public static property getter from exported class is using inaccessible module {0}.",
        Return_type_of_public_property_getter_from_exported_class_is_using_inaccessible_module_0: "Return type of public property getter from exported class is using inaccessible module {0}.",
        Return_type_of_constructor_signature_from_exported_interface_is_using_inaccessible_module_0: "Return type of constructor signature from exported interface is using inaccessible module {0}.",
        Return_type_of_call_signature_from_exported_interface_is_using_inaccessible_module_0: "Return type of call signature from exported interface is using inaccessible module {0}.",
        Return_type_of_index_signature_from_exported_interface_is_using_inaccessible_module_0: "Return type of index signature from exported interface is using inaccessible module {0}.",
        Return_type_of_public_static_method_from_exported_class_is_using_inaccessible_module_0: "Return type of public static method from exported class is using inaccessible module {0}.",
        Return_type_of_public_method_from_exported_class_is_using_inaccessible_module_0: "Return type of public method from exported class is using inaccessible module {0}.",
        Return_type_of_method_from_exported_interface_is_using_inaccessible_module_0: "Return type of method from exported interface is using inaccessible module {0}.",
        Return_type_of_exported_function_is_using_inaccessible_module_0: "Return type of exported function is using inaccessible module {0}.",
        new_T_cannot_be_used_to_create_an_array_Use_new_Array_T_instead: "'new T[]' cannot be used to create an array. Use 'new Array<T>()' instead.",
        A_parameter_list_must_follow_a_generic_type_argument_list_expected: "A parameter list must follow a generic type argument list. '(' expected.",
        Multiple_constructor_implementations_are_not_allowed: "Multiple constructor implementations are not allowed.",
        Cannot_find_external_module_0: "Cannot find external module '{0}'.",
        Module_cannot_be_aliased_to_a_non_module_type: "Module cannot be aliased to a non-module type.",
        A_class_may_only_extend_another_class: "A class may only extend another class.",
        A_class_may_only_implement_another_class_or_interface: "A class may only implement another class or interface.",
        An_interface_may_only_extend_a_class_or_another_interface: "An interface may only extend a class or another interface.",
        Unable_to_resolve_type: "Unable to resolve type.",
        Unable_to_resolve_type_of_0: "Unable to resolve type of '{0}'.",
        Unable_to_resolve_type_parameter_constraint: "Unable to resolve type parameter constraint.",
        Type_parameter_constraint_cannot_be_a_primitive_type: "Type parameter constraint cannot be a primitive type.",
        Supplied_parameters_do_not_match_any_signature_of_call_target: "Supplied parameters do not match any signature of call target.",
        Supplied_parameters_do_not_match_any_signature_of_call_target_NL_0: "Supplied parameters do not match any signature of call target:{NL}{0}",
        Cannot_use_new_with_an_expression_whose_type_lacks_a_signature: "Cannot use 'new' with an expression whose type lacks a signature.",
        Only_a_void_function_can_be_called_with_the_new_keyword: "Only a void function can be called with the 'new' keyword.",
        Could_not_select_overload_for_new_expression: "Could not select overload for 'new' expression.",
        Type_0_does_not_satisfy_the_constraint_1: "Type '{0}' does not satisfy the constraint '{1}'.",
        Could_not_select_overload_for_call_expression: "Could not select overload for 'call' expression.",
        Cannot_invoke_an_expression_whose_type_lacks_a_call_signature: "Cannot invoke an expression whose type lacks a call signature.",
        Calls_to_super_are_only_valid_inside_a_class: "Calls to 'super' are only valid inside a class.",
        Generic_type_0_requires_1_type_argument_s: "Generic type '{0}' requires {1} type argument(s).",
        Type_of_array_literal_cannot_be_determined_Best_common_type_could_not_be_found_for_array_elements: "Type of array literal cannot be determined. Best common type could not be found for array elements.",
        Could_not_find_enclosing_symbol_for_dotted_name_0: "Could not find enclosing symbol for dotted name '{0}'.",
        Property_0_does_not_exist_on_value_of_type_1: "Property '{0}' does not exist on value of type '{1}'.",
        Cannot_find_name_0: "Cannot find name '{0}'.",
        get_and_set_accessor_must_have_the_same_type: "'get' and 'set' accessor must have the same type.",
        this_cannot_be_referenced_in_current_location: "'this' cannot be referenced in current location.",
        Static_members_cannot_reference_class_type_parameters: "Static members cannot reference class type parameters.",
        Type_0_recursively_references_itself_as_a_base_type: "Type '{0}' recursively references itself as a base type.",
        super_property_access_is_permitted_only_in_a_constructor_member_function_or_member_accessor_of_a_derived_class: "'super' property access is permitted only in a constructor, member function, or member accessor of a derived class.",
        super_can_only_be_referenced_in_a_derived_class: "'super' can only be referenced in a derived class.",
        A_super_call_must_be_the_first_statement_in_the_constructor_when_a_class_contains_initialized_properties_or_has_parameter_properties: "A 'super' call must be the first statement in the constructor when a class contains initialized properties or has parameter properties.",
        Constructors_for_derived_classes_must_contain_a_super_call: "Constructors for derived classes must contain a 'super' call.",
        Super_calls_are_not_permitted_outside_constructors_or_in_nested_functions_inside_constructors: "Super calls are not permitted outside constructors or in nested functions inside constructors.",
        _0_1_is_inaccessible: "'{0}.{1}' is inaccessible.",
        this_cannot_be_referenced_in_a_module_body: "'this' cannot be referenced in a module body.",
        Invalid_expression_types_not_known_to_support_the_addition_operator: "Invalid '+' expression - types not known to support the addition operator.",
        The_right_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_or_an_enum_type: "The right-hand side of an arithmetic operation must be of type 'any', 'number' or an enum type.",
        The_left_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_or_an_enum_type: "The left-hand side of an arithmetic operation must be of type 'any', 'number' or an enum type.",
        An_arithmetic_operand_must_be_of_type_any_number_or_an_enum_type: "An arithmetic operand must be of type 'any', 'number' or an enum type.",
        Variable_declarations_of_a_for_statement_cannot_use_a_type_annotation: "Variable declarations of a 'for' statement cannot use a type annotation.",
        Variable_declarations_of_a_for_statement_must_be_of_types_string_or_any: "Variable declarations of a 'for' statement must be of types 'string' or 'any'.",
        The_right_hand_side_of_a_for_in_statement_must_be_of_type_any_an_object_type_or_a_type_parameter: "The right-hand side of a 'for...in' statement must be of type 'any', an object type or a type parameter.",
        The_left_hand_side_of_an_in_expression_must_be_of_types_any_string_or_number: "The left-hand side of an 'in' expression must be of types 'any', 'string' or 'number'.",
        The_right_hand_side_of_an_in_expression_must_be_of_type_any_an_object_type_or_a_type_parameter: "The right-hand side of an 'in' expression must be of type 'any', an object type or a type parameter.",
        The_left_hand_side_of_an_instanceof_expression_must_be_of_type_any_an_object_type_or_a_type_parameter: "The left-hand side of an 'instanceof' expression must be of type 'any', an object type or a type parameter.",
        The_right_hand_side_of_an_instanceof_expression_must_be_of_type_any_or_of_a_type_assignable_to_the_Function_interface_type: "The right-hand side of an 'instanceof' expression must be of type 'any' or of a type assignable to the 'Function' interface type.",
        Setters_cannot_return_a_value: "Setters cannot return a value.",
        Tried_to_query_type_of_uninitialized_module_0: "Tried to query type of uninitialized module '{0}'.",
        Tried_to_set_variable_type_to_uninitialized_module_type_0: "Tried to set variable type to uninitialized module type '{0}'.",
        Type_0_is_not_generic: "Type '{0}' is not generic.",
        Getters_must_return_a_value: "Getters must return a value.",
        Getter_and_setter_accessors_do_not_agree_in_visibility: "Getter and setter accessors do not agree in visibility.",
        Invalid_left_hand_side_of_assignment_expression: "Invalid left-hand side of assignment expression.",
        Function_declared_a_non_void_return_type_but_has_no_return_expression: "Function declared a non-void return type, but has no return expression.",
        Cannot_resolve_return_type_reference: "Cannot resolve return type reference.",
        Constructors_cannot_have_a_return_type_of_void: "Constructors cannot have a return type of 'void'.",
        Subsequent_variable_declarations_must_have_the_same_type_Variable_0_must_be_of_type_1_but_here_has_type_2: "Subsequent variable declarations must have the same type.  Variable '{0}' must be of type '{1}', but here has type '{2}'.",
        All_symbols_within_a_with_block_will_be_resolved_to_any: "All symbols within a with block will be resolved to 'any'.",
        Import_declarations_in_an_internal_module_cannot_reference_an_external_module: "Import declarations in an internal module cannot reference an external module.",
        Class_0_declares_interface_1_but_does_not_implement_it_NL_2: "Class {0} declares interface {1} but does not implement it:{NL}{2}",
        Class_0_declares_class_1_as_an_interface_but_does_not_implement_it_NL_2: "Class {0} declares class {1} as an interface but does not implement it:{NL}{2}",
        The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_property_or_indexer: "The operand of an increment or decrement operator must be a variable, property or indexer.",
        this_cannot_be_referenced_in_a_static_property_initializer: "'this' cannot be referenced in a static property initializer.",
        Class_0_cannot_extend_class_1_NL_2: "Class '{0}' cannot extend class '{1}':{NL}{2}",
        Interface_0_cannot_extend_class_1_NL_2: "Interface '{0}' cannot extend class '{1}':{NL}{2}",
        Interface_0_cannot_extend_interface_1_NL_2: "Interface '{0}' cannot extend interface '{1}':{NL}{2}",
        Overload_signature_is_not_compatible_with_function_definition: "Overload signature is not compatible with function definition.",
        Overload_signature_is_not_compatible_with_function_definition_NL_0: "Overload signature is not compatible with function definition:{NL}{0}",
        Overload_signatures_must_all_be_public_or_private: "Overload signatures must all be public or private.",
        Overload_signatures_must_all_be_exported_or_not_exported: "Overload signatures must all be exported or not exported.",
        Overload_signatures_must_all_be_ambient_or_non_ambient: "Overload signatures must all be ambient or non-ambient.",
        Overload_signatures_must_all_be_optional_or_required: "Overload signatures must all be optional or required.",
        Specialized_overload_signature_is_not_assignable_to_any_non_specialized_signature: "Specialized overload signature is not assignable to any non-specialized signature.",
        this_cannot_be_referenced_in_constructor_arguments: "'this' cannot be referenced in constructor arguments.",
        Instance_member_cannot_be_accessed_off_a_class: "Instance member cannot be accessed off a class.",
        Untyped_function_calls_may_not_accept_type_arguments: "Untyped function calls may not accept type arguments.",
        Non_generic_functions_may_not_accept_type_arguments: "Non-generic functions may not accept type arguments.",
        A_generic_type_may_not_reference_itself_with_a_wrapped_form_of_its_own_type_parameters: "A generic type may not reference itself with a wrapped form of its own type parameters.",
        A_rest_parameter_must_be_of_an_array_type: "A rest parameter must be of an array type.",
        Overload_signature_implementation_cannot_use_specialized_type: "Overload signature implementation cannot use specialized type.",
        Export_assignments_may_only_be_used_at_the_top_level_of_external_modules: "Export assignments may only be used at the top-level of external modules.",
        Export_assignments_may_only_be_made_with_variables_functions_classes_interfaces_enums_and_internal_modules: "Export assignments may only be made with variables, functions, classes, interfaces, enums and internal modules.",
        Only_public_methods_of_the_base_class_are_accessible_via_the_super_keyword: "Only public methods of the base class are accessible via the 'super' keyword.",
        Numeric_indexer_type_0_must_be_assignable_to_string_indexer_type_1: "Numeric indexer type '{0}' must be assignable to string indexer type '{1}'.",
        Numeric_indexer_type_0_must_be_assignable_to_string_indexer_type_1_NL_2: "Numeric indexer type '{0}' must be assignable to string indexer type '{1}':{NL}{2}",
        All_numerically_named_properties_must_be_assignable_to_numeric_indexer_type_0: "All numerically named properties must be assignable to numeric indexer type '{0}'.",
        All_numerically_named_properties_must_be_assignable_to_numeric_indexer_type_0_NL_1: "All numerically named properties must be assignable to numeric indexer type '{0}':{NL}{1}",
        All_named_properties_must_be_assignable_to_string_indexer_type_0: "All named properties must be assignable to string indexer type '{0}'.",
        All_named_properties_must_be_assignable_to_string_indexer_type_0_NL_1: "All named properties must be assignable to string indexer type '{0}':{NL}{1}",
        A_parameter_initializer_is_only_allowed_in_a_function_or_constructor_implementation: "A parameter initializer is only allowed in a function or constructor implementation.",
        Function_expression_declared_a_non_void_return_type_but_has_no_return_expression: "Function expression declared a non-void return type, but has no return expression.",
        Import_declaration_referencing_identifier_from_internal_module_can_only_be_made_with_variables_functions_classes_interfaces_enums_and_internal_modules: "Import declaration referencing identifier from internal module can only be made with variables, functions, classes, interfaces, enums and internal modules.",
        Module_0_has_no_exported_member_1: "Module '{0}' has no exported member '{1}'.",
        Unable_to_resolve_module_reference_0: "Unable to resolve module reference '{0}'.",
        Could_not_find_module_0_in_module_1: "Could not find module '{0}' in module '{1}'.",
        Exported_import_declaration_0_is_assigned_value_with_type_that_has_or_is_using_private_type_1: "Exported import declaration '{0}' is assigned value with type that has or is using private type '{1}'.",
        Exported_import_declaration_0_is_assigned_value_with_type_that_is_using_inaccessible_module_1: "Exported import declaration '{0}' is assigned value with type that is using inaccessible module '{1}'.",
        Exported_import_declaration_0_is_assigned_type_that_has_or_is_using_private_type_1: "Exported import declaration '{0}' is assigned type that has or is using private type '{1}'.",
        Exported_import_declaration_0_is_assigned_type_that_is_using_inaccessible_module_1: "Exported import declaration '{0}' is assigned type that is using inaccessible module '{1}'.",
        Exported_import_declaration_0_is_assigned_container_that_is_or_is_using_inaccessible_module_1: "Exported import declaration '{0}' is assigned container that is or is using inaccessible module '{1}'.",
        Type_name_0_in_extends_clause_does_not_reference_constructor_function_for_1: "Type name '{0}' in extends clause does not reference constructor function for '{1}'.",
        Internal_module_reference_0_in_import_declaration_does_not_reference_module_instance_for_1: "Internal module reference '{0}' in import declaration does not reference module instance for '{1}'.",
        Module_0_cannot_merge_with_previous_declaration_of_1_in_a_different_file_2: "Module '{0}' cannot merge with previous declaration of '{1}' in a different file '{2}'.",
        Interface_0_cannot_simultaneously_extend_types_1_and_2_NL_3: "Interface '{0}' cannot simultaneously extend types '{1}' and '{2}':{NL}{3}",
        Initializer_of_parameter_0_cannot_reference_identifier_1_declared_after_it: "Initializer of parameter '{0}' cannot reference identifier '{1}' declared after it.",
        Ambient_external_module_declaration_cannot_be_reopened: "Ambient external module declaration cannot be reopened.",
        All_declarations_of_merged_declaration_0_must_be_exported_or_not_exported: "All declarations of merged declaration '{0}' must be exported or not exported.",
        super_cannot_be_referenced_in_constructor_arguments: "'super' cannot be referenced in constructor arguments.",
        Return_type_of_constructor_signature_must_be_assignable_to_the_instance_type_of_the_class: "Return type of constructor signature must be assignable to the instance type of the class.",
        Ambient_external_module_declaration_must_be_defined_in_global_context: "Ambient external module declaration must be defined in global context.",
        Ambient_external_module_declaration_cannot_specify_relative_module_name: "Ambient external module declaration cannot specify relative module name.",
        Import_declaration_in_an_ambient_external_module_declaration_cannot_reference_external_module_through_relative_external_module_name: "Import declaration in an ambient external module declaration cannot reference external module through relative external module name.",
        No_best_common_type_exists_among_return_expressions: "No best common type exists among return expressions.",
        Import_declaration_cannot_refer_to_external_module_reference_when_noResolve_option_is_set: "Import declaration cannot refer to external module reference when --noResolve option is set.",
        Duplicate_identifier_this_Compiler_uses_variable_declaration_this_to_capture_this_reference: "Duplicate identifier '_this'. Compiler uses variable declaration '_this' to capture 'this' reference.",
        Duplicate_identifier_super_Compiler_uses_super_to_capture_base_class_reference: "Duplicate identifier '_super'. Compiler uses '_super' to capture base class reference.",
        Expression_resolves_to_variable_declaration_this_that_compiler_uses_to_capture_this_reference: "Expression resolves to variable declaration '_this' that compiler uses to capture 'this' reference.",
        Expression_resolves_to_super_that_compiler_uses_to_capture_base_class_reference: "Expression resolves to '_super' that compiler uses to capture base class reference.",
        TypeParameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_private_type_1: "TypeParameter '{0}' of constructor signature from exported interface has or is using private type '{1}'.",
        TypeParameter_0_of_call_signature_from_exported_interface_has_or_is_using_private_type_1: "TypeParameter '{0}' of call signature from exported interface has or is using private type '{1}'.",
        TypeParameter_0_of_public_static_method_from_exported_class_has_or_is_using_private_type_1: "TypeParameter '{0}' of public static method from exported class has or is using private type '{1}'.",
        TypeParameter_0_of_public_method_from_exported_class_has_or_is_using_private_type_1: "TypeParameter '{0}' of public method from exported class has or is using private type '{1}'.",
        TypeParameter_0_of_method_from_exported_interface_has_or_is_using_private_type_1: "TypeParameter '{0}' of method from exported interface has or is using private type '{1}'.",
        TypeParameter_0_of_exported_function_has_or_is_using_private_type_1: "TypeParameter '{0}' of exported function has or is using private type '{1}'.",
        TypeParameter_0_of_constructor_signature_from_exported_interface_is_using_inaccessible_module_1: "TypeParameter '{0}' of constructor signature from exported interface is using inaccessible module {1}.",
        TypeParameter_0_of_call_signature_from_exported_interface_is_using_inaccessible_module_1: "TypeParameter '{0}' of call signature from exported interface is using inaccessible module {1}",
        TypeParameter_0_of_public_static_method_from_exported_class_is_using_inaccessible_module_1: "TypeParameter '{0}' of public static method from exported class is using inaccessible module {1}.",
        TypeParameter_0_of_public_method_from_exported_class_is_using_inaccessible_module_1: "TypeParameter '{0}' of public method from exported class is using inaccessible module {1}.",
        TypeParameter_0_of_method_from_exported_interface_is_using_inaccessible_module_1: "TypeParameter '{0}' of method from exported interface is using inaccessible module {1}.",
        TypeParameter_0_of_exported_function_is_using_inaccessible_module_1: "TypeParameter '{0}' of exported function is using inaccessible module {1}.",
        TypeParameter_0_of_exported_class_has_or_is_using_private_type_1: "TypeParameter '{0}' of exported class has or is using private type '{1}'.",
        TypeParameter_0_of_exported_interface_has_or_is_using_private_type_1: "TypeParameter '{0}' of exported interface has or is using private type '{1}'.",
        TypeParameter_0_of_exported_class_is_using_inaccessible_module_1: "TypeParameter '{0}' of exported class is using inaccessible module {1}.",
        TypeParameter_0_of_exported_interface_is_using_inaccessible_module_1: "TypeParameter '{0}' of exported interface is using inaccessible module {1}.",
        Duplicate_identifier_i_Compiler_uses_i_to_initialize_rest_parameter: "Duplicate identifier '_i'. Compiler uses '_i' to initialize rest parameter.",
        Duplicate_identifier_arguments_Compiler_uses_arguments_to_initialize_rest_parameters: "Duplicate identifier 'arguments'. Compiler uses 'arguments' to initialize rest parameters.",
        No_best_common_type_exists_between_0_and_1: "No best common type exists between '{0}' and '{1}'.",
        No_best_common_type_exists_between_0_1_and_2: "No best common type exists between '{0}', '{1}', and '{2}'.",
        Duplicate_identifier_0_Compiler_reserves_name_1_in_top_level_scope_of_an_external_module: "Duplicate identifier '{0}'. Compiler reserves name '{1}' in top level scope of an external module.",
        Constraint_of_a_type_parameter_cannot_reference_any_type_parameter_from_the_same_type_parameter_list: "Constraint of a type parameter cannot reference any type parameter from the same type parameter list.",
        Initializer_of_instance_member_variable_0_cannot_reference_identifier_1_declared_in_the_constructor: "Initializer of instance member variable '{0}' cannot reference identifier '{1}' declared in the constructor.",
        Parameter_0_cannot_be_referenced_in_its_initializer: "Parameter '{0}' cannot be referenced in its initializer.",
        Duplicate_string_index_signature: "Duplicate string index signature.",
        Duplicate_number_index_signature: "Duplicate number index signature.",
        All_declarations_of_an_interface_must_have_identical_type_parameters: "All declarations of an interface must have identical type parameters.",
        Expression_resolves_to_variable_declaration_i_that_compiler_uses_to_initialize_rest_parameter: "Expression resolves to variable declaration '_i' that compiler uses to initialize rest parameter.",
        Neither_type_0_nor_type_1_is_assignable_to_the_other: "Neither type '{0}' nor type '{1}' is assignable to the other.",
        Neither_type_0_nor_type_1_is_assignable_to_the_other_NL_2: "Neither type '{0}' nor type '{1}' is assignable to the other:{NL}{2}",
        Duplicate_function_implementation: "Duplicate function implementation.",
        Function_implementation_expected: "Function implementation expected.",
        Function_overload_name_must_be_0: "Function overload name must be '{0}'.",
        Constructor_implementation_expected: "Constructor implementation expected.",
        Class_name_cannot_be_0: "Class name cannot be '{0}'.",
        Interface_name_cannot_be_0: "Interface name cannot be '{0}'.",
        Enum_name_cannot_be_0: "Enum name cannot be '{0}'.",
        A_module_cannot_have_multiple_export_assignments: "A module cannot have multiple export assignments.",
        Export_assignment_not_allowed_in_module_with_exported_element: "Export assignment not allowed in module with exported element.",
        A_parameter_property_is_only_allowed_in_a_constructor_implementation: "A parameter property is only allowed in a constructor implementation.",
        Function_overload_must_be_static: "Function overload must be static.",
        Function_overload_must_not_be_static: "Function overload must not be static.",
        Type_0_is_missing_property_1_from_type_2: "Type '{0}' is missing property '{1}' from type '{2}'.",
        Types_of_property_0_of_types_1_and_2_are_incompatible: "Types of property '{0}' of types '{1}' and '{2}' are incompatible.",
        Types_of_property_0_of_types_1_and_2_are_incompatible_NL_3: "Types of property '{0}' of types '{1}' and '{2}' are incompatible:{NL}{3}",
        Property_0_defined_as_private_in_type_1_is_defined_as_public_in_type_2: "Property '{0}' defined as private in type '{1}' is defined as public in type '{2}'.",
        Property_0_defined_as_public_in_type_1_is_defined_as_private_in_type_2: "Property '{0}' defined as public in type '{1}' is defined as private in type '{2}'.",
        Types_0_and_1_define_property_2_as_private: "Types '{0}' and '{1}' define property '{2}' as private.",
        Call_signatures_of_types_0_and_1_are_incompatible: "Call signatures of types '{0}' and '{1}' are incompatible.",
        Call_signatures_of_types_0_and_1_are_incompatible_NL_2: "Call signatures of types '{0}' and '{1}' are incompatible:{NL}{2}",
        Type_0_requires_a_call_signature_but_type_1_lacks_one: "Type '{0}' requires a call signature, but type '{1}' lacks one.",
        Construct_signatures_of_types_0_and_1_are_incompatible: "Construct signatures of types '{0}' and '{1}' are incompatible.",
        Construct_signatures_of_types_0_and_1_are_incompatible_NL_2: "Construct signatures of types '{0}' and '{1}' are incompatible:{NL}{2}",
        Type_0_requires_a_construct_signature_but_type_1_lacks_one: "Type '{0}' requires a construct signature, but type '{1}' lacks one.",
        Index_signatures_of_types_0_and_1_are_incompatible: "Index signatures of types '{0}' and '{1}' are incompatible.",
        Index_signatures_of_types_0_and_1_are_incompatible_NL_2: "Index signatures of types '{0}' and '{1}' are incompatible:{NL}{2}",
        Call_signature_expects_0_or_fewer_parameters: "Call signature expects {0} or fewer parameters.",
        Could_not_apply_type_0_to_argument_1_which_is_of_type_2: "Could not apply type '{0}' to argument {1} which is of type '{2}'.",
        Class_0_defines_instance_member_accessor_1_but_extended_class_2_defines_it_as_instance_member_function: "Class '{0}' defines instance member accessor '{1}', but extended class '{2}' defines it as instance member function.",
        Class_0_defines_instance_member_property_1_but_extended_class_2_defines_it_as_instance_member_function: "Class '{0}' defines instance member property '{1}', but extended class '{2}' defines it as instance member function.",
        Class_0_defines_instance_member_function_1_but_extended_class_2_defines_it_as_instance_member_accessor: "Class '{0}' defines instance member function '{1}', but extended class '{2}' defines it as instance member accessor.",
        Class_0_defines_instance_member_function_1_but_extended_class_2_defines_it_as_instance_member_property: "Class '{0}' defines instance member function '{1}', but extended class '{2}' defines it as instance member property.",
        Types_of_static_property_0_of_class_1_and_class_2_are_incompatible: "Types of static property '{0}' of class '{1}' and class '{2}' are incompatible.",
        Types_of_static_property_0_of_class_1_and_class_2_are_incompatible_NL_3: "Types of static property '{0}' of class '{1}' and class '{2}' are incompatible:{NL}{3}",
        Type_reference_cannot_refer_to_container_0: "Type reference cannot refer to container '{0}'.",
        Type_reference_must_refer_to_type: "Type reference must refer to type.",
        In_enums_with_multiple_declarations_only_one_declaration_can_omit_an_initializer_for_the_first_enum_element: "In enums with multiple declarations only one declaration can omit an initializer for the first enum element.",
        _0_overload_s: " (+ {0} overload(s))",
        Variable_declaration_cannot_have_the_same_name_as_an_import_declaration: "Variable declaration cannot have the same name as an import declaration.",
        Signature_expected_0_type_arguments_got_1_instead: "Signature expected {0} type arguments, got {1} instead.",
        Property_0_defined_as_optional_in_type_1_but_is_required_in_type_2: "Property '{0}' defined as optional in type '{1}', but is required in type '{2}'.",
        Types_0_and_1_originating_in_infinitely_expanding_type_reference_do_not_refer_to_same_named_type: "Types '{0}' and '{1}' originating in infinitely expanding type reference do not refer to same named type.",
        Types_0_and_1_originating_in_infinitely_expanding_type_reference_have_incompatible_type_arguments: "Types '{0}' and '{1}' originating in infinitely expanding type reference have incompatible type arguments.",
        Types_0_and_1_originating_in_infinitely_expanding_type_reference_have_incompatible_type_arguments_NL_2: "Types '{0}' and '{1}' originating in infinitely expanding type reference have incompatible type arguments:{NL}{2}",
        Named_properties_0_of_types_1_and_2_are_not_identical: "Named properties '{0}' of types '{1}' and '{2}' are not identical.",
        Types_of_string_indexer_of_types_0_and_1_are_not_identical: "Types of string indexer of types '{0}' and '{1}' are not identical.",
        Types_of_number_indexer_of_types_0_and_1_are_not_identical: "Types of number indexer of types '{0}' and '{1}' are not identical.",
        Type_of_number_indexer_in_type_0_is_not_assignable_to_string_indexer_type_in_type_1_NL_2: "Type of number indexer in type '{0}' is not assignable to string indexer type in type '{1}'.{NL}{2}",
        Type_of_property_0_in_type_1_is_not_assignable_to_string_indexer_type_in_type_2_NL_3: "Type of property '{0}' in type '{1}' is not assignable to string indexer type in type '{2}'.{NL}{3}",
        Type_of_property_0_in_type_1_is_not_assignable_to_number_indexer_type_in_type_2_NL_3: "Type of property '{0}' in type '{1}' is not assignable to number indexer type in type '{2}'.{NL}{3}",
        Static_property_0_defined_as_private_in_type_1_is_defined_as_public_in_type_2: "Static property '{0}' defined as private in type '{1}' is defined as public in type '{2}'.",
        Static_property_0_defined_as_public_in_type_1_is_defined_as_private_in_type_2: "Static property '{0}' defined as public in type '{1}' is defined as private in type '{2}'.",
        Types_0_and_1_define_static_property_2_as_private: "Types '{0}' and '{1}' define static property '{2}' as private.",
        Current_host_does_not_support_0_option: "Current host does not support '{0}' option.",
        ECMAScript_target_version_0_not_supported_Specify_a_valid_target_version_1_default_or_2: "ECMAScript target version '{0}' not supported.  Specify a valid target version: '{1}' (default), or '{2}'",
        Argument_for_0_option_must_be_1_or_2: "Argument for '{0}' option must be '{1}' or '{2}'",
        Could_not_find_file_0: "Could not find file: '{0}'.",
        A_file_cannot_have_a_reference_to_itself: "A file cannot have a reference to itself.",
        Cannot_resolve_referenced_file_0: "Cannot resolve referenced file: '{0}'.",
        Cannot_find_the_common_subdirectory_path_for_the_input_files: "Cannot find the common subdirectory path for the input files.",
        Emit_Error_0: "Emit Error: {0}.",
        Cannot_read_file_0_1: "Cannot read file '{0}': {1}",
        Unsupported_file_encoding: "Unsupported file encoding.",
        Locale_must_be_of_the_form_language_or_language_territory_For_example_0_or_1: "Locale must be of the form <language> or <language>-<territory>. For example '{0}' or '{1}'.",
        Unsupported_locale_0: "Unsupported locale: '{0}'.",
        Execution_Failed_NL: "Execution Failed.{NL}",
        Invalid_call_to_up: "Invalid call to 'up'",
        Invalid_call_to_down: "Invalid call to 'down'",
        Base64_value_0_finished_with_a_continuation_bit: "Base64 value '{0}' finished with a continuation bit.",
        Unknown_compiler_option_0: "Unknown compiler option '{0}'",
        Expected_0_arguments_to_message_got_1_instead: "Expected {0} arguments to message, got {1} instead.",
        Expected_the_message_0_to_have_1_arguments_but_it_had_2: "Expected the message '{0}' to have {1} arguments, but it had {2}",
        Could_not_delete_file_0: "Could not delete file '{0}'",
        Could_not_create_directory_0: "Could not create directory '{0}'",
        Error_while_executing_file_0: "Error while executing file '{0}': ",
        Cannot_compile_external_modules_unless_the_module_flag_is_provided: "Cannot compile external modules unless the '--module' flag is provided.",
        Option_mapRoot_cannot_be_specified_without_specifying_sourcemap_option: "Option mapRoot cannot be specified without specifying sourcemap option.",
        Option_sourceRoot_cannot_be_specified_without_specifying_sourcemap_option: "Option sourceRoot cannot be specified without specifying sourcemap option.",
        Options_mapRoot_and_sourceRoot_cannot_be_specified_without_specifying_sourcemap_option: "Options mapRoot and sourceRoot cannot be specified without specifying sourcemap option.",
        Option_0_specified_without_1: "Option '{0}' specified without '{1}'",
        codepage_option_not_supported_on_current_platform: "'codepage' option not supported on current platform.",
        Concatenate_and_emit_output_to_single_file: "Concatenate and emit output to single file.",
        Generates_corresponding_0_file: "Generates corresponding {0} file.",
        Specifies_the_location_where_debugger_should_locate_map_files_instead_of_generated_locations: "Specifies the location where debugger should locate map files instead of generated locations.",
        Specifies_the_location_where_debugger_should_locate_TypeScript_files_instead_of_source_locations: "Specifies the location where debugger should locate TypeScript files instead of source locations.",
        Watch_input_files: "Watch input files.",
        Redirect_output_structure_to_the_directory: "Redirect output structure to the directory.",
        Do_not_emit_comments_to_output: "Do not emit comments to output.",
        Skip_resolution_and_preprocessing: "Skip resolution and preprocessing.",
        Specify_ECMAScript_target_version_0_default_or_1: "Specify ECMAScript target version: '{0}' (default), or '{1}'",
        Specify_module_code_generation_0_or_1: "Specify module code generation: '{0}' or '{1}'",
        Print_this_message: "Print this message.",
        Print_the_compiler_s_version_0: "Print the compiler's version: {0}",
        Allow_use_of_deprecated_0_keyword_when_referencing_an_external_module: "Allow use of deprecated '{0}' keyword when referencing an external module.",
        Specify_locale_for_errors_and_messages_For_example_0_or_1: "Specify locale for errors and messages. For example '{0}' or '{1}'",
        Syntax_0: "Syntax:   {0}",
        options: "options",
        file1: "file",
        Examples: "Examples:",
        Options: "Options:",
        Insert_command_line_options_and_files_from_a_file: "Insert command line options and files from a file.",
        Version_0: "Version {0}",
        Use_the_0_flag_to_see_options: "Use the '{0}' flag to see options.",
        NL_Recompiling_0: "{NL}Recompiling ({0}):",
        STRING: "STRING",
        KIND: "KIND",
        file2: "FILE",
        VERSION: "VERSION",
        LOCATION: "LOCATION",
        DIRECTORY: "DIRECTORY",
        NUMBER: "NUMBER",
        Specify_the_codepage_to_use_when_opening_source_files: "Specify the codepage to use when opening source files.",
        Additional_locations: "Additional locations:",
        This_version_of_the_Javascript_runtime_does_not_support_the_0_function: "This version of the Javascript runtime does not support the '{0}' function.",
        Unknown_rule: "Unknown rule.",
        Invalid_line_number_0: "Invalid line number ({0})",
        Warn_on_expressions_and_declarations_with_an_implied_any_type: "Warn on expressions and declarations with an implied 'any' type.",
        Variable_0_implicitly_has_an_any_type: "Variable '{0}' implicitly has an 'any' type.",
        Parameter_0_of_1_implicitly_has_an_any_type: "Parameter '{0}' of '{1}' implicitly has an 'any' type.",
        Parameter_0_of_function_type_implicitly_has_an_any_type: "Parameter '{0}' of function type implicitly has an 'any' type.",
        Member_0_of_object_type_implicitly_has_an_any_type: "Member '{0}' of object type implicitly has an 'any' type.",
        new_expression_which_lacks_a_constructor_signature_implicitly_has_an_any_type: "'new' expression, which lacks a constructor signature, implicitly has an 'any' type.",
        _0_which_lacks_return_type_annotation_implicitly_has_an_any_return_type: "'{0}', which lacks return-type annotation, implicitly has an 'any' return type.",
        Function_expression_which_lacks_return_type_annotation_implicitly_has_an_any_return_type: "Function expression, which lacks return-type annotation, implicitly has an 'any' return type.",
        Parameter_0_of_lambda_function_implicitly_has_an_any_type: "Parameter '{0}' of lambda function implicitly has an 'any' type.",
        Constructor_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type: "Constructor signature, which lacks return-type annotation, implicitly has an 'any' return type.",
        Lambda_Function_which_lacks_return_type_annotation_implicitly_has_an_any_return_type: "Lambda Function, which lacks return-type annotation, implicitly has an 'any' return type.",
        Array_Literal_implicitly_has_an_any_type_from_widening: "Array Literal implicitly has an 'any' type from widening.",
        _0_which_lacks_get_accessor_and_parameter_type_annotation_on_set_accessor_implicitly_has_an_any_type: "'{0}', which lacks 'get' accessor and parameter type annotation on 'set' accessor, implicitly has an 'any' type.",
        Index_signature_of_object_type_implicitly_has_an_any_type: "Index signature of object type implicitly has an 'any' type.",
        Object_literal_s_property_0_implicitly_has_an_any_type_from_widening: "Object literal's property '{0}' implicitly has an 'any' type from widening."
    };
})(TypeScript || (TypeScript = {}));
///<reference path='references.ts' />
var TypeScript;
(function (TypeScript) {
    (function (DiagnosticCategory) {
        DiagnosticCategory[DiagnosticCategory["Warning"] = 0] = "Warning";
        DiagnosticCategory[DiagnosticCategory["Error"] = 1] = "Error";
        DiagnosticCategory[DiagnosticCategory["Message"] = 2] = "Message";
        DiagnosticCategory[DiagnosticCategory["NoPrefix"] = 3] = "NoPrefix";
    })(TypeScript.DiagnosticCategory || (TypeScript.DiagnosticCategory = {}));
    var DiagnosticCategory = TypeScript.DiagnosticCategory;
})(TypeScript || (TypeScript = {}));
// <auto-generated />
/// <reference path="..\core\diagnosticCategory.ts" />
var TypeScript;
(function (TypeScript) {
    TypeScript.diagnosticInformationMap = {
        "error TS{0}: {1}": { "code": 0, "category": 3 /* NoPrefix */ },
        "warning TS{0}: {1}": { "code": 1, "category": 3 /* NoPrefix */ },
        "Unrecognized escape sequence.": { "code": 1000, "category": 1 /* Error */ },
        "Unexpected character {0}.": { "code": 1001, "category": 1 /* Error */ },
        "Missing close quote character.": { "code": 1002, "category": 1 /* Error */ },
        "Identifier expected.": { "code": 1003, "category": 1 /* Error */ },
        "'{0}' keyword expected.": { "code": 1004, "category": 1 /* Error */ },
        "'{0}' expected.": { "code": 1005, "category": 1 /* Error */ },
        "Identifier expected; '{0}' is a keyword.": { "code": 1006, "category": 1 /* Error */ },
        "Automatic semicolon insertion not allowed.": { "code": 1007, "category": 1 /* Error */ },
        "Unexpected token; '{0}' expected.": { "code": 1008, "category": 1 /* Error */ },
        "Trailing comma not allowed.": { "code": 1009, "category": 1 /* Error */ },
        "'*/' expected.": { "code": 1010, "category": 1 /* Error */ },
        "'public' or 'private' modifier must precede 'static'.": { "code": 1011, "category": 1 /* Error */ },
        "Unexpected token.": { "code": 1012, "category": 1 /* Error */ },
        "Catch clause parameter cannot have a type annotation.": { "code": 1013, "category": 1 /* Error */ },
        "A rest parameter must be last in a parameter list.": { "code": 1014, "category": 1 /* Error */ },
        "Parameter cannot have question mark and initializer.": { "code": 1015, "category": 1 /* Error */ },
        "A required parameter cannot follow an optional parameter.": { "code": 1016, "category": 1 /* Error */ },
        "Index signatures cannot have rest parameters.": { "code": 1017, "category": 1 /* Error */ },
        "Index signature parameter cannot have accessibility modifiers.": { "code": 1018, "category": 1 /* Error */ },
        "Index signature parameter cannot have a question mark.": { "code": 1019, "category": 1 /* Error */ },
        "Index signature parameter cannot have an initializer.": { "code": 1020, "category": 1 /* Error */ },
        "Index signature must have a type annotation.": { "code": 1021, "category": 1 /* Error */ },
        "Index signature parameter must have a type annotation.": { "code": 1022, "category": 1 /* Error */ },
        "Index signature parameter type must be 'string' or 'number'.": { "code": 1023, "category": 1 /* Error */ },
        "'extends' clause already seen.": { "code": 1024, "category": 1 /* Error */ },
        "'extends' clause must precede 'implements' clause.": { "code": 1025, "category": 1 /* Error */ },
        "Classes can only extend a single class.": { "code": 1026, "category": 1 /* Error */ },
        "'implements' clause already seen.": { "code": 1027, "category": 1 /* Error */ },
        "Accessibility modifier already seen.": { "code": 1028, "category": 1 /* Error */ },
        "'{0}' modifier must precede '{1}' modifier.": { "code": 1029, "category": 1 /* Error */ },
        "'{0}' modifier already seen.": { "code": 1030, "category": 1 /* Error */ },
        "'{0}' modifier cannot appear on a class element.": { "code": 1031, "category": 1 /* Error */ },
        "Interface declaration cannot have 'implements' clause.": { "code": 1032, "category": 1 /* Error */ },
        "'super' invocation cannot have type arguments.": { "code": 1034, "category": 1 /* Error */ },
        "Only ambient modules can use quoted names.": { "code": 1035, "category": 1 /* Error */ },
        "Statements are not allowed in ambient contexts.": { "code": 1036, "category": 1 /* Error */ },
        "A function implementation cannot be declared in an ambient context.": { "code": 1037, "category": 1 /* Error */ },
        "A 'declare' modifier cannot be used in an already ambient context.": { "code": 1038, "category": 1 /* Error */ },
        "Initializers are not allowed in ambient contexts.": { "code": 1039, "category": 1 /* Error */ },
        "'{0}' modifier cannot appear on a module element.": { "code": 1044, "category": 1 /* Error */ },
        "A 'declare' modifier cannot be used with an interface declaration.": { "code": 1045, "category": 1 /* Error */ },
        "A 'declare' modifier is required for a top level declaration in a .d.ts file.": { "code": 1046, "category": 1 /* Error */ },
        "A rest parameter cannot be optional.": { "code": 1047, "category": 1 /* Error */ },
        "A rest parameter cannot have an initializer.": { "code": 1048, "category": 1 /* Error */ },
        "'set' accessor must have exactly one parameter.": { "code": 1049, "category": 1 /* Error */ },
        "'set' accessor parameter cannot be optional.": { "code": 1051, "category": 1 /* Error */ },
        "'set' accessor parameter cannot have an initializer.": { "code": 1052, "category": 1 /* Error */ },
        "'set' accessor cannot have rest parameter.": { "code": 1053, "category": 1 /* Error */ },
        "'get' accessor cannot have parameters.": { "code": 1054, "category": 1 /* Error */ },
        "Modifiers cannot appear here.": { "code": 1055, "category": 1 /* Error */ },
        "Accessors are only available when targeting ECMAScript 5 and higher.": { "code": 1056, "category": 1 /* Error */ },
        "Enum member must have initializer.": { "code": 1061, "category": 1 /* Error */ },
        "Export assignment cannot be used in internal modules.": { "code": 1063, "category": 1 /* Error */ },
        "Ambient enum elements can only have integer literal initializers.": { "code": 1066, "category": 1 /* Error */ },
        "module, class, interface, enum, import or statement": { "code": 1067, "category": 3 /* NoPrefix */ },
        "constructor, function, accessor or variable": { "code": 1068, "category": 3 /* NoPrefix */ },
        "statement": { "code": 1069, "category": 3 /* NoPrefix */ },
        "case or default clause": { "code": 1070, "category": 3 /* NoPrefix */ },
        "identifier": { "code": 1071, "category": 3 /* NoPrefix */ },
        "call, construct, index, property or function signature": { "code": 1072, "category": 3 /* NoPrefix */ },
        "expression": { "code": 1073, "category": 3 /* NoPrefix */ },
        "type name": { "code": 1074, "category": 3 /* NoPrefix */ },
        "property or accessor": { "code": 1075, "category": 3 /* NoPrefix */ },
        "parameter": { "code": 1076, "category": 3 /* NoPrefix */ },
        "type": { "code": 1077, "category": 3 /* NoPrefix */ },
        "type parameter": { "code": 1078, "category": 3 /* NoPrefix */ },
        "A 'declare' modifier cannot be used with an import declaration.": { "code": 1079, "category": 1 /* Error */ },
        "Invalid 'reference' directive syntax.": { "code": 1084, "category": 1 /* Error */ },
        "Octal literals are not available when targeting ECMAScript 5 and higher.": { "code": 1085, "category": 1 /* Error */ },
        "Accessors are not allowed in ambient contexts.": { "code": 1086, "category": 1 /* Error */ },
        "'{0}' modifier cannot appear on a constructor declaration.": { "code": 1089, "category": 1 /* Error */ },
        "'{0}' modifier cannot appear on a parameter.": { "code": 1090, "category": 1 /* Error */ },
        "Only a single variable declaration is allowed in a 'for...in' statement.": { "code": 1091, "category": 1 /* Error */ },
        "Type parameters cannot appear on a constructor declaration.": { "code": 1092, "category": 1 /* Error */ },
        "Type annotation cannot appear on a constructor declaration.": { "code": 1093, "category": 1 /* Error */ },
        "Type parameters cannot appear on an accessor.": { "code": 1094, "category": 1 /* Error */ },
        "Type annotation cannot appear on a 'set' accessor.": { "code": 1095, "category": 1 /* Error */ },
        "Index signature must have exactly one parameter.": { "code": 1096, "category": 1 /* Error */ },
        "'{0}' list cannot be empty.": { "code": 1097, "category": 1 /* Error */ },
        "variable declaration": { "code": 1098, "category": 3 /* NoPrefix */ },
        "type argument": { "code": 1099, "category": 3 /* NoPrefix */ },
        "Invalid use of '{0}' in strict mode.": { "code": 1100, "category": 1 /* Error */ },
        "'with' statements are not allowed in strict mode.": { "code": 1101, "category": 1 /* Error */ },
        "'delete' cannot be called on an identifier in strict mode.": { "code": 1102, "category": 1 /* Error */ },
        "Invalid left-hand side in 'for...in' statement.": { "code": 1103, "category": 1 /* Error */ },
        "'continue' statement can only be used within an enclosing iteration statement.": { "code": 1104, "category": 1 /* Error */ },
        "'break' statement can only be used within an enclosing iteration or switch statement.": { "code": 1105, "category": 1 /* Error */ },
        "Jump target not found.": { "code": 1106, "category": 1 /* Error */ },
        "Jump target cannot cross function boundary.": { "code": 1107, "category": 1 /* Error */ },
        "'return' statement must be contained within a function body.": { "code": 1108, "category": 1 /* Error */ },
        "Expression expected.": { "code": 1109, "category": 1 /* Error */ },
        "Type expected.": { "code": 1110, "category": 1 /* Error */ },
        "Duplicate identifier '{0}'.": { "code": 2000, "category": 1 /* Error */ },
        "The name '{0}' does not exist in the current scope.": { "code": 2001, "category": 1 /* Error */ },
        "The name '{0}' does not refer to a value.": { "code": 2002, "category": 1 /* Error */ },
        "'super' can only be used inside a class instance method.": { "code": 2003, "category": 1 /* Error */ },
        "The left-hand side of an assignment expression must be a variable, property or indexer.": { "code": 2004, "category": 1 /* Error */ },
        "Value of type '{0}' is not callable. Did you mean to include 'new'?": { "code": 2161, "category": 1 /* Error */ },
        "Value of type '{0}' is not callable.": { "code": 2006, "category": 1 /* Error */ },
        "Value of type '{0}' is not newable.": { "code": 2007, "category": 1 /* Error */ },
        "An index expression argument must be 'string', 'number', or 'any'.": { "code": 2008, "category": 1 /* Error */ },
        "Operator '{0}' cannot be applied to types '{1}' and '{2}'.": { "code": 2009, "category": 1 /* Error */ },
        "Type '{0}' is not assignable to type '{1}'.": { "code": 2011, "category": 1 /* Error */ },
        "Type '{0}' is not assignable to type '{1}':{NL}{2}": { "code": 2012, "category": 1 /* Error */ },
        "Expected var, class, interface, or module.": { "code": 2013, "category": 1 /* Error */ },
        "Getter '{0}' already declared.": { "code": 2015, "category": 1 /* Error */ },
        "Setter '{0}' already declared.": { "code": 2016, "category": 1 /* Error */ },
        "Exported class '{0}' extends private class '{1}'.": { "code": 2018, "category": 1 /* Error */ },
        "Exported class '{0}' implements private interface '{1}'.": { "code": 2019, "category": 1 /* Error */ },
        "Exported interface '{0}' extends private interface '{1}'.": { "code": 2020, "category": 1 /* Error */ },
        "Exported class '{0}' extends class from inaccessible module {1}.": { "code": 2021, "category": 1 /* Error */ },
        "Exported class '{0}' implements interface from inaccessible module {1}.": { "code": 2022, "category": 1 /* Error */ },
        "Exported interface '{0}' extends interface from inaccessible module {1}.": { "code": 2023, "category": 1 /* Error */ },
        "Public static property '{0}' of exported class has or is using private type '{1}'.": { "code": 2024, "category": 1 /* Error */ },
        "Public property '{0}' of exported class has or is using private type '{1}'.": { "code": 2025, "category": 1 /* Error */ },
        "Property '{0}' of exported interface has or is using private type '{1}'.": { "code": 2026, "category": 1 /* Error */ },
        "Exported variable '{0}' has or is using private type '{1}'.": { "code": 2027, "category": 1 /* Error */ },
        "Public static property '{0}' of exported class is using inaccessible module {1}.": { "code": 2028, "category": 1 /* Error */ },
        "Public property '{0}' of exported class is using inaccessible module {1}.": { "code": 2029, "category": 1 /* Error */ },
        "Property '{0}' of exported interface is using inaccessible module {1}.": { "code": 2030, "category": 1 /* Error */ },
        "Exported variable '{0}' is using inaccessible module {1}.": { "code": 2031, "category": 1 /* Error */ },
        "Parameter '{0}' of constructor from exported class has or is using private type '{1}'.": { "code": 2032, "category": 1 /* Error */ },
        "Parameter '{0}' of public static property setter from exported class has or is using private type '{1}'.": { "code": 2033, "category": 1 /* Error */ },
        "Parameter '{0}' of public property setter from exported class has or is using private type '{1}'.": { "code": 2034, "category": 1 /* Error */ },
        "Parameter '{0}' of constructor signature from exported interface has or is using private type '{1}'.": { "code": 2035, "category": 1 /* Error */ },
        "Parameter '{0}' of call signature from exported interface has or is using private type '{1}'.": { "code": 2036, "category": 1 /* Error */ },
        "Parameter '{0}' of public static method from exported class has or is using private type '{1}'.": { "code": 2037, "category": 1 /* Error */ },
        "Parameter '{0}' of public method from exported class has or is using private type '{1}'.": { "code": 2038, "category": 1 /* Error */ },
        "Parameter '{0}' of method from exported interface has or is using private type '{1}'.": { "code": 2039, "category": 1 /* Error */ },
        "Parameter '{0}' of exported function has or is using private type '{1}'.": { "code": 2040, "category": 1 /* Error */ },
        "Parameter '{0}' of constructor from exported class is using inaccessible module {1}.": { "code": 2041, "category": 1 /* Error */ },
        "Parameter '{0}' of public static property setter from exported class is using inaccessible module {1}.": { "code": 2042, "category": 1 /* Error */ },
        "Parameter '{0}' of public property setter from exported class is using inaccessible module {1}.": { "code": 2043, "category": 1 /* Error */ },
        "Parameter '{0}' of constructor signature from exported interface is using inaccessible module {1}.": { "code": 2044, "category": 1 /* Error */ },
        "Parameter '{0}' of call signature from exported interface is using inaccessible module {1}": { "code": 2045, "category": 1 /* Error */ },
        "Parameter '{0}' of public static method from exported class is using inaccessible module {1}.": { "code": 2046, "category": 1 /* Error */ },
        "Parameter '{0}' of public method from exported class is using inaccessible module {1}.": { "code": 2047, "category": 1 /* Error */ },
        "Parameter '{0}' of method from exported interface is using inaccessible module {1}.": { "code": 2048, "category": 1 /* Error */ },
        "Parameter '{0}' of exported function is using inaccessible module {1}.": { "code": 2049, "category": 1 /* Error */ },
        "Return type of public static property getter from exported class has or is using private type '{0}'.": { "code": 2050, "category": 1 /* Error */ },
        "Return type of public property getter from exported class has or is using private type '{0}'.": { "code": 2051, "category": 1 /* Error */ },
        "Return type of constructor signature from exported interface has or is using private type '{0}'.": { "code": 2052, "category": 1 /* Error */ },
        "Return type of call signature from exported interface has or is using private type '{0}'.": { "code": 2053, "category": 1 /* Error */ },
        "Return type of index signature from exported interface has or is using private type '{0}'.": { "code": 2054, "category": 1 /* Error */ },
        "Return type of public static method from exported class has or is using private type '{0}'.": { "code": 2055, "category": 1 /* Error */ },
        "Return type of public method from exported class has or is using private type '{0}'.": { "code": 2056, "category": 1 /* Error */ },
        "Return type of method from exported interface has or is using private type '{0}'.": { "code": 2057, "category": 1 /* Error */ },
        "Return type of exported function has or is using private type '{0}'.": { "code": 2058, "category": 1 /* Error */ },
        "Return type of public static property getter from exported class is using inaccessible module {0}.": { "code": 2059, "category": 1 /* Error */ },
        "Return type of public property getter from exported class is using inaccessible module {0}.": { "code": 2060, "category": 1 /* Error */ },
        "Return type of constructor signature from exported interface is using inaccessible module {0}.": { "code": 2061, "category": 1 /* Error */ },
        "Return type of call signature from exported interface is using inaccessible module {0}.": { "code": 2062, "category": 1 /* Error */ },
        "Return type of index signature from exported interface is using inaccessible module {0}.": { "code": 2063, "category": 1 /* Error */ },
        "Return type of public static method from exported class is using inaccessible module {0}.": { "code": 2064, "category": 1 /* Error */ },
        "Return type of public method from exported class is using inaccessible module {0}.": { "code": 2065, "category": 1 /* Error */ },
        "Return type of method from exported interface is using inaccessible module {0}.": { "code": 2066, "category": 1 /* Error */ },
        "Return type of exported function is using inaccessible module {0}.": { "code": 2067, "category": 1 /* Error */ },
        "'new T[]' cannot be used to create an array. Use 'new Array<T>()' instead.": { "code": 2068, "category": 1 /* Error */ },
        "A parameter list must follow a generic type argument list. '(' expected.": { "code": 2069, "category": 1 /* Error */ },
        "Multiple constructor implementations are not allowed.": { "code": 2070, "category": 1 /* Error */ },
        "Cannot find external module '{0}'.": { "code": 2071, "category": 1 /* Error */ },
        "Module cannot be aliased to a non-module type.": { "code": 2072, "category": 1 /* Error */ },
        "A class may only extend another class.": { "code": 2073, "category": 1 /* Error */ },
        "A class may only implement another class or interface.": { "code": 2074, "category": 1 /* Error */ },
        "An interface may only extend a class or another interface.": { "code": 2075, "category": 1 /* Error */ },
        "Unable to resolve type.": { "code": 2077, "category": 1 /* Error */ },
        "Unable to resolve type of '{0}'.": { "code": 2078, "category": 1 /* Error */ },
        "Unable to resolve type parameter constraint.": { "code": 2079, "category": 1 /* Error */ },
        "Type parameter constraint cannot be a primitive type.": { "code": 2080, "category": 1 /* Error */ },
        "Supplied parameters do not match any signature of call target.": { "code": 2081, "category": 1 /* Error */ },
        "Supplied parameters do not match any signature of call target:{NL}{0}": { "code": 2082, "category": 1 /* Error */ },
        "Cannot use 'new' with an expression whose type lacks a signature.": { "code": 2083, "category": 1 /* Error */ },
        "Only a void function can be called with the 'new' keyword.": { "code": 2084, "category": 1 /* Error */ },
        "Could not select overload for 'new' expression.": { "code": 2085, "category": 1 /* Error */ },
        "Type '{0}' does not satisfy the constraint '{1}'.": { "code": 2086, "category": 1 /* Error */ },
        "Could not select overload for 'call' expression.": { "code": 2087, "category": 1 /* Error */ },
        "Cannot invoke an expression whose type lacks a call signature.": { "code": 2088, "category": 1 /* Error */ },
        "Calls to 'super' are only valid inside a class.": { "code": 2089, "category": 1 /* Error */ },
        "Generic type '{0}' requires {1} type argument(s).": { "code": 2090, "category": 1 /* Error */ },
        "Type of array literal cannot be determined. Best common type could not be found for array elements.": { "code": 2092, "category": 1 /* Error */ },
        "Could not find enclosing symbol for dotted name '{0}'.": { "code": 2093, "category": 1 /* Error */ },
        "Property '{0}' does not exist on value of type '{1}'.": { "code": 2094, "category": 1 /* Error */ },
        "Cannot find name '{0}'.": { "code": 2095, "category": 1 /* Error */ },
        "'get' and 'set' accessor must have the same type.": { "code": 2096, "category": 1 /* Error */ },
        "'this' cannot be referenced in current location.": { "code": 2097, "category": 1 /* Error */ },
        "Static members cannot reference class type parameters.": { "code": 2099, "category": 1 /* Error */ },
        "Type '{0}' recursively references itself as a base type.": { "code": 2100, "category": 1 /* Error */ },
        "'super' property access is permitted only in a constructor, member function, or member accessor of a derived class.": { "code": 2102, "category": 1 /* Error */ },
        "'super' can only be referenced in a derived class.": { "code": 2103, "category": 1 /* Error */ },
        "A 'super' call must be the first statement in the constructor when a class contains initialized properties or has parameter properties.": { "code": 2104, "category": 1 /* Error */ },
        "Constructors for derived classes must contain a 'super' call.": { "code": 2105, "category": 1 /* Error */ },
        "Super calls are not permitted outside constructors or in nested functions inside constructors.": { "code": 2106, "category": 1 /* Error */ },
        "'{0}.{1}' is inaccessible.": { "code": 2107, "category": 1 /* Error */ },
        "'this' cannot be referenced in a module body.": { "code": 2108, "category": 1 /* Error */ },
        "Invalid '+' expression - types not known to support the addition operator.": { "code": 2111, "category": 1 /* Error */ },
        "The right-hand side of an arithmetic operation must be of type 'any', 'number' or an enum type.": { "code": 2112, "category": 1 /* Error */ },
        "The left-hand side of an arithmetic operation must be of type 'any', 'number' or an enum type.": { "code": 2113, "category": 1 /* Error */ },
        "An arithmetic operand must be of type 'any', 'number' or an enum type.": { "code": 2114, "category": 1 /* Error */ },
        "Variable declarations of a 'for' statement cannot use a type annotation.": { "code": 2115, "category": 1 /* Error */ },
        "Variable declarations of a 'for' statement must be of types 'string' or 'any'.": { "code": 2116, "category": 1 /* Error */ },
        "The right-hand side of a 'for...in' statement must be of type 'any', an object type or a type parameter.": { "code": 2117, "category": 1 /* Error */ },
        "The left-hand side of an 'in' expression must be of types 'any', 'string' or 'number'.": { "code": 2118, "category": 1 /* Error */ },
        "The right-hand side of an 'in' expression must be of type 'any', an object type or a type parameter.": { "code": 2119, "category": 1 /* Error */ },
        "The left-hand side of an 'instanceof' expression must be of type 'any', an object type or a type parameter.": { "code": 2120, "category": 1 /* Error */ },
        "The right-hand side of an 'instanceof' expression must be of type 'any' or of a type assignable to the 'Function' interface type.": { "code": 2121, "category": 1 /* Error */ },
        "Setters cannot return a value.": { "code": 2122, "category": 1 /* Error */ },
        "Tried to query type of uninitialized module '{0}'.": { "code": 2123, "category": 1 /* Error */ },
        "Tried to set variable type to uninitialized module type '{0}'.": { "code": 2124, "category": 1 /* Error */ },
        "Type '{0}' is not generic.": { "code": 2125, "category": 1 /* Error */ },
        "Getters must return a value.": { "code": 2126, "category": 1 /* Error */ },
        "Getter and setter accessors do not agree in visibility.": { "code": 2127, "category": 1 /* Error */ },
        "Invalid left-hand side of assignment expression.": { "code": 2130, "category": 1 /* Error */ },
        "Function declared a non-void return type, but has no return expression.": { "code": 2131, "category": 1 /* Error */ },
        "Cannot resolve return type reference.": { "code": 2132, "category": 1 /* Error */ },
        "Constructors cannot have a return type of 'void'.": { "code": 2133, "category": 1 /* Error */ },
        "Subsequent variable declarations must have the same type.  Variable '{0}' must be of type '{1}', but here has type '{2}'.": { "code": 2134, "category": 1 /* Error */ },
        "All symbols within a with block will be resolved to 'any'.": { "code": 2135, "category": 1 /* Error */ },
        "Import declarations in an internal module cannot reference an external module.": { "code": 2136, "category": 1 /* Error */ },
        "Class {0} declares interface {1} but does not implement it:{NL}{2}": { "code": 2137, "category": 1 /* Error */ },
        "Class {0} declares class {1} as an interface but does not implement it:{NL}{2}": { "code": 2138, "category": 1 /* Error */ },
        "The operand of an increment or decrement operator must be a variable, property or indexer.": { "code": 2139, "category": 1 /* Error */ },
        "'this' cannot be referenced in a static property initializer.": { "code": 2140, "category": 1 /* Error */ },
        "Class '{0}' cannot extend class '{1}':{NL}{2}": { "code": 2141, "category": 1 /* Error */ },
        "Interface '{0}' cannot extend class '{1}':{NL}{2}": { "code": 2142, "category": 1 /* Error */ },
        "Interface '{0}' cannot extend interface '{1}':{NL}{2}": { "code": 2143, "category": 1 /* Error */ },
        "Overload signature is not compatible with function definition.": { "code": 2148, "category": 1 /* Error */ },
        "Overload signature is not compatible with function definition:{NL}{0}": { "code": 2149, "category": 1 /* Error */ },
        "Overload signatures must all be public or private.": { "code": 2150, "category": 1 /* Error */ },
        "Overload signatures must all be exported or not exported.": { "code": 2151, "category": 1 /* Error */ },
        "Overload signatures must all be ambient or non-ambient.": { "code": 2152, "category": 1 /* Error */ },
        "Overload signatures must all be optional or required.": { "code": 2153, "category": 1 /* Error */ },
        "Specialized overload signature is not assignable to any non-specialized signature.": { "code": 2154, "category": 1 /* Error */ },
        "'this' cannot be referenced in constructor arguments.": { "code": 2155, "category": 1 /* Error */ },
        "Instance member cannot be accessed off a class.": { "code": 2157, "category": 1 /* Error */ },
        "Untyped function calls may not accept type arguments.": { "code": 2158, "category": 1 /* Error */ },
        "Non-generic functions may not accept type arguments.": { "code": 2159, "category": 1 /* Error */ },
        "A generic type may not reference itself with a wrapped form of its own type parameters.": { "code": 2160, "category": 1 /* Error */ },
        "A rest parameter must be of an array type.": { "code": 2162, "category": 1 /* Error */ },
        "Overload signature implementation cannot use specialized type.": { "code": 2163, "category": 1 /* Error */ },
        "Export assignments may only be used at the top-level of external modules.": { "code": 2164, "category": 1 /* Error */ },
        "Export assignments may only be made with variables, functions, classes, interfaces, enums and internal modules.": { "code": 2165, "category": 1 /* Error */ },
        "Only public methods of the base class are accessible via the 'super' keyword.": { "code": 2166, "category": 1 /* Error */ },
        "Numeric indexer type '{0}' must be assignable to string indexer type '{1}'.": { "code": 2167, "category": 1 /* Error */ },
        "Numeric indexer type '{0}' must be assignable to string indexer type '{1}':{NL}{2}": { "code": 2168, "category": 1 /* Error */ },
        "All numerically named properties must be assignable to numeric indexer type '{0}'.": { "code": 2169, "category": 1 /* Error */ },
        "All numerically named properties must be assignable to numeric indexer type '{0}':{NL}{1}": { "code": 2170, "category": 1 /* Error */ },
        "All named properties must be assignable to string indexer type '{0}'.": { "code": 2171, "category": 1 /* Error */ },
        "All named properties must be assignable to string indexer type '{0}':{NL}{1}": { "code": 2172, "category": 1 /* Error */ },
        "A parameter initializer is only allowed in a function or constructor implementation.": { "code": 2174, "category": 1 /* Error */ },
        "Function expression declared a non-void return type, but has no return expression.": { "code": 2176, "category": 1 /* Error */ },
        "Import declaration referencing identifier from internal module can only be made with variables, functions, classes, interfaces, enums and internal modules.": { "code": 2177, "category": 1 /* Error */ },
        "Module '{0}' has no exported member '{1}'.": { "code": 2178, "category": 1 /* Error */ },
        "Unable to resolve module reference '{0}'.": { "code": 2179, "category": 1 /* Error */ },
        "Could not find module '{0}' in module '{1}'.": { "code": 2180, "category": 1 /* Error */ },
        "Exported import declaration '{0}' is assigned value with type that has or is using private type '{1}'.": { "code": 2181, "category": 1 /* Error */ },
        "Exported import declaration '{0}' is assigned value with type that is using inaccessible module '{1}'.": { "code": 2182, "category": 1 /* Error */ },
        "Exported import declaration '{0}' is assigned type that has or is using private type '{1}'.": { "code": 2183, "category": 1 /* Error */ },
        "Exported import declaration '{0}' is assigned type that is using inaccessible module '{1}'.": { "code": 2184, "category": 1 /* Error */ },
        "Exported import declaration '{0}' is assigned container that is or is using inaccessible module '{1}'.": { "code": 2185, "category": 1 /* Error */ },
        "Type name '{0}' in extends clause does not reference constructor function for '{1}'.": { "code": 2186, "category": 1 /* Error */ },
        "Internal module reference '{0}' in import declaration does not reference module instance for '{1}'.": { "code": 2187, "category": 1 /* Error */ },
        "Module '{0}' cannot merge with previous declaration of '{1}' in a different file '{2}'.": { "code": 2188, "category": 1 /* Error */ },
        "Interface '{0}' cannot simultaneously extend types '{1}' and '{2}':{NL}{3}": { "code": 2189, "category": 1 /* Error */ },
        "Initializer of parameter '{0}' cannot reference identifier '{1}' declared after it.": { "code": 2190, "category": 1 /* Error */ },
        "Ambient external module declaration cannot be reopened.": { "code": 2191, "category": 1 /* Error */ },
        "All declarations of merged declaration '{0}' must be exported or not exported.": { "code": 2192, "category": 1 /* Error */ },
        "'super' cannot be referenced in constructor arguments.": { "code": 2193, "category": 1 /* Error */ },
        "Return type of constructor signature must be assignable to the instance type of the class.": { "code": 2194, "category": 1 /* Error */ },
        "Ambient external module declaration must be defined in global context.": { "code": 2195, "category": 1 /* Error */ },
        "Ambient external module declaration cannot specify relative module name.": { "code": 2196, "category": 1 /* Error */ },
        "Import declaration in an ambient external module declaration cannot reference external module through relative external module name.": { "code": 2197, "category": 1 /* Error */ },
        "No best common type exists among return expressions.": { "code": 2198, "category": 1 /* Error */ },
        "Import declaration cannot refer to external module reference when --noResolve option is set.": { "code": 2199, "category": 1 /* Error */ },
        "Duplicate identifier '_this'. Compiler uses variable declaration '_this' to capture 'this' reference.": { "code": 2200, "category": 1 /* Error */ },
        "Duplicate identifier '_super'. Compiler uses '_super' to capture base class reference.": { "code": 2205, "category": 1 /* Error */ },
        "Expression resolves to variable declaration '_this' that compiler uses to capture 'this' reference.": { "code": 2206, "category": 1 /* Error */ },
        "Expression resolves to '_super' that compiler uses to capture base class reference.": { "code": 2207, "category": 1 /* Error */ },
        "TypeParameter '{0}' of constructor signature from exported interface has or is using private type '{1}'.": { "code": 2208, "category": 1 /* Error */ },
        "TypeParameter '{0}' of call signature from exported interface has or is using private type '{1}'.": { "code": 2209, "category": 1 /* Error */ },
        "TypeParameter '{0}' of public static method from exported class has or is using private type '{1}'.": { "code": 2210, "category": 1 /* Error */ },
        "TypeParameter '{0}' of public method from exported class has or is using private type '{1}'.": { "code": 2211, "category": 1 /* Error */ },
        "TypeParameter '{0}' of method from exported interface has or is using private type '{1}'.": { "code": 2212, "category": 1 /* Error */ },
        "TypeParameter '{0}' of exported function has or is using private type '{1}'.": { "code": 2213, "category": 1 /* Error */ },
        "TypeParameter '{0}' of constructor signature from exported interface is using inaccessible module {1}.": { "code": 2214, "category": 1 /* Error */ },
        "TypeParameter '{0}' of call signature from exported interface is using inaccessible module {1}": { "code": 2215, "category": 1 /* Error */ },
        "TypeParameter '{0}' of public static method from exported class is using inaccessible module {1}.": { "code": 2216, "category": 1 /* Error */ },
        "TypeParameter '{0}' of public method from exported class is using inaccessible module {1}.": { "code": 2217, "category": 1 /* Error */ },
        "TypeParameter '{0}' of method from exported interface is using inaccessible module {1}.": { "code": 2218, "category": 1 /* Error */ },
        "TypeParameter '{0}' of exported function is using inaccessible module {1}.": { "code": 2219, "category": 1 /* Error */ },
        "TypeParameter '{0}' of exported class has or is using private type '{1}'.": { "code": 2220, "category": 1 /* Error */ },
        "TypeParameter '{0}' of exported interface has or is using private type '{1}'.": { "code": 2221, "category": 1 /* Error */ },
        "TypeParameter '{0}' of exported class is using inaccessible module {1}.": { "code": 2222, "category": 1 /* Error */ },
        "TypeParameter '{0}' of exported interface is using inaccessible module {1}.": { "code": 2223, "category": 1 /* Error */ },
        "Duplicate identifier '_i'. Compiler uses '_i' to initialize rest parameter.": { "code": 2224, "category": 1 /* Error */ },
        "Duplicate identifier 'arguments'. Compiler uses 'arguments' to initialize rest parameters.": { "code": 2225, "category": 1 /* Error */ },
        "No best common type exists between '{0}' and '{1}'.": { "code": 2226, "category": 1 /* Error */ },
        "No best common type exists between '{0}', '{1}', and '{2}'.": { "code": 2227, "category": 1 /* Error */ },
        "Duplicate identifier '{0}'. Compiler reserves name '{1}' in top level scope of an external module.": { "code": 2228, "category": 1 /* Error */ },
        "Constraint of a type parameter cannot reference any type parameter from the same type parameter list.": { "code": 2229, "category": 1 /* Error */ },
        "Initializer of instance member variable '{0}' cannot reference identifier '{1}' declared in the constructor.": { "code": 2230, "category": 1 /* Error */ },
        "Parameter '{0}' cannot be referenced in its initializer.": { "code": 2231, "category": 1 /* Error */ },
        "Duplicate string index signature.": { "code": 2232, "category": 1 /* Error */ },
        "Duplicate number index signature.": { "code": 2233, "category": 1 /* Error */ },
        "All declarations of an interface must have identical type parameters.": { "code": 2234, "category": 1 /* Error */ },
        "Expression resolves to variable declaration '_i' that compiler uses to initialize rest parameter.": { "code": 2235, "category": 1 /* Error */ },
        "Neither type '{0}' nor type '{1}' is assignable to the other.": { "code": 2236, "category": 1 /* Error */ },
        "Neither type '{0}' nor type '{1}' is assignable to the other:{NL}{2}": { "code": 2237, "category": 1 /* Error */ },
        "Duplicate function implementation.": { "code": 2237, "category": 1 /* Error */ },
        "Function implementation expected.": { "code": 2238, "category": 1 /* Error */ },
        "Function overload name must be '{0}'.": { "code": 2239, "category": 1 /* Error */ },
        "Constructor implementation expected.": { "code": 2240, "category": 1 /* Error */ },
        "Class name cannot be '{0}'.": { "code": 2241, "category": 1 /* Error */ },
        "Interface name cannot be '{0}'.": { "code": 2242, "category": 1 /* Error */ },
        "Enum name cannot be '{0}'.": { "code": 2243, "category": 1 /* Error */ },
        "A module cannot have multiple export assignments.": { "code": 2244, "category": 1 /* Error */ },
        "Export assignment not allowed in module with exported element.": { "code": 2245, "category": 1 /* Error */ },
        "A parameter property is only allowed in a constructor implementation.": { "code": 2246, "category": 1 /* Error */ },
        "Function overload must be static.": { "code": 2247, "category": 1 /* Error */ },
        "Function overload must not be static.": { "code": 2248, "category": 1 /* Error */ },
        "Type '{0}' is missing property '{1}' from type '{2}'.": { "code": 4000, "category": 3 /* NoPrefix */ },
        "Types of property '{0}' of types '{1}' and '{2}' are incompatible.": { "code": 4001, "category": 3 /* NoPrefix */ },
        "Types of property '{0}' of types '{1}' and '{2}' are incompatible:{NL}{3}": { "code": 4002, "category": 3 /* NoPrefix */ },
        "Property '{0}' defined as private in type '{1}' is defined as public in type '{2}'.": { "code": 4003, "category": 3 /* NoPrefix */ },
        "Property '{0}' defined as public in type '{1}' is defined as private in type '{2}'.": { "code": 4004, "category": 3 /* NoPrefix */ },
        "Types '{0}' and '{1}' define property '{2}' as private.": { "code": 4005, "category": 3 /* NoPrefix */ },
        "Call signatures of types '{0}' and '{1}' are incompatible.": { "code": 4006, "category": 3 /* NoPrefix */ },
        "Call signatures of types '{0}' and '{1}' are incompatible:{NL}{2}": { "code": 4007, "category": 3 /* NoPrefix */ },
        "Type '{0}' requires a call signature, but type '{1}' lacks one.": { "code": 4008, "category": 3 /* NoPrefix */ },
        "Construct signatures of types '{0}' and '{1}' are incompatible.": { "code": 4009, "category": 3 /* NoPrefix */ },
        "Construct signatures of types '{0}' and '{1}' are incompatible:{NL}{2}": { "code": 4010, "category": 3 /* NoPrefix */ },
        "Type '{0}' requires a construct signature, but type '{1}' lacks one.": { "code": 4011, "category": 3 /* NoPrefix */ },
        "Index signatures of types '{0}' and '{1}' are incompatible.": { "code": 4012, "category": 3 /* NoPrefix */ },
        "Index signatures of types '{0}' and '{1}' are incompatible:{NL}{2}": { "code": 4013, "category": 3 /* NoPrefix */ },
        "Call signature expects {0} or fewer parameters.": { "code": 4014, "category": 3 /* NoPrefix */ },
        "Could not apply type '{0}' to argument {1} which is of type '{2}'.": { "code": 4015, "category": 3 /* NoPrefix */ },
        "Class '{0}' defines instance member accessor '{1}', but extended class '{2}' defines it as instance member function.": { "code": 4016, "category": 3 /* NoPrefix */ },
        "Class '{0}' defines instance member property '{1}', but extended class '{2}' defines it as instance member function.": { "code": 4017, "category": 3 /* NoPrefix */ },
        "Class '{0}' defines instance member function '{1}', but extended class '{2}' defines it as instance member accessor.": { "code": 4018, "category": 3 /* NoPrefix */ },
        "Class '{0}' defines instance member function '{1}', but extended class '{2}' defines it as instance member property.": { "code": 4019, "category": 3 /* NoPrefix */ },
        "Types of static property '{0}' of class '{1}' and class '{2}' are incompatible.": { "code": 4020, "category": 3 /* NoPrefix */ },
        "Types of static property '{0}' of class '{1}' and class '{2}' are incompatible:{NL}{3}": { "code": 4021, "category": 3 /* NoPrefix */ },
        "Type reference cannot refer to container '{0}'.": { "code": 4022, "category": 1 /* Error */ },
        "Type reference must refer to type.": { "code": 4023, "category": 1 /* Error */ },
        "In enums with multiple declarations only one declaration can omit an initializer for the first enum element.": { "code": 4024, "category": 1 /* Error */ },
        " (+ {0} overload(s))": { "code": 4025, "category": 2 /* Message */ },
        "Variable declaration cannot have the same name as an import declaration.": { "code": 4026, "category": 1 /* Error */ },
        "Signature expected {0} type arguments, got {1} instead.": { "code": 4027, "category": 1 /* Error */ },
        "Property '{0}' defined as optional in type '{1}', but is required in type '{2}'.": { "code": 4028, "category": 3 /* NoPrefix */ },
        "Types '{0}' and '{1}' originating in infinitely expanding type reference do not refer to same named type.": { "code": 4029, "category": 3 /* NoPrefix */ },
        "Types '{0}' and '{1}' originating in infinitely expanding type reference have incompatible type arguments.": { "code": 4030, "category": 3 /* NoPrefix */ },
        "Types '{0}' and '{1}' originating in infinitely expanding type reference have incompatible type arguments:{NL}{2}": { "code": 4031, "category": 3 /* NoPrefix */ },
        "Named properties '{0}' of types '{1}' and '{2}' are not identical.": { "code": 4032, "category": 3 /* NoPrefix */ },
        "Types of string indexer of types '{0}' and '{1}' are not identical.": { "code": 4033, "category": 3 /* NoPrefix */ },
        "Types of number indexer of types '{0}' and '{1}' are not identical.": { "code": 4034, "category": 3 /* NoPrefix */ },
        "Type of number indexer in type '{0}' is not assignable to string indexer type in type '{1}'.{NL}{2}": { "code": 4035, "category": 3 /* NoPrefix */ },
        "Type of property '{0}' in type '{1}' is not assignable to string indexer type in type '{2}'.{NL}{3}": { "code": 4036, "category": 3 /* NoPrefix */ },
        "Type of property '{0}' in type '{1}' is not assignable to number indexer type in type '{2}'.{NL}{3}": { "code": 4037, "category": 3 /* NoPrefix */ },
        "Static property '{0}' defined as private in type '{1}' is defined as public in type '{2}'.": { "code": 4038, "category": 3 /* NoPrefix */ },
        "Static property '{0}' defined as public in type '{1}' is defined as private in type '{2}'.": { "code": 4039, "category": 3 /* NoPrefix */ },
        "Types '{0}' and '{1}' define static property '{2}' as private.": { "code": 4040, "category": 3 /* NoPrefix */ },
        "Current host does not support '{0}' option.": { "code": 5001, "category": 1 /* Error */ },
        "ECMAScript target version '{0}' not supported.  Specify a valid target version: '{1}' (default), or '{2}'": { "code": 5002, "category": 1 /* Error */ },
        "Argument for '{0}' option must be '{1}' or '{2}'": { "code": 5003, "category": 1 /* Error */ },
        "Could not find file: '{0}'.": { "code": 5004, "category": 1 /* Error */ },
        "A file cannot have a reference to itself.": { "code": 5006, "category": 1 /* Error */ },
        "Cannot resolve referenced file: '{0}'.": { "code": 5007, "category": 1 /* Error */ },
        "Cannot find the common subdirectory path for the input files.": { "code": 5009, "category": 1 /* Error */ },
        "Emit Error: {0}.": { "code": 5011, "category": 1 /* Error */ },
        "Cannot read file '{0}': {1}": { "code": 5012, "category": 1 /* Error */ },
        "Unsupported file encoding.": { "code": 5013, "category": 3 /* NoPrefix */ },
        "Locale must be of the form <language> or <language>-<territory>. For example '{0}' or '{1}'.": { "code": 5014, "category": 1 /* Error */ },
        "Unsupported locale: '{0}'.": { "code": 5015, "category": 1 /* Error */ },
        "Execution Failed.{NL}": { "code": 5016, "category": 1 /* Error */ },
        "Invalid call to 'up'": { "code": 5019, "category": 1 /* Error */ },
        "Invalid call to 'down'": { "code": 5020, "category": 1 /* Error */ },
        "Base64 value '{0}' finished with a continuation bit.": { "code": 5021, "category": 1 /* Error */ },
        "Unknown compiler option '{0}'": { "code": 5023, "category": 1 /* Error */ },
        "Expected {0} arguments to message, got {1} instead.": { "code": 5024, "category": 1 /* Error */ },
        "Expected the message '{0}' to have {1} arguments, but it had {2}": { "code": 5025, "category": 1 /* Error */ },
        "Could not delete file '{0}'": { "code": 5034, "category": 1 /* Error */ },
        "Could not create directory '{0}'": { "code": 5035, "category": 1 /* Error */ },
        "Error while executing file '{0}': ": { "code": 5036, "category": 1 /* Error */ },
        "Cannot compile external modules unless the '--module' flag is provided.": { "code": 5037, "category": 1 /* Error */ },
        "Option mapRoot cannot be specified without specifying sourcemap option.": { "code": 5038, "category": 1 /* Error */ },
        "Option sourceRoot cannot be specified without specifying sourcemap option.": { "code": 5039, "category": 1 /* Error */ },
        "Options mapRoot and sourceRoot cannot be specified without specifying sourcemap option.": { "code": 5040, "category": 1 /* Error */ },
        "Option '{0}' specified without '{1}'": { "code": 5041, "category": 1 /* Error */ },
        "'codepage' option not supported on current platform.": { "code": 5042, "category": 1 /* Error */ },
        "Concatenate and emit output to single file.": { "code": 6001, "category": 2 /* Message */ },
        "Generates corresponding {0} file.": { "code": 6002, "category": 2 /* Message */ },
        "Specifies the location where debugger should locate map files instead of generated locations.": { "code": 6003, "category": 2 /* Message */ },
        "Specifies the location where debugger should locate TypeScript files instead of source locations.": { "code": 6004, "category": 2 /* Message */ },
        "Watch input files.": { "code": 6005, "category": 2 /* Message */ },
        "Redirect output structure to the directory.": { "code": 6006, "category": 2 /* Message */ },
        "Do not emit comments to output.": { "code": 6009, "category": 2 /* Message */ },
        "Skip resolution and preprocessing.": { "code": 6010, "category": 2 /* Message */ },
        "Specify ECMAScript target version: '{0}' (default), or '{1}'": { "code": 6015, "category": 2 /* Message */ },
        "Specify module code generation: '{0}' or '{1}'": { "code": 6016, "category": 2 /* Message */ },
        "Print this message.": { "code": 6017, "category": 2 /* Message */ },
        "Print the compiler's version: {0}": { "code": 6019, "category": 2 /* Message */ },
        "Allow use of deprecated '{0}' keyword when referencing an external module.": { "code": 6021, "category": 2 /* Message */ },
        "Specify locale for errors and messages. For example '{0}' or '{1}'": { "code": 6022, "category": 2 /* Message */ },
        "Syntax:   {0}": { "code": 6023, "category": 2 /* Message */ },
        "options": { "code": 6024, "category": 2 /* Message */ },
        "file1": { "code": 6025, "category": 2 /* Message */ },
        "Examples:": { "code": 6026, "category": 2 /* Message */ },
        "Options:": { "code": 6027, "category": 2 /* Message */ },
        "Insert command line options and files from a file.": { "code": 6030, "category": 2 /* Message */ },
        "Version {0}": { "code": 6029, "category": 2 /* Message */ },
        "Use the '{0}' flag to see options.": { "code": 6031, "category": 2 /* Message */ },
        "{NL}Recompiling ({0}):": { "code": 6032, "category": 2 /* Message */ },
        "STRING": { "code": 6033, "category": 2 /* Message */ },
        "KIND": { "code": 6034, "category": 2 /* Message */ },
        "file2": { "code": 6035, "category": 2 /* Message */ },
        "VERSION": { "code": 6036, "category": 2 /* Message */ },
        "LOCATION": { "code": 6037, "category": 2 /* Message */ },
        "DIRECTORY": { "code": 6038, "category": 2 /* Message */ },
        "NUMBER": { "code": 6039, "category": 2 /* Message */ },
        "Specify the codepage to use when opening source files.": { "code": 6040, "category": 2 /* Message */ },
        "Additional locations:": { "code": 6041, "category": 2 /* Message */ },
        "This version of the Javascript runtime does not support the '{0}' function.": { "code": 7000, "category": 1 /* Error */ },
        "Unknown rule.": { "code": 7002, "category": 1 /* Error */ },
        "Invalid line number ({0})": { "code": 7003, "category": 1 /* Error */ },
        "Warn on expressions and declarations with an implied 'any' type.": { "code": 7004, "category": 2 /* Message */ },
        "Variable '{0}' implicitly has an 'any' type.": { "code": 7005, "category": 1 /* Error */ },
        "Parameter '{0}' of '{1}' implicitly has an 'any' type.": { "code": 7006, "category": 1 /* Error */ },
        "Parameter '{0}' of function type implicitly has an 'any' type.": { "code": 7007, "category": 1 /* Error */ },
        "Member '{0}' of object type implicitly has an 'any' type.": { "code": 7008, "category": 1 /* Error */ },
        "'new' expression, which lacks a constructor signature, implicitly has an 'any' type.": { "code": 7009, "category": 1 /* Error */ },
        "'{0}', which lacks return-type annotation, implicitly has an 'any' return type.": { "code": 7010, "category": 1 /* Error */ },
        "Function expression, which lacks return-type annotation, implicitly has an 'any' return type.": { "code": 7011, "category": 1 /* Error */ },
        "Parameter '{0}' of lambda function implicitly has an 'any' type.": { "code": 7012, "category": 1 /* Error */ },
        "Constructor signature, which lacks return-type annotation, implicitly has an 'any' return type.": { "code": 7013, "category": 1 /* Error */ },
        "Lambda Function, which lacks return-type annotation, implicitly has an 'any' return type.": { "code": 7014, "category": 1 /* Error */ },
        "Array Literal implicitly has an 'any' type from widening.": { "code": 7015, "category": 1 /* Error */ },
        "'{0}', which lacks 'get' accessor and parameter type annotation on 'set' accessor, implicitly has an 'any' type.": { "code": 7016, "category": 1 /* Error */ },
        "Index signature of object type implicitly has an 'any' type.": { "code": 7017, "category": 1 /* Error */ },
        "Object literal's property '{0}' implicitly has an 'any' type from widening.": { "code": 7018, "category": 1 /* Error */ }
    };
})(TypeScript || (TypeScript = {}));
///<reference path='references.ts' />
var TypeScript;
(function (TypeScript) {
    var ArrayUtilities = (function () {
        function ArrayUtilities() {
        }
        ArrayUtilities.sequenceEquals = function (array1, array2, equals) {
            if (array1 === array2) {
                return true;
            }
            if (array1 === null || array2 === null) {
                return false;
            }
            if (array1.length !== array2.length) {
                return false;
            }
            for (var i = 0, n = array1.length; i < n; i++) {
                if (!equals(array1[i], array2[i])) {
                    return false;
                }
            }
            return true;
        };
        ArrayUtilities.contains = function (array, value) {
            for (var i = 0; i < array.length; i++) {
                if (array[i] === value) {
                    return true;
                }
            }
            return false;
        };
        // Gets unique element array
        ArrayUtilities.distinct = function (array, equalsFn) {
            var result = [];
            for (var i = 0, n = array.length; i < n; i++) {
                var current = array[i];
                for (var j = 0; j < result.length; j++) {
                    if (equalsFn(result[j], current)) {
                        break;
                    }
                }
                if (j === result.length) {
                    result.push(current);
                }
            }
            return result;
        };
        ArrayUtilities.last = function (array) {
            if (array.length === 0) {
                throw TypeScript.Errors.argumentOutOfRange('array');
            }
            return array[array.length - 1];
        };
        ArrayUtilities.lastOrDefault = function (array, predicate) {
            for (var i = array.length - 1; i >= 0; i--) {
                var v = array[i];
                if (predicate(v, i)) {
                    return v;
                }
            }
            return null;
        };
        ArrayUtilities.firstOrDefault = function (array, func) {
            for (var i = 0, n = array.length; i < n; i++) {
                var value = array[i];
                if (func(value, i)) {
                    return value;
                }
            }
            return null;
        };
        ArrayUtilities.first = function (array, func) {
            for (var i = 0, n = array.length; i < n; i++) {
                var value = array[i];
                if (!func || func(value, i)) {
                    return value;
                }
            }
            throw TypeScript.Errors.invalidOperation();
        };
        ArrayUtilities.sum = function (array, func) {
            var result = 0;
            for (var i = 0, n = array.length; i < n; i++) {
                result += func(array[i]);
            }
            return result;
        };
        ArrayUtilities.select = function (values, func) {
            var result = new Array(values.length);
            for (var i = 0; i < values.length; i++) {
                result[i] = func(values[i]);
            }
            return result;
        };
        ArrayUtilities.where = function (values, func) {
            var result = new Array();
            for (var i = 0; i < values.length; i++) {
                if (func(values[i])) {
                    result.push(values[i]);
                }
            }
            return result;
        };
        ArrayUtilities.any = function (array, func) {
            for (var i = 0, n = array.length; i < n; i++) {
                if (func(array[i])) {
                    return true;
                }
            }
            return false;
        };
        ArrayUtilities.all = function (array, func) {
            for (var i = 0, n = array.length; i < n; i++) {
                if (!func(array[i])) {
                    return false;
                }
            }
            return true;
        };
        ArrayUtilities.binarySearch = function (array, value) {
            var low = 0;
            var high = array.length - 1;
            while (low <= high) {
                var middle = low + ((high - low) >> 1);
                var midValue = array[middle];
                if (midValue === value) {
                    return middle;
                }
                else if (midValue > value) {
                    high = middle - 1;
                }
                else {
                    low = middle + 1;
                }
            }
            return ~low;
        };
        ArrayUtilities.createArray = function (length, defaultValue) {
            var result = new Array(length);
            for (var i = 0; i < length; i++) {
                result[i] = defaultValue;
            }
            return result;
        };
        ArrayUtilities.grow = function (array, length, defaultValue) {
            var count = length - array.length;
            for (var i = 0; i < count; i++) {
                array.push(defaultValue);
            }
        };
        ArrayUtilities.copy = function (sourceArray, sourceIndex, destinationArray, destinationIndex, length) {
            for (var i = 0; i < length; i++) {
                destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i];
            }
        };
        ArrayUtilities.indexOf = function (array, predicate) {
            for (var i = 0, n = array.length; i < n; i++) {
                if (predicate(array[i])) {
                    return i;
                }
            }
            return -1;
        };
        return ArrayUtilities;
    })();
    TypeScript.ArrayUtilities = ArrayUtilities;
})(TypeScript || (TypeScript = {}));
///<reference path='references.ts' />
var TypeScript;
(function (TypeScript) {
    (function (AssertionLevel) {
        AssertionLevel[AssertionLevel["None"] = 0] = "None";
        AssertionLevel[AssertionLevel["Normal"] = 1] = "Normal";
        AssertionLevel[AssertionLevel["Aggressive"] = 2] = "Aggressive";
        AssertionLevel[AssertionLevel["VeryAggressive"] = 3] = "VeryAggressive";
    })(TypeScript.AssertionLevel || (TypeScript.AssertionLevel = {}));
    var AssertionLevel = TypeScript.AssertionLevel;
    var Debug = (function () {
        function Debug() {
        }
        Debug.shouldAssert = function (level) {
            return this.currentAssertionLevel >= level;
        };
        Debug.assert = function (expression, message, verboseDebugInfo) {
            if (message === void 0) { message = ""; }
            if (verboseDebugInfo === void 0) { verboseDebugInfo = null; }
            if (!expression) {
                var verboseDebugString = "";
                if (verboseDebugInfo) {
                    verboseDebugString = "\r\nVerbose Debug Information:" + verboseDebugInfo();
                }
                throw new Error("Debug Failure. False expression: " + message + verboseDebugString);
            }
        };
        Debug.fail = function (message) {
            Debug.assert(false, message);
        };
        Debug.currentAssertionLevel = 0 /* None */;
        return Debug;
    })();
    TypeScript.Debug = Debug;
})(TypeScript || (TypeScript = {}));
///<reference path='references.ts' />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var TypeScript;
(function (TypeScript) {
    TypeScript.LocalizedDiagnosticMessages = null;
    var Location = (function () {
        function Location(fileName, lineMap, start, length) {
            this._fileName = fileName;
            this._lineMap = lineMap;
            this._start = start;
            this._length = length;
        }
        Location.prototype.fileName = function () {
            return this._fileName;
        };
        Location.prototype.lineMap = function () {
            return this._lineMap;
        };
        Location.prototype.line = function () {
            return this._lineMap ? this._lineMap.getLineNumberFromPosition(this.start()) : 0;
        };
        Location.prototype.character = function () {
            return this._lineMap ? this._lineMap.getLineAndCharacterFromPosition(this.start()).character() : 0;
        };
        Location.prototype.start = function () {
            return this._start;
        };
        Location.prototype.length = function () {
            return this._length;
        };
        Location.equals = function (location1, location2) {
            return location1._fileName === location2._fileName && location1._start === location2._start && location1._length === location2._length;
        };
        return Location;
    })();
    TypeScript.Location = Location;
    var Diagnostic = (function (_super) {
        __extends(Diagnostic, _super);
        function Diagnostic(fileName, lineMap, start, length, diagnosticKey, _arguments, additionalLocations) {
            if (_arguments === void 0) { _arguments = null; }
            if (additionalLocations === void 0) { additionalLocations = null; }
            _super.call(this, fileName, lineMap, start, length);
            this._diagnosticKey = diagnosticKey;
            this._arguments = (_arguments && _arguments.length > 0) ? _arguments : null;
            this._additionalLocations = (additionalLocations && additionalLocations.length > 0) ? additionalLocations : null;
        }
        Diagnostic.prototype.toJSON = function (key) {
            var result = {};
            result.start = this.start();
            result.length = this.length();
            result.diagnosticCode = this._diagnosticKey;
            var _arguments = this.arguments();
            if (_arguments && _arguments.length > 0) {
                result.arguments = _arguments;
            }
            return result;
        };
        Diagnostic.prototype.diagnosticKey = function () {
            return this._diagnosticKey;
        };
        Diagnostic.prototype.arguments = function () {
            return this._arguments;
        };
        /**
         * Get the text of the message in the given language.
         */
        Diagnostic.prototype.text = function () {
            return TypeScript.getLocalizedText(this._diagnosticKey, this._arguments);
        };
        /**
         * Get the text of the message including the error code in the given language.
         */
        Diagnostic.prototype.message = function () {
            return TypeScript.getDiagnosticMessage(this._diagnosticKey, this._arguments);
        };
        /**
         * If a derived class has additional information about other referenced symbols, it can
         * expose the locations of those symbols in a general way, so they can be reported along
         * with the error.
         */
        Diagnostic.prototype.additionalLocations = function () {
            return this._additionalLocations || [];
        };
        Diagnostic.equals = function (diagnostic1, diagnostic2) {
            return Location.equals(diagnostic1, diagnostic2) && diagnostic1._diagnosticKey === diagnostic2._diagnosticKey && TypeScript.ArrayUtilities.sequenceEquals(diagnostic1._arguments, diagnostic2._arguments, function (v1, v2) { return v1 === v2; });
        };
        Diagnostic.prototype.info = function () {
            return getDiagnosticInfoFromKey(this.diagnosticKey());
        };
        return Diagnostic;
    })(Location);
    TypeScript.Diagnostic = Diagnostic;
    function newLine() {
        // TODO: We need to expose an extensibility point on our hosts to have them tell us what 
        // they want the newline string to be.  That way we can get the correct result regardless
        // of which host we use
        return "\r\n";
    }
    TypeScript.newLine = newLine;
    function getLargestIndex(diagnostic) {
        var largest = -1;
        var regex = /\{(\d+)\}/g;
        var match;
        while (match = regex.exec(diagnostic)) {
            var val = parseInt(match[1]);
            if (!isNaN(val) && val > largest) {
                largest = val;
            }
        }
        return largest;
    }
    function getDiagnosticInfoFromKey(diagnosticKey) {
        var result = TypeScript.diagnosticInformationMap[diagnosticKey];
        TypeScript.Debug.assert(result);
        return result;
    }
    function getLocalizedText(diagnosticKey, args) {
        var diagnosticMessageText = diagnosticKey;
        TypeScript.Debug.assert(diagnosticMessageText !== undefined && diagnosticMessageText !== null);
        var actualCount = args ? args.length : 0;
        // We have a string like "foo_0_bar_1".  We want to find the largest integer there.
        // (i.e.'1').  We then need one more arg than that to be correct.
        var expectedCount = 1 + getLargestIndex(diagnosticKey);
        if (expectedCount !== actualCount) {
            throw new Error(getLocalizedText(TypeScript.DiagnosticCode.Expected_0_arguments_to_message_got_1_instead, [expectedCount, actualCount]));
        }
        // This should also be the same number of arguments as the message text
        var valueCount = 1 + getLargestIndex(diagnosticMessageText);
        if (valueCount !== expectedCount) {
            throw new Error(getLocalizedText(TypeScript.DiagnosticCode.Expected_the_message_0_to_have_1_arguments_but_it_had_2, [diagnosticMessageText, expectedCount, valueCount]));
        }
        diagnosticMessageText = diagnosticMessageText.replace(/{(\d+)}/g, function (match, num) {
            return typeof args[num] !== 'undefined' ? args[num] : match;
        });
        diagnosticMessageText = diagnosticMessageText.replace(/{(NL)}/g, function (match) {
            return TypeScript.newLine();
        });
        return diagnosticMessageText;
    }
    TypeScript.getLocalizedText = getLocalizedText;
    function getDiagnosticMessage(diagnosticKey, args) {
        var diagnostic = getDiagnosticInfoFromKey(diagnosticKey);
        var diagnosticMessageText = getLocalizedText(diagnosticKey, args);
        var message;
        if (diagnostic.category === 1 /* Error */) {
            message = getLocalizedText(TypeScript.DiagnosticCode.error_TS_0_1, [diagnostic.code, diagnosticMessageText]);
        }
        else if (diagnostic.category === 0 /* Warning */) {
            message = getLocalizedText(TypeScript.DiagnosticCode.warning_TS_0_1, [diagnostic.code, diagnosticMessageText]);
        }
        else {
            message = diagnosticMessageText;
        }
        return message;
    }
    TypeScript.getDiagnosticMessage = getDiagnosticMessage;
})(TypeScript || (TypeScript = {}));
///<reference path='references.ts' />
///<reference path='references.ts' />
var TypeScript;
(function (TypeScript) {
    var Errors = (function () {
        function Errors() {
        }
        Errors.argument = function (argument, message) {
            return new Error("Invalid argument: " + argument + ". " + message);
        };
        Errors.argumentOutOfRange = function (argument) {
            return new Error("Argument out of range: " + argument);
        };
        Errors.argumentNull = function (argument) {
            return new Error("Argument null: " + argument);
        };
        Errors.abstract = function () {
            return new Error("Operation not implemented properly by subclass.");
        };
        Errors.notYetImplemented = function () {
            return new Error("Not yet implemented.");
        };
        Errors.invalidOperation = function (message) {
            return new Error("Invalid operation: " + message);
        };
        return Errors;
    })();
    TypeScript.Errors = Errors;
})(TypeScript || (TypeScript = {}));
///<reference path='references.ts' />
var TypeScript;
(function (TypeScript) {
    var IntegerUtilities;
    (function (IntegerUtilities) {
        function integerDivide(numerator, denominator) {
            return (numerator / denominator) >> 0;
        }
        IntegerUtilities.integerDivide = integerDivide;
        function integerMultiplyLow32Bits(n1, n2) {
            var n1Low16 = n1 & 0x0000ffff;
            var n1High16 = n1 >>> 16;
            var n2Low16 = n2 & 0x0000ffff;
            var n2High16 = n2 >>> 16;
            var resultLow32 = (((n1 & 0xffff0000) * n2) >>> 0) + (((n1 & 0x0000ffff) * n2) >>> 0) >>> 0;
            return resultLow32;
        }
        IntegerUtilities.integerMultiplyLow32Bits = integerMultiplyLow32Bits;
        function isInteger(text) {
            return /^[0-9]+$/.test(text);
        }
        IntegerUtilities.isInteger = isInteger;
        function isHexInteger(text) {
            return /^0(x|X)[0-9a-fA-F]+$/.test(text);
        }
        IntegerUtilities.isHexInteger = isHexInteger;
    })(IntegerUtilities = TypeScript.IntegerUtilities || (TypeScript.IntegerUtilities = {}));
})(TypeScript || (TypeScript = {}));
///<reference path='references.ts' />
var TypeScript;
(function (TypeScript) {
    var LineMap = (function () {
        function LineMap(_computeLineStarts, length) {
            this._computeLineStarts = _computeLineStarts;
            this.length = length;
            this._lineStarts = null;
        }
        LineMap.prototype.toJSON = function (key) {
            return { lineStarts: this.lineStarts(), length: this.length };
        };
        LineMap.prototype.equals = function (other) {
            return this.length === other.length && TypeScript.ArrayUtilities.sequenceEquals(this.lineStarts(), other.lineStarts(), function (v1, v2) { return v1 === v2; });
        };
        LineMap.prototype.lineStarts = function () {
            if (this._lineStarts === null) {
                this._lineStarts = this._computeLineStarts();
            }
            return this._lineStarts;
        };
        LineMap.prototype.lineCount = function () {
            return this.lineStarts().length;
        };
        LineMap.prototype.getPosition = function (line, character) {
            return this.lineStarts()[line] + character;
        };
        LineMap.prototype.getLineNumberFromPosition = function (position) {
            if (position < 0 || position > this.length) {
                throw TypeScript.Errors.argumentOutOfRange("position");
            }
            if (position === this.length) {
                // this can happen when the user tried to get the line of items
                // that are at the absolute end of this text (i.e. the EndOfLine
                // token, or missing tokens that are at the end of the text).
                // In this case, we want the last line in the text.
                return this.lineCount() - 1;
            }
            // Binary search to find the right line
            var lineNumber = TypeScript.ArrayUtilities.binarySearch(this.lineStarts(), position);
            if (lineNumber < 0) {
                lineNumber = (~lineNumber) - 1;
            }
            return lineNumber;
        };
        LineMap.prototype.getLineStartPosition = function (lineNumber) {
            return this.lineStarts()[lineNumber];
        };
        LineMap.prototype.fillLineAndCharacterFromPosition = function (position, lineAndCharacter) {
            if (position < 0 || position > this.length) {
                throw TypeScript.Errors.argumentOutOfRange("position");
            }
            var lineNumber = this.getLineNumberFromPosition(position);
            lineAndCharacter.line = lineNumber;
            lineAndCharacter.character = position - this.lineStarts()[lineNumber];
        };
        LineMap.prototype.getLineAndCharacterFromPosition = function (position) {
            if (position < 0 || position > this.length) {
                throw TypeScript.Errors.argumentOutOfRange("position");
            }
            var lineNumber = this.getLineNumberFromPosition(position);
            return new TypeScript.LineAndCharacter(lineNumber, position - this.lineStarts()[lineNumber]);
        };
        LineMap.empty = new LineMap(function () { return [0]; }, 0);
        return LineMap;
    })();
    TypeScript.LineMap = LineMap;
})(TypeScript || (TypeScript = {}));
///<reference path='references.ts' />
var TypeScript;
(function (TypeScript) {
    var LineAndCharacter = (function () {
        /**
         * Initializes a new instance of a LinePosition with the given line and character. ArgumentOutOfRangeException if "line" or "character" is less than zero.
         * @param line The line of the line position. The first line in a file is defined as line 0 (zero based line numbering).
         * @param character The character position in the line.
         */
        function LineAndCharacter(line, character) {
            this._line = 0;
            this._character = 0;
            if (line < 0) {
                throw TypeScript.Errors.argumentOutOfRange("line");
            }
            if (character < 0) {
                throw TypeScript.Errors.argumentOutOfRange("character");
            }
            this._line = line;
            this._character = character;
        }
        LineAndCharacter.prototype.line = function () {
            return this._line;
        };
        LineAndCharacter.prototype.character = function () {
            return this._character;
        };
        return LineAndCharacter;
    })();
    TypeScript.LineAndCharacter = LineAndCharacter;
})(TypeScript || (TypeScript = {}));
///<reference path='references.ts' />
var TypeScript;
(function (TypeScript) {
    var StringUtilities = (function () {
        function StringUtilities() {
        }
        StringUtilities.isString = function (value) {
            return Object.prototype.toString.apply(value, []) === '[object String]';
        };
        StringUtilities.endsWith = function (string, value) {
            return string.substring(string.length - value.length, string.length) === value;
        };
        StringUtilities.startsWith = function (string, value) {
            return string.substr(0, value.length) === value;
        };
        StringUtilities.repeat = function (value, count) {
            return Array(count + 1).join(value);
        };
        return StringUtilities;
    })();
    TypeScript.StringUtilities = StringUtilities;
})(TypeScript || (TypeScript = {}));
///<reference path='..\resources\references.ts' />
///<reference path='references.ts' />
var TypeScript;
(function (TypeScript) {
    (function (CharacterCodes) {
        CharacterCodes[CharacterCodes["nullCharacter"] = 0] = "nullCharacter";
        CharacterCodes[CharacterCodes["maxAsciiCharacter"] = 127] = "maxAsciiCharacter";
        CharacterCodes[CharacterCodes["lineFeed"] = 10] = "lineFeed";
        CharacterCodes[CharacterCodes["carriageReturn"] = 13] = "carriageReturn";
        CharacterCodes[CharacterCodes["lineSeparator"] = 0x2028] = "lineSeparator";
        CharacterCodes[CharacterCodes["paragraphSeparator"] = 0x2029] = "paragraphSeparator";
        // REVIEW: do we need to support this?  The scanner doesn't, but our IText does.  This seems 
        // like an odd disparity?  (Or maybe it's completely fine for them to be different).
        CharacterCodes[CharacterCodes["nextLine"] = 0x0085] = "nextLine";
        // Unicode 3.0 space characters
        CharacterCodes[CharacterCodes["space"] = 0x0020] = "space";
        CharacterCodes[CharacterCodes["nonBreakingSpace"] = 0x00A0] = "nonBreakingSpace";
        CharacterCodes[CharacterCodes["enQuad"] = 0x2000] = "enQuad";
        CharacterCodes[CharacterCodes["emQuad"] = 0x2001] = "emQuad";
        CharacterCodes[CharacterCodes["enSpace"] = 0x2002] = "enSpace";
        CharacterCodes[CharacterCodes["emSpace"] = 0x2003] = "emSpace";
        CharacterCodes[CharacterCodes["threePerEmSpace"] = 0x2004] = "threePerEmSpace";
        CharacterCodes[CharacterCodes["fourPerEmSpace"] = 0x2005] = "fourPerEmSpace";
        CharacterCodes[CharacterCodes["sixPerEmSpace"] = 0x2006] = "sixPerEmSpace";
        CharacterCodes[CharacterCodes["figureSpace"] = 0x2007] = "figureSpace";
        CharacterCodes[CharacterCodes["punctuationSpace"] = 0x2008] = "punctuationSpace";
        CharacterCodes[CharacterCodes["thinSpace"] = 0x2009] = "thinSpace";
        CharacterCodes[CharacterCodes["hairSpace"] = 0x200A] = "hairSpace";
        CharacterCodes[CharacterCodes["zeroWidthSpace"] = 0x200B] = "zeroWidthSpace";
        CharacterCodes[CharacterCodes["narrowNoBreakSpace"] = 0x202F] = "narrowNoBreakSpace";
        CharacterCodes[CharacterCodes["ideographicSpace"] = 0x3000] = "ideographicSpace";
        CharacterCodes[CharacterCodes["_"] = 95] = "_";
        CharacterCodes[CharacterCodes["$"] = 36] = "$";
        CharacterCodes[CharacterCodes["_0"] = 48] = "_0";
        CharacterCodes[CharacterCodes["_1"] = 49] = "_1";
        CharacterCodes[CharacterCodes["_2"] = 50] = "_2";
        CharacterCodes[CharacterCodes["_3"] = 51] = "_3";
        CharacterCodes[CharacterCodes["_4"] = 52] = "_4";
        CharacterCodes[CharacterCodes["_5"] = 53] = "_5";
        CharacterCodes[CharacterCodes["_6"] = 54] = "_6";
        CharacterCodes[CharacterCodes["_7"] = 55] = "_7";
        CharacterCodes[CharacterCodes["_8"] = 56] = "_8";
        CharacterCodes[CharacterCodes["_9"] = 57] = "_9";
        CharacterCodes[CharacterCodes["a"] = 97] = "a";
        CharacterCodes[CharacterCodes["b"] = 98] = "b";
        CharacterCodes[CharacterCodes["c"] = 99] = "c";
        CharacterCodes[CharacterCodes["d"] = 100] = "d";
        CharacterCodes[CharacterCodes["e"] = 101] = "e";
        CharacterCodes[CharacterCodes["f"] = 102] = "f";
        CharacterCodes[CharacterCodes["g"] = 103] = "g";
        CharacterCodes[CharacterCodes["h"] = 104] = "h";
        CharacterCodes[CharacterCodes["i"] = 105] = "i";
        CharacterCodes[CharacterCodes["j"] = 106] = "j";
        CharacterCodes[CharacterCodes["k"] = 107] = "k";
        CharacterCodes[CharacterCodes["l"] = 108] = "l";
        CharacterCodes[CharacterCodes["m"] = 109] = "m";
        CharacterCodes[CharacterCodes["n"] = 110] = "n";
        CharacterCodes[CharacterCodes["o"] = 111] = "o";
        CharacterCodes[CharacterCodes["p"] = 112] = "p";
        CharacterCodes[CharacterCodes["q"] = 113] = "q";
        CharacterCodes[CharacterCodes["r"] = 114] = "r";
        CharacterCodes[CharacterCodes["s"] = 115] = "s";
        CharacterCodes[CharacterCodes["t"] = 116] = "t";
        CharacterCodes[CharacterCodes["u"] = 117] = "u";
        CharacterCodes[CharacterCodes["v"] = 118] = "v";
        CharacterCodes[CharacterCodes["w"] = 119] = "w";
        CharacterCodes[CharacterCodes["x"] = 120] = "x";
        CharacterCodes[CharacterCodes["y"] = 121] = "y";
        CharacterCodes[CharacterCodes["z"] = 122] = "z";
        CharacterCodes[CharacterCodes["A"] = 65] = "A";
        CharacterCodes[CharacterCodes["B"] = 66] = "B";
        CharacterCodes[CharacterCodes["C"] = 67] = "C";
        CharacterCodes[CharacterCodes["D"] = 68] = "D";
        CharacterCodes[CharacterCodes["E"] = 69] = "E";
        CharacterCodes[CharacterCodes["F"] = 70] = "F";
        CharacterCodes[CharacterCodes["G"] = 71] = "G";
        CharacterCodes[CharacterCodes["H"] = 72] = "H";
        CharacterCodes[CharacterCodes["I"] = 73] = "I";
        CharacterCodes[CharacterCodes["J"] = 74] = "J";
        CharacterCodes[CharacterCodes["K"] = 75] = "K";
        CharacterCodes[CharacterCodes["L"] = 76] = "L";
        CharacterCodes[CharacterCodes["M"] = 77] = "M";
        CharacterCodes[CharacterCodes["N"] = 78] = "N";
        CharacterCodes[CharacterCodes["O"] = 79] = "O";
        CharacterCodes[CharacterCodes["P"] = 80] = "P";
        CharacterCodes[CharacterCodes["Q"] = 81] = "Q";
        CharacterCodes[CharacterCodes["R"] = 82] = "R";
        CharacterCodes[CharacterCodes["S"] = 83] = "S";
        CharacterCodes[CharacterCodes["T"] = 84] = "T";
        CharacterCodes[CharacterCodes["U"] = 85] = "U";
        CharacterCodes[CharacterCodes["V"] = 86] = "V";
        CharacterCodes[CharacterCodes["W"] = 87] = "W";
        CharacterCodes[CharacterCodes["X"] = 88] = "X";
        CharacterCodes[CharacterCodes["Y"] = 89] = "Y";
        CharacterCodes[CharacterCodes["Z"] = 90] = "Z";
        CharacterCodes[CharacterCodes["ampersand"] = 38] = "ampersand";
        CharacterCodes[CharacterCodes["asterisk"] = 42] = "asterisk";
        CharacterCodes[CharacterCodes["at"] = 64] = "at";
        CharacterCodes[CharacterCodes["backslash"] = 92] = "backslash";
        CharacterCodes[CharacterCodes["bar"] = 124] = "bar";
        CharacterCodes[CharacterCodes["caret"] = 94] = "caret";
        CharacterCodes[CharacterCodes["closeBrace"] = 125] = "closeBrace";
        CharacterCodes[CharacterCodes["closeBracket"] = 93] = "closeBracket";
        CharacterCodes[CharacterCodes["closeParen"] = 41] = "closeParen";
        CharacterCodes[CharacterCodes["colon"] = 58] = "colon";
        CharacterCodes[CharacterCodes["comma"] = 44] = "comma";
        CharacterCodes[CharacterCodes["dot"] = 46] = "dot";
        CharacterCodes[CharacterCodes["doubleQuote"] = 34] = "doubleQuote";
        CharacterCodes[CharacterCodes["equals"] = 61] = "equals";
        CharacterCodes[CharacterCodes["exclamation"] = 33] = "exclamation";
        CharacterCodes[CharacterCodes["greaterThan"] = 62] = "greaterThan";
        CharacterCodes[CharacterCodes["lessThan"] = 60] = "lessThan";
        CharacterCodes[CharacterCodes["minus"] = 45] = "minus";
        CharacterCodes[CharacterCodes["openBrace"] = 123] = "openBrace";
        CharacterCodes[CharacterCodes["openBracket"] = 91] = "openBracket";
        CharacterCodes[CharacterCodes["openParen"] = 40] = "openParen";
        CharacterCodes[CharacterCodes["percent"] = 37] = "percent";
        CharacterCodes[CharacterCodes["plus"] = 43] = "plus";
        CharacterCodes[CharacterCodes["question"] = 63] = "question";
        CharacterCodes[CharacterCodes["semicolon"] = 59] = "semicolon";
        CharacterCodes[CharacterCodes["singleQuote"] = 39] = "singleQuote";
        CharacterCodes[CharacterCodes["slash"] = 47] = "slash";
        CharacterCodes[CharacterCodes["tilde"] = 126] = "tilde";
        CharacterCodes[CharacterCodes["backspace"] = 8] = "backspace";
        CharacterCodes[CharacterCodes["formFeed"] = 12] = "formFeed";
        CharacterCodes[CharacterCodes["byteOrderMark"] = 0xFEFF] = "byteOrderMark";
        CharacterCodes[CharacterCodes["tab"] = 9] = "tab";
        CharacterCodes[CharacterCodes["verticalTab"] = 11] = "verticalTab";
    })(TypeScript.CharacterCodes || (TypeScript.CharacterCodes = {}));
    var CharacterCodes = TypeScript.CharacterCodes;
})(TypeScript || (TypeScript = {}));
///<reference path='references.ts' />
var TypeScript;
(function (TypeScript) {
    var ScriptSnapshot;
    (function (ScriptSnapshot) {
        var StringScriptSnapshot = (function () {
            function StringScriptSnapshot(text) {
                this.text = text;
                this._lineStartPositions = null;
            }
            StringScriptSnapshot.prototype.getText = function (start, end) {
                return this.text.substring(start, end);
            };
            StringScriptSnapshot.prototype.getLength = function () {
                return this.text.length;
            };
            StringScriptSnapshot.prototype.getLineStartPositions = function () {
                if (!this._lineStartPositions) {
                    this._lineStartPositions = TypeScript.TextUtilities.parseLineStarts(this.text);
                }
                return this._lineStartPositions;
            };
            StringScriptSnapshot.prototype.getChangeRange = function (oldSnapshot) {
                throw TypeScript.Errors.notYetImplemented();
            };
            return StringScriptSnapshot;
        })();
        function fromString(text) {
            return new StringScriptSnapshot(text);
        }
        ScriptSnapshot.fromString = fromString;
    })(ScriptSnapshot = TypeScript.ScriptSnapshot || (TypeScript.ScriptSnapshot = {}));
})(TypeScript || (TypeScript = {}));
///<reference path='references.ts' />
///<reference path='references.ts' />
var TypeScript;
(function (TypeScript) {
    var LineMap1;
    (function (LineMap1) {
        function fromSimpleText(text) {
            return new TypeScript.LineMap(function () { return TypeScript.TextUtilities.parseLineStarts({ charCodeAt: function (index) { return text.charCodeAt(index); }, length: text.length() }); }, text.length());
        }
        LineMap1.fromSimpleText = fromSimpleText;
        function fromScriptSnapshot(scriptSnapshot) {
            return new TypeScript.LineMap(function () { return scriptSnapshot.getLineStartPositions(); }, scriptSnapshot.getLength());
        }
        LineMap1.fromScriptSnapshot = fromScriptSnapshot;
        function fromString(text) {
            return new TypeScript.LineMap(function () { return TypeScript.TextUtilities.parseLineStarts(text); }, text.length);
        }
        LineMap1.fromString = fromString;
    })(LineMap1 = TypeScript.LineMap1 || (TypeScript.LineMap1 = {}));
})(TypeScript || (TypeScript = {}));
///<reference path='references.ts' />
var TypeScript;
(function (TypeScript) {
    var SimpleText;
    (function (SimpleText) {
        var SimpleStringText = (function () {
            function SimpleStringText(value) {
                this.value = value;
                this._lineMap = null;
            }
            SimpleStringText.prototype.length = function () {
                return this.value.length;
            };
            SimpleStringText.prototype.substr = function (start, length) {
                return this.value.substr(start, length);
            };
            SimpleStringText.prototype.charCodeAt = function (index) {
                return this.value.charCodeAt(index);
            };
            SimpleStringText.prototype.lineMap = function () {
                if (!this._lineMap) {
                    this._lineMap = TypeScript.LineMap1.fromString(this.value);
                }
                return this._lineMap;
            };
            return SimpleStringText;
        })();
        // Class which wraps a host IScriptSnapshot and exposes an ISimpleText for newer compiler code. 
        var SimpleScriptSnapshotText = (function () {
            function SimpleScriptSnapshotText(scriptSnapshot) {
                this.scriptSnapshot = scriptSnapshot;
                this._lineMap = null;
            }
            SimpleScriptSnapshotText.prototype.charCodeAt = function (index) {
                return this.scriptSnapshot.getText(index, index + 1).charCodeAt(0);
            };
            SimpleScriptSnapshotText.prototype.length = function () {
                return this.scriptSnapshot.getLength();
            };
            SimpleScriptSnapshotText.prototype.substr = function (start, length) {
                return this.scriptSnapshot.getText(start, start + length);
            };
            SimpleScriptSnapshotText.prototype.lineMap = function () {
                var _this = this;
                if (this._lineMap === null) {
                    this._lineMap = new TypeScript.LineMap(function () { return _this.scriptSnapshot.getLineStartPositions(); }, this.length());
                }
                return this._lineMap;
            };
            return SimpleScriptSnapshotText;
        })();
        function fromString(value) {
            return new SimpleStringText(value);
        }
        SimpleText.fromString = fromString;
        function fromScriptSnapshot(scriptSnapshot) {
            return new SimpleScriptSnapshotText(scriptSnapshot);
        }
        SimpleText.fromScriptSnapshot = fromScriptSnapshot;
    })(SimpleText = TypeScript.SimpleText || (TypeScript.SimpleText = {}));
})(TypeScript || (TypeScript = {}));
///<reference path='references.ts' />
var TypeScript;
(function (TypeScript) {
    var TextUtilities;
    (function (TextUtilities) {
        function parseLineStarts(text) {
            var length = text.length;
            // Corner case check
            if (0 === length) {
                var result = new Array();
                result.push(0);
                return result;
            }
            var position = 0;
            var index = 0;
            var arrayBuilder = new Array();
            var lineNumber = 0;
            while (index < length) {
                var c = text.charCodeAt(index);
                var lineBreakLength;
                // common case - ASCII & not a line break
                if (c > 13 /* carriageReturn */ && c <= 127) {
                    index++;
                    continue;
                }
                else if (c === 13 /* carriageReturn */ && index + 1 < length && text.charCodeAt(index + 1) === 10 /* lineFeed */) {
                    lineBreakLength = 2;
                }
                else if (c === 10 /* lineFeed */) {
                    lineBreakLength = 1;
                }
                else {
                    lineBreakLength = TextUtilities.getLengthOfLineBreak(text, index);
                }
                if (0 === lineBreakLength) {
                    index++;
                }
                else {
                    arrayBuilder.push(position);
                    index += lineBreakLength;
                    position = index;
                    lineNumber++;
                }
            }
            // Create a start for the final line.  
            arrayBuilder.push(position);
            return arrayBuilder;
        }
        TextUtilities.parseLineStarts = parseLineStarts;
        function getLengthOfLineBreakSlow(text, index, c) {
            if (c === 13 /* carriageReturn */) {
                var next = index + 1;
                return (next < text.length) && 10 /* lineFeed */ === text.charCodeAt(next) ? 2 : 1;
            }
            else if (isAnyLineBreakCharacter(c)) {
                return 1;
            }
            else {
                return 0;
            }
        }
        TextUtilities.getLengthOfLineBreakSlow = getLengthOfLineBreakSlow;
        function getLengthOfLineBreak(text, index) {
            var c = text.charCodeAt(index);
            // common case - ASCII & not a line break
            if (c > 13 /* carriageReturn */ && c <= 127) {
                return 0;
            }
            return getLengthOfLineBreakSlow(text, index, c);
        }
        TextUtilities.getLengthOfLineBreak = getLengthOfLineBreak;
        function isAnyLineBreakCharacter(c) {
            return c === 10 /* lineFeed */ || c === 13 /* carriageReturn */ || c === 133 /* nextLine */ || c === 8232 /* lineSeparator */ || c === 8233 /* paragraphSeparator */;
        }
        TextUtilities.isAnyLineBreakCharacter = isAnyLineBreakCharacter;
    })(TextUtilities = TypeScript.TextUtilities || (TypeScript.TextUtilities = {}));
})(TypeScript || (TypeScript = {}));
///<reference path='references.ts' />
var TypeScript;
(function (TypeScript) {
    var TextSpan = (function () {
        /**
         * Creates a TextSpan instance beginning with the position Start and having the Length
         * specified with length.
         */
        function TextSpan(start, length) {
            if (start < 0) {
                TypeScript.Errors.argument("start");
            }
            if (length < 0) {
                TypeScript.Errors.argument("length");
            }
            this._start = start;
            this._length = length;
        }
        TextSpan.prototype.toJSON = function (key) {
            return { start: this._start, length: this._length };
        };
        TextSpan.prototype.start = function () {
            return this._start;
        };
        TextSpan.prototype.length = function () {
            return this._length;
        };
        TextSpan.prototype.end = function () {
            return this._start + this._length;
        };
        TextSpan.prototype.isEmpty = function () {
            return this._length === 0;
        };
        /**
         * Determines whether the position lies within the span. Returns true if the position is greater than or equal to Start and strictly less
         * than End, otherwise false.
         * @param position The position to check.
         */
        TextSpan.prototype.containsPosition = function (position) {
            return position >= this._start && position < this.end();
        };
        /**
         * Determines whether span falls completely within this span. Returns true if the specified span falls completely within this span, otherwise false.
         * @param span The span to check.
         */
        TextSpan.prototype.containsTextSpan = function (span) {
            return span._start >= this._start && span.end() <= this.end();
        };
        /**
         * Determines whether the given span overlaps this span. Two spans are considered to overlap
         * if they have positions in common and neither is empty. Empty spans do not overlap with any
         * other span. Returns true if the spans overlap, false otherwise.
         * @param span The span to check.
         */
        TextSpan.prototype.overlapsWith = function (span) {
            var overlapStart = Math.max(this._start, span._start);
            var overlapEnd = Math.min(this.end(), span.end());
            return overlapStart < overlapEnd;
        };
        /**
         * Returns the overlap with the given span, or null if there is no overlap.
         * @param span The span to check.
         */
        TextSpan.prototype.overlap = function (span) {
            var overlapStart = Math.max(this._start, span._start);
            var overlapEnd = Math.min(this.end(), span.end());
            if (overlapStart < overlapEnd) {
                return TextSpan.fromBounds(overlapStart, overlapEnd);
            }
            return null;
        };
        /**
         * Determines whether span intersects this span. Two spans are considered to
         * intersect if they have positions in common or the end of one span
         * coincides with the start of the other span. Returns true if the spans intersect, false otherwise.
         * @param The span to check.
         */
        TextSpan.prototype.intersectsWithTextSpan = function (span) {
            return span._start <= this.end() && span.end() >= this._start;
        };
        TextSpan.prototype.intersectsWith = function (start, length) {
            var end = start + length;
            return start <= this.end() && end >= this._start;
        };
        /**
         * Determines whether the given position intersects this span.
         * A position is considered to intersect if it is between the start and
         * end positions (inclusive) of this span. Returns true if the position intersects, false otherwise.
         * @param position The position to check.
         */
        TextSpan.prototype.intersectsWithPosition = function (position) {
            return position <= this.end() && position >= this._start;
        };
        /**
         * Returns the intersection with the given span, or null if there is no intersection.
         * @param span The span to check.
         */
        TextSpan.prototype.intersection = function (span) {
            var intersectStart = Math.max(this._start, span._start);
            var intersectEnd = Math.min(this.end(), span.end());
            if (intersectStart <= intersectEnd) {
                return TextSpan.fromBounds(intersectStart, intersectEnd);
            }
            return null;
        };
        /**
         * Creates a new TextSpan from the given start and end positions
         * as opposed to a position and length.
         */
        TextSpan.fromBounds = function (start, end) {
            TypeScript.Debug.assert(start >= 0);
            TypeScript.Debug.assert(end - start >= 0);
            return new TextSpan(start, end - start);
        };
        return TextSpan;
    })();
    TypeScript.TextSpan = TextSpan;
})(TypeScript || (TypeScript = {}));
///<reference path='references.ts' />
var TypeScript;
(function (TypeScript) {
    var TextChangeRange = (function () {
        /**
         * Initializes a new instance of TextChangeRange.
         */
        function TextChangeRange(span, newLength) {
            if (newLength < 0) {
                throw TypeScript.Errors.argumentOutOfRange("newLength");
            }
            this._span = span;
            this._newLength = newLength;
        }
        /**
         * The span of text before the edit which is being changed
         */
        TextChangeRange.prototype.span = function () {
            return this._span;
        };
        /**
         * Width of the span after the edit.  A 0 here would represent a delete
         */
        TextChangeRange.prototype.newLength = function () {
            return this._newLength;
        };
        TextChangeRange.prototype.newSpan = function () {
            return new TypeScript.TextSpan(this.span().start(), this.newLength());
        };
        TextChangeRange.prototype.isUnchanged = function () {
            return this.span().isEmpty() && this.newLength() === 0;
        };
        /**
         * Called to merge all the changes that occurred across several versions of a script snapshot
         * into a single change.  i.e. if a user keeps making successive edits to a script we will
         * have a text change from V1 to V2, V2 to V3, ..., Vn.
         *
         * This function will then merge those changes into a single change range valid between V1 and
         * Vn.
         */
        TextChangeRange.collapseChangesAcrossMultipleVersions = function (changes) {
            if (changes.length === 0) {
                return TextChangeRange.unchanged;
            }
            if (changes.length === 1) {
                return changes[0];
            }
            // We change from talking about { { oldStart, oldLength }, newLength } to { oldStart, oldEnd, newEnd }
            // as it makes things much easier to reason about.
            var change0 = changes[0];
            var oldStartN = change0.span().start();
            var oldEndN = change0.span().end();
            var newEndN = oldStartN + change0.newLength();
            for (var i = 1; i < changes.length; i++) {
                var nextChange = changes[i];
                // Consider the following case:
                // i.e. two edits.  The first represents the text change range { { 10, 50 }, 30 }.  i.e. The span starting
                // at 10, with length 50 is reduced to length 30.  The second represents the text change range { { 30, 30 }, 40 }.
                // i.e. the span starting at 30 with length 30 is increased to length 40.
                //
                //      0         10        20        30        40        50        60        70        80        90        100
                //      -------------------------------------------------------------------------------------------------------
                //                |                                                 /                                          
                //                |                                            /----                                           
                //  T1            |                                       /----                                                
                //                |                                  /----                                                     
                //                |                             /----                                                          
                //      -------------------------------------------------------------------------------------------------------
                //                                     |                            \                                          
                //                                     |                               \                                       
                //   T2                                |                                 \                                     
                //                                     |                                   \                                   
                //                                     |                                      \                                
                //      -------------------------------------------------------------------------------------------------------
                //
                // Merging these turns out to not be too difficult.  First, determining the new start of the change is trivial
                // it's just the min of the old and new starts.  i.e.:
                //
                //      0         10        20        30        40        50        60        70        80        90        100
                //      ------------------------------------------------------------*------------------------------------------
                //                |                                                 /                                          
                //                |                                            /----                                           
                //  T1            |                                       /----                                                
                //                |                                  /----                                                     
                //                |                             /----                                                          
                //      ----------------------------------------$-------------------$------------------------------------------
                //                .                    |                            \                                          
                //                .                    |                               \                                       
                //   T2           .                    |                                 \                                     
                //                .                    |                                   \                                   
                //                .                    |                                      \                                
                //      ----------------------------------------------------------------------*--------------------------------
                //
                // (Note the dots represent the newly inferrred start.
                // Determining the new and old end is also pretty simple.  Basically it boils down to paying attention to the
                // absolute positions at the asterixes, and the relative change between the dollar signs. Basically, we see
                // which if the two $'s precedes the other, and we move that one forward until they line up.  in this case that
                // means:
                //
                //      0         10        20        30        40        50        60        70        80        90        100
                //      --------------------------------------------------------------------------------*----------------------
                //                |                                                                     /                      
                //                |                                                                /----                       
                //  T1            |                                                           /----                            
                //                |                                                      /----                                 
                //                |                                                 /----                                      
                //      ------------------------------------------------------------$------------------------------------------
                //                .                    |                            \                                          
                //                .                    |                               \                                       
                //   T2           .                    |                                 \                                     
                //                .                    |                                   \                                   
                //                .                    |                                      \                                
                //      ----------------------------------------------------------------------*--------------------------------
                //
                // In other words (in this case), we're recognizing that the second edit happened after where the first edit
                // ended with a delta of 20 characters (60 - 40).  Thus, if we go back in time to where the first edit started
                // that's the same as if we started at char 80 instead of 60.  
                //
                // As it so happens, the same logic applies if the second edit precedes the first edit.  In that case rahter
                // than pusing the first edit forward to match the second, we'll push the second edit forward to match the
                // first.
                //
                // In this case that means we have { oldStart: 10, oldEnd: 80, newEnd: 70 } or, in TextChangeRange
                // semantics: { { start: 10, length: 70 }, newLength: 60 }
                //
                // The math then works out as follows.
                // If we have { oldStart1, oldEnd1, newEnd1 } and { oldStart2, oldEnd2, newEnd2 } then we can compute the 
                // final result like so:
                //
                // {
                //      oldStart3: Min(oldStart1, oldStart2),
                //      oldEnd3  : Max(oldEnd1, oldEnd1 + (oldEnd2 - newEnd1)),
                //      newEnd3  : Max(newEnd2, newEnd2 + (newEnd1 - oldEnd2))
                // }
                var oldStart1 = oldStartN;
                var oldEnd1 = oldEndN;
                var newEnd1 = newEndN;
                var oldStart2 = nextChange.span().start();
                var oldEnd2 = nextChange.span().end();
                var newEnd2 = oldStart2 + nextChange.newLength();
                oldStartN = Math.min(oldStart1, oldStart2);
                oldEndN = Math.max(oldEnd1, oldEnd1 + (oldEnd2 - newEnd1));
                newEndN = Math.max(newEnd2, newEnd2 + (newEnd1 - oldEnd2));
            }
            return new TextChangeRange(TypeScript.TextSpan.fromBounds(oldStartN, oldEndN), newEndN - oldStartN);
        };
        TextChangeRange.unchanged = new TextChangeRange(new TypeScript.TextSpan(0, 0), 0);
        return TextChangeRange;
    })();
    TypeScript.TextChangeRange = TextChangeRange;
})(TypeScript || (TypeScript = {}));
///<reference path='..\core\references.ts' />
///<reference path='references.ts' />
var TypeScript;
(function (TypeScript) {
    var CharacterInfo;
    (function (CharacterInfo) {
        function isDecimalDigit(c) {
            return c >= 48 /* _0 */ && c <= 57 /* _9 */;
        }
        CharacterInfo.isDecimalDigit = isDecimalDigit;
        function isOctalDigit(c) {
            return c >= 48 /* _0 */ && c <= 55 /* _7 */;
        }
        CharacterInfo.isOctalDigit = isOctalDigit;
        function isHexDigit(c) {
            return CharacterInfo.isDecimalDigit(c) || (c >= 65 /* A */ && c <= 70 /* F */) || (c >= 97 /* a */ && c <= 102 /* f */);
        }
        CharacterInfo.isHexDigit = isHexDigit;
        function hexValue(c) {
            // Debug.assert(isHexDigit(c));
            return CharacterInfo.isDecimalDigit(c) ? (c - 48 /* _0 */) : (c >= 65 /* A */ && c <= 70 /* F */) ? c - 65 /* A */ + 10 : c - 97 /* a */ + 10;
        }
        CharacterInfo.hexValue = hexValue;
        function isWhitespace(ch) {
            switch (ch) {
                case 32 /* space */:
                case 160 /* nonBreakingSpace */:
                case 8192 /* enQuad */:
                case 8193 /* emQuad */:
                case 8194 /* enSpace */:
                case 8195 /* emSpace */:
                case 8196 /* threePerEmSpace */:
                case 8197 /* fourPerEmSpace */:
                case 8198 /* sixPerEmSpace */:
                case 8199 /* figureSpace */:
                case 8200 /* punctuationSpace */:
                case 8201 /* thinSpace */:
                case 8202 /* hairSpace */:
                case 8203 /* zeroWidthSpace */:
                case 8239 /* narrowNoBreakSpace */:
                case 12288 /* ideographicSpace */:
                case 9 /* tab */:
                case 11 /* verticalTab */:
                case 12 /* formFeed */:
                case 65279 /* byteOrderMark */:
                    return true;
            }
            return false;
        }
        CharacterInfo.isWhitespace = isWhitespace;
        function isLineTerminator(ch) {
            switch (ch) {
                case 13 /* carriageReturn */:
                case 10 /* lineFeed */:
                case 8233 /* paragraphSeparator */:
                case 8232 /* lineSeparator */:
                    return true;
            }
            return false;
        }
        CharacterInfo.isLineTerminator = isLineTerminator;
    })(CharacterInfo = TypeScript.CharacterInfo || (TypeScript.CharacterInfo = {}));
})(TypeScript || (TypeScript = {}));
///<reference path='references.ts' />
var TypeScript;
(function (TypeScript) {
    (function (SyntaxConstants) {
        SyntaxConstants[SyntaxConstants["None"] = 0] = "None";
        // Masks that we use to place information about a node into a single int.  The first bit tells
        // us if we've computed the data for a node.
        //
        // The second bit tells us if the node is incrementally reusable if it does not
        // containe any skipped tokens, zero width tokens, regex tokens in it ("/", "/=" or "/.../"), 
        // and contains no tokens that were parser generated.
        //
        // The next bit lets us know if the nodes was parsed in a strict context or node.  A node can
        // only be used by the incremental parser if it is parsed in the same strict context as before.
        // last masks off the part of the int
        //
        // The width of the node is stored in the remainder of the int.  This allows us up to 512MB
        // for a node by using all 29 bits.  However, in the common case, we'll use less than 29 bits
        // for the width.  Thus, the info will be stored in a single int in chakra.
        SyntaxConstants[SyntaxConstants["NodeDataComputed"] = 0x00000001] = "NodeDataComputed";
        SyntaxConstants[SyntaxConstants["NodeIncrementallyUnusableMask"] = 0x00000002] = "NodeIncrementallyUnusableMask";
        SyntaxConstants[SyntaxConstants["NodeParsedInStrictModeMask"] = 0x00000004] = "NodeParsedInStrictModeMask";
        SyntaxConstants[SyntaxConstants["NodeFullWidthShift"] = 3] = "NodeFullWidthShift";
    })(TypeScript.SyntaxConstants || (TypeScript.SyntaxConstants = {}));
    var SyntaxConstants = TypeScript.SyntaxConstants;
})(TypeScript || (TypeScript = {}));
///<reference path='references.ts' />
var TypeScript;
(function (TypeScript) {
    var FormattingOptions = (function () {
        function FormattingOptions(useTabs, spacesPerTab, indentSpaces, newLineCharacter) {
            this.useTabs = useTabs;
            this.spacesPerTab = spacesPerTab;
            this.indentSpaces = indentSpaces;
            this.newLineCharacter = newLineCharacter;
        }
        FormattingOptions.defaultOptions = new FormattingOptions(false, 4, 4, "\r\n");
        return FormattingOptions;
    })();
    TypeScript.FormattingOptions = FormattingOptions;
})(TypeScript || (TypeScript = {}));
// If you change anything in this enum, make sure you run SyntaxGenerator again!
var TypeScript;
(function (TypeScript) {
    (function (SyntaxKind) {
        // Variable width tokens, trivia and lists.
        SyntaxKind[SyntaxKind["None"] = 0] = "None";
        SyntaxKind[SyntaxKind["List"] = 1] = "List";
        SyntaxKind[SyntaxKind["SeparatedList"] = 2] = "SeparatedList";
        SyntaxKind[SyntaxKind["TriviaList"] = 3] = "TriviaList";
        // Trivia
        SyntaxKind[SyntaxKind["WhitespaceTrivia"] = 4] = "WhitespaceTrivia";
        SyntaxKind[SyntaxKind["NewLineTrivia"] = 5] = "NewLineTrivia";
        SyntaxKind[SyntaxKind["MultiLineCommentTrivia"] = 6] = "MultiLineCommentTrivia";
        SyntaxKind[SyntaxKind["SingleLineCommentTrivia"] = 7] = "SingleLineCommentTrivia";
        SyntaxKind[SyntaxKind["SkippedTokenTrivia"] = 8] = "SkippedTokenTrivia";
        // Note: all variable width tokens must come before all fixed width tokens.
        SyntaxKind[SyntaxKind["ErrorToken"] = 9] = "ErrorToken";
        SyntaxKind[SyntaxKind["EndOfFileToken"] = 10] = "EndOfFileToken";
        // Tokens
        SyntaxKind[SyntaxKind["IdentifierName"] = 11] = "IdentifierName";
        // LiteralTokens
        SyntaxKind[SyntaxKind["RegularExpressionLiteral"] = 12] = "RegularExpressionLiteral";
        SyntaxKind[SyntaxKind["NumericLiteral"] = 13] = "NumericLiteral";
        SyntaxKind[SyntaxKind["StringLiteral"] = 14] = "StringLiteral";
        // All fixed width tokens follow.
        // Keywords
        SyntaxKind[SyntaxKind["BreakKeyword"] = 15] = "BreakKeyword";
        SyntaxKind[SyntaxKind["CaseKeyword"] = 16] = "CaseKeyword";
        SyntaxKind[SyntaxKind["CatchKeyword"] = 17] = "CatchKeyword";
        SyntaxKind[SyntaxKind["ContinueKeyword"] = 18] = "ContinueKeyword";
        SyntaxKind[SyntaxKind["DebuggerKeyword"] = 19] = "DebuggerKeyword";
        SyntaxKind[SyntaxKind["DefaultKeyword"] = 20] = "DefaultKeyword";
        SyntaxKind[SyntaxKind["DeleteKeyword"] = 21] = "DeleteKeyword";
        SyntaxKind[SyntaxKind["DoKeyword"] = 22] = "DoKeyword";
        SyntaxKind[SyntaxKind["ElseKeyword"] = 23] = "ElseKeyword";
        SyntaxKind[SyntaxKind["FalseKeyword"] = 24] = "FalseKeyword";
        SyntaxKind[SyntaxKind["FinallyKeyword"] = 25] = "FinallyKeyword";
        SyntaxKind[SyntaxKind["ForKeyword"] = 26] = "ForKeyword";
        SyntaxKind[SyntaxKind["FunctionKeyword"] = 27] = "FunctionKeyword";
        SyntaxKind[SyntaxKind["IfKeyword"] = 28] = "IfKeyword";
        SyntaxKind[SyntaxKind["InKeyword"] = 29] = "InKeyword";
        SyntaxKind[SyntaxKind["InstanceOfKeyword"] = 30] = "InstanceOfKeyword";
        SyntaxKind[SyntaxKind["NewKeyword"] = 31] = "NewKeyword";
        SyntaxKind[SyntaxKind["NullKeyword"] = 32] = "NullKeyword";
        SyntaxKind[SyntaxKind["ReturnKeyword"] = 33] = "ReturnKeyword";
        SyntaxKind[SyntaxKind["SwitchKeyword"] = 34] = "SwitchKeyword";
        SyntaxKind[SyntaxKind["ThisKeyword"] = 35] = "ThisKeyword";
        SyntaxKind[SyntaxKind["ThrowKeyword"] = 36] = "ThrowKeyword";
        SyntaxKind[SyntaxKind["TrueKeyword"] = 37] = "TrueKeyword";
        SyntaxKind[SyntaxKind["TryKeyword"] = 38] = "TryKeyword";
        SyntaxKind[SyntaxKind["TypeOfKeyword"] = 39] = "TypeOfKeyword";
        SyntaxKind[SyntaxKind["VarKeyword"] = 40] = "VarKeyword";
        SyntaxKind[SyntaxKind["VoidKeyword"] = 41] = "VoidKeyword";
        SyntaxKind[SyntaxKind["WhileKeyword"] = 42] = "WhileKeyword";
        SyntaxKind[SyntaxKind["WithKeyword"] = 43] = "WithKeyword";
        // FutureReservedWords.
        SyntaxKind[SyntaxKind["ClassKeyword"] = 44] = "ClassKeyword";
        SyntaxKind[SyntaxKind["ConstKeyword"] = 45] = "ConstKeyword";
        SyntaxKind[SyntaxKind["EnumKeyword"] = 46] = "EnumKeyword";
        SyntaxKind[SyntaxKind["ExportKeyword"] = 47] = "ExportKeyword";
        SyntaxKind[SyntaxKind["ExtendsKeyword"] = 48] = "ExtendsKeyword";
        SyntaxKind[SyntaxKind["ImportKeyword"] = 49] = "ImportKeyword";
        SyntaxKind[SyntaxKind["SuperKeyword"] = 50] = "SuperKeyword";
        // FutureReservedStrictWords.
        SyntaxKind[SyntaxKind["ImplementsKeyword"] = 51] = "ImplementsKeyword";
        SyntaxKind[SyntaxKind["InterfaceKeyword"] = 52] = "InterfaceKeyword";
        SyntaxKind[SyntaxKind["LetKeyword"] = 53] = "LetKeyword";
        SyntaxKind[SyntaxKind["PackageKeyword"] = 54] = "PackageKeyword";
        SyntaxKind[SyntaxKind["PrivateKeyword"] = 55] = "PrivateKeyword";
        SyntaxKind[SyntaxKind["ProtectedKeyword"] = 56] = "ProtectedKeyword";
        SyntaxKind[SyntaxKind["PublicKeyword"] = 57] = "PublicKeyword";
        SyntaxKind[SyntaxKind["StaticKeyword"] = 58] = "StaticKeyword";
        SyntaxKind[SyntaxKind["YieldKeyword"] = 59] = "YieldKeyword";
        // TypeScript keywords.
        SyntaxKind[SyntaxKind["AnyKeyword"] = 60] = "AnyKeyword";
        SyntaxKind[SyntaxKind["BooleanKeyword"] = 61] = "BooleanKeyword";
        SyntaxKind[SyntaxKind["ConstructorKeyword"] = 62] = "ConstructorKeyword";
        SyntaxKind[SyntaxKind["DeclareKeyword"] = 63] = "DeclareKeyword";
        SyntaxKind[SyntaxKind["GetKeyword"] = 64] = "GetKeyword";
        SyntaxKind[SyntaxKind["ModuleKeyword"] = 65] = "ModuleKeyword";
        SyntaxKind[SyntaxKind["RequireKeyword"] = 66] = "RequireKeyword";
        SyntaxKind[SyntaxKind["NumberKeyword"] = 67] = "NumberKeyword";
        SyntaxKind[SyntaxKind["SetKeyword"] = 68] = "SetKeyword";
        SyntaxKind[SyntaxKind["StringKeyword"] = 69] = "StringKeyword";
        // Punctuators
        SyntaxKind[SyntaxKind["OpenBraceToken"] = 70] = "OpenBraceToken";
        SyntaxKind[SyntaxKind["CloseBraceToken"] = 71] = "CloseBraceToken";
        SyntaxKind[SyntaxKind["OpenParenToken"] = 72] = "OpenParenToken";
        SyntaxKind[SyntaxKind["CloseParenToken"] = 73] = "CloseParenToken";
        SyntaxKind[SyntaxKind["OpenBracketToken"] = 74] = "OpenBracketToken";
        SyntaxKind[SyntaxKind["CloseBracketToken"] = 75] = "CloseBracketToken";
        SyntaxKind[SyntaxKind["DotToken"] = 76] = "DotToken";
        SyntaxKind[SyntaxKind["DotDotDotToken"] = 77] = "DotDotDotToken";
        SyntaxKind[SyntaxKind["SemicolonToken"] = 78] = "SemicolonToken";
        SyntaxKind[SyntaxKind["CommaToken"] = 79] = "CommaToken";
        SyntaxKind[SyntaxKind["LessThanToken"] = 80] = "LessThanToken";
        SyntaxKind[SyntaxKind["GreaterThanToken"] = 81] = "GreaterThanToken";
        SyntaxKind[SyntaxKind["LessThanEqualsToken"] = 82] = "LessThanEqualsToken";
        SyntaxKind[SyntaxKind["GreaterThanEqualsToken"] = 83] = "GreaterThanEqualsToken";
        SyntaxKind[SyntaxKind["EqualsEqualsToken"] = 84] = "EqualsEqualsToken";
        SyntaxKind[SyntaxKind["EqualsGreaterThanToken"] = 85] = "EqualsGreaterThanToken";
        SyntaxKind[SyntaxKind["ExclamationEqualsToken"] = 86] = "ExclamationEqualsToken";
        SyntaxKind[SyntaxKind["EqualsEqualsEqualsToken"] = 87] = "EqualsEqualsEqualsToken";
        SyntaxKind[SyntaxKind["ExclamationEqualsEqualsToken"] = 88] = "ExclamationEqualsEqualsToken";
        SyntaxKind[SyntaxKind["PlusToken"] = 89] = "PlusToken";
        SyntaxKind[SyntaxKind["MinusToken"] = 90] = "MinusToken";
        SyntaxKind[SyntaxKind["AsteriskToken"] = 91] = "AsteriskToken";
        SyntaxKind[SyntaxKind["PercentToken"] = 92] = "PercentToken";
        SyntaxKind[SyntaxKind["PlusPlusToken"] = 93] = "PlusPlusToken";
        SyntaxKind[SyntaxKind["MinusMinusToken"] = 94] = "MinusMinusToken";
        SyntaxKind[SyntaxKind["LessThanLessThanToken"] = 95] = "LessThanLessThanToken";
        SyntaxKind[SyntaxKind["GreaterThanGreaterThanToken"] = 96] = "GreaterThanGreaterThanToken";
        SyntaxKind[SyntaxKind["GreaterThanGreaterThanGreaterThanToken"] = 97] = "GreaterThanGreaterThanGreaterThanToken";
        SyntaxKind[SyntaxKind["AmpersandToken"] = 98] = "AmpersandToken";
        SyntaxKind[SyntaxKind["BarToken"] = 99] = "BarToken";
        SyntaxKind[SyntaxKind["CaretToken"] = 100] = "CaretToken";
        SyntaxKind[SyntaxKind["ExclamationToken"] = 101] = "ExclamationToken";
        SyntaxKind[SyntaxKind["TildeToken"] = 102] = "TildeToken";
        SyntaxKind[SyntaxKind["AmpersandAmpersandToken"] = 103] = "AmpersandAmpersandToken";
        SyntaxKind[SyntaxKind["BarBarToken"] = 104] = "BarBarToken";
        SyntaxKind[SyntaxKind["QuestionToken"] = 105] = "QuestionToken";
        SyntaxKind[SyntaxKind["ColonToken"] = 106] = "ColonToken";
        SyntaxKind[SyntaxKind["EqualsToken"] = 107] = "EqualsToken";
        SyntaxKind[SyntaxKind["PlusEqualsToken"] = 108] = "PlusEqualsToken";
        SyntaxKind[SyntaxKind["MinusEqualsToken"] = 109] = "MinusEqualsToken";
        SyntaxKind[SyntaxKind["AsteriskEqualsToken"] = 110] = "AsteriskEqualsToken";
        SyntaxKind[SyntaxKind["PercentEqualsToken"] = 111] = "PercentEqualsToken";
        SyntaxKind[SyntaxKind["LessThanLessThanEqualsToken"] = 112] = "LessThanLessThanEqualsToken";
        SyntaxKind[SyntaxKind["GreaterThanGreaterThanEqualsToken"] = 113] = "GreaterThanGreaterThanEqualsToken";
        SyntaxKind[SyntaxKind["GreaterThanGreaterThanGreaterThanEqualsToken"] = 114] = "GreaterThanGreaterThanGreaterThanEqualsToken";
        SyntaxKind[SyntaxKind["AmpersandEqualsToken"] = 115] = "AmpersandEqualsToken";
        SyntaxKind[SyntaxKind["BarEqualsToken"] = 116] = "BarEqualsToken";
        SyntaxKind[SyntaxKind["CaretEqualsToken"] = 117] = "CaretEqualsToken";
        SyntaxKind[SyntaxKind["SlashToken"] = 118] = "SlashToken";
        SyntaxKind[SyntaxKind["SlashEqualsToken"] = 119] = "SlashEqualsToken";
        // SyntaxNodes
        SyntaxKind[SyntaxKind["SourceUnit"] = 120] = "SourceUnit";
        // Names
        SyntaxKind[SyntaxKind["QualifiedName"] = 121] = "QualifiedName";
        // Types
        SyntaxKind[SyntaxKind["ObjectType"] = 122] = "ObjectType";
        SyntaxKind[SyntaxKind["FunctionType"] = 123] = "FunctionType";
        SyntaxKind[SyntaxKind["ArrayType"] = 124] = "ArrayType";
        SyntaxKind[SyntaxKind["ConstructorType"] = 125] = "ConstructorType";
        SyntaxKind[SyntaxKind["GenericType"] = 126] = "GenericType";
        SyntaxKind[SyntaxKind["TypeQuery"] = 127] = "TypeQuery";
        SyntaxKind[SyntaxKind["TupleType"] = 128] = "TupleType";
        // Module elements.
        SyntaxKind[SyntaxKind["InterfaceDeclaration"] = 129] = "InterfaceDeclaration";
        SyntaxKind[SyntaxKind["FunctionDeclaration"] = 130] = "FunctionDeclaration";
        SyntaxKind[SyntaxKind["ModuleDeclaration"] = 131] = "ModuleDeclaration";
        SyntaxKind[SyntaxKind["ClassDeclaration"] = 132] = "ClassDeclaration";
        SyntaxKind[SyntaxKind["EnumDeclaration"] = 133] = "EnumDeclaration";
        SyntaxKind[SyntaxKind["ImportDeclaration"] = 134] = "ImportDeclaration";
        SyntaxKind[SyntaxKind["ExportAssignment"] = 135] = "ExportAssignment";
        // ClassElements
        SyntaxKind[SyntaxKind["MemberFunctionDeclaration"] = 136] = "MemberFunctionDeclaration";
        SyntaxKind[SyntaxKind["MemberVariableDeclaration"] = 137] = "MemberVariableDeclaration";
        SyntaxKind[SyntaxKind["ConstructorDeclaration"] = 138] = "ConstructorDeclaration";
        SyntaxKind[SyntaxKind["IndexMemberDeclaration"] = 139] = "IndexMemberDeclaration";
        // ClassElement and PropertyAssignment
        SyntaxKind[SyntaxKind["GetAccessor"] = 140] = "GetAccessor";
        SyntaxKind[SyntaxKind["SetAccessor"] = 141] = "SetAccessor";
        // Type members.
        SyntaxKind[SyntaxKind["PropertySignature"] = 142] = "PropertySignature";
        SyntaxKind[SyntaxKind["CallSignature"] = 143] = "CallSignature";
        SyntaxKind[SyntaxKind["ConstructSignature"] = 144] = "ConstructSignature";
        SyntaxKind[SyntaxKind["IndexSignature"] = 145] = "IndexSignature";
        SyntaxKind[SyntaxKind["MethodSignature"] = 146] = "MethodSignature";
        // Statements
        SyntaxKind[SyntaxKind["Block"] = 147] = "Block";
        SyntaxKind[SyntaxKind["IfStatement"] = 148] = "IfStatement";
        SyntaxKind[SyntaxKind["VariableStatement"] = 149] = "VariableStatement";
        SyntaxKind[SyntaxKind["ExpressionStatement"] = 150] = "ExpressionStatement";
        SyntaxKind[SyntaxKind["ReturnStatement"] = 151] = "ReturnStatement";
        SyntaxKind[SyntaxKind["SwitchStatement"] = 152] = "SwitchStatement";
        SyntaxKind[SyntaxKind["BreakStatement"] = 153] = "BreakStatement";
        SyntaxKind[SyntaxKind["ContinueStatement"] = 154] = "ContinueStatement";
        SyntaxKind[SyntaxKind["ForStatement"] = 155] = "ForStatement";
        SyntaxKind[SyntaxKind["ForInStatement"] = 156] = "ForInStatement";
        SyntaxKind[SyntaxKind["EmptyStatement"] = 157] = "EmptyStatement";
        SyntaxKind[SyntaxKind["ThrowStatement"] = 158] = "ThrowStatement";
        SyntaxKind[SyntaxKind["WhileStatement"] = 159] = "WhileStatement";
        SyntaxKind[SyntaxKind["TryStatement"] = 160] = "TryStatement";
        SyntaxKind[SyntaxKind["LabeledStatement"] = 161] = "LabeledStatement";
        SyntaxKind[SyntaxKind["DoStatement"] = 162] = "DoStatement";
        SyntaxKind[SyntaxKind["DebuggerStatement"] = 163] = "DebuggerStatement";
        SyntaxKind[SyntaxKind["WithStatement"] = 164] = "WithStatement";
        // Expressions
        SyntaxKind[SyntaxKind["PlusExpression"] = 165] = "PlusExpression";
        SyntaxKind[SyntaxKind["NegateExpression"] = 166] = "NegateExpression";
        SyntaxKind[SyntaxKind["BitwiseNotExpression"] = 167] = "BitwiseNotExpression";
        SyntaxKind[SyntaxKind["LogicalNotExpression"] = 168] = "LogicalNotExpression";
        SyntaxKind[SyntaxKind["PreIncrementExpression"] = 169] = "PreIncrementExpression";
        SyntaxKind[SyntaxKind["PreDecrementExpression"] = 170] = "PreDecrementExpression";
        SyntaxKind[SyntaxKind["DeleteExpression"] = 171] = "DeleteExpression";
        SyntaxKind[SyntaxKind["TypeOfExpression"] = 172] = "TypeOfExpression";
        SyntaxKind[SyntaxKind["VoidExpression"] = 173] = "VoidExpression";
        SyntaxKind[SyntaxKind["CommaExpression"] = 174] = "CommaExpression";
        SyntaxKind[SyntaxKind["AssignmentExpression"] = 175] = "AssignmentExpression";
        SyntaxKind[SyntaxKind["AddAssignmentExpression"] = 176] = "AddAssignmentExpression";
        SyntaxKind[SyntaxKind["SubtractAssignmentExpression"] = 177] = "SubtractAssignmentExpression";
        SyntaxKind[SyntaxKind["MultiplyAssignmentExpression"] = 178] = "MultiplyAssignmentExpression";
        SyntaxKind[SyntaxKind["DivideAssignmentExpression"] = 179] = "DivideAssignmentExpression";
        SyntaxKind[SyntaxKind["ModuloAssignmentExpression"] = 180] = "ModuloAssignmentExpression";
        SyntaxKind[SyntaxKind["AndAssignmentExpression"] = 181] = "AndAssignmentExpression";
        SyntaxKind[SyntaxKind["ExclusiveOrAssignmentExpression"] = 182] = "ExclusiveOrAssignmentExpression";
        SyntaxKind[SyntaxKind["OrAssignmentExpression"] = 183] = "OrAssignmentExpression";
        SyntaxKind[SyntaxKind["LeftShiftAssignmentExpression"] = 184] = "LeftShiftAssignmentExpression";
        SyntaxKind[SyntaxKind["SignedRightShiftAssignmentExpression"] = 185] = "SignedRightShiftAssignmentExpression";
        SyntaxKind[SyntaxKind["UnsignedRightShiftAssignmentExpression"] = 186] = "UnsignedRightShiftAssignmentExpression";
        SyntaxKind[SyntaxKind["ConditionalExpression"] = 187] = "ConditionalExpression";
        SyntaxKind[SyntaxKind["LogicalOrExpression"] = 188] = "LogicalOrExpression";
        SyntaxKind[SyntaxKind["LogicalAndExpression"] = 189] = "LogicalAndExpression";
        SyntaxKind[SyntaxKind["BitwiseOrExpression"] = 190] = "BitwiseOrExpression";
        SyntaxKind[SyntaxKind["BitwiseExclusiveOrExpression"] = 191] = "BitwiseExclusiveOrExpression";
        SyntaxKind[SyntaxKind["BitwiseAndExpression"] = 192] = "BitwiseAndExpression";
        SyntaxKind[SyntaxKind["EqualsWithTypeConversionExpression"] = 193] = "EqualsWithTypeConversionExpression";
        SyntaxKind[SyntaxKind["NotEqualsWithTypeConversionExpression"] = 194] = "NotEqualsWithTypeConversionExpression";
        SyntaxKind[SyntaxKind["EqualsExpression"] = 195] = "EqualsExpression";
        SyntaxKind[SyntaxKind["NotEqualsExpression"] = 196] = "NotEqualsExpression";
        SyntaxKind[SyntaxKind["LessThanExpression"] = 197] = "LessThanExpression";
        SyntaxKind[SyntaxKind["GreaterThanExpression"] = 198] = "GreaterThanExpression";
        SyntaxKind[SyntaxKind["LessThanOrEqualExpression"] = 199] = "LessThanOrEqualExpression";
        SyntaxKind[SyntaxKind["GreaterThanOrEqualExpression"] = 200] = "GreaterThanOrEqualExpression";
        SyntaxKind[SyntaxKind["InstanceOfExpression"] = 201] = "InstanceOfExpression";
        SyntaxKind[SyntaxKind["InExpression"] = 202] = "InExpression";
        SyntaxKind[SyntaxKind["LeftShiftExpression"] = 203] = "LeftShiftExpression";
        SyntaxKind[SyntaxKind["SignedRightShiftExpression"] = 204] = "SignedRightShiftExpression";
        SyntaxKind[SyntaxKind["UnsignedRightShiftExpression"] = 205] = "UnsignedRightShiftExpression";
        SyntaxKind[SyntaxKind["MultiplyExpression"] = 206] = "MultiplyExpression";
        SyntaxKind[SyntaxKind["DivideExpression"] = 207] = "DivideExpression";
        SyntaxKind[SyntaxKind["ModuloExpression"] = 208] = "ModuloExpression";
        SyntaxKind[SyntaxKind["AddExpression"] = 209] = "AddExpression";
        SyntaxKind[SyntaxKind["SubtractExpression"] = 210] = "SubtractExpression";
        SyntaxKind[SyntaxKind["PostIncrementExpression"] = 211] = "PostIncrementExpression";
        SyntaxKind[SyntaxKind["PostDecrementExpression"] = 212] = "PostDecrementExpression";
        SyntaxKind[SyntaxKind["MemberAccessExpression"] = 213] = "MemberAccessExpression";
        SyntaxKind[SyntaxKind["InvocationExpression"] = 214] = "InvocationExpression";
        SyntaxKind[SyntaxKind["ArrayLiteralExpression"] = 215] = "ArrayLiteralExpression";
        SyntaxKind[SyntaxKind["ObjectLiteralExpression"] = 216] = "ObjectLiteralExpression";
        SyntaxKind[SyntaxKind["ObjectCreationExpression"] = 217] = "ObjectCreationExpression";
        SyntaxKind[SyntaxKind["ParenthesizedExpression"] = 218] = "ParenthesizedExpression";
        SyntaxKind[SyntaxKind["ParenthesizedArrowFunctionExpression"] = 219] = "ParenthesizedArrowFunctionExpression";
        SyntaxKind[SyntaxKind["SimpleArrowFunctionExpression"] = 220] = "SimpleArrowFunctionExpression";
        SyntaxKind[SyntaxKind["CastExpression"] = 221] = "CastExpression";
        SyntaxKind[SyntaxKind["ElementAccessExpression"] = 222] = "ElementAccessExpression";
        SyntaxKind[SyntaxKind["FunctionExpression"] = 223] = "FunctionExpression";
        SyntaxKind[SyntaxKind["OmittedExpression"] = 224] = "OmittedExpression";
        // Variable declarations
        SyntaxKind[SyntaxKind["VariableDeclaration"] = 225] = "VariableDeclaration";
        SyntaxKind[SyntaxKind["VariableDeclarator"] = 226] = "VariableDeclarator";
        // Lists
        SyntaxKind[SyntaxKind["ArgumentList"] = 227] = "ArgumentList";
        SyntaxKind[SyntaxKind["ParameterList"] = 228] = "ParameterList";
        SyntaxKind[SyntaxKind["TypeArgumentList"] = 229] = "TypeArgumentList";
        SyntaxKind[SyntaxKind["TypeParameterList"] = 230] = "TypeParameterList";
        // Clauses
        SyntaxKind[SyntaxKind["ExtendsHeritageClause"] = 231] = "ExtendsHeritageClause";
        SyntaxKind[SyntaxKind["ImplementsHeritageClause"] = 232] = "ImplementsHeritageClause";
        SyntaxKind[SyntaxKind["EqualsValueClause"] = 233] = "EqualsValueClause";
        SyntaxKind[SyntaxKind["CaseSwitchClause"] = 234] = "CaseSwitchClause";
        SyntaxKind[SyntaxKind["DefaultSwitchClause"] = 235] = "DefaultSwitchClause";
        SyntaxKind[SyntaxKind["ElseClause"] = 236] = "ElseClause";
        SyntaxKind[SyntaxKind["CatchClause"] = 237] = "CatchClause";
        SyntaxKind[SyntaxKind["FinallyClause"] = 238] = "FinallyClause";
        // Generics
        SyntaxKind[SyntaxKind["TypeParameter"] = 239] = "TypeParameter";
        SyntaxKind[SyntaxKind["Constraint"] = 240] = "Constraint";
        // Property Assignment
        SyntaxKind[SyntaxKind["SimplePropertyAssignment"] = 241] = "SimplePropertyAssignment";
        // GetAccessorPropertyAssignment,
        // SetAccessorPropertyAssignment,
        SyntaxKind[SyntaxKind["FunctionPropertyAssignment"] = 242] = "FunctionPropertyAssignment";
        // Misc.
        SyntaxKind[SyntaxKind["Parameter"] = 243] = "Parameter";
        SyntaxKind[SyntaxKind["EnumElement"] = 244] = "EnumElement";
        SyntaxKind[SyntaxKind["TypeAnnotation"] = 245] = "TypeAnnotation";
        SyntaxKind[SyntaxKind["ExternalModuleReference"] = 246] = "ExternalModuleReference";
        SyntaxKind[SyntaxKind["ModuleNameModuleReference"] = 247] = "ModuleNameModuleReference";
        SyntaxKind[SyntaxKind["FirstStandardKeyword"] = SyntaxKind.BreakKeyword] = "FirstStandardKeyword";
        SyntaxKind[SyntaxKind["LastStandardKeyword"] = SyntaxKind.WithKeyword] = "LastStandardKeyword";
        SyntaxKind[SyntaxKind["FirstFutureReservedKeyword"] = SyntaxKind.ClassKeyword] = "FirstFutureReservedKeyword";
        SyntaxKind[SyntaxKind["LastFutureReservedKeyword"] = SyntaxKind.SuperKeyword] = "LastFutureReservedKeyword";
        SyntaxKind[SyntaxKind["FirstFutureReservedStrictKeyword"] = SyntaxKind.ImplementsKeyword] = "FirstFutureReservedStrictKeyword";
        SyntaxKind[SyntaxKind["LastFutureReservedStrictKeyword"] = SyntaxKind.YieldKeyword] = "LastFutureReservedStrictKeyword";
        SyntaxKind[SyntaxKind["FirstTypeScriptKeyword"] = SyntaxKind.AnyKeyword] = "FirstTypeScriptKeyword";
        SyntaxKind[SyntaxKind["LastTypeScriptKeyword"] = SyntaxKind.StringKeyword] = "LastTypeScriptKeyword";
        SyntaxKind[SyntaxKind["FirstKeyword"] = SyntaxKind.FirstStandardKeyword] = "FirstKeyword";
        SyntaxKind[SyntaxKind["LastKeyword"] = SyntaxKind.LastTypeScriptKeyword] = "LastKeyword";
        SyntaxKind[SyntaxKind["FirstToken"] = SyntaxKind.ErrorToken] = "FirstToken";
        SyntaxKind[SyntaxKind["LastToken"] = SyntaxKind.SlashEqualsToken] = "LastToken";
        SyntaxKind[SyntaxKind["FirstPunctuation"] = SyntaxKind.OpenBraceToken] = "FirstPunctuation";
        SyntaxKind[SyntaxKind["LastPunctuation"] = SyntaxKind.SlashEqualsToken] = "LastPunctuation";
        SyntaxKind[SyntaxKind["FirstFixedWidth"] = SyntaxKind.FirstKeyword] = "FirstFixedWidth";
        SyntaxKind[SyntaxKind["LastFixedWidth"] = SyntaxKind.LastPunctuation] = "LastFixedWidth";
        SyntaxKind[SyntaxKind["FirstTrivia"] = SyntaxKind.WhitespaceTrivia] = "FirstTrivia";
        SyntaxKind[SyntaxKind["LastTrivia"] = SyntaxKind.SkippedTokenTrivia] = "LastTrivia";
        SyntaxKind[SyntaxKind["FirstNode"] = SyntaxKind.SourceUnit] = "FirstNode";
        SyntaxKind[SyntaxKind["LastNode"] = SyntaxKind.ModuleNameModuleReference] = "LastNode";
    })(TypeScript.SyntaxKind || (TypeScript.SyntaxKind = {}));
    var SyntaxKind = TypeScript.SyntaxKind;
})(TypeScript || (TypeScript = {}));
///<reference path='syntaxKind.ts' />
var TypeScript;
(function (TypeScript) {
    var SyntaxFacts;
    (function (SyntaxFacts) {
        var textToKeywordKind = {
            "any": 60 /* AnyKeyword */,
            "boolean": 61 /* BooleanKeyword */,
            "break": 15 /* BreakKeyword */,
            "case": 16 /* CaseKeyword */,
            "catch": 17 /* CatchKeyword */,
            "class": 44 /* ClassKeyword */,
            "continue": 18 /* ContinueKeyword */,
            "const": 45 /* ConstKeyword */,
            "constructor": 62 /* ConstructorKeyword */,
            "debugger": 19 /* DebuggerKeyword */,
            "declare": 63 /* DeclareKeyword */,
            "default": 20 /* DefaultKeyword */,
            "delete": 21 /* DeleteKeyword */,
            "do": 22 /* DoKeyword */,
            "else": 23 /* ElseKeyword */,
            "enum": 46 /* EnumKeyword */,
            "export": 47 /* ExportKeyword */,
            "extends": 48 /* ExtendsKeyword */,
            "false": 24 /* FalseKeyword */,
            "finally": 25 /* FinallyKeyword */,
            "for": 26 /* ForKeyword */,
            "function": 27 /* FunctionKeyword */,
            "get": 64 /* GetKeyword */,
            "if": 28 /* IfKeyword */,
            "implements": 51 /* ImplementsKeyword */,
            "import": 49 /* ImportKeyword */,
            "in": 29 /* InKeyword */,
            "instanceof": 30 /* InstanceOfKeyword */,
            "interface": 52 /* InterfaceKeyword */,
            "let": 53 /* LetKeyword */,
            "module": 65 /* ModuleKeyword */,
            "new": 31 /* NewKeyword */,
            "null": 32 /* NullKeyword */,
            "number": 67 /* NumberKeyword */,
            "package": 54 /* PackageKeyword */,
            "private": 55 /* PrivateKeyword */,
            "protected": 56 /* ProtectedKeyword */,
            "public": 57 /* PublicKeyword */,
            "require": 66 /* RequireKeyword */,
            "return": 33 /* ReturnKeyword */,
            "set": 68 /* SetKeyword */,
            "static": 58 /* StaticKeyword */,
            "string": 69 /* StringKeyword */,
            "super": 50 /* SuperKeyword */,
            "switch": 34 /* SwitchKeyword */,
            "this": 35 /* ThisKeyword */,
            "throw": 36 /* ThrowKeyword */,
            "true": 37 /* TrueKeyword */,
            "try": 38 /* TryKeyword */,
            "typeof": 39 /* TypeOfKeyword */,
            "var": 40 /* VarKeyword */,
            "void": 41 /* VoidKeyword */,
            "while": 42 /* WhileKeyword */,
            "with": 43 /* WithKeyword */,
            "yield": 59 /* YieldKeyword */,
            "{": 70 /* OpenBraceToken */,
            "}": 71 /* CloseBraceToken */,
            "(": 72 /* OpenParenToken */,
            ")": 73 /* CloseParenToken */,
            "[": 74 /* OpenBracketToken */,
            "]": 75 /* CloseBracketToken */,
            ".": 76 /* DotToken */,
            "...": 77 /* DotDotDotToken */,
            ";": 78 /* SemicolonToken */,
            ",": 79 /* CommaToken */,
            "<": 80 /* LessThanToken */,
            ">": 81 /* GreaterThanToken */,
            "<=": 82 /* LessThanEqualsToken */,
            ">=": 83 /* GreaterThanEqualsToken */,
            "==": 84 /* EqualsEqualsToken */,
            "=>": 85 /* EqualsGreaterThanToken */,
            "!=": 86 /* ExclamationEqualsToken */,
            "===": 87 /* EqualsEqualsEqualsToken */,
            "!==": 88 /* ExclamationEqualsEqualsToken */,
            "+": 89 /* PlusToken */,
            "-": 90 /* MinusToken */,
            "*": 91 /* AsteriskToken */,
            "%": 92 /* PercentToken */,
            "++": 93 /* PlusPlusToken */,
            "--": 94 /* MinusMinusToken */,
            "<<": 95 /* LessThanLessThanToken */,
            ">>": 96 /* GreaterThanGreaterThanToken */,
            ">>>": 97 /* GreaterThanGreaterThanGreaterThanToken */,
            "&": 98 /* AmpersandToken */,
            "|": 99 /* BarToken */,
            "^": 100 /* CaretToken */,
            "!": 101 /* ExclamationToken */,
            "~": 102 /* TildeToken */,
            "&&": 103 /* AmpersandAmpersandToken */,
            "||": 104 /* BarBarToken */,
            "?": 105 /* QuestionToken */,
            ":": 106 /* ColonToken */,
            "=": 107 /* EqualsToken */,
            "+=": 108 /* PlusEqualsToken */,
            "-=": 109 /* MinusEqualsToken */,
            "*=": 110 /* AsteriskEqualsToken */,
            "%=": 111 /* PercentEqualsToken */,
            "<<=": 112 /* LessThanLessThanEqualsToken */,
            ">>=": 113 /* GreaterThanGreaterThanEqualsToken */,
            ">>>=": 114 /* GreaterThanGreaterThanGreaterThanEqualsToken */,
            "&=": 115 /* AmpersandEqualsToken */,
            "|=": 116 /* BarEqualsToken */,
            "^=": 117 /* CaretEqualsToken */,
            "/": 118 /* SlashToken */,
            "/=": 119 /* SlashEqualsToken */
        };
        var kindToText = new Array();
        for (var name in textToKeywordKind) {
            if (textToKeywordKind.hasOwnProperty(name)) {
                // Debug.assert(kindToText[textToKeywordKind[name]] === undefined);
                kindToText[textToKeywordKind[name]] = name;
            }
        }
        // Manually work around a bug in the CScript 5.8 runtime where 'constructor' is not
        // listed when SyntaxFacts.textToKeywordKind is enumerated because it is the name of
        // the constructor function.
        kindToText[62 /* ConstructorKeyword */] = "constructor";
        function getTokenKind(text) {
            if (textToKeywordKind.hasOwnProperty(text)) {
                return textToKeywordKind[text];
            }
            return 0 /* None */;
        }
        SyntaxFacts.getTokenKind = getTokenKind;
        function getText(kind) {
            var result = kindToText[kind];
            return result !== undefined ? result : null;
        }
        SyntaxFacts.getText = getText;
        function isAnyKeyword(kind) {
            return kind >= TypeScript.SyntaxKind.FirstKeyword && kind <= TypeScript.SyntaxKind.LastKeyword;
        }
        SyntaxFacts.isAnyKeyword = isAnyKeyword;
        function isAnyPunctuation(kind) {
            return kind >= TypeScript.SyntaxKind.FirstPunctuation && kind <= TypeScript.SyntaxKind.LastPunctuation;
        }
        SyntaxFacts.isAnyPunctuation = isAnyPunctuation;
        function isPrefixUnaryExpressionOperatorToken(tokenKind) {
            return getPrefixUnaryExpressionFromOperatorToken(tokenKind) !== 0 /* None */;
        }
        SyntaxFacts.isPrefixUnaryExpressionOperatorToken = isPrefixUnaryExpressionOperatorToken;
        function isBinaryExpressionOperatorToken(tokenKind) {
            return getBinaryExpressionFromOperatorToken(tokenKind) !== 0 /* None */;
        }
        SyntaxFacts.isBinaryExpressionOperatorToken = isBinaryExpressionOperatorToken;
        function getPrefixUnaryExpressionFromOperatorToken(tokenKind) {
            switch (tokenKind) {
                case 89 /* PlusToken */:
                    return 165 /* PlusExpression */;
                case 90 /* MinusToken */:
                    return 166 /* NegateExpression */;
                case 102 /* TildeToken */:
                    return 167 /* BitwiseNotExpression */;
                case 101 /* ExclamationToken */:
                    return 168 /* LogicalNotExpression */;
                case 93 /* PlusPlusToken */:
                    return 169 /* PreIncrementExpression */;
                case 94 /* MinusMinusToken */:
                    return 170 /* PreDecrementExpression */;
                default:
                    return 0 /* None */;
            }
        }
        SyntaxFacts.getPrefixUnaryExpressionFromOperatorToken = getPrefixUnaryExpressionFromOperatorToken;
        function getPostfixUnaryExpressionFromOperatorToken(tokenKind) {
            switch (tokenKind) {
                case 93 /* PlusPlusToken */:
                    return 211 /* PostIncrementExpression */;
                case 94 /* MinusMinusToken */:
                    return 212 /* PostDecrementExpression */;
                default:
                    return 0 /* None */;
            }
        }
        SyntaxFacts.getPostfixUnaryExpressionFromOperatorToken = getPostfixUnaryExpressionFromOperatorToken;
        function getBinaryExpressionFromOperatorToken(tokenKind) {
            switch (tokenKind) {
                case 91 /* AsteriskToken */:
                    return 206 /* MultiplyExpression */;
                case 118 /* SlashToken */:
                    return 207 /* DivideExpression */;
                case 92 /* PercentToken */:
                    return 208 /* ModuloExpression */;
                case 89 /* PlusToken */:
                    return 209 /* AddExpression */;
                case 90 /* MinusToken */:
                    return 210 /* SubtractExpression */;
                case 95 /* LessThanLessThanToken */:
                    return 203 /* LeftShiftExpression */;
                case 96 /* GreaterThanGreaterThanToken */:
                    return 204 /* SignedRightShiftExpression */;
                case 97 /* GreaterThanGreaterThanGreaterThanToken */:
                    return 205 /* UnsignedRightShiftExpression */;
                case 80 /* LessThanToken */:
                    return 197 /* LessThanExpression */;
                case 81 /* GreaterThanToken */:
                    return 198 /* GreaterThanExpression */;
                case 82 /* LessThanEqualsToken */:
                    return 199 /* LessThanOrEqualExpression */;
                case 83 /* GreaterThanEqualsToken */:
                    return 200 /* GreaterThanOrEqualExpression */;
                case 30 /* InstanceOfKeyword */:
                    return 201 /* InstanceOfExpression */;
                case 29 /* InKeyword */:
                    return 202 /* InExpression */;
                case 84 /* EqualsEqualsToken */:
                    return 193 /* EqualsWithTypeConversionExpression */;
                case 86 /* ExclamationEqualsToken */:
                    return 194 /* NotEqualsWithTypeConversionExpression */;
                case 87 /* EqualsEqualsEqualsToken */:
                    return 195 /* EqualsExpression */;
                case 88 /* ExclamationEqualsEqualsToken */:
                    return 196 /* NotEqualsExpression */;
                case 98 /* AmpersandToken */:
                    return 192 /* BitwiseAndExpression */;
                case 100 /* CaretToken */:
                    return 191 /* BitwiseExclusiveOrExpression */;
                case 99 /* BarToken */:
                    return 190 /* BitwiseOrExpression */;
                case 103 /* AmpersandAmpersandToken */:
                    return 189 /* LogicalAndExpression */;
                case 104 /* BarBarToken */:
                    return 188 /* LogicalOrExpression */;
                case 116 /* BarEqualsToken */:
                    return 183 /* OrAssignmentExpression */;
                case 115 /* AmpersandEqualsToken */:
                    return 181 /* AndAssignmentExpression */;
                case 117 /* CaretEqualsToken */:
                    return 182 /* ExclusiveOrAssignmentExpression */;
                case 112 /* LessThanLessThanEqualsToken */:
                    return 184 /* LeftShiftAssignmentExpression */;
                case 113 /* GreaterThanGreaterThanEqualsToken */:
                    return 185 /* SignedRightShiftAssignmentExpression */;
                case 114 /* GreaterThanGreaterThanGreaterThanEqualsToken */:
                    return 186 /* UnsignedRightShiftAssignmentExpression */;
                case 108 /* PlusEqualsToken */:
                    return 176 /* AddAssignmentExpression */;
                case 109 /* MinusEqualsToken */:
                    return 177 /* SubtractAssignmentExpression */;
                case 110 /* AsteriskEqualsToken */:
                    return 178 /* MultiplyAssignmentExpression */;
                case 119 /* SlashEqualsToken */:
                    return 179 /* DivideAssignmentExpression */;
                case 111 /* PercentEqualsToken */:
                    return 180 /* ModuloAssignmentExpression */;
                case 107 /* EqualsToken */:
                    return 175 /* AssignmentExpression */;
                case 79 /* CommaToken */:
                    return 174 /* CommaExpression */;
                default:
                    return 0 /* None */;
            }
        }
        SyntaxFacts.getBinaryExpressionFromOperatorToken = getBinaryExpressionFromOperatorToken;
        function getOperatorTokenFromBinaryExpression(tokenKind) {
            switch (tokenKind) {
                case 206 /* MultiplyExpression */:
                    return 91 /* AsteriskToken */;
                case 207 /* DivideExpression */:
                    return 118 /* SlashToken */;
                case 208 /* ModuloExpression */:
                    return 92 /* PercentToken */;
                case 209 /* AddExpression */:
                    return 89 /* PlusToken */;
                case 210 /* SubtractExpression */:
                    return 90 /* MinusToken */;
                case 203 /* LeftShiftExpression */:
                    return 95 /* LessThanLessThanToken */;
                case 204 /* SignedRightShiftExpression */:
                    return 96 /* GreaterThanGreaterThanToken */;
                case 205 /* UnsignedRightShiftExpression */:
                    return 97 /* GreaterThanGreaterThanGreaterThanToken */;
                case 197 /* LessThanExpression */:
                    return 80 /* LessThanToken */;
                case 198 /* GreaterThanExpression */:
                    return 81 /* GreaterThanToken */;
                case 199 /* LessThanOrEqualExpression */:
                    return 82 /* LessThanEqualsToken */;
                case 200 /* GreaterThanOrEqualExpression */:
                    return 83 /* GreaterThanEqualsToken */;
                case 201 /* InstanceOfExpression */:
                    return 30 /* InstanceOfKeyword */;
                case 202 /* InExpression */:
                    return 29 /* InKeyword */;
                case 193 /* EqualsWithTypeConversionExpression */:
                    return 84 /* EqualsEqualsToken */;
                case 194 /* NotEqualsWithTypeConversionExpression */:
                    return 86 /* ExclamationEqualsToken */;
                case 195 /* EqualsExpression */:
                    return 87 /* EqualsEqualsEqualsToken */;
                case 196 /* NotEqualsExpression */:
                    return 88 /* ExclamationEqualsEqualsToken */;
                case 192 /* BitwiseAndExpression */:
                    return 98 /* AmpersandToken */;
                case 191 /* BitwiseExclusiveOrExpression */:
                    return 100 /* CaretToken */;
                case 190 /* BitwiseOrExpression */:
                    return 99 /* BarToken */;
                case 189 /* LogicalAndExpression */:
                    return 103 /* AmpersandAmpersandToken */;
                case 188 /* LogicalOrExpression */:
                    return 104 /* BarBarToken */;
                case 183 /* OrAssignmentExpression */:
                    return 116 /* BarEqualsToken */;
                case 181 /* AndAssignmentExpression */:
                    return 115 /* AmpersandEqualsToken */;
                case 182 /* ExclusiveOrAssignmentExpression */:
                    return 117 /* CaretEqualsToken */;
                case 184 /* LeftShiftAssignmentExpression */:
                    return 112 /* LessThanLessThanEqualsToken */;
                case 185 /* SignedRightShiftAssignmentExpression */:
                    return 113 /* GreaterThanGreaterThanEqualsToken */;
                case 186 /* UnsignedRightShiftAssignmentExpression */:
                    return 114 /* GreaterThanGreaterThanGreaterThanEqualsToken */;
                case 176 /* AddAssignmentExpression */:
                    return 108 /* PlusEqualsToken */;
                case 177 /* SubtractAssignmentExpression */:
                    return 109 /* MinusEqualsToken */;
                case 178 /* MultiplyAssignmentExpression */:
                    return 110 /* AsteriskEqualsToken */;
                case 179 /* DivideAssignmentExpression */:
                    return 119 /* SlashEqualsToken */;
                case 180 /* ModuloAssignmentExpression */:
                    return 111 /* PercentEqualsToken */;
                case 175 /* AssignmentExpression */:
                    return 107 /* EqualsToken */;
                case 174 /* CommaExpression */:
                    return 79 /* CommaToken */;
                default:
                    return 0 /* None */;
            }
        }
        SyntaxFacts.getOperatorTokenFromBinaryExpression = getOperatorTokenFromBinaryExpression;
        function isAssignmentOperatorToken(tokenKind) {
            switch (tokenKind) {
                case 116 /* BarEqualsToken */:
                case 115 /* AmpersandEqualsToken */:
                case 117 /* CaretEqualsToken */:
                case 112 /* LessThanLessThanEqualsToken */:
                case 113 /* GreaterThanGreaterThanEqualsToken */:
                case 114 /* GreaterThanGreaterThanGreaterThanEqualsToken */:
                case 108 /* PlusEqualsToken */:
                case 109 /* MinusEqualsToken */:
                case 110 /* AsteriskEqualsToken */:
                case 119 /* SlashEqualsToken */:
                case 111 /* PercentEqualsToken */:
                case 107 /* EqualsToken */:
                    return true;
                default:
                    return false;
            }
        }
        SyntaxFacts.isAssignmentOperatorToken = isAssignmentOperatorToken;
        function isType(kind) {
            switch (kind) {
                case 124 /* ArrayType */:
                case 60 /* AnyKeyword */:
                case 67 /* NumberKeyword */:
                case 61 /* BooleanKeyword */:
                case 69 /* StringKeyword */:
                case 41 /* VoidKeyword */:
                case 123 /* FunctionType */:
                case 122 /* ObjectType */:
                case 125 /* ConstructorType */:
                case 127 /* TypeQuery */:
                case 126 /* GenericType */:
                case 121 /* QualifiedName */:
                case 11 /* IdentifierName */:
                    return true;
            }
            return false;
        }
        SyntaxFacts.isType = isType;
    })(SyntaxFacts = TypeScript.SyntaxFacts || (TypeScript.SyntaxFacts = {}));
})(TypeScript || (TypeScript = {}));
///<reference path='references.ts' />
var TypeScript;
(function (TypeScript) {
    var Scanner;
    (function (Scanner) {
        // Make sure we can encode a token's kind in 7 bits.
        TypeScript.Debug.assert(TypeScript.SyntaxKind.LastToken <= 127);
        // Fixed width tokens (keywords and punctuation) that have no trivia generally make up 30% of
        // all the tokens in a program.  We heavily optimize for that case with a token instance that
        // just needs a parent pointer and a single 30bit int like so:
        //
        // 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0xxx xxxx    <-- kind
        // 0000 0000 0000 0000 0000 0000 0000 0000 00xx xxxx xxxx xxxx xxxx xxxx x000 0000    <-- full start
        // ^                                         ^                                   ^
        // |                                         |                                   |
        // Bit 64                                    Bit 30                              Bit 1
        //
        // This gives us 23 bits for the start of the token.  We don't need to store the width as it
        // can be inferred from the 'kind' for a fixed width token.
        // 
        // For small tokens, we encode the data in one 30bit int like so:
        //
        // 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0xxx xxxx    <-- kind
        // 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 xxxx x000 0000    <-- full width
        // 0000 0000 0000 0000 0000 0000 0000 0000 00xx xxxx xxxx xxxx xxxx 0000 0000 0000    <-- full start
        // ^                                         ^                                   ^
        // |                                         |                                   |
        // Bit 64                                    Bit 30                              Bit 1
        //
        // This allows for 5bits for teh width.  i.e. tokens up to 31 chars in width.  And 18 bits for
        // the full start.  This allows for tokens starting up to and including position 262,143.
        //
        // In practice, for codebases we have measured, these values are sufficient to cover ~85% of 
        // all tokens.  If a token won't fit within those limits, we make a large token for it.
        //
        //
        // For large tokens, we encode data with two 30 bit ints like so:
        //
        //   _packedFullStartAndInfo:
        //
        // 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 000x    <-- has leading trivia
        // 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 00x0    <-- has leading comment (implies has leading trivia)
        // 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x00    <-- has trailing trivia
        // 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 x000    <-- has trailing comment (implies has trailing trivia)
        // 0000 0000 0000 0000 0000 0000 0000 0000 00xx xxxx xxxx xxxx xxxx xxxx xxxx 0000    <-- full start
        // ^                                         ^                                   ^
        // |                                         |                                   |
        // Bit 64                                    Bit 30                              Bit 1
        //
        // This gives us 26 bits for the start of the token.  At 64MB That's more than enough for
        // any codebase.
        //
        //   _packedFullWidthAndKind:
        //
        // 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0xxx xxxx    <-- kind
        // 0000 0000 0000 0000 0000 0000 0000 0000 00xx xxxx xxxx xxxx xxxx xxxx x000 0000    <-- full width
        // ^                                         ^                                   ^
        // |                                         |                                   |
        // Bit 64                                    Bit 30                              Bit 1
        //
        // This gives us 23bit for width (or 8MB of width which should be enough for any codebase).
        var ScannerConstants;
        (function (ScannerConstants) {
            ScannerConstants[ScannerConstants["LargeTokenFullStartShift"] = 4] = "LargeTokenFullStartShift";
            ScannerConstants[ScannerConstants["LargeTokenFullWidthShift"] = 7] = "LargeTokenFullWidthShift";
            ScannerConstants[ScannerConstants["LargeTokenLeadingTriviaBitMask"] = 0x01] = "LargeTokenLeadingTriviaBitMask";
            ScannerConstants[ScannerConstants["LargeTokenLeadingCommentBitMask"] = 0x02] = "LargeTokenLeadingCommentBitMask";
            ScannerConstants[ScannerConstants["LargeTokenTrailingTriviaBitMask"] = 0x04] = "LargeTokenTrailingTriviaBitMask";
            ScannerConstants[ScannerConstants["LargeTokenTrailingCommentBitMask"] = 0x08] = "LargeTokenTrailingCommentBitMask";
            ScannerConstants[ScannerConstants["LargeTokenTriviaBitMask"] = 0x0F] = "LargeTokenTriviaBitMask";
            ScannerConstants[ScannerConstants["FixedWidthTokenFullStartShift"] = 7] = "FixedWidthTokenFullStartShift";
            ScannerConstants[ScannerConstants["FixedWidthTokenMaxFullStart"] = 0x7FFFFF] = "FixedWidthTokenMaxFullStart";
            ScannerConstants[ScannerConstants["SmallTokenFullWidthShift"] = 7] = "SmallTokenFullWidthShift";
            ScannerConstants[ScannerConstants["SmallTokenFullStartShift"] = 12] = "SmallTokenFullStartShift";
            ScannerConstants[ScannerConstants["SmallTokenMaxFullStart"] = 0x3FFFF] = "SmallTokenMaxFullStart";
            ScannerConstants[ScannerConstants["SmallTokenMaxFullWidth"] = 0x1F] = "SmallTokenMaxFullWidth";
            ScannerConstants[ScannerConstants["SmallTokenFullWidthMask"] = 0x1F] = "SmallTokenFullWidthMask";
            ScannerConstants[ScannerConstants["KindMask"] = 0x7F] = "KindMask";
            ScannerConstants[ScannerConstants["IsVariableWidthMask"] = 0x80] = "IsVariableWidthMask";
        })(ScannerConstants || (ScannerConstants = {}));
        // Make sure our math works for packing/unpacking large fullStarts.
        TypeScript.Debug.assert(largeTokenUnpackFullStart(largeTokenPackFullStartAndInfo(1 << 26, 3)) === (1 << 26));
        TypeScript.Debug.assert(largeTokenUnpackFullStart(largeTokenPackFullStartAndInfo(3 << 25, 1)) === (3 << 25));
        TypeScript.Debug.assert(largeTokenUnpackFullStart(largeTokenPackFullStartAndInfo(10 << 23, 2)) === (10 << 23));
        function fixedWidthTokenPackData(fullStart, kind) {
            return (fullStart << 7 /* FixedWidthTokenFullStartShift */) | kind;
        }
        function fixedWidthTokenUnpackFullStart(packedData) {
            return packedData >> 7 /* FixedWidthTokenFullStartShift */;
        }
        function smallTokenPackData(fullStart, fullWidth, kind) {
            return (fullStart << 12 /* SmallTokenFullStartShift */) | (fullWidth << 7 /* SmallTokenFullWidthShift */) | kind;
        }
        function smallTokenUnpackFullWidth(packedData) {
            return (packedData >> 7 /* SmallTokenFullWidthShift */) & 31 /* SmallTokenFullWidthMask */;
        }
        function smallTokenUnpackFullStart(packedData) {
            return packedData >> 12 /* SmallTokenFullStartShift */;
        }
        function largeTokenPackFullStartAndInfo(fullStart, triviaInfo) {
            return (fullStart << 4 /* LargeTokenFullStartShift */) | triviaInfo;
        }
        function largeTokenUnpackFullWidth(packedFullWidthAndKind) {
            return packedFullWidthAndKind >> 7 /* LargeTokenFullWidthShift */;
        }
        function largeTokenUnpackFullStart(packedFullStartAndInfo) {
            return packedFullStartAndInfo >> 4 /* LargeTokenFullStartShift */;
        }
        function largeTokenUnpackHasLeadingTrivia(packed) {
            return (packed & 1 /* LargeTokenLeadingTriviaBitMask */) !== 0;
        }
        function largeTokenUnpackHasTrailingTrivia(packed) {
            return (packed & 4 /* LargeTokenTrailingTriviaBitMask */) !== 0;
        }
        function largeTokenUnpackHasLeadingComment(packed) {
            return (packed & 2 /* LargeTokenLeadingCommentBitMask */) !== 0;
        }
        function largeTokenUnpackHasTrailingComment(packed) {
            return (packed & 8 /* LargeTokenTrailingCommentBitMask */) !== 0;
        }
        function largeTokenUnpackTriviaInfo(packed) {
            return packed & 15 /* LargeTokenTriviaBitMask */;
        }
        var isKeywordStartCharacter = TypeScript.ArrayUtilities.createArray(127 /* maxAsciiCharacter */, 0);
        var isIdentifierStartCharacter = TypeScript.ArrayUtilities.createArray(127 /* maxAsciiCharacter */, false);
        var isIdentifierPartCharacter = TypeScript.ArrayUtilities.createArray(127 /* maxAsciiCharacter */, false);
        for (var character = 0; character < 127 /* maxAsciiCharacter */; character++) {
            if ((character >= 97 /* a */ && character <= 122 /* z */) || (character >= 65 /* A */ && character <= 90 /* Z */) || character === 95 /* _ */ || character === 36 /* $ */) {
                isIdentifierStartCharacter[character] = true;
                isIdentifierPartCharacter[character] = true;
            }
            else if (character >= 48 /* _0 */ && character <= 57 /* _9 */) {
                isIdentifierPartCharacter[character] = true;
            }
        }
        for (var keywordKind = TypeScript.SyntaxKind.FirstKeyword; keywordKind <= TypeScript.SyntaxKind.LastKeyword; keywordKind++) {
            var keyword = TypeScript.SyntaxFacts.getText(keywordKind);
            isKeywordStartCharacter[keyword.charCodeAt(0)] = 1;
        }
        function isContextualToken(token) {
            switch (token.kind()) {
                case 12 /* RegularExpressionLiteral */:
                case 96 /* GreaterThanGreaterThanToken */:
                case 97 /* GreaterThanGreaterThanGreaterThanToken */:
                case 83 /* GreaterThanEqualsToken */:
                case 113 /* GreaterThanGreaterThanEqualsToken */:
                case 114 /* GreaterThanGreaterThanGreaterThanEqualsToken */:
                    return true;
                default:
                    return token.isKeywordConvertedToIdentifier();
            }
        }
        Scanner.isContextualToken = isContextualToken;
        var lastTokenInfo = { leadingTriviaWidth: -1, width: -1 };
        var lastTokenInfoTokenID = -1;
        var triviaScanner = createScannerInternal(1 /* ES5 */, TypeScript.SimpleText.fromString(""), function () {
        });
        function fillSizeInfo(token, text) {
            if (lastTokenInfoTokenID !== TypeScript.syntaxID(token)) {
                triviaScanner.fillTokenInfo(token, text, lastTokenInfo);
                lastTokenInfoTokenID = TypeScript.syntaxID(token);
            }
        }
        function fullText(token, text) {
            return text.substr(token.fullStart(), token.fullWidth());
        }
        function leadingTrivia(token, text) {
            if (!token.hasLeadingTrivia()) {
                return TypeScript.Syntax.emptyTriviaList;
            }
            return triviaScanner.scanTrivia(token, text, false);
        }
        function trailingTrivia(token, text) {
            if (!token.hasTrailingTrivia()) {
                return TypeScript.Syntax.emptyTriviaList;
            }
            return triviaScanner.scanTrivia(token, text, true);
        }
        function leadingTriviaWidth(token, text) {
            if (!token.hasLeadingTrivia()) {
                return 0;
            }
            fillSizeInfo(token, text);
            return lastTokenInfo.leadingTriviaWidth;
        }
        function trailingTriviaWidth(token, text) {
            if (!token.hasTrailingTrivia()) {
                return 0;
            }
            fillSizeInfo(token, text);
            return token.fullWidth() - lastTokenInfo.leadingTriviaWidth - lastTokenInfo.width;
        }
        function tokenIsIncrementallyUnusable(token) {
            // No scanner tokens make their *containing node* incrementally unusable.  
            // Note: several scanner tokens may themselves be unusable.  i.e. if the parser asks
            // for a full node, then that ndoe can be returned even if it contains parser generated
            // tokens (like regexs and merged operator tokens). However, if the parser asks for a
            // for a token, then those contextual tokens will not be reusable.
            return false;
        }
        var FixedWidthTokenWithNoTrivia = (function () {
            function FixedWidthTokenWithNoTrivia(_packedData) {
                this._packedData = _packedData;
            }
            FixedWidthTokenWithNoTrivia.prototype.setFullStart = function (fullStart) {
                this._packedData = fixedWidthTokenPackData(fullStart, this.kind());
            };
            FixedWidthTokenWithNoTrivia.prototype.isIncrementallyUnusable = function () {
                return false;
            };
            FixedWidthTokenWithNoTrivia.prototype.isKeywordConvertedToIdentifier = function () {
                return false;
            };
            FixedWidthTokenWithNoTrivia.prototype.hasSkippedToken = function () {
                return false;
            };
            FixedWidthTokenWithNoTrivia.prototype.fullText = function () {
                return TypeScript.SyntaxFacts.getText(this.kind());
            };
            FixedWidthTokenWithNoTrivia.prototype.text = function () {
                return this.fullText();
            };
            FixedWidthTokenWithNoTrivia.prototype.leadingTrivia = function () {
                return TypeScript.Syntax.emptyTriviaList;
            };
            FixedWidthTokenWithNoTrivia.prototype.trailingTrivia = function () {
                return TypeScript.Syntax.emptyTriviaList;
            };
            FixedWidthTokenWithNoTrivia.prototype.leadingTriviaWidth = function () {
                return 0;
            };
            FixedWidthTokenWithNoTrivia.prototype.trailingTriviaWidth = function () {
                return 0;
            };
            FixedWidthTokenWithNoTrivia.prototype.kind = function () {
                return this._packedData & 127 /* KindMask */;
            };
            FixedWidthTokenWithNoTrivia.prototype.fullWidth = function () {
                return this.fullText().length;
            };
            FixedWidthTokenWithNoTrivia.prototype.fullStart = function () {
                return fixedWidthTokenUnpackFullStart(this._packedData);
            };
            FixedWidthTokenWithNoTrivia.prototype.hasLeadingTrivia = function () {
                return false;
            };
            FixedWidthTokenWithNoTrivia.prototype.hasTrailingTrivia = function () {
                return false;
            };
            FixedWidthTokenWithNoTrivia.prototype.hasLeadingComment = function () {
                return false;
            };
            FixedWidthTokenWithNoTrivia.prototype.hasTrailingComment = function () {
                return false;
            };
            FixedWidthTokenWithNoTrivia.prototype.clone = function () {
                return new FixedWidthTokenWithNoTrivia(this._packedData);
            };
            return FixedWidthTokenWithNoTrivia;
        })();
        var LargeScannerToken = (function () {
            function LargeScannerToken(_packedFullStartAndInfo, _packedFullWidthAndKind, cachedText) {
                this._packedFullStartAndInfo = _packedFullStartAndInfo;
                this._packedFullWidthAndKind = _packedFullWidthAndKind;
                if (cachedText !== undefined) {
                    this.cachedText = cachedText;
                }
            }
            LargeScannerToken.prototype.setFullStart = function (fullStart) {
                this._packedFullStartAndInfo = largeTokenPackFullStartAndInfo(fullStart, largeTokenUnpackTriviaInfo(this._packedFullStartAndInfo));
            };
            LargeScannerToken.prototype.syntaxTreeText = function (text) {
                var result = text || TypeScript.syntaxTree(this).text;
                TypeScript.Debug.assert(result);
                return result;
            };
            LargeScannerToken.prototype.isIncrementallyUnusable = function () {
                return tokenIsIncrementallyUnusable(this);
            };
            LargeScannerToken.prototype.isKeywordConvertedToIdentifier = function () {
                return false;
            };
            LargeScannerToken.prototype.hasSkippedToken = function () {
                return false;
            };
            LargeScannerToken.prototype.fullText = function (text) {
                return fullText(this, this.syntaxTreeText(text));
            };
            LargeScannerToken.prototype.text = function () {
                var cachedText = this.cachedText;
                return cachedText !== undefined ? cachedText : TypeScript.SyntaxFacts.getText(this.kind());
            };
            LargeScannerToken.prototype.leadingTrivia = function (text) {
                return leadingTrivia(this, this.syntaxTreeText(text));
            };
            LargeScannerToken.prototype.trailingTrivia = function (text) {
                return trailingTrivia(this, this.syntaxTreeText(text));
            };
            LargeScannerToken.prototype.leadingTriviaWidth = function (text) {
                return leadingTriviaWidth(this, this.syntaxTreeText(text));
            };
            LargeScannerToken.prototype.trailingTriviaWidth = function (text) {
                return trailingTriviaWidth(this, this.syntaxTreeText(text));
            };
            LargeScannerToken.prototype.kind = function () {
                return this._packedFullWidthAndKind & 127 /* KindMask */;
            };
            LargeScannerToken.prototype.fullWidth = function () {
                return largeTokenUnpackFullWidth(this._packedFullWidthAndKind);
            };
            LargeScannerToken.prototype.fullStart = function () {
                return largeTokenUnpackFullStart(this._packedFullStartAndInfo);
            };
            LargeScannerToken.prototype.hasLeadingTrivia = function () {
                return largeTokenUnpackHasLeadingTrivia(this._packedFullStartAndInfo);
            };
            LargeScannerToken.prototype.hasTrailingTrivia = function () {
                return largeTokenUnpackHasTrailingTrivia(this._packedFullStartAndInfo);
            };
            LargeScannerToken.prototype.hasLeadingComment = function () {
                return largeTokenUnpackHasLeadingComment(this._packedFullStartAndInfo);
            };
            LargeScannerToken.prototype.hasTrailingComment = function () {
                return largeTokenUnpackHasTrailingComment(this._packedFullStartAndInfo);
            };
            LargeScannerToken.prototype.clone = function () {
                return new LargeScannerToken(this._packedFullStartAndInfo, this._packedFullWidthAndKind, this.cachedText);
            };
            return LargeScannerToken;
        })();
        function createScanner(languageVersion, text, reportDiagnostic) {
            var scanner = createScannerInternal(languageVersion, text, reportDiagnostic);
            return {
                setIndex: scanner.setIndex,
                scan: scanner.scan
            };
        }
        Scanner.createScanner = createScanner;
        function createScannerInternal(languageVersion, text, reportDiagnostic) {
            var str;
            var index;
            var start;
            var end;
            function setIndex(_index) {
                index = _index;
            }
            function reset(_text, _start, _end) {
                TypeScript.Debug.assert(_start <= _text.length(), "Token's start was not within the bounds of text: " + _start + " - [0, " + _text.length() + ")");
                TypeScript.Debug.assert(_end <= _text.length(), "Token's end was not within the bounds of text: " + _end + " - [0, " + _text.length() + ")");
                if (!str || text !== _text) {
                    text = _text;
                    str = _text.substr(0, _text.length());
                }
                start = _start;
                end = _end;
                index = _start;
            }
            function scan(allowContextualToken) {
                var fullStart = index;
                var leadingTriviaInfo = scanTriviaInfo(false);
                var start = index;
                var kindAndIsVariableWidth = scanSyntaxKind(allowContextualToken);
                var end = index;
                var trailingTriviaInfo = scanTriviaInfo(true);
                var fullWidth = index - fullStart;
                // If we have no trivia, and we are a fixed width token kind, and our size isn't too 
                // large, and we're a real fixed width token (and not something like "\u0076ar").
                var kind = kindAndIsVariableWidth & 127 /* KindMask */;
                var isFixedWidth = kind >= TypeScript.SyntaxKind.FirstFixedWidth && kind <= TypeScript.SyntaxKind.LastFixedWidth && ((kindAndIsVariableWidth & 128 /* IsVariableWidthMask */) === 0);
                if (isFixedWidth && leadingTriviaInfo === 0 && trailingTriviaInfo === 0 && fullStart <= 8388607 /* FixedWidthTokenMaxFullStart */ && (kindAndIsVariableWidth & 128 /* IsVariableWidthMask */) === 0) {
                    return new FixedWidthTokenWithNoTrivia((fullStart << 7 /* FixedWidthTokenFullStartShift */) | kind);
                }
                else {
                    // inline the packing logic for perf.  
                    var packedFullStartAndTriviaInfo = (fullStart << 4 /* LargeTokenFullStartShift */) | leadingTriviaInfo | (trailingTriviaInfo << 2);
                    var packedFullWidthAndKind = (fullWidth << 7 /* LargeTokenFullWidthShift */) | kind;
                    var cachedText = isFixedWidth ? undefined : text.substr(start, end - start);
                    return new LargeScannerToken(packedFullStartAndTriviaInfo, packedFullWidthAndKind, cachedText);
                }
            }
            function scanTrivia(parent, text, isTrailing) {
                var tokenFullStart = parent.fullStart();
                var tokenStart = tokenFullStart + leadingTriviaWidth(parent, text);
                if (isTrailing) {
                    reset(text, tokenStart + parent.text().length, tokenFullStart + parent.fullWidth());
                }
                else {
                    reset(text, tokenFullStart, tokenStart);
                }
                // Debug.assert(length > 0);
                // Keep this exactly in sync with scanTriviaInfo
                var trivia = [];
                while (true) {
                    if (index < end) {
                        var ch = str.charCodeAt(index);
                        switch (ch) {
                            case 32 /* space */:
                            case 160 /* nonBreakingSpace */:
                            case 8192 /* enQuad */:
                            case 8193 /* emQuad */:
                            case 8194 /* enSpace */:
                            case 8195 /* emSpace */:
                            case 8196 /* threePerEmSpace */:
                            case 8197 /* fourPerEmSpace */:
                            case 8198 /* sixPerEmSpace */:
                            case 8199 /* figureSpace */:
                            case 8200 /* punctuationSpace */:
                            case 8201 /* thinSpace */:
                            case 8202 /* hairSpace */:
                            case 8203 /* zeroWidthSpace */:
                            case 8239 /* narrowNoBreakSpace */:
                            case 12288 /* ideographicSpace */:
                            case 9 /* tab */:
                            case 11 /* verticalTab */:
                            case 12 /* formFeed */:
                            case 65279 /* byteOrderMark */:
                                // Normal whitespace.  Consume and continue.
                                trivia.push(scanWhitespaceTrivia());
                                continue;
                            case 47 /* slash */:
                                // Potential comment.  Consume if so.  Otherwise, break out and return.
                                var ch2 = str.charCodeAt(index + 1);
                                if (ch2 === 47 /* slash */) {
                                    trivia.push(scanSingleLineCommentTrivia());
                                    continue;
                                }
                                if (ch2 === 42 /* asterisk */) {
                                    trivia.push(scanMultiLineCommentTrivia());
                                    continue;
                                }
                                throw TypeScript.Errors.invalidOperation();
                            case 13 /* carriageReturn */:
                            case 10 /* lineFeed */:
                            case 8233 /* paragraphSeparator */:
                            case 8232 /* lineSeparator */:
                                trivia.push(scanLineTerminatorSequenceTrivia(ch));
                                // If we're consuming leading trivia, then we will continue consuming more 
                                // trivia (including newlines) up to the first token we see.  If we're 
                                // consuming trailing trivia, then we break after the first newline we see.
                                if (!isTrailing) {
                                    continue;
                                }
                                break;
                            default:
                                throw TypeScript.Errors.invalidOperation();
                        }
                    }
                    // Debug.assert(trivia.length > 0);
                    var triviaList = TypeScript.Syntax.triviaList(trivia);
                    triviaList.parent = parent;
                    return triviaList;
                }
            }
            // Returns 0 if there was no trivia, or 1 if there was trivia.  Returned as an int instead 
            // of a boolean because we'll need a numerical value later on to store in our tokens.
            function scanTriviaInfo(isTrailing) {
                // Keep this exactly in sync with scanTrivia
                var result = 0;
                var _end = end;
                while (index < _end) {
                    var ch = str.charCodeAt(index);
                    switch (ch) {
                        case 9 /* tab */:
                        case 32 /* space */:
                        case 11 /* verticalTab */:
                        case 12 /* formFeed */:
                            index++;
                            // we have trivia
                            result |= 1;
                            continue;
                        case 13 /* carriageReturn */:
                            if ((index + 1) < end && str.charCodeAt(index + 1) === 10 /* lineFeed */) {
                                index++;
                            }
                        case 10 /* lineFeed */:
                            index++;
                            // we have trivia
                            result |= 1;
                            // If we're consuming leading trivia, then we will continue consuming more 
                            // trivia (including newlines) up to the first token we see.  If we're 
                            // consuming trailing trivia, then we break after the first newline we see.
                            if (isTrailing) {
                                return result;
                            }
                            continue;
                        case 47 /* slash */:
                            if ((index + 1) < _end) {
                                var ch2 = str.charCodeAt(index + 1);
                                if (ch2 === 47 /* slash */) {
                                    // we have a comment, and we have trivia
                                    result |= 3;
                                    skipSingleLineCommentTrivia();
                                    continue;
                                }
                                if (ch2 === 42 /* asterisk */) {
                                    // we have a comment, and we have trivia
                                    result |= 3;
                                    skipMultiLineCommentTrivia();
                                    continue;
                                }
                            }
                            // Not a comment.  Don't consume.
                            return result;
                        default:
                            if (ch > 127 /* maxAsciiCharacter */ && slowScanTriviaInfo(ch)) {
                                result |= 1;
                                continue;
                            }
                            return result;
                    }
                }
                return result;
            }
            function slowScanTriviaInfo(ch) {
                switch (ch) {
                    case 160 /* nonBreakingSpace */:
                    case 8192 /* enQuad */:
                    case 8193 /* emQuad */:
                    case 8194 /* enSpace */:
                    case 8195 /* emSpace */:
                    case 8196 /* threePerEmSpace */:
                    case 8197 /* fourPerEmSpace */:
                    case 8198 /* sixPerEmSpace */:
                    case 8199 /* figureSpace */:
                    case 8200 /* punctuationSpace */:
                    case 8201 /* thinSpace */:
                    case 8202 /* hairSpace */:
                    case 8203 /* zeroWidthSpace */:
                    case 8239 /* narrowNoBreakSpace */:
                    case 12288 /* ideographicSpace */:
                    case 65279 /* byteOrderMark */:
                    case 8233 /* paragraphSeparator */:
                    case 8232 /* lineSeparator */:
                        index++;
                        return true;
                    default:
                        return false;
                }
            }
            function isNewLineCharacter(ch) {
                switch (ch) {
                    case 13 /* carriageReturn */:
                    case 10 /* lineFeed */:
                    case 8233 /* paragraphSeparator */:
                    case 8232 /* lineSeparator */:
                        return true;
                    default:
                        return false;
                }
            }
            function scanWhitespaceTrivia() {
                // We're going to be extracting text out of sliding window.  Make sure it can't move past
                // this point.
                var absoluteStartIndex = index;
                while (true) {
                    var ch = str.charCodeAt(index);
                    switch (ch) {
                        case 32 /* space */:
                        case 160 /* nonBreakingSpace */:
                        case 8192 /* enQuad */:
                        case 8193 /* emQuad */:
                        case 8194 /* enSpace */:
                        case 8195 /* emSpace */:
                        case 8196 /* threePerEmSpace */:
                        case 8197 /* fourPerEmSpace */:
                        case 8198 /* sixPerEmSpace */:
                        case 8199 /* figureSpace */:
                        case 8200 /* punctuationSpace */:
                        case 8201 /* thinSpace */:
                        case 8202 /* hairSpace */:
                        case 8203 /* zeroWidthSpace */:
                        case 8239 /* narrowNoBreakSpace */:
                        case 12288 /* ideographicSpace */:
                        case 9 /* tab */:
                        case 11 /* verticalTab */:
                        case 12 /* formFeed */:
                        case 65279 /* byteOrderMark */:
                            // Normal whitespace.  Consume and continue.
                            index++;
                            continue;
                    }
                    break;
                }
                return createTrivia(4 /* WhitespaceTrivia */, absoluteStartIndex);
            }
            function createTrivia(kind, absoluteStartIndex) {
                var fullWidth = index - absoluteStartIndex;
                return TypeScript.Syntax.deferredTrivia(kind, text, absoluteStartIndex, fullWidth);
            }
            function scanSingleLineCommentTrivia() {
                var absoluteStartIndex = index;
                skipSingleLineCommentTrivia();
                return createTrivia(7 /* SingleLineCommentTrivia */, absoluteStartIndex);
            }
            function skipSingleLineCommentTrivia() {
                index += 2;
                while (index < end) {
                    if (isNewLineCharacter(str.charCodeAt(index))) {
                        return;
                    }
                    index++;
                }
            }
            function scanMultiLineCommentTrivia() {
                var absoluteStartIndex = index;
                skipMultiLineCommentTrivia();
                return createTrivia(6 /* MultiLineCommentTrivia */, absoluteStartIndex);
            }
            function skipMultiLineCommentTrivia() {
                // The '2' is for the "/*" we consumed.
                index += 2;
                while (true) {
                    if (index === end) {
                        reportDiagnostic(end, 0, TypeScript.DiagnosticCode.AsteriskSlash_expected, null);
                        return;
                    }
                    if ((index + 1) < end && str.charCodeAt(index) === 42 /* asterisk */ && str.charCodeAt(index + 1) === 47 /* slash */) {
                        index += 2;
                        return;
                    }
                    index++;
                }
            }
            function scanLineTerminatorSequenceTrivia(ch) {
                var absoluteStartIndex = index;
                skipLineTerminatorSequence(ch);
                return createTrivia(5 /* NewLineTrivia */, absoluteStartIndex);
            }
            function skipLineTerminatorSequence(ch) {
                // Consume the first of the line terminator we saw.
                index++;
                // If it happened to be a \r and there's a following \n, then consume both.
                if (ch === 13 /* carriageReturn */ && str.charCodeAt(index) === 10 /* lineFeed */) {
                    index++;
                }
            }
            function scanSyntaxKind(allowContextualToken) {
                if (index >= end) {
                    return 10 /* EndOfFileToken */;
                }
                var character = str.charCodeAt(index);
                index++;
                switch (character) {
                    case 33 /* exclamation */:
                        return scanExclamationToken();
                    case 34 /* doubleQuote */:
                        return scanStringLiteral(character);
                    case 37 /* percent */:
                        return scanPercentToken();
                    case 38 /* ampersand */:
                        return scanAmpersandToken();
                    case 39 /* singleQuote */:
                        return scanStringLiteral(character);
                    case 40 /* openParen */:
                        return 72 /* OpenParenToken */;
                    case 41 /* closeParen */:
                        return 73 /* CloseParenToken */;
                    case 42 /* asterisk */:
                        return scanAsteriskToken();
                    case 43 /* plus */:
                        return scanPlusToken();
                    case 44 /* comma */:
                        return 79 /* CommaToken */;
                    case 45 /* minus */:
                        return scanMinusToken();
                    case 46 /* dot */:
                        return scanDotToken();
                    case 47 /* slash */:
                        return scanSlashToken(allowContextualToken);
                    case 48 /* _0 */:
                    case 49 /* _1 */:
                    case 50 /* _2 */:
                    case 51 /* _3 */:
                    case 52 /* _4 */:
                    case 53 /* _5 */:
                    case 54 /* _6 */:
                    case 55 /* _7 */:
                    case 56 /* _8 */:
                    case 57 /* _9 */:
                        return scanNumericLiteral(character);
                    case 58 /* colon */:
                        return 106 /* ColonToken */;
                    case 59 /* semicolon */:
                        return 78 /* SemicolonToken */;
                    case 60 /* lessThan */:
                        return scanLessThanToken();
                    case 61 /* equals */:
                        return scanEqualsToken();
                    case 62 /* greaterThan */:
                        return scanGreaterThanToken(allowContextualToken);
                    case 63 /* question */:
                        return 105 /* QuestionToken */;
                    case 91 /* openBracket */:
                        return 74 /* OpenBracketToken */;
                    case 93 /* closeBracket */:
                        return 75 /* CloseBracketToken */;
                    case 94 /* caret */:
                        return scanCaretToken();
                    case 123 /* openBrace */:
                        return 70 /* OpenBraceToken */;
                    case 124 /* bar */:
                        return scanBarToken();
                    case 125 /* closeBrace */:
                        return 71 /* CloseBraceToken */;
                    case 126 /* tilde */:
                        return 102 /* TildeToken */;
                }
                // We run into so many identifiers (and keywords) when scanning, that we want the code to
                // be as fast as possible.  To that end, we have an extremely fast path for scanning that
                // handles the 99.9% case of no-unicode characters and no unicode escapes.
                if (isIdentifierStartCharacter[character]) {
                    var result = tryFastScanIdentifierOrKeyword(character);
                    if (result !== 0 /* None */) {
                        return result;
                    }
                }
                // Move the index back one and try the slow path.
                index--;
                if (isIdentifierStart(peekCharOrUnicodeEscape())) {
                    return slowScanIdentifierOrKeyword();
                }
                // Was nothing that we could understand.  Report the issue and keep moving on.
                var text = String.fromCharCode(character);
                var messageText = getErrorMessageText(text);
                reportDiagnostic(index, 1, TypeScript.DiagnosticCode.Unexpected_character_0, [messageText]);
                index++;
                return 9 /* ErrorToken */;
            }
            function isIdentifierStart(interpretedChar) {
                if (isIdentifierStartCharacter[interpretedChar]) {
                    return true;
                }
                return interpretedChar > 127 /* maxAsciiCharacter */ && TypeScript.Unicode.isIdentifierStart(interpretedChar, languageVersion);
            }
            function isIdentifierPart(interpretedChar) {
                if (isIdentifierPartCharacter[interpretedChar]) {
                    return true;
                }
                return interpretedChar > 127 /* maxAsciiCharacter */ && TypeScript.Unicode.isIdentifierPart(interpretedChar, languageVersion);
            }
            function tryFastScanIdentifierOrKeyword(firstCharacter) {
                var startIndex = index;
                var character = firstCharacter;
                while (index < end) {
                    character = str.charCodeAt(index);
                    if (!isIdentifierPartCharacter[character]) {
                        break;
                    }
                    index++;
                }
                if (index < end && (character === 92 /* backslash */ || character > 127 /* maxAsciiCharacter */)) {
                    // We saw a \ (which could start a unicode escape), or we saw a unicode character.
                    // This can't be scanned quickly.  Don't update the window position and just bail out
                    // to the slow path.
                    index = startIndex;
                    return 0 /* None */;
                }
                else {
                    // Saw an ascii character that wasn't a backslash and wasn't an identifier 
                    // character.  Or we hit the end of the file  This identifier is done.
                    // Also check if it a keyword if it started with a keyword start char.
                    if (isKeywordStartCharacter[firstCharacter]) {
                        return TypeScript.ScannerUtilities.identifierKind(str, startIndex - 1, index - startIndex + 1);
                    }
                    else {
                        return 11 /* IdentifierName */;
                    }
                }
            }
            // A slow path for scanning identifiers.  Called when we run into a unicode character or
            // escape sequence while processing the fast path.
            function slowScanIdentifierOrKeyword() {
                var startIndex = index;
                do {
                    scanCharOrUnicodeEscape();
                } while (isIdentifierPart(peekCharOrUnicodeEscape()));
                // From ES6 specification.
                // The ReservedWord definitions are specified as literal sequences of Unicode 
                // characters.However, any Unicode character in a ReservedWord can also be 
                // expressed by a \ UnicodeEscapeSequence that expresses that same Unicode 
                // character's code point.Use of such escape sequences does not change the meaning 
                // of the ReservedWord.
                //
                // i.e. "\u0076ar" is the keyword 'var'.  Check for that here.
                var length = index - startIndex;
                var text = str.substr(startIndex, length);
                var valueText = TypeScript.massageEscapes(text);
                var keywordKind = TypeScript.SyntaxFacts.getTokenKind(valueText);
                if (keywordKind >= TypeScript.SyntaxKind.FirstKeyword && keywordKind <= TypeScript.SyntaxKind.LastKeyword) {
                    // We have a keyword, but it is also variable width.  We can't put represent this
                    // width a fixed width token.
                    return keywordKind | 128 /* IsVariableWidthMask */;
                }
                return 11 /* IdentifierName */;
            }
            function scanNumericLiteral(ch) {
                if (isHexNumericLiteral(ch)) {
                    scanHexNumericLiteral();
                }
                else if (isOctalNumericLiteral(ch)) {
                    scanOctalNumericLiteral();
                }
                else {
                    scanDecimalNumericLiteral();
                }
                return 13 /* NumericLiteral */;
            }
            function isOctalNumericLiteral(ch) {
                return ch === 48 /* _0 */ && TypeScript.CharacterInfo.isOctalDigit(str.charCodeAt(index));
            }
            function scanOctalNumericLiteral() {
                var start = index - 1;
                while (TypeScript.CharacterInfo.isOctalDigit(str.charCodeAt(index))) {
                    index++;
                }
                if (languageVersion >= 1 /* ES5 */) {
                    reportDiagnostic(start, index - start, TypeScript.DiagnosticCode.Octal_literals_are_not_available_when_targeting_ECMAScript_5_and_higher, null);
                }
            }
            function scanDecimalDigits() {
                while (TypeScript.CharacterInfo.isDecimalDigit(str.charCodeAt(index))) {
                    index++;
                }
            }
            function scanDecimalNumericLiteral() {
                scanDecimalDigits();
                if (str.charCodeAt(index) === 46 /* dot */) {
                    index++;
                }
                scanDecimalNumericLiteralAfterDot();
            }
            function scanDecimalNumericLiteralAfterDot() {
                scanDecimalDigits();
                // If we see an 'e' or 'E' we should only consume it if its of the form:
                // e<number> or E<number> 
                // e+<number>   E+<number>
                // e-<number>   E-<number>
                var ch = str.charCodeAt(index);
                if (ch === 101 /* e */ || ch === 69 /* E */) {
                    // Ok, we've got 'e' or 'E'.  Make sure it's followed correctly.
                    var nextChar1 = str.charCodeAt(index + 1);
                    if (TypeScript.CharacterInfo.isDecimalDigit(nextChar1)) {
                        // e<number> or E<number>
                        // Consume 'e' or 'E' and the number portion.
                        index++;
                        scanDecimalDigits();
                    }
                    else if (nextChar1 === 45 /* minus */ || nextChar1 === 43 /* plus */) {
                        // e+ or E+ or e- or E-
                        var nextChar2 = str.charCodeAt(index + 2);
                        if (TypeScript.CharacterInfo.isDecimalDigit(nextChar2)) {
                            // e+<number> or E+<number> or e-<number> or E-<number>
                            // Consume first two characters and the number portion.
                            index += 2;
                            scanDecimalDigits();
                        }
                    }
                }
            }
            function scanHexNumericLiteral() {
                // Move past the x.
                index++;
                while (TypeScript.CharacterInfo.isHexDigit(str.charCodeAt(index))) {
                    index++;
                }
            }
            function isHexNumericLiteral(ch) {
                if (ch === 48 /* _0 */) {
                    var ch = str.charCodeAt(index);
                    if (ch === 120 /* x */ || ch === 88 /* X */) {
                        return TypeScript.CharacterInfo.isHexDigit(str.charCodeAt(index + 1));
                    }
                }
                return false;
            }
            function scanLessThanToken() {
                var ch0 = str.charCodeAt(index);
                if (ch0 === 61 /* equals */) {
                    index++;
                    return 82 /* LessThanEqualsToken */;
                }
                else if (ch0 === 60 /* lessThan */) {
                    index++;
                    if (str.charCodeAt(index) === 61 /* equals */) {
                        index++;
                        return 112 /* LessThanLessThanEqualsToken */;
                    }
                    else {
                        return 95 /* LessThanLessThanToken */;
                    }
                }
                else {
                    return 80 /* LessThanToken */;
                }
            }
            function scanGreaterThanToken(allowContextualToken) {
                if (allowContextualToken) {
                    var ch0 = str.charCodeAt(index);
                    if (ch0 === 62 /* greaterThan */) {
                        // >>
                        index++;
                        var ch1 = str.charCodeAt(index);
                        if (ch1 === 62 /* greaterThan */) {
                            // >>>
                            index++;
                            var ch2 = str.charCodeAt(index);
                            if (ch2 === 61 /* equals */) {
                                // >>>=
                                index++;
                                return 114 /* GreaterThanGreaterThanGreaterThanEqualsToken */;
                            }
                            else {
                                return 97 /* GreaterThanGreaterThanGreaterThanToken */;
                            }
                        }
                        else if (ch1 === 61 /* equals */) {
                            // >>=
                            index++;
                            return 113 /* GreaterThanGreaterThanEqualsToken */;
                        }
                        else {
                            return 96 /* GreaterThanGreaterThanToken */;
                        }
                    }
                    else if (ch0 === 61 /* equals */) {
                        // >=
                        index++;
                        return 83 /* GreaterThanEqualsToken */;
                    }
                }
                return 81 /* GreaterThanToken */;
            }
            function scanBarToken() {
                var ch = str.charCodeAt(index);
                if (ch === 61 /* equals */) {
                    index++;
                    return 116 /* BarEqualsToken */;
                }
                else if (ch === 124 /* bar */) {
                    index++;
                    return 104 /* BarBarToken */;
                }
                else {
                    return 99 /* BarToken */;
                }
            }
            function scanCaretToken() {
                if (str.charCodeAt(index) === 61 /* equals */) {
                    index++;
                    return 117 /* CaretEqualsToken */;
                }
                else {
                    return 100 /* CaretToken */;
                }
            }
            function scanAmpersandToken() {
                var character = str.charCodeAt(index);
                if (character === 61 /* equals */) {
                    index++;
                    return 115 /* AmpersandEqualsToken */;
                }
                else if (character === 38 /* ampersand */) {
                    index++;
                    return 103 /* AmpersandAmpersandToken */;
                }
                else {
                    return 98 /* AmpersandToken */;
                }
            }
            function scanPercentToken() {
                if (str.charCodeAt(index) === 61 /* equals */) {
                    index++;
                    return 111 /* PercentEqualsToken */;
                }
                else {
                    return 92 /* PercentToken */;
                }
            }
            function scanMinusToken() {
                var character = str.charCodeAt(index);
                if (character === 61 /* equals */) {
                    index++;
                    return 109 /* MinusEqualsToken */;
                }
                else if (character === 45 /* minus */) {
                    index++;
                    return 94 /* MinusMinusToken */;
                }
                else {
                    return 90 /* MinusToken */;
                }
            }
            function scanPlusToken() {
                var character = str.charCodeAt(index);
                if (character === 61 /* equals */) {
                    index++;
                    return 108 /* PlusEqualsToken */;
                }
                else if (character === 43 /* plus */) {
                    index++;
                    return 93 /* PlusPlusToken */;
                }
                else {
                    return 89 /* PlusToken */;
                }
            }
            function scanAsteriskToken() {
                if (str.charCodeAt(index) === 61 /* equals */) {
                    index++;
                    return 110 /* AsteriskEqualsToken */;
                }
                else {
                    return 91 /* AsteriskToken */;
                }
            }
            function scanEqualsToken() {
                var character = str.charCodeAt(index);
                if (character === 61 /* equals */) {
                    index++;
                    if (str.charCodeAt(index) === 61 /* equals */) {
                        index++;
                        return 87 /* EqualsEqualsEqualsToken */;
                    }
                    else {
                        return 84 /* EqualsEqualsToken */;
                    }
                }
                else if (character === 62 /* greaterThan */) {
                    index++;
                    return 85 /* EqualsGreaterThanToken */;
                }
                else {
                    return 107 /* EqualsToken */;
                }
            }
            function scanDotToken() {
                var nextChar = str.charCodeAt(index);
                if (TypeScript.CharacterInfo.isDecimalDigit(nextChar)) {
                    scanDecimalNumericLiteralAfterDot();
                    return 13 /* NumericLiteral */;
                }
                if (nextChar === 46 /* dot */ && str.charCodeAt(index + 1) === 46 /* dot */) {
                    index += 2;
                    return 77 /* DotDotDotToken */;
                }
                else {
                    return 76 /* DotToken */;
                }
            }
            function scanSlashToken(allowContextualToken) {
                // NOTE: By default, we do not try scanning a / as a regexp here.  We instead consider it a
                // div or div-assign.  Later on, if the parser runs into a situation where it would like a 
                // term, and it sees one of these then it may restart us asking specifically if we could 
                // scan out a regex.
                if (allowContextualToken) {
                    var result = tryScanRegularExpressionToken();
                    if (result !== 0 /* None */) {
                        return result;
                    }
                }
                if (str.charCodeAt(index) === 61 /* equals */) {
                    index++;
                    return 119 /* SlashEqualsToken */;
                }
                else {
                    return 118 /* SlashToken */;
                }
            }
            function tryScanRegularExpressionToken() {
                var startIndex = index;
                var inEscape = false;
                var inCharacterClass = false;
                while (true) {
                    var ch = str.charCodeAt(index);
                    if (isNaN(ch) || isNewLineCharacter(ch)) {
                        index = startIndex;
                        return 0 /* None */;
                    }
                    index++;
                    if (inEscape) {
                        inEscape = false;
                        continue;
                    }
                    switch (ch) {
                        case 92 /* backslash */:
                            // We're now in an escape.  Consume the next character we see (unless it's
                            // a newline or null.
                            inEscape = true;
                            continue;
                        case 91 /* openBracket */:
                            // If we see a [ then we're starting an character class.  Note: it's ok if 
                            // we then hit another [ inside a character class.  We'll just set the value
                            // to true again and that's ok.
                            inCharacterClass = true;
                            continue;
                        case 93 /* closeBracket */:
                            // If we ever hit a cloe bracket then we're now no longer in a character 
                            // class.  If we weren't in a character class to begin with, then this has 
                            // no effect.
                            inCharacterClass = false;
                            continue;
                        case 47 /* slash */:
                            // If we see a slash, and we're in a character class, then ignore it.
                            if (inCharacterClass) {
                                continue;
                            }
                            break;
                        default:
                            continue;
                    }
                    break;
                }
                while (isIdentifierPartCharacter[str.charCodeAt(index)]) {
                    index++;
                }
                return 12 /* RegularExpressionLiteral */;
            }
            function scanExclamationToken() {
                if (str.charCodeAt(index) === 61 /* equals */) {
                    index++;
                    if (str.charCodeAt(index) === 61 /* equals */) {
                        index++;
                        return 88 /* ExclamationEqualsEqualsToken */;
                    }
                    else {
                        return 86 /* ExclamationEqualsToken */;
                    }
                }
                else {
                    return 101 /* ExclamationToken */;
                }
            }
            // Convert text into a printable form usable for an error message.  This will both quote the 
            // string, and ensure all characters printable (i.e. by using unicode escapes when they're not).
            function getErrorMessageText(text) {
                // For just a simple backslash, we return it as is.  The default behavior of JSON.stringify
                // is not what we want here.
                if (text === "\\") {
                    return '"\\"';
                }
                return JSON.stringify(text);
            }
            function skipEscapeSequence() {
                var rewindPoint = index;
                // Consume the backslash.
                index++;
                // Get the char after the backslash
                var ch = str.charCodeAt(index);
                if (isNaN(ch)) {
                    // if we're at teh end of the file, just return, the string scanning code will 
                    // report an appropriate error.
                    return;
                }
                index++;
                switch (ch) {
                    case 120 /* x */:
                    case 117 /* u */:
                        index = rewindPoint;
                        var value = scanUnicodeOrHexEscape(true);
                        break;
                    case 13 /* carriageReturn */:
                        // If it's \r\n then consume both characters.
                        if (str.charCodeAt(index) === 10 /* lineFeed */) {
                            index++;
                        }
                        break;
                    default:
                        break;
                }
            }
            function scanStringLiteral(quoteCharacter) {
                // Debug.assert(quoteCharacter === CharacterCodes.singleQuote || quoteCharacter === CharacterCodes.doubleQuote);
                while (true) {
                    var ch = str.charCodeAt(index);
                    if (ch === 92 /* backslash */) {
                        skipEscapeSequence();
                    }
                    else if (ch === quoteCharacter) {
                        index++;
                        break;
                    }
                    else if (isNaN(ch) || isNewLineCharacter(ch)) {
                        reportDiagnostic(Math.min(index, end), 1, TypeScript.DiagnosticCode.Missing_close_quote_character, null);
                        break;
                    }
                    else {
                        index++;
                    }
                }
                return 14 /* StringLiteral */;
            }
            function isUnicodeEscape(character) {
                return character === 92 /* backslash */ && str.charCodeAt(index + 1) === 117 /* u */;
            }
            function peekCharOrUnicodeEscape() {
                var character = str.charCodeAt(index);
                if (isUnicodeEscape(character)) {
                    return peekUnicodeOrHexEscape();
                }
                else {
                    return character;
                }
            }
            function peekUnicodeOrHexEscape() {
                var startIndex = index;
                // if we're peeking, then we don't want to change the position
                var ch = scanUnicodeOrHexEscape(false);
                index = startIndex;
                return ch;
            }
            // Returns true if this was a unicode escape.
            function scanCharOrUnicodeEscape() {
                if (str.charCodeAt(index) === 92 /* backslash */ && str.charCodeAt(index + 1) === 117 /* u */) {
                    scanUnicodeOrHexEscape(true);
                }
                else {
                    index++;
                }
            }
            function scanUnicodeOrHexEscape(report) {
                var start = index;
                var character = str.charCodeAt(index);
                // Debug.assert(character === CharacterCodes.backslash);
                index++;
                character = str.charCodeAt(index);
                // Debug.assert(character === CharacterCodes.u || character === CharacterCodes.x);
                var intChar = 0;
                index++;
                var count = character === 117 /* u */ ? 4 : 2;
                for (var i = 0; i < count; i++) {
                    var ch2 = str.charCodeAt(index);
                    if (!TypeScript.CharacterInfo.isHexDigit(ch2)) {
                        if (report) {
                            reportDiagnostic(start, index - start, TypeScript.DiagnosticCode.Unrecognized_escape_sequence, null);
                        }
                        break;
                    }
                    intChar = (intChar << 4) + TypeScript.CharacterInfo.hexValue(ch2);
                    index++;
                }
                return intChar;
            }
            function fillTokenInfo(token, text, tokenInfo) {
                var fullStart = token.fullStart();
                var fullEnd = fullStart + token.fullWidth();
                reset(text, fullStart, fullEnd);
                scanTriviaInfo(false);
                var start = index;
                scanSyntaxKind(isContextualToken(token));
                var end = index;
                tokenInfo.leadingTriviaWidth = start - fullStart;
                tokenInfo.width = end - start;
            }
            reset(text, 0, text.length());
            return {
                setIndex: setIndex,
                scan: scan,
                fillTokenInfo: fillTokenInfo,
                scanTrivia: scanTrivia
            };
        }
        function isValidIdentifier(text, languageVersion) {
            var hadError = false;
            var scanner = createScanner(languageVersion, text, function () { return hadError = true; });
            var token = scanner.scan(false);
            return !hadError && TypeScript.SyntaxFacts.isIdentifierNameOrAnyKeyword(token) && TypeScript.width(token) === text.length();
        }
        Scanner.isValidIdentifier = isValidIdentifier;
        // Parser source used in batch scenarios.  Directly calls into an underlying text scanner and
        // supports none of the functionality to reuse nodes.  Good for when you just want want to do
        // a single parse of a file.
        function createParserSource(fileName, text, languageVersion) {
            // The absolute position we're at in the text we're reading from.
            var _absolutePosition = 0;
            // The diagnostics we get while scanning.  Note: this never gets rewound when we do a normal
            // rewind.  That's because rewinding doesn't affect the tokens created.  It only affects where
            // in the token stream we're pointing at.  However, it will get modified if we we decide to
            // reparse a / or /= as a regular expression.
            var _tokenDiagnostics = [];
            // Pool of rewind points we give out if the parser needs one.
            var rewindPointPool = [];
            var rewindPointPoolCount = 0;
            var lastDiagnostic = null;
            var reportDiagnostic = function (position, fullWidth, diagnosticKey, args) {
                lastDiagnostic = new TypeScript.Diagnostic(fileName, text.lineMap(), position, fullWidth, diagnosticKey, args);
            };
            // The sliding window that we store tokens in.
            var slidingWindow = new TypeScript.SlidingWindow(fetchNextItem, TypeScript.ArrayUtilities.createArray(1024, null), null);
            // The scanner we're pulling tokens from.
            var scanner = createScanner(languageVersion, text, reportDiagnostic);
            function release() {
                slidingWindow = null;
                scanner = null;
                _tokenDiagnostics = [];
                rewindPointPool = [];
                lastDiagnostic = null;
                reportDiagnostic = null;
            }
            function currentNode() {
                // The normal parser source never returns nodes.  They're only returned by the 
                // incremental parser source.
                return null;
            }
            function consumeNode(node) {
                throw TypeScript.Errors.invalidOperation();
            }
            function absolutePosition() {
                return _absolutePosition;
            }
            function tokenDiagnostics() {
                return _tokenDiagnostics;
            }
            function getOrCreateRewindPoint() {
                if (rewindPointPoolCount === 0) {
                    return {};
                }
                rewindPointPoolCount--;
                var result = rewindPointPool[rewindPointPoolCount];
                rewindPointPool[rewindPointPoolCount] = null;
                return result;
            }
            function getRewindPoint() {
                var slidingWindowIndex = slidingWindow.getAndPinAbsoluteIndex();
                var rewindPoint = getOrCreateRewindPoint();
                rewindPoint.slidingWindowIndex = slidingWindowIndex;
                rewindPoint.absolutePosition = _absolutePosition;
                // rewindPoint.pinCount = slidingWindow.pinCount();
                return rewindPoint;
            }
            function rewind(rewindPoint) {
                slidingWindow.rewindToPinnedIndex(rewindPoint.slidingWindowIndex);
                _absolutePosition = rewindPoint.absolutePosition;
            }
            function releaseRewindPoint(rewindPoint) {
                // Debug.assert(slidingWindow.pinCount() === rewindPoint.pinCount);
                slidingWindow.releaseAndUnpinAbsoluteIndex(rewindPoint.absoluteIndex);
                rewindPointPool[rewindPointPoolCount] = rewindPoint;
                rewindPointPoolCount++;
            }
            function fetchNextItem(allowContextualToken) {
                // Assert disabled because it is actually expensive enugh to affect perf.
                // Debug.assert(spaceAvailable > 0);
                var token = scanner.scan(allowContextualToken);
                if (lastDiagnostic === null) {
                    return token;
                }
                // If we produced any diagnostics while creating this token, then realize the token so 
                // it won't be reused in incremental scenarios.
                _tokenDiagnostics.push(lastDiagnostic);
                lastDiagnostic = null;
                return TypeScript.Syntax.realizeToken(token, text);
            }
            function peekToken(n) {
                return slidingWindow.peekItemN(n);
            }
            function consumeToken(token) {
                // Debug.assert(currentToken() === token);
                _absolutePosition += token.fullWidth();
                slidingWindow.moveToNextItem();
            }
            function currentToken() {
                return slidingWindow.currentItem(false);
            }
            function removeDiagnosticsOnOrAfterPosition(position) {
                // walk backwards, removing any diagnostics that came after the the current token's
                // full start position.
                var tokenDiagnosticsLength = _tokenDiagnostics.length;
                while (tokenDiagnosticsLength > 0) {
                    var diagnostic = _tokenDiagnostics[tokenDiagnosticsLength - 1];
                    if (diagnostic.start() >= position) {
                        tokenDiagnosticsLength--;
                    }
                    else {
                        break;
                    }
                }
                _tokenDiagnostics.length = tokenDiagnosticsLength;
            }
            function resetToPosition(absolutePosition) {
                TypeScript.Debug.assert(absolutePosition <= text.length(), "Trying to set the position outside the bounds of the text!");
                _absolutePosition = absolutePosition;
                // First, remove any diagnostics that came after this position.
                removeDiagnosticsOnOrAfterPosition(absolutePosition);
                // Now, tell our sliding window to throw away all tokens after this position as well.
                slidingWindow.disgardAllItemsFromCurrentIndexOnwards();
                // Now tell the scanner to reset its position to this position as well.  That way
                // when we try to scan the next item, we'll be at the right location.
                scanner.setIndex(absolutePosition);
            }
            function currentContextualToken() {
                // We better be on a / or > token right now.
                // Debug.assert(SyntaxFacts.isAnyDivideToken(currentToken().kind()));
                // First, we're going to rewind all our data to the point where this / or /= token started.
                // That's because if it does turn out to be a regular expression, then any tokens or token 
                // diagnostics we produced after the original / may no longer be valid.  This would actually
                // be a  fairly expected case.  For example, if you had:  / ... gibberish ... /, we may have 
                // produced several diagnostics in the process of scanning the tokens after the first / as
                // they may not have been legal javascript okens.
                //
                // We also need to remove all the tokens we've gotten from the slash and onwards.  They may
                // not have been what the scanner would have produced if it decides that this is actually
                // a regular expresion.
                resetToPosition(_absolutePosition);
                // Now actually fetch the token again from the scanner. This time let it know that it
                // can scan it as a regex token if it wants to.
                var token = slidingWindow.currentItem(true);
                // We have better gotten some sort of regex token.  Otherwise, something *very* wrong has
                // occurred.
                // Debug.assert(SyntaxFacts.isAnyDivideOrRegularExpressionToken(token.kind()));
                return token;
            }
            return {
                text: text,
                fileName: fileName,
                languageVersion: languageVersion,
                currentNode: currentNode,
                currentToken: currentToken,
                currentContextualToken: currentContextualToken,
                peekToken: peekToken,
                consumeNode: consumeNode,
                consumeToken: consumeToken,
                getRewindPoint: getRewindPoint,
                rewind: rewind,
                releaseRewindPoint: releaseRewindPoint,
                tokenDiagnostics: tokenDiagnostics,
                release: release,
                absolutePosition: absolutePosition,
                resetToPosition: resetToPosition
            };
        }
        Scanner.createParserSource = createParserSource;
    })(Scanner = TypeScript.Scanner || (TypeScript.Scanner = {}));
})(TypeScript || (TypeScript = {}));
///<reference path='references.ts' />
var TypeScript;
(function (TypeScript) {
    var ScannerUtilities = (function () {
        function ScannerUtilities() {
        }
        ScannerUtilities.identifierKind = function (str, start, length) {
            switch (length) {
                case 2:
                    switch (str.charCodeAt(start)) {
                        case 100 /* d */:
                            return (str.charCodeAt(start + 1) === 111 /* o */) ? 22 /* DoKeyword */ : 11 /* IdentifierName */;
                        case 105 /* i */:
                            switch (str.charCodeAt(start + 1)) {
                                case 102 /* f */:
                                    return 28 /* IfKeyword */;
                                case 110 /* n */:
                                    return 29 /* InKeyword */;
                                default:
                                    return 11 /* IdentifierName */;
                            }
                        default:
                            return 11 /* IdentifierName */;
                    }
                case 3:
                    switch (str.charCodeAt(start)) {
                        case 97 /* a */:
                            return (str.charCodeAt(start + 1) === 110 /* n */ && str.charCodeAt(start + 2) === 121 /* y */) ? 60 /* AnyKeyword */ : 11 /* IdentifierName */;
                        case 102 /* f */:
                            return (str.charCodeAt(start + 1) === 111 /* o */ && str.charCodeAt(start + 2) === 114 /* r */) ? 26 /* ForKeyword */ : 11 /* IdentifierName */;
                        case 103 /* g */:
                            return (str.charCodeAt(start + 1) === 101 /* e */ && str.charCodeAt(start + 2) === 116 /* t */) ? 64 /* GetKeyword */ : 11 /* IdentifierName */;
                        case 108 /* l */:
                            return (str.charCodeAt(start + 1) === 101 /* e */ && str.charCodeAt(start + 2) === 116 /* t */) ? 53 /* LetKeyword */ : 11 /* IdentifierName */;
                        case 110 /* n */:
                            return (str.charCodeAt(start + 1) === 101 /* e */ && str.charCodeAt(start + 2) === 119 /* w */) ? 31 /* NewKeyword */ : 11 /* IdentifierName */;
                        case 115 /* s */:
                            return (str.charCodeAt(start + 1) === 101 /* e */ && str.charCodeAt(start + 2) === 116 /* t */) ? 68 /* SetKeyword */ : 11 /* IdentifierName */;
                        case 116 /* t */:
                            return (str.charCodeAt(start + 1) === 114 /* r */ && str.charCodeAt(start + 2) === 121 /* y */) ? 38 /* TryKeyword */ : 11 /* IdentifierName */;
                        case 118 /* v */:
                            return (str.charCodeAt(start + 1) === 97 /* a */ && str.charCodeAt(start + 2) === 114 /* r */) ? 40 /* VarKeyword */ : 11 /* IdentifierName */;
                        default:
                            return 11 /* IdentifierName */;
                    }
                case 4:
                    switch (str.charCodeAt(start)) {
                        case 99 /* c */:
                            return (str.charCodeAt(start + 1) === 97 /* a */ && str.charCodeAt(start + 2) === 115 /* s */ && str.charCodeAt(start + 3) === 101 /* e */) ? 16 /* CaseKeyword */ : 11 /* IdentifierName */;
                        case 101 /* e */:
                            switch (str.charCodeAt(start + 1)) {
                                case 108 /* l */:
                                    return (str.charCodeAt(start + 2) === 115 /* s */ && str.charCodeAt(start + 3) === 101 /* e */) ? 23 /* ElseKeyword */ : 11 /* IdentifierName */;
                                case 110 /* n */:
                                    return (str.charCodeAt(start + 2) === 117 /* u */ && str.charCodeAt(start + 3) === 109 /* m */) ? 46 /* EnumKeyword */ : 11 /* IdentifierName */;
                                default:
                                    return 11 /* IdentifierName */;
                            }
                        case 110 /* n */:
                            return (str.charCodeAt(start + 1) === 117 /* u */ && str.charCodeAt(start + 2) === 108 /* l */ && str.charCodeAt(start + 3) === 108 /* l */) ? 32 /* NullKeyword */ : 11 /* IdentifierName */;
                        case 116 /* t */:
                            switch (str.charCodeAt(start + 1)) {
                                case 104 /* h */:
                                    return (str.charCodeAt(start + 2) === 105 /* i */ && str.charCodeAt(start + 3) === 115 /* s */) ? 35 /* ThisKeyword */ : 11 /* IdentifierName */;
                                case 114 /* r */:
                                    return (str.charCodeAt(start + 2) === 117 /* u */ && str.charCodeAt(start + 3) === 101 /* e */) ? 37 /* TrueKeyword */ : 11 /* IdentifierName */;
                                default:
                                    return 11 /* IdentifierName */;
                            }
                        case 118 /* v */:
                            return (str.charCodeAt(start + 1) === 111 /* o */ && str.charCodeAt(start + 2) === 105 /* i */ && str.charCodeAt(start + 3) === 100 /* d */) ? 41 /* VoidKeyword */ : 11 /* IdentifierName */;
                        case 119 /* w */:
                            return (str.charCodeAt(start + 1) === 105 /* i */ && str.charCodeAt(start + 2) === 116 /* t */ && str.charCodeAt(start + 3) === 104 /* h */) ? 43 /* WithKeyword */ : 11 /* IdentifierName */;
                        default:
                            return 11 /* IdentifierName */;
                    }
                case 5:
                    switch (str.charCodeAt(start)) {
                        case 98 /* b */:
                            return (str.charCodeAt(start + 1) === 114 /* r */ && str.charCodeAt(start + 2) === 101 /* e */ && str.charCodeAt(start + 3) === 97 /* a */ && str.charCodeAt(start + 4) === 107 /* k */) ? 15 /* BreakKeyword */ : 11 /* IdentifierName */;
                        case 99 /* c */:
                            switch (str.charCodeAt(start + 1)) {
                                case 97 /* a */:
                                    return (str.charCodeAt(start + 2) === 116 /* t */ && str.charCodeAt(start + 3) === 99 /* c */ && str.charCodeAt(start + 4) === 104 /* h */) ? 17 /* CatchKeyword */ : 11 /* IdentifierName */;
                                case 108 /* l */:
                                    return (str.charCodeAt(start + 2) === 97 /* a */ && str.charCodeAt(start + 3) === 115 /* s */ && str.charCodeAt(start + 4) === 115 /* s */) ? 44 /* ClassKeyword */ : 11 /* IdentifierName */;
                                case 111 /* o */:
                                    return (str.charCodeAt(start + 2) === 110 /* n */ && str.charCodeAt(start + 3) === 115 /* s */ && str.charCodeAt(start + 4) === 116 /* t */) ? 45 /* ConstKeyword */ : 11 /* IdentifierName */;
                                default:
                                    return 11 /* IdentifierName */;
                            }
                        case 102 /* f */:
                            return (str.charCodeAt(start + 1) === 97 /* a */ && str.charCodeAt(start + 2) === 108 /* l */ && str.charCodeAt(start + 3) === 115 /* s */ && str.charCodeAt(start + 4) === 101 /* e */) ? 24 /* FalseKeyword */ : 11 /* IdentifierName */;
                        case 115 /* s */:
                            return (str.charCodeAt(start + 1) === 117 /* u */ && str.charCodeAt(start + 2) === 112 /* p */ && str.charCodeAt(start + 3) === 101 /* e */ && str.charCodeAt(start + 4) === 114 /* r */) ? 50 /* SuperKeyword */ : 11 /* IdentifierName */;
                        case 116 /* t */:
                            return (str.charCodeAt(start + 1) === 104 /* h */ && str.charCodeAt(start + 2) === 114 /* r */ && str.charCodeAt(start + 3) === 111 /* o */ && str.charCodeAt(start + 4) === 119 /* w */) ? 36 /* ThrowKeyword */ : 11 /* IdentifierName */;
                        case 119 /* w */:
                            return (str.charCodeAt(start + 1) === 104 /* h */ && str.charCodeAt(start + 2) === 105 /* i */ && str.charCodeAt(start + 3) === 108 /* l */ && str.charCodeAt(start + 4) === 101 /* e */) ? 42 /* WhileKeyword */ : 11 /* IdentifierName */;
                        case 121 /* y */:
                            return (str.charCodeAt(start + 1) === 105 /* i */ && str.charCodeAt(start + 2) === 101 /* e */ && str.charCodeAt(start + 3) === 108 /* l */ && str.charCodeAt(start + 4) === 100 /* d */) ? 59 /* YieldKeyword */ : 11 /* IdentifierName */;
                        default:
                            return 11 /* IdentifierName */;
                    }
                case 6:
                    switch (str.charCodeAt(start)) {
                        case 100 /* d */:
                            return (str.charCodeAt(start + 1) === 101 /* e */ && str.charCodeAt(start + 2) === 108 /* l */ && str.charCodeAt(start + 3) === 101 /* e */ && str.charCodeAt(start + 4) === 116 /* t */ && str.charCodeAt(start + 5) === 101 /* e */) ? 21 /* DeleteKeyword */ : 11 /* IdentifierName */;
                        case 101 /* e */:
                            return (str.charCodeAt(start + 1) === 120 /* x */ && str.charCodeAt(start + 2) === 112 /* p */ && str.charCodeAt(start + 3) === 111 /* o */ && str.charCodeAt(start + 4) === 114 /* r */ && str.charCodeAt(start + 5) === 116 /* t */) ? 47 /* ExportKeyword */ : 11 /* IdentifierName */;
                        case 105 /* i */:
                            return (str.charCodeAt(start + 1) === 109 /* m */ && str.charCodeAt(start + 2) === 112 /* p */ && str.charCodeAt(start + 3) === 111 /* o */ && str.charCodeAt(start + 4) === 114 /* r */ && str.charCodeAt(start + 5) === 116 /* t */) ? 49 /* ImportKeyword */ : 11 /* IdentifierName */;
                        case 109 /* m */:
                            return (str.charCodeAt(start + 1) === 111 /* o */ && str.charCodeAt(start + 2) === 100 /* d */ && str.charCodeAt(start + 3) === 117 /* u */ && str.charCodeAt(start + 4) === 108 /* l */ && str.charCodeAt(start + 5) === 101 /* e */) ? 65 /* ModuleKeyword */ : 11 /* IdentifierName */;
                        case 110 /* n */:
                            return (str.charCodeAt(start + 1) === 117 /* u */ && str.charCodeAt(start + 2) === 109 /* m */ && str.charCodeAt(start + 3) === 98 /* b */ && str.charCodeAt(start + 4) === 101 /* e */ && str.charCodeAt(start + 5) === 114 /* r */) ? 67 /* NumberKeyword */ : 11 /* IdentifierName */;
                        case 112 /* p */:
                            return (str.charCodeAt(start + 1) === 117 /* u */ && str.charCodeAt(start + 2) === 98 /* b */ && str.charCodeAt(start + 3) === 108 /* l */ && str.charCodeAt(start + 4) === 105 /* i */ && str.charCodeAt(start + 5) === 99 /* c */) ? 57 /* PublicKeyword */ : 11 /* IdentifierName */;
                        case 114 /* r */:
                            return (str.charCodeAt(start + 1) === 101 /* e */ && str.charCodeAt(start + 2) === 116 /* t */ && str.charCodeAt(start + 3) === 117 /* u */ && str.charCodeAt(start + 4) === 114 /* r */ && str.charCodeAt(start + 5) === 110 /* n */) ? 33 /* ReturnKeyword */ : 11 /* IdentifierName */;
                        case 115 /* s */:
                            switch (str.charCodeAt(start + 1)) {
                                case 116 /* t */:
                                    switch (str.charCodeAt(start + 2)) {
                                        case 97 /* a */:
                                            return (str.charCodeAt(start + 3) === 116 /* t */ && str.charCodeAt(start + 4) === 105 /* i */ && str.charCodeAt(start + 5) === 99 /* c */) ? 58 /* StaticKeyword */ : 11 /* IdentifierName */;
                                        case 114 /* r */:
                                            return (str.charCodeAt(start + 3) === 105 /* i */ && str.charCodeAt(start + 4) === 110 /* n */ && str.charCodeAt(start + 5) === 103 /* g */) ? 69 /* StringKeyword */ : 11 /* IdentifierName */;
                                        default:
                                            return 11 /* IdentifierName */;
                                    }
                                case 119 /* w */:
                                    return (str.charCodeAt(start + 2) === 105 /* i */ && str.charCodeAt(start + 3) === 116 /* t */ && str.charCodeAt(start + 4) === 99 /* c */ && str.charCodeAt(start + 5) === 104 /* h */) ? 34 /* SwitchKeyword */ : 11 /* IdentifierName */;
                                default:
                                    return 11 /* IdentifierName */;
                            }
                        case 116 /* t */:
                            return (str.charCodeAt(start + 1) === 121 /* y */ && str.charCodeAt(start + 2) === 112 /* p */ && str.charCodeAt(start + 3) === 101 /* e */ && str.charCodeAt(start + 4) === 111 /* o */ && str.charCodeAt(start + 5) === 102 /* f */) ? 39 /* TypeOfKeyword */ : 11 /* IdentifierName */;
                        default:
                            return 11 /* IdentifierName */;
                    }
                case 7:
                    switch (str.charCodeAt(start)) {
                        case 98 /* b */:
                            return (str.charCodeAt(start + 1) === 111 /* o */ && str.charCodeAt(start + 2) === 111 /* o */ && str.charCodeAt(start + 3) === 108 /* l */ && str.charCodeAt(start + 4) === 101 /* e */ && str.charCodeAt(start + 5) === 97 /* a */ && str.charCodeAt(start + 6) === 110 /* n */) ? 61 /* BooleanKeyword */ : 11 /* IdentifierName */;
                        case 100 /* d */:
                            switch (str.charCodeAt(start + 1)) {
                                case 101 /* e */:
                                    switch (str.charCodeAt(start + 2)) {
                                        case 99 /* c */:
                                            return (str.charCodeAt(start + 3) === 108 /* l */ && str.charCodeAt(start + 4) === 97 /* a */ && str.charCodeAt(start + 5) === 114 /* r */ && str.charCodeAt(start + 6) === 101 /* e */) ? 63 /* DeclareKeyword */ : 11 /* IdentifierName */;
                                        case 102 /* f */:
                                            return (str.charCodeAt(start + 3) === 97 /* a */ && str.charCodeAt(start + 4) === 117 /* u */ && str.charCodeAt(start + 5) === 108 /* l */ && str.charCodeAt(start + 6) === 116 /* t */) ? 20 /* DefaultKeyword */ : 11 /* IdentifierName */;
                                        default:
                                            return 11 /* IdentifierName */;
                                    }
                                default:
                                    return 11 /* IdentifierName */;
                            }
                        case 101 /* e */:
                            return (str.charCodeAt(start + 1) === 120 /* x */ && str.charCodeAt(start + 2) === 116 /* t */ && str.charCodeAt(start + 3) === 101 /* e */ && str.charCodeAt(start + 4) === 110 /* n */ && str.charCodeAt(start + 5) === 100 /* d */ && str.charCodeAt(start + 6) === 115 /* s */) ? 48 /* ExtendsKeyword */ : 11 /* IdentifierName */;
                        case 102 /* f */:
                            return (str.charCodeAt(start + 1) === 105 /* i */ && str.charCodeAt(start + 2) === 110 /* n */ && str.charCodeAt(start + 3) === 97 /* a */ && str.charCodeAt(start + 4) === 108 /* l */ && str.charCodeAt(start + 5) === 108 /* l */ && str.charCodeAt(start + 6) === 121 /* y */) ? 25 /* FinallyKeyword */ : 11 /* IdentifierName */;
                        case 112 /* p */:
                            switch (str.charCodeAt(start + 1)) {
                                case 97 /* a */:
                                    return (str.charCodeAt(start + 2) === 99 /* c */ && str.charCodeAt(start + 3) === 107 /* k */ && str.charCodeAt(start + 4) === 97 /* a */ && str.charCodeAt(start + 5) === 103 /* g */ && str.charCodeAt(start + 6) === 101 /* e */) ? 54 /* PackageKeyword */ : 11 /* IdentifierName */;
                                case 114 /* r */:
                                    return (str.charCodeAt(start + 2) === 105 /* i */ && str.charCodeAt(start + 3) === 118 /* v */ && str.charCodeAt(start + 4) === 97 /* a */ && str.charCodeAt(start + 5) === 116 /* t */ && str.charCodeAt(start + 6) === 101 /* e */) ? 55 /* PrivateKeyword */ : 11 /* IdentifierName */;
                                default:
                                    return 11 /* IdentifierName */;
                            }
                        case 114 /* r */:
                            return (str.charCodeAt(start + 1) === 101 /* e */ && str.charCodeAt(start + 2) === 113 /* q */ && str.charCodeAt(start + 3) === 117 /* u */ && str.charCodeAt(start + 4) === 105 /* i */ && str.charCodeAt(start + 5) === 114 /* r */ && str.charCodeAt(start + 6) === 101 /* e */) ? 66 /* RequireKeyword */ : 11 /* IdentifierName */;
                        default:
                            return 11 /* IdentifierName */;
                    }
                case 8:
                    switch (str.charCodeAt(start)) {
                        case 99 /* c */:
                            return (str.charCodeAt(start + 1) === 111 /* o */ && str.charCodeAt(start + 2) === 110 /* n */ && str.charCodeAt(start + 3) === 116 /* t */ && str.charCodeAt(start + 4) === 105 /* i */ && str.charCodeAt(start + 5) === 110 /* n */ && str.charCodeAt(start + 6) === 117 /* u */ && str.charCodeAt(start + 7) === 101 /* e */) ? 18 /* ContinueKeyword */ : 11 /* IdentifierName */;
                        case 100 /* d */:
                            return (str.charCodeAt(start + 1) === 101 /* e */ && str.charCodeAt(start + 2) === 98 /* b */ && str.charCodeAt(start + 3) === 117 /* u */ && str.charCodeAt(start + 4) === 103 /* g */ && str.charCodeAt(start + 5) === 103 /* g */ && str.charCodeAt(start + 6) === 101 /* e */ && str.charCodeAt(start + 7) === 114 /* r */) ? 19 /* DebuggerKeyword */ : 11 /* IdentifierName */;
                        case 102 /* f */:
                            return (str.charCodeAt(start + 1) === 117 /* u */ && str.charCodeAt(start + 2) === 110 /* n */ && str.charCodeAt(start + 3) === 99 /* c */ && str.charCodeAt(start + 4) === 116 /* t */ && str.charCodeAt(start + 5) === 105 /* i */ && str.charCodeAt(start + 6) === 111 /* o */ && str.charCodeAt(start + 7) === 110 /* n */) ? 27 /* FunctionKeyword */ : 11 /* IdentifierName */;
                        default:
                            return 11 /* IdentifierName */;
                    }
                case 9:
                    switch (str.charCodeAt(start)) {
                        case 105 /* i */:
                            return (str.charCodeAt(start + 1) === 110 /* n */ && str.charCodeAt(start + 2) === 116 /* t */ && str.charCodeAt(start + 3) === 101 /* e */ && str.charCodeAt(start + 4) === 114 /* r */ && str.charCodeAt(start + 5) === 102 /* f */ && str.charCodeAt(start + 6) === 97 /* a */ && str.charCodeAt(start + 7) === 99 /* c */ && str.charCodeAt(start + 8) === 101 /* e */) ? 52 /* InterfaceKeyword */ : 11 /* IdentifierName */;
                        case 112 /* p */:
                            return (str.charCodeAt(start + 1) === 114 /* r */ && str.charCodeAt(start + 2) === 111 /* o */ && str.charCodeAt(start + 3) === 116 /* t */ && str.charCodeAt(start + 4) === 101 /* e */ && str.charCodeAt(start + 5) === 99 /* c */ && str.charCodeAt(start + 6) === 116 /* t */ && str.charCodeAt(start + 7) === 101 /* e */ && str.charCodeAt(start + 8) === 100 /* d */) ? 56 /* ProtectedKeyword */ : 11 /* IdentifierName */;
                        default:
                            return 11 /* IdentifierName */;
                    }
                case 10:
                    switch (str.charCodeAt(start)) {
                        case 105 /* i */:
                            switch (str.charCodeAt(start + 1)) {
                                case 109 /* m */:
                                    return (str.charCodeAt(start + 2) === 112 /* p */ && str.charCodeAt(start + 3) === 108 /* l */ && str.charCodeAt(start + 4) === 101 /* e */ && str.charCodeAt(start + 5) === 109 /* m */ && str.charCodeAt(start + 6) === 101 /* e */ && str.charCodeAt(start + 7) === 110 /* n */ && str.charCodeAt(start + 8) === 116 /* t */ && str.charCodeAt(start + 9) === 115 /* s */) ? 51 /* ImplementsKeyword */ : 11 /* IdentifierName */;
                                case 110 /* n */:
                                    return (str.charCodeAt(start + 2) === 115 /* s */ && str.charCodeAt(start + 3) === 116 /* t */ && str.charCodeAt(start + 4) === 97 /* a */ && str.charCodeAt(start + 5) === 110 /* n */ && str.charCodeAt(start + 6) === 99 /* c */ && str.charCodeAt(start + 7) === 101 /* e */ && str.charCodeAt(start + 8) === 111 /* o */ && str.charCodeAt(start + 9) === 102 /* f */) ? 30 /* InstanceOfKeyword */ : 11 /* IdentifierName */;
                                default:
                                    return 11 /* IdentifierName */;
                            }
                        default:
                            return 11 /* IdentifierName */;
                    }
                case 11:
                    return (str.charCodeAt(start) === 99 /* c */ && str.charCodeAt(start + 1) === 111 /* o */ && str.charCodeAt(start + 2) === 110 /* n */ && str.charCodeAt(start + 3) === 115 /* s */ && str.charCodeAt(start + 4) === 116 /* t */ && str.charCodeAt(start + 5) === 114 /* r */ && str.charCodeAt(start + 6) === 117 /* u */ && str.charCodeAt(start + 7) === 99 /* c */ && str.charCodeAt(start + 8) === 116 /* t */ && str.charCodeAt(start + 9) === 111 /* o */ && str.charCodeAt(start + 10) === 114 /* r */) ? 62 /* ConstructorKeyword */ : 11 /* IdentifierName */;
                default:
                    return 11 /* IdentifierName */;
            }
        };
        return ScannerUtilities;
    })();
    TypeScript.ScannerUtilities = ScannerUtilities;
})(TypeScript || (TypeScript = {}));
///<reference path='references.ts' />
var TypeScript;
(function (TypeScript) {
    var SlidingWindow = (function () {
        function SlidingWindow(// Underlying source that we retrieve items from.
            fetchNextItem, 
            // A window of items that has been read in from the underlying source.
            window, 
            // The default value to return when there are no more items left in the window.
            defaultValue, 
            // The length of the source we're reading from if we know it up front.  -1 if we do not.
            sourceLength) {
            if (sourceLength === void 0) { sourceLength = -1; }
            this.fetchNextItem = fetchNextItem;
            this.window = window;
            this.defaultValue = defaultValue;
            this.sourceLength = sourceLength;
            // The number of valid items in window.
            this.windowCount = 0;
            // The *absolute* index in the *full* array of items the *window* array starts at.  i.e.
            // if there were 100 items, and window contains tokens [70, 80), then this value would be
            // 70.
            this.windowAbsoluteStartIndex = 0;
            // The index in the window array that we're at. i.e. if there 100 items and 
            // window contains tokens [70, 80), and we're on item 75, then this value would be '5'.
            // Note: it is not absolute.  It is relative to the start of the window.
            this.currentRelativeItemIndex = 0;
            // The number of pinned points there are.  As long as there is at least one  pinned point, we 
            // will not advance the start of the window array past the item marked by that pin point.
            this._pinCount = 0;
            // If there are any outstanding rewind points, this is index in the full array of items
            // that the first rewind point points to.  If this is not -1, then we will not shift the
            // start of the items array past this point.
            this.firstPinnedAbsoluteIndex = -1;
        }
        SlidingWindow.prototype.addMoreItemsToWindow = function (argument) {
            var sourceLength = this.sourceLength;
            if (sourceLength >= 0 && this.absoluteIndex() >= sourceLength) {
                return false;
            }
            // First, make room for the new items if we're out of room.
            if (this.windowCount >= this.window.length) {
                this.tryShiftOrGrowWindow();
            }
            var item = this.fetchNextItem(argument);
            this.window[this.windowCount] = item;
            // Assert disabled because it is actually expensive enugh to affect perf.
            this.windowCount++;
            return true;
        };
        SlidingWindow.prototype.tryShiftOrGrowWindow = function () {
            // We want to shift if our current item is past the halfway point of the current item window.
            var currentIndexIsPastWindowHalfwayPoint = this.currentRelativeItemIndex > (this.window.length >>> 1);
            // However, we can only shift if we have no outstanding rewind points.  Or, if we have an 
            // outstanding rewind point, that it points to some point after the start of the window.
            var isAllowedToShift = this.firstPinnedAbsoluteIndex === -1 || this.firstPinnedAbsoluteIndex > this.windowAbsoluteStartIndex;
            if (currentIndexIsPastWindowHalfwayPoint && isAllowedToShift) {
                // Figure out where we're going to start shifting from. If we have no oustanding rewind 
                // points, then we'll start shifting over all the items starting from the current 
                // token we're point out.  Otherwise, we'll shift starting from the first item that 
                // the rewind point is pointing at.
                // 
                // We'll call that point 'N' from now on. 
                var shiftStartIndex = this.firstPinnedAbsoluteIndex === -1 ? this.currentRelativeItemIndex : this.firstPinnedAbsoluteIndex - this.windowAbsoluteStartIndex;
                // We have to shift the number of elements between the start index and the number of 
                // items in the window.
                var shiftCount = this.windowCount - shiftStartIndex;
                // Debug.assert(shiftStartIndex > 0);
                if (shiftCount > 0) {
                    TypeScript.ArrayUtilities.copy(this.window, shiftStartIndex, this.window, 0, shiftCount);
                }
                // The window has now moved over to the right by N.
                this.windowAbsoluteStartIndex += shiftStartIndex;
                // The number of valid items in the window has now decreased by N.
                this.windowCount -= shiftStartIndex;
                // The current item now starts further to the left in the window.
                this.currentRelativeItemIndex -= shiftStartIndex;
            }
            else {
                // Grow the exisitng array.
                // this.window[this.window.length * 2 - 1] = this.defaultValue;
                TypeScript.ArrayUtilities.grow(this.window, this.window.length * 2, this.defaultValue);
            }
        };
        SlidingWindow.prototype.absoluteIndex = function () {
            return this.windowAbsoluteStartIndex + this.currentRelativeItemIndex;
        };
        SlidingWindow.prototype.isAtEndOfSource = function () {
            return this.absoluteIndex() >= this.sourceLength;
        };
        SlidingWindow.prototype.getAndPinAbsoluteIndex = function () {
            // Find the absolute index of this pin point.  i.e. it's the index as if we had an 
            // array containing *all* tokens.  
            var absoluteIndex = this.absoluteIndex();
            var pinCount = this._pinCount++;
            if (pinCount === 0) {
                // If this is the first pinned point, then store off this index.  We will ensure that
                // we never shift the window past this point.
                this.firstPinnedAbsoluteIndex = absoluteIndex;
            }
            return absoluteIndex;
        };
        SlidingWindow.prototype.releaseAndUnpinAbsoluteIndex = function (absoluteIndex) {
            this._pinCount--;
            if (this._pinCount === 0) {
                // If we just released the last outstanding pin, then we no longer need to 'fix' the 
                // token window so it can't move forward.  Set the index to -1 so that we can shift 
                // things over the next time we read past the end of the array.
                this.firstPinnedAbsoluteIndex = -1;
            }
        };
        SlidingWindow.prototype.rewindToPinnedIndex = function (absoluteIndex) {
            // The rewind point shows which absolute item we want to rewind to.  Get the relative 
            // index in the actual array that we want to point to.
            var relativeIndex = absoluteIndex - this.windowAbsoluteStartIndex;
            // Make sure we haven't screwed anything up.
            // Debug.assert(relativeIndex >= 0 && relativeIndex < this.windowCount);
            // Set ourselves back to that point.
            this.currentRelativeItemIndex = relativeIndex;
        };
        SlidingWindow.prototype.currentItem = function (argument) {
            if (this.currentRelativeItemIndex >= this.windowCount) {
                if (!this.addMoreItemsToWindow(argument)) {
                    return this.defaultValue;
                }
            }
            return this.window[this.currentRelativeItemIndex];
        };
        SlidingWindow.prototype.peekItemN = function (n) {
            while (this.currentRelativeItemIndex + n >= this.windowCount) {
                if (!this.addMoreItemsToWindow(null)) {
                    return this.defaultValue;
                }
            }
            return this.window[this.currentRelativeItemIndex + n];
        };
        SlidingWindow.prototype.moveToNextItem = function () {
            this.currentRelativeItemIndex++;
        };
        SlidingWindow.prototype.disgardAllItemsFromCurrentIndexOnwards = function () {
            // By setting the window count to the current relative offset, we are effectively making
            // any items we added to the window from the current offset onwards unusable.  When we
            // try to get the next item, we'll be forced to refetch them from the underlying source.
            this.windowCount = this.currentRelativeItemIndex;
        };
        return SlidingWindow;
    })();
    TypeScript.SlidingWindow = SlidingWindow;
})(TypeScript || (TypeScript = {}));
///<reference path='references.ts' />
var TypeScript;
(function (TypeScript) {
    var Syntax;
    (function (Syntax) {
        Syntax._nextSyntaxID = 1;
        function childIndex(parent, child) {
            for (var i = 0, n = TypeScript.childCount(parent); i < n; i++) {
                var current = TypeScript.childAt(parent, i);
                if (current === child) {
                    return i;
                }
            }
            throw TypeScript.Errors.invalidOperation();
        }
        Syntax.childIndex = childIndex;
        function nodeHasSkippedOrMissingTokens(node) {
            for (var i = 0; i < TypeScript.childCount(node); i++) {
                var child = TypeScript.childAt(node, i);
                if (TypeScript.isToken(child)) {
                    var token = child;
                    // If a token is skipped, return true. Or if it is a missing token. The only empty token that is not missing is EOF
                    if (token.hasSkippedToken() || (TypeScript.width(token) === 0 && token.kind() !== 10 /* EndOfFileToken */)) {
                        return true;
                    }
                }
            }
            return false;
        }
        Syntax.nodeHasSkippedOrMissingTokens = nodeHasSkippedOrMissingTokens;
        function isUnterminatedStringLiteral(token) {
            if (token && token.kind() === 14 /* StringLiteral */) {
                var text = token.text();
                return text.length < 2 || text.charCodeAt(text.length - 1) !== text.charCodeAt(0);
            }
            return false;
        }
        Syntax.isUnterminatedStringLiteral = isUnterminatedStringLiteral;
        function isUnterminatedMultilineCommentTrivia(trivia) {
            if (trivia && trivia.kind() === 6 /* MultiLineCommentTrivia */) {
                var text = trivia.fullText();
                return text.length < 4 || text.substring(text.length - 2) !== "*/";
            }
            return false;
        }
        Syntax.isUnterminatedMultilineCommentTrivia = isUnterminatedMultilineCommentTrivia;
        function isEntirelyInsideCommentTrivia(trivia, fullStart, position) {
            if (trivia && trivia.isComment() && position > fullStart) {
                var end = fullStart + trivia.fullWidth();
                if (position < end) {
                    return true;
                }
                else if (position === end) {
                    return trivia.kind() === 7 /* SingleLineCommentTrivia */ || isUnterminatedMultilineCommentTrivia(trivia);
                }
            }
            return false;
        }
        Syntax.isEntirelyInsideCommentTrivia = isEntirelyInsideCommentTrivia;
        function isEntirelyInsideComment(sourceUnit, position) {
            var positionedToken = TypeScript.findToken(sourceUnit, position);
            var fullStart = positionedToken.fullStart();
            var triviaList = null;
            var lastTriviaBeforeToken = null;
            if (positionedToken.kind() === 10 /* EndOfFileToken */) {
                // Check if the trivia is leading on the EndOfFile token
                if (positionedToken.hasLeadingTrivia()) {
                    triviaList = positionedToken.leadingTrivia();
                }
                else {
                    positionedToken = TypeScript.previousToken(positionedToken);
                    if (positionedToken) {
                        if (positionedToken && positionedToken.hasTrailingTrivia()) {
                            triviaList = positionedToken.trailingTrivia();
                            fullStart = TypeScript.end(positionedToken);
                        }
                    }
                }
            }
            else {
                if (position <= (fullStart + positionedToken.leadingTriviaWidth())) {
                    triviaList = positionedToken.leadingTrivia();
                }
                else if (position >= (fullStart + TypeScript.width(positionedToken))) {
                    triviaList = positionedToken.trailingTrivia();
                    fullStart = TypeScript.end(positionedToken);
                }
            }
            if (triviaList) {
                for (var i = 0, n = triviaList.count(); i < n; i++) {
                    var trivia = triviaList.syntaxTriviaAt(i);
                    if (position <= fullStart) {
                        break;
                    }
                    else if (position <= fullStart + trivia.fullWidth() && trivia.isComment()) {
                        // Found the comment trivia we were looking for
                        lastTriviaBeforeToken = trivia;
                        break;
                    }
                    fullStart += trivia.fullWidth();
                }
            }
            return lastTriviaBeforeToken && isEntirelyInsideCommentTrivia(lastTriviaBeforeToken, fullStart, position);
        }
        Syntax.isEntirelyInsideComment = isEntirelyInsideComment;
        function isEntirelyInStringOrRegularExpressionLiteral(sourceUnit, position) {
            var positionedToken = TypeScript.findToken(sourceUnit, position);
            if (positionedToken) {
                if (positionedToken.kind() === 10 /* EndOfFileToken */) {
                    // EndOfFile token, enusre it did not follow an unterminated string literal
                    positionedToken = TypeScript.previousToken(positionedToken);
                    return positionedToken && positionedToken.trailingTriviaWidth() === 0 && isUnterminatedStringLiteral(positionedToken);
                }
                else if (position > TypeScript.start(positionedToken)) {
                    // Ensure position falls enterily within the literal if it is terminated, or the line if it is not
                    return (position < TypeScript.end(positionedToken) && (positionedToken.kind() === 14 /* StringLiteral */ || positionedToken.kind() === 12 /* RegularExpressionLiteral */)) || (position <= TypeScript.end(positionedToken) && isUnterminatedStringLiteral(positionedToken));
                }
            }
            return false;
        }
        Syntax.isEntirelyInStringOrRegularExpressionLiteral = isEntirelyInStringOrRegularExpressionLiteral;
        function findSkippedTokenOnLeftInTriviaList(positionedToken, position, lookInLeadingTriviaList) {
            var triviaList = null;
            var fullEnd;
            if (lookInLeadingTriviaList) {
                triviaList = positionedToken.leadingTrivia();
                fullEnd = positionedToken.fullStart() + triviaList.fullWidth();
            }
            else {
                triviaList = positionedToken.trailingTrivia();
                fullEnd = TypeScript.fullEnd(positionedToken);
            }
            if (triviaList && triviaList.hasSkippedToken()) {
                for (var i = triviaList.count() - 1; i >= 0; i--) {
                    var trivia = triviaList.syntaxTriviaAt(i);
                    var triviaWidth = trivia.fullWidth();
                    if (trivia.isSkippedToken() && position >= fullEnd) {
                        return trivia.skippedToken();
                    }
                    fullEnd -= triviaWidth;
                }
            }
            return null;
        }
        function findSkippedTokenOnLeft(positionedToken, position) {
            var positionInLeadingTriviaList = (position < TypeScript.start(positionedToken));
            return findSkippedTokenOnLeftInTriviaList(positionedToken, position, positionInLeadingTriviaList);
        }
        Syntax.findSkippedTokenOnLeft = findSkippedTokenOnLeft;
        function getAncestorOfKind(positionedToken, kind) {
            while (positionedToken && positionedToken.parent) {
                if (positionedToken.parent.kind() === kind) {
                    return positionedToken.parent;
                }
                positionedToken = positionedToken.parent;
            }
            return null;
        }
        Syntax.getAncestorOfKind = getAncestorOfKind;
        function hasAncestorOfKind(positionedToken, kind) {
            return getAncestorOfKind(positionedToken, kind) !== null;
        }
        Syntax.hasAncestorOfKind = hasAncestorOfKind;
        function isIntegerLiteral(expression) {
            if (expression) {
                switch (expression.kind()) {
                    case 165 /* PlusExpression */:
                    case 166 /* NegateExpression */:
                        // Note: if there is a + or - sign, we can only allow a normal integer following
                        // (and not a hex integer).  i.e. -0xA is a legal expression, but it is not a 
                        // *literal*.
                        expression = expression.operand;
                        return TypeScript.isToken(expression) && TypeScript.IntegerUtilities.isInteger(expression.text());
                    case 13 /* NumericLiteral */:
                        // If it doesn't have a + or -, then either an integer literal or a hex literal
                        // is acceptable.
                        var text = expression.text();
                        return TypeScript.IntegerUtilities.isInteger(text) || TypeScript.IntegerUtilities.isHexInteger(text);
                }
            }
            return false;
        }
        Syntax.isIntegerLiteral = isIntegerLiteral;
        function containingNode(element) {
            var current = element.parent;
            while (current !== null && !TypeScript.isNode(current)) {
                current = current.parent;
            }
            return current;
        }
        Syntax.containingNode = containingNode;
        function findTokenOnLeft(element, position, includeSkippedTokens) {
            if (includeSkippedTokens === void 0) { includeSkippedTokens = false; }
            var positionedToken = TypeScript.findToken(element, position, false);
            var _start = TypeScript.start(positionedToken);
            // Position better fall within this token.
            // Debug.assert(position >= positionedToken.fullStart());
            // Debug.assert(position < positionedToken.fullEnd() || positionedToken.token().tokenKind === SyntaxKind.EndOfFileToken);
            if (includeSkippedTokens) {
                positionedToken = findSkippedTokenOnLeft(positionedToken, position) || positionedToken;
            }
            // if position is after the start of the token, then this token is the token on the left.
            if (position > _start) {
                return positionedToken;
            }
            // we're in the trivia before the start of the token.  Need to return the previous token.
            if (positionedToken.fullStart() === 0) {
                // Already on the first token.  Nothing before us.
                return null;
            }
            return TypeScript.previousToken(positionedToken, includeSkippedTokens);
        }
        Syntax.findTokenOnLeft = findTokenOnLeft;
        function findCompleteTokenOnLeft(element, position, includeSkippedTokens) {
            if (includeSkippedTokens === void 0) { includeSkippedTokens = false; }
            var positionedToken = TypeScript.findToken(element, position, false);
            // Position better fall within this token.
            // Debug.assert(position >= positionedToken.fullStart());
            // Debug.assert(position < positionedToken.fullEnd() || positionedToken.token().tokenKind === SyntaxKind.EndOfFileToken);
            if (includeSkippedTokens) {
                positionedToken = findSkippedTokenOnLeft(positionedToken, position) || positionedToken;
            }
            // if position is after the end of the token, then this token is the token on the left.
            if (TypeScript.width(positionedToken) > 0 && position >= TypeScript.end(positionedToken)) {
                return positionedToken;
            }
            return TypeScript.previousToken(positionedToken, includeSkippedTokens);
        }
        Syntax.findCompleteTokenOnLeft = findCompleteTokenOnLeft;
        function firstTokenInLineContainingPosition(syntaxTree, position) {
            var current = TypeScript.findToken(syntaxTree.sourceUnit(), position);
            while (true) {
                if (isFirstTokenInLine(current, syntaxTree.lineMap())) {
                    break;
                }
                current = TypeScript.previousToken(current);
            }
            return current;
        }
        Syntax.firstTokenInLineContainingPosition = firstTokenInLineContainingPosition;
        function isFirstTokenInLine(token, lineMap) {
            var _previousToken = TypeScript.previousToken(token);
            if (_previousToken === null) {
                return true;
            }
            return lineMap.getLineNumberFromPosition(TypeScript.end(_previousToken)) !== lineMap.getLineNumberFromPosition(TypeScript.start(token));
        }
    })(Syntax = TypeScript.Syntax || (TypeScript.Syntax = {}));
})(TypeScript || (TypeScript = {}));
///<reference path='references.ts' />
var TypeScript;
(function (TypeScript) {
    // True if there is only a single instance of this element (and thus can be reused in many 
    // places in a syntax tree).  Examples of this include our empty lists.  Because empty 
    // lists can be found all over the tree, we want to save on memory by using this single
    // instance instead of creating new objects for each case.  Note: because of this, shared
    // nodes don't have positions or parents.
    function isShared(element) {
        var kind = element.kind();
        return (kind === 1 /* List */ || kind === 2 /* SeparatedList */) && element.length === 0;
    }
    TypeScript.isShared = isShared;
    function childCount(element) {
        var kind = element.kind();
        if (kind === 1 /* List */) {
            return element.length;
        }
        else if (kind === 2 /* SeparatedList */) {
            return element.length + element.separators.length;
        }
        else if (kind >= TypeScript.SyntaxKind.FirstToken && kind <= TypeScript.SyntaxKind.LastToken) {
            return 0;
        }
        else {
            return TypeScript.nodeMetadata[kind].length;
        }
    }
    TypeScript.childCount = childCount;
    function childAt(element, index) {
        var kind = element.kind();
        if (kind === 1 /* List */) {
            return element[index];
        }
        else if (kind === 2 /* SeparatedList */) {
            return (index % 2 === 0) ? element[index / 2] : element.separators[(index - 1) / 2];
        }
        else {
            // Debug.assert(isNode(element));
            return element[TypeScript.nodeMetadata[element.kind()][index]];
        }
    }
    TypeScript.childAt = childAt;
    function syntaxTree(element) {
        if (element) {
            TypeScript.Debug.assert(!isShared(element));
            while (element) {
                if (element.kind() === 120 /* SourceUnit */) {
                    return element.syntaxTree;
                }
                element = element.parent;
            }
        }
        return null;
    }
    TypeScript.syntaxTree = syntaxTree;
    function parsedInStrictMode(node) {
        var info = node.data;
        if (info === undefined) {
            return false;
        }
        return (info & 4 /* NodeParsedInStrictModeMask */) !== 0;
    }
    TypeScript.parsedInStrictMode = parsedInStrictMode;
    function previousToken(token, includeSkippedTokens) {
        if (includeSkippedTokens === void 0) { includeSkippedTokens = false; }
        if (includeSkippedTokens) {
            var triviaList = token.leadingTrivia();
            if (triviaList && triviaList.hasSkippedToken()) {
                var currentTriviaEndPosition = TypeScript.start(token);
                for (var i = triviaList.count() - 1; i >= 0; i--) {
                    var trivia = triviaList.syntaxTriviaAt(i);
                    if (trivia.isSkippedToken()) {
                        return trivia.skippedToken();
                    }
                    currentTriviaEndPosition -= trivia.fullWidth();
                }
            }
        }
        var start = token.fullStart();
        if (start === 0) {
            return null;
        }
        return findToken(syntaxTree(token).sourceUnit(), start - 1, includeSkippedTokens);
    }
    TypeScript.previousToken = previousToken;
    /**
     * Finds a token according to the following rules:
     * 1) If position matches the End of the node/s FullSpan and the node is SourceUnitSyntax,
     *    then the EOF token is returned.
     *
     *  2) If node.FullSpan.Contains(position) then the token that contains given position is
     *     returned.
     *
     *  3) Otherwise an ArgumentOutOfRangeException is thrown
     *
     * Note: findToken will always return a non-missing token with width greater than or equal to
     * 1 (except for EOF).  Empty tokens synthesized by the parser are never returned.
     */
    function findToken(element, position, includeSkippedTokens) {
        if (includeSkippedTokens === void 0) { includeSkippedTokens = false; }
        var endOfFileToken = tryGetEndOfFileAt(element, position);
        if (endOfFileToken !== null) {
            return endOfFileToken;
        }
        if (position < 0 || position >= fullWidth(element)) {
            throw TypeScript.Errors.argumentOutOfRange("position");
        }
        var positionedToken = findTokenWorker(element, position);
        if (includeSkippedTokens) {
            return findSkippedTokenInPositionedToken(positionedToken, position) || positionedToken;
        }
        // Could not find a better match
        return positionedToken;
    }
    TypeScript.findToken = findToken;
    function findSkippedTokenInPositionedToken(positionedToken, position) {
        var positionInLeadingTriviaList = (position < start(positionedToken));
        return findSkippedTokenInTriviaList(positionedToken, position, positionInLeadingTriviaList);
    }
    TypeScript.findSkippedTokenInPositionedToken = findSkippedTokenInPositionedToken;
    function findSkippedTokenInLeadingTriviaList(positionedToken, position) {
        return findSkippedTokenInTriviaList(positionedToken, position, true);
    }
    TypeScript.findSkippedTokenInLeadingTriviaList = findSkippedTokenInLeadingTriviaList;
    function findSkippedTokenInTrailingTriviaList(positionedToken, position) {
        return findSkippedTokenInTriviaList(positionedToken, position, false);
    }
    TypeScript.findSkippedTokenInTrailingTriviaList = findSkippedTokenInTrailingTriviaList;
    function findSkippedTokenInTriviaList(positionedToken, position, lookInLeadingTriviaList) {
        var triviaList = null;
        var fullStart;
        if (lookInLeadingTriviaList) {
            triviaList = positionedToken.leadingTrivia();
            fullStart = positionedToken.fullStart();
        }
        else {
            triviaList = positionedToken.trailingTrivia();
            fullStart = end(positionedToken);
        }
        if (triviaList && triviaList.hasSkippedToken()) {
            for (var i = 0, n = triviaList.count(); i < n; i++) {
                var trivia = triviaList.syntaxTriviaAt(i);
                var triviaWidth = trivia.fullWidth();
                if (trivia.isSkippedToken() && position >= fullStart && position <= fullStart + triviaWidth) {
                    return trivia.skippedToken();
                }
                fullStart += triviaWidth;
            }
        }
        return null;
    }
    function findTokenWorker(element, position) {
        // Debug.assert(position >= 0 && position < this.fullWidth());
        if (isToken(element)) {
            TypeScript.Debug.assert(fullWidth(element) > 0);
            return element;
        }
        if (isShared(element)) {
            throw TypeScript.Errors.invalidOperation();
        }
        for (var i = 0, n = childCount(element); i < n; i++) {
            var child = childAt(element, i);
            if (child !== null) {
                var childFullWidth = fullWidth(child);
                if (childFullWidth > 0) {
                    var childFullStart = fullStart(child);
                    if (position >= childFullStart) {
                        var childFullEnd = childFullStart + childFullWidth;
                        if (position < childFullEnd) {
                            return findTokenWorker(child, position);
                        }
                    }
                }
            }
        }
        throw TypeScript.Errors.invalidOperation();
    }
    function tryGetEndOfFileAt(element, position) {
        if (element.kind() === 120 /* SourceUnit */ && position === fullWidth(element)) {
            var sourceUnit = element;
            return sourceUnit.endOfFileToken;
        }
        return null;
    }
    function nextToken(token, text, includeSkippedTokens) {
        if (includeSkippedTokens === void 0) { includeSkippedTokens = false; }
        if (token.kind() === 10 /* EndOfFileToken */) {
            return null;
        }
        if (includeSkippedTokens) {
            var triviaList = token.trailingTrivia(text);
            if (triviaList && triviaList.hasSkippedToken()) {
                for (var i = 0, n = triviaList.count(); i < n; i++) {
                    var trivia = triviaList.syntaxTriviaAt(i);
                    if (trivia.isSkippedToken()) {
                        return trivia.skippedToken();
                    }
                }
            }
        }
        return findToken(syntaxTree(token).sourceUnit(), fullEnd(token), includeSkippedTokens);
    }
    TypeScript.nextToken = nextToken;
    function isNode(element) {
        if (element !== null) {
            var kind = element.kind();
            return kind >= TypeScript.SyntaxKind.FirstNode && kind <= TypeScript.SyntaxKind.LastNode;
        }
        return false;
    }
    TypeScript.isNode = isNode;
    function isTokenKind(kind) {
        return kind >= TypeScript.SyntaxKind.FirstToken && kind <= TypeScript.SyntaxKind.LastToken;
    }
    function isToken(element) {
        if (element !== null) {
            return isTokenKind(element.kind());
        }
        return false;
    }
    TypeScript.isToken = isToken;
    function isList(element) {
        return element !== null && element.kind() === 1 /* List */;
    }
    TypeScript.isList = isList;
    function isSeparatedList(element) {
        return element !== null && element.kind() === 2 /* SeparatedList */;
    }
    TypeScript.isSeparatedList = isSeparatedList;
    function syntaxID(element) {
        if (isShared(element)) {
            throw TypeScript.Errors.invalidOperation("Should not use shared syntax element as a key.");
        }
        var obj = element;
        if (obj._syntaxID === undefined) {
            obj._syntaxID = TypeScript.Syntax._nextSyntaxID++;
        }
        return obj._syntaxID;
    }
    TypeScript.syntaxID = syntaxID;
    function collectTextElements(element, elements, text) {
        if (element) {
            if (isToken(element)) {
                elements.push(element.fullText(text));
            }
            else {
                for (var i = 0, n = childCount(element); i < n; i++) {
                    collectTextElements(childAt(element, i), elements, text);
                }
            }
        }
    }
    function fullText(element, text) {
        if (isToken(element)) {
            return element.fullText(text);
        }
        var elements = [];
        collectTextElements(element, elements, text);
        return elements.join("");
    }
    TypeScript.fullText = fullText;
    function leadingTriviaWidth(element, text) {
        var token = firstToken(element);
        return token ? token.leadingTriviaWidth(text) : 0;
    }
    TypeScript.leadingTriviaWidth = leadingTriviaWidth;
    function trailingTriviaWidth(element, text) {
        var token = lastToken(element);
        return token ? token.trailingTriviaWidth(text) : 0;
    }
    TypeScript.trailingTriviaWidth = trailingTriviaWidth;
    function firstToken(element) {
        if (element) {
            var kind = element.kind();
            if (isTokenKind(kind)) {
                return fullWidth(element) > 0 || element.kind() === 10 /* EndOfFileToken */ ? element : null;
            }
            if (kind === 1 /* List */) {
                var array = element;
                for (var i = 0, n = array.length; i < n; i++) {
                    var token = firstToken(array[i]);
                    if (token) {
                        return token;
                    }
                }
            }
            else if (kind === 2 /* SeparatedList */) {
                var array = element;
                var separators = array.separators;
                for (var i = 0, n = array.length + separators.length; i < n; i++) {
                    var token = firstToken(i % 2 === 0 ? array[i / 2] : separators[(i - 1) / 2]);
                    if (token) {
                        return token;
                    }
                }
            }
            else {
                var metadata = TypeScript.nodeMetadata[kind];
                for (var i = 0, n = metadata.length; i < n; i++) {
                    var child = element[metadata[i]];
                    var token = firstToken(child);
                    if (token) {
                        return token;
                    }
                }
                if (element.kind() === 120 /* SourceUnit */) {
                    return element.endOfFileToken;
                }
            }
        }
        return null;
    }
    TypeScript.firstToken = firstToken;
    function lastToken(element) {
        if (isToken(element)) {
            return fullWidth(element) > 0 || element.kind() === 10 /* EndOfFileToken */ ? element : null;
        }
        if (element.kind() === 120 /* SourceUnit */) {
            return element.endOfFileToken;
        }
        for (var i = childCount(element) - 1; i >= 0; i--) {
            var child = childAt(element, i);
            if (child !== null) {
                var token = lastToken(child);
                if (token) {
                    return token;
                }
            }
        }
        return null;
    }
    TypeScript.lastToken = lastToken;
    function fullStart(element) {
        TypeScript.Debug.assert(!isShared(element));
        var token = isToken(element) ? element : firstToken(element);
        return token ? token.fullStart() : -1;
    }
    TypeScript.fullStart = fullStart;
    function fullWidth(element) {
        if (isToken(element)) {
            return element.fullWidth();
        }
        if (isShared(element)) {
            return 0;
        }
        var info = data(element);
        return info >>> 3 /* NodeFullWidthShift */;
    }
    TypeScript.fullWidth = fullWidth;
    function isIncrementallyUnusable(element) {
        if (isToken(element)) {
            return element.isIncrementallyUnusable();
        }
        if (isShared(element)) {
            // All shared lists are reusable.
            return false;
        }
        return (data(element) & 2 /* NodeIncrementallyUnusableMask */) !== 0;
    }
    TypeScript.isIncrementallyUnusable = isIncrementallyUnusable;
    function data(element) {
        TypeScript.Debug.assert(isNode(element) || isList(element) || isSeparatedList(element));
        // Lists and nodes all have a 'data' element.
        var dataElement = element;
        var info = dataElement.data;
        if (info === undefined) {
            info = 0;
        }
        if ((info & 1 /* NodeDataComputed */) === 0) {
            info |= computeData(element);
            dataElement.data = info;
        }
        return info;
    }
    function computeData(element) {
        var slotCount = childCount(element);
        var fullWidth = 0;
        // If we have no children (like an OmmittedExpressionSyntax), we're automatically not reusable.
        var isIncrementallyUnusable = slotCount === 0;
        for (var i = 0, n = slotCount; i < n; i++) {
            var child = childAt(element, i);
            if (child) {
                fullWidth += TypeScript.fullWidth(child);
                isIncrementallyUnusable = isIncrementallyUnusable || TypeScript.isIncrementallyUnusable(child);
            }
        }
        return (fullWidth << 3 /* NodeFullWidthShift */) | (isIncrementallyUnusable ? 2 /* NodeIncrementallyUnusableMask */ : 0) | 1 /* NodeDataComputed */;
    }
    function start(element, text) {
        var token = isToken(element) ? element : firstToken(element);
        return token ? token.fullStart() + token.leadingTriviaWidth(text) : -1;
    }
    TypeScript.start = start;
    function end(element, text) {
        var token = isToken(element) ? element : lastToken(element);
        return token ? fullEnd(token) - token.trailingTriviaWidth(text) : -1;
    }
    TypeScript.end = end;
    function width(element, text) {
        if (isToken(element)) {
            return element.text().length;
        }
        return fullWidth(element) - leadingTriviaWidth(element, text) - trailingTriviaWidth(element, text);
    }
    TypeScript.width = width;
    function fullEnd(element) {
        return fullStart(element) + fullWidth(element);
    }
    TypeScript.fullEnd = fullEnd;
    function existsNewLineBetweenTokens(token1, token2, text) {
        if (token1 === token2) {
            return false;
        }
        if (token1 === null || token2 === null) {
            return true;
        }
        var lineMap = text.lineMap();
        return lineMap.getLineNumberFromPosition(end(token1, text)) !== lineMap.getLineNumberFromPosition(start(token2, text));
    }
    TypeScript.existsNewLineBetweenTokens = existsNewLineBetweenTokens;
})(TypeScript || (TypeScript = {}));
///<reference path='references.ts' />
var TypeScript;
(function (TypeScript) {
    var SyntaxFacts;
    (function (SyntaxFacts) {
        function isDirectivePrologueElement(node) {
            if (node.kind() === 150 /* ExpressionStatement */) {
                var expressionStatement = node;
                var expression = expressionStatement.expression;
                if (expression.kind() === 14 /* StringLiteral */) {
                    return true;
                }
            }
            return false;
        }
        SyntaxFacts.isDirectivePrologueElement = isDirectivePrologueElement;
        function isUseStrictDirective(node) {
            var expressionStatement = node;
            var stringLiteral = expressionStatement.expression;
            var text = stringLiteral.text();
            return text === '"use strict"' || text === "'use strict'";
        }
        SyntaxFacts.isUseStrictDirective = isUseStrictDirective;
        function isIdentifierNameOrAnyKeyword(token) {
            var tokenKind = token.kind();
            return tokenKind === 11 /* IdentifierName */ || SyntaxFacts.isAnyKeyword(tokenKind);
        }
        SyntaxFacts.isIdentifierNameOrAnyKeyword = isIdentifierNameOrAnyKeyword;
        function isAccessibilityModifier(kind) {
            switch (kind) {
                case 57 /* PublicKeyword */:
                case 55 /* PrivateKeyword */:
                case 56 /* ProtectedKeyword */:
                    return true;
            }
            return false;
        }
        SyntaxFacts.isAccessibilityModifier = isAccessibilityModifier;
    })(SyntaxFacts = TypeScript.SyntaxFacts || (TypeScript.SyntaxFacts = {}));
})(TypeScript || (TypeScript = {}));
///<reference path='references.ts' />
var TypeScript;
(function (TypeScript) {
    var Syntax;
    (function (Syntax) {
        var _emptyList = [];
        var _emptySeparatedList = [];
        var _emptySeparators = [];
        _emptySeparatedList.separators = _emptySeparators;
        function assertEmptyLists() {
            // Debug.assert(_emptyList.length === 0);
            // var separators = _emptySeparatedList.separators;
            // Debug.assert(!separators || separators.length === 0);
        }
        Array.prototype.kind = function () {
            return this.separators === undefined ? 1 /* List */ : 2 /* SeparatedList */;
        };
        Array.prototype.separatorCount = function () {
            assertEmptyLists();
            // Debug.assert(this.kind === SyntaxKind.SeparatedList);
            return this.separators.length;
        };
        Array.prototype.separatorAt = function (index) {
            assertEmptyLists();
            // Debug.assert(this.kind === SyntaxKind.SeparatedList);
            // Debug.assert(index >= 0 && index < this.separators.length);
            return this.separators[index];
        };
        function emptyList() {
            return _emptyList;
        }
        Syntax.emptyList = emptyList;
        function emptySeparatedList() {
            return _emptySeparatedList;
        }
        Syntax.emptySeparatedList = emptySeparatedList;
        function list(nodes) {
            if (nodes === undefined || nodes === null || nodes.length === 0) {
                return emptyList();
            }
            for (var i = 0, n = nodes.length; i < n; i++) {
                nodes[i].parent = nodes;
            }
            return nodes;
        }
        Syntax.list = list;
        function separatedList(nodes, separators) {
            if (nodes === undefined || nodes === null || nodes.length === 0) {
                return emptySeparatedList();
            }
            for (var i = 0, n = nodes.length; i < n; i++) {
                nodes[i].parent = nodes;
            }
            for (var i = 0, n = separators.length; i < n; i++) {
                separators[i].parent = nodes;
            }
            nodes.separators = separators.length === 0 ? _emptySeparators : separators;
            return nodes;
        }
        Syntax.separatedList = separatedList;
        function nonSeparatorIndexOf(list, ast) {
            for (var i = 0, n = list.length; i < n; i++) {
                if (list[i] === ast) {
                    return i;
                }
            }
            return -1;
        }
        Syntax.nonSeparatorIndexOf = nonSeparatorIndexOf;
    })(Syntax = TypeScript.Syntax || (TypeScript.Syntax = {}));
})(TypeScript || (TypeScript = {}));
///<reference path='references.ts' />
var TypeScript;
(function (TypeScript) {
    var SyntaxNode = (function () {
        function SyntaxNode(data) {
            if (data) {
                this.data = data;
            }
        }
        SyntaxNode.prototype.kind = function () {
            return this.__kind;
        };
        return SyntaxNode;
    })();
    TypeScript.SyntaxNode = SyntaxNode;
})(TypeScript || (TypeScript = {}));
///<reference path='references.ts' />
///<reference path='references.ts' />
var TypeScript;
(function (TypeScript) {
    TypeScript.nodeMetadata = [[], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], ["moduleElements", "endOfFileToken"], ["left", "dotToken", "right"], ["openBraceToken", "typeMembers", "closeBraceToken"], ["typeParameterList", "parameterList", "equalsGreaterThanToken", "type"], ["type", "openBracketToken", "closeBracketToken"], ["newKeyword", "typeParameterList", "parameterList", "equalsGreaterThanToken", "type"], ["name", "typeArgumentList"], ["typeOfKeyword", "name"], ["openBracketToken", "types", "closeBracketToken"], ["modifiers", "interfaceKeyword", "identifier", "typeParameterList", "heritageClauses", "body"], ["modifiers", "functionKeyword", "identifier", "callSignature", "block", "semicolonToken"], ["modifiers", "moduleKeyword", "name", "stringLiteral", "openBraceToken", "moduleElements", "closeBraceToken"], ["modifiers", "classKeyword", "identifier", "typeParameterList", "heritageClauses", "openBraceToken", "classElements", "closeBraceToken"], ["modifiers", "enumKeyword", "identifier", "openBraceToken", "enumElements", "closeBraceToken"], ["modifiers", "importKeyword", "identifier", "equalsToken", "moduleReference", "semicolonToken"], ["exportKeyword", "equalsToken", "identifier", "semicolonToken"], ["modifiers", "propertyName", "callSignature", "block", "semicolonToken"], ["modifiers", "variableDeclarator", "semicolonToken"], ["modifiers", "constructorKeyword", "callSignature", "block", "semicolonToken"], ["modifiers", "indexSignature", "semicolonToken"], ["modifiers", "getKeyword", "propertyName", "callSignature", "block"], ["modifiers", "setKeyword", "propertyName", "callSignature", "block"], ["propertyName", "questionToken", "typeAnnotation"], ["typeParameterList", "parameterList", "typeAnnotation"], ["newKeyword", "callSignature"], ["openBracketToken", "parameters", "closeBracketToken", "typeAnnotation"], ["propertyName", "questionToken", "callSignature"], ["openBraceToken", "statements", "closeBraceToken"], ["ifKeyword", "openParenToken", "condition", "closeParenToken", "statement", "elseClause"], ["modifiers", "variableDeclaration", "semicolonToken"], ["expression", "semicolonToken"], ["returnKeyword", "expression", "semicolonToken"], ["switchKeyword", "openParenToken", "expression", "closeParenToken", "openBraceToken", "switchClauses", "closeBraceToken"], ["breakKeyword", "identifier", "semicolonToken"], ["continueKeyword", "identifier", "semicolonToken"], ["forKeyword", "openParenToken", "variableDeclaration", "initializer", "firstSemicolonToken", "condition", "secondSemicolonToken", "incrementor", "closeParenToken", "statement"], ["forKeyword", "openParenToken", "variableDeclaration", "left", "inKeyword", "expression", "closeParenToken", "statement"], ["semicolonToken"], ["throwKeyword", "expression", "semicolonToken"], ["whileKeyword", "openParenToken", "condition", "closeParenToken", "statement"], ["tryKeyword", "block", "catchClause", "finallyClause"], ["identifier", "colonToken", "statement"], ["doKeyword", "statement", "whileKeyword", "openParenToken", "condition", "closeParenToken", "semicolonToken"], ["debuggerKeyword", "semicolonToken"], ["withKeyword", "openParenToken", "condition", "closeParenToken", "statement"], ["operatorToken", "operand"], ["operatorToken", "operand"], ["operatorToken", "operand"], ["operatorToken", "operand"], ["operatorToken", "operand"], ["operatorToken", "operand"], ["deleteKeyword", "expression"], ["typeOfKeyword", "expression"], ["voidKeyword", "expression"], ["left", "operatorToken", "right"], ["left", "operatorToken", "right"], ["left", "operatorToken", "right"], ["left", "operatorToken", "right"], ["left", "operatorToken", "right"], ["left", "operatorToken", "right"], ["left", "operatorToken", "right"], ["left", "operatorToken", "right"], ["left", "operatorToken", "right"], ["left", "operatorToken", "right"], ["left", "operatorToken", "right"], ["left", "operatorToken", "right"], ["left", "operatorToken", "right"], ["condition", "questionToken", "whenTrue", "colonToken", "whenFalse"], ["left", "operatorToken", "right"], ["left", "operatorToken", "right"], ["left", "operatorToken", "right"], ["left", "operatorToken", "right"], ["left", "operatorToken", "right"], ["left", "operatorToken", "right"], ["left", "operatorToken", "right"], ["left", "operatorToken", "right"], ["left", "operatorToken", "right"], ["left", "operatorToken", "right"], ["left", "operatorToken", "right"], ["left", "operatorToken", "right"], ["left", "operatorToken", "right"], ["left", "operatorToken", "right"], ["left", "operatorToken", "right"], ["left", "operatorToken", "right"], ["left", "operatorToken", "right"], ["left", "operatorToken", "right"], ["left", "operatorToken", "right"], ["left", "operatorToken", "right"], ["left", "operatorToken", "right"], ["left", "operatorToken", "right"], ["left", "operatorToken", "right"], ["operand", "operatorToken"], ["operand", "operatorToken"], ["expression", "dotToken", "name"], ["expression", "argumentList"], ["openBracketToken", "expressions", "closeBracketToken"], ["openBraceToken", "propertyAssignments", "closeBraceToken"], ["newKeyword", "expression", "argumentList"], ["openParenToken", "expression", "closeParenToken"], ["callSignature", "equalsGreaterThanToken", "block", "expression"], ["parameter", "equalsGreaterThanToken", "block", "expression"], ["lessThanToken", "type", "greaterThanToken", "expression"], ["expression", "openBracketToken", "argumentExpression", "closeBracketToken"], ["functionKeyword", "identifier", "callSignature", "block"], [], ["varKeyword", "variableDeclarators"], ["propertyName", "typeAnnotation", "equalsValueClause"], ["typeArgumentList", "openParenToken", "arguments", "closeParenToken"], ["openParenToken", "parameters", "closeParenToken"], ["lessThanToken", "typeArguments", "greaterThanToken"], ["lessThanToken", "typeParameters", "greaterThanToken"], ["extendsOrImplementsKeyword", "typeNames"], ["extendsOrImplementsKeyword", "typeNames"], ["equalsToken", "value"], ["caseKeyword", "expression", "colonToken", "statements"], ["defaultKeyword", "colonToken", "statements"], ["elseKeyword", "statement"], ["catchKeyword", "openParenToken", "identifier", "typeAnnotation", "closeParenToken", "block"], ["finallyKeyword", "block"], ["identifier", "constraint"], ["extendsKeyword", "typeOrExpression"], ["propertyName", "colonToken", "expression"], ["propertyName", "callSignature", "block"], ["dotDotDotToken", "modifiers", "identifier", "questionToken", "typeAnnotation", "equalsValueClause"], ["propertyName", "equalsValueClause"], ["colonToken", "type"], ["requireKeyword", "openParenToken", "stringLiteral", "closeParenToken"], ["moduleName"], ];
})(TypeScript || (TypeScript = {}));
///<reference path='references.ts' />
var TypeScript;
(function (TypeScript) {
    function tokenValue(token) {
        if (token.fullWidth() === 0) {
            return null;
        }
        var kind = token.kind();
        var text = token.text();
        if (kind === 11 /* IdentifierName */) {
            return massageEscapes(text);
        }
        switch (kind) {
            case 37 /* TrueKeyword */:
                return true;
            case 24 /* FalseKeyword */:
                return false;
            case 32 /* NullKeyword */:
                return null;
        }
        if (TypeScript.SyntaxFacts.isAnyKeyword(kind) || TypeScript.SyntaxFacts.isAnyPunctuation(kind)) {
            return TypeScript.SyntaxFacts.getText(kind);
        }
        if (kind === 13 /* NumericLiteral */) {
            return TypeScript.IntegerUtilities.isHexInteger(text) ? parseInt(text, 16) : parseFloat(text);
        }
        else if (kind === 14 /* StringLiteral */) {
            if (text.length > 1 && text.charCodeAt(text.length - 1) === text.charCodeAt(0)) {
                // Properly terminated.  Remove the quotes, and massage any escape characters we see.
                return massageEscapes(text.substr(1, text.length - 2));
            }
            else {
                // Not property terminated.  Remove the first quote and massage any escape characters we see.
                return massageEscapes(text.substr(1));
            }
        }
        else if (kind === 12 /* RegularExpressionLiteral */) {
            return regularExpressionValue(text);
        }
        else if (kind === 10 /* EndOfFileToken */ || kind === 9 /* ErrorToken */) {
            return null;
        }
        else {
            throw TypeScript.Errors.invalidOperation();
        }
    }
    TypeScript.tokenValue = tokenValue;
    function tokenValueText(token) {
        var value = tokenValue(token);
        return value === null ? "" : massageDisallowedIdentifiers(value.toString());
    }
    TypeScript.tokenValueText = tokenValueText;
    function massageEscapes(text) {
        return text.indexOf("\\") >= 0 ? convertEscapes(text) : text;
    }
    TypeScript.massageEscapes = massageEscapes;
    function regularExpressionValue(text) {
        try {
            var lastSlash = text.lastIndexOf("/");
            var body = text.substring(1, lastSlash);
            var flags = text.substring(lastSlash + 1);
            return new RegExp(body, flags);
        }
        catch (e) {
            return null;
        }
    }
    function massageDisallowedIdentifiers(text) {
        // We routinely store the 'valueText' for a token as keys in dictionaries.  However, as those
        // dictionaries are usually just a javascript object, we run into issues when teh keys collide
        // with certain predefined keys they depend on (like __proto__).  To workaround this
        // we ensure that the valueText of any token is not __proto__ but is instead ___proto__.
        //
        // We also prepend a _ to any identifier starting with two __ .  That allows us to carve 
        // out the entire namespace of identifiers starting with __ for ourselves.
        if (text.charCodeAt(0) === 95 /* _ */ && text.charCodeAt(1) === 95 /* _ */) {
            return "_" + text;
        }
        return text;
    }
    var characterArray = [];
    function convertEscapes(text) {
        characterArray.length = 0;
        var result = "";
        for (var i = 0, n = text.length; i < n; i++) {
            var ch = text.charCodeAt(i);
            if (ch === 92 /* backslash */) {
                i++;
                if (i < n) {
                    ch = text.charCodeAt(i);
                    switch (ch) {
                        case 48 /* _0 */:
                            characterArray.push(0 /* nullCharacter */);
                            continue;
                        case 98 /* b */:
                            characterArray.push(8 /* backspace */);
                            continue;
                        case 102 /* f */:
                            characterArray.push(12 /* formFeed */);
                            continue;
                        case 110 /* n */:
                            characterArray.push(10 /* lineFeed */);
                            continue;
                        case 114 /* r */:
                            characterArray.push(13 /* carriageReturn */);
                            continue;
                        case 116 /* t */:
                            characterArray.push(9 /* tab */);
                            continue;
                        case 118 /* v */:
                            characterArray.push(11 /* verticalTab */);
                            continue;
                        case 120 /* x */:
                            characterArray.push(hexValue(text, i + 1, 2));
                            i += 2;
                            continue;
                        case 117 /* u */:
                            characterArray.push(hexValue(text, i + 1, 4));
                            i += 4;
                            continue;
                        case 13 /* carriageReturn */:
                            var nextIndex = i + 1;
                            if (nextIndex < text.length && text.charCodeAt(nextIndex) === 10 /* lineFeed */) {
                                // Skip the entire \r\n sequence.
                                i++;
                            }
                            continue;
                        case 10 /* lineFeed */:
                        case 8233 /* paragraphSeparator */:
                        case 8232 /* lineSeparator */:
                            continue;
                        default:
                    }
                }
            }
            characterArray.push(ch);
            if (i && !(i % 1024)) {
                result = result.concat(String.fromCharCode.apply(null, characterArray));
                characterArray.length = 0;
            }
        }
        if (characterArray.length) {
            result = result.concat(String.fromCharCode.apply(null, characterArray));
        }
        return result;
    }
    function hexValue(text, start, length) {
        var intChar = 0;
        for (var i = 0; i < length; i++) {
            var ch2 = text.charCodeAt(start + i);
            if (!TypeScript.CharacterInfo.isHexDigit(ch2)) {
                break;
            }
            intChar = (intChar << 4) + TypeScript.CharacterInfo.hexValue(ch2);
        }
        return intChar;
    }
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var Syntax;
    (function (Syntax) {
        function realizeToken(token, text) {
            return new RealizedToken(token.fullStart(), token.kind(), token.isKeywordConvertedToIdentifier(), token.leadingTrivia(text), token.text(), token.trailingTrivia(text));
        }
        Syntax.realizeToken = realizeToken;
        function convertKeywordToIdentifier(token) {
            return new ConvertedKeywordToken(token);
        }
        Syntax.convertKeywordToIdentifier = convertKeywordToIdentifier;
        function withLeadingTrivia(token, leadingTrivia, text) {
            return new RealizedToken(token.fullStart(), token.kind(), token.isKeywordConvertedToIdentifier(), leadingTrivia, token.text(), token.trailingTrivia(text));
        }
        Syntax.withLeadingTrivia = withLeadingTrivia;
        function withTrailingTrivia(token, trailingTrivia, text) {
            return new RealizedToken(token.fullStart(), token.kind(), token.isKeywordConvertedToIdentifier(), token.leadingTrivia(text), token.text(), trailingTrivia);
        }
        Syntax.withTrailingTrivia = withTrailingTrivia;
        function emptyToken(kind) {
            return new EmptyToken(kind);
        }
        Syntax.emptyToken = emptyToken;
        var EmptyToken = (function () {
            function EmptyToken(_kind) {
                this._kind = _kind;
            }
            EmptyToken.prototype.setFullStart = function (fullStart) {
                // An empty token is always at the -1 position.
            };
            EmptyToken.prototype.kind = function () {
                return this._kind;
            };
            EmptyToken.prototype.clone = function () {
                return new EmptyToken(this.kind());
            };
            // Empty tokens are never incrementally reusable.
            EmptyToken.prototype.isIncrementallyUnusable = function () {
                return true;
            };
            EmptyToken.prototype.isKeywordConvertedToIdentifier = function () {
                return false;
            };
            EmptyToken.prototype.fullWidth = function () {
                return 0;
            };
            EmptyToken.prototype.position = function () {
                // It's hard for us to tell the position of an empty token at the eact time we create 
                // it.  For example, we may have:
                //
                //      a / finally
                //
                // There will be a missing token detected after the forward slash, so it would be 
                // tempting to set its position as the full-end of hte slash token. However, 
                // immediately after that, the 'finally' token will be skipped and will be attached
                // as skipped text to the forward slash.  This means the 'full-end' of the forward
                // slash will change, and thus the empty token will now appear to be embedded inside
                // another token.  This violates are rule that all tokens must only touch at the end,
                // and makes enforcing invariants much harder.
                //
                // To address this we create the empty token with no known position, and then we 
                // determine what it's position should be based on where it lies in the tree.  
                // Specifically, we find the previous non-zero-width syntax element, and we consider
                // the full-start of this token to be at the full-end of that element.
                var previousElement = this.previousNonZeroWidthElement();
                return previousElement === null ? 0 : TypeScript.fullStart(previousElement) + TypeScript.fullWidth(previousElement);
            };
            EmptyToken.prototype.previousNonZeroWidthElement = function () {
                var current = this;
                while (true) {
                    var parent = current.parent;
                    if (parent === null) {
                        TypeScript.Debug.assert(current.kind() === 120 /* SourceUnit */, "We had a node without a parent that was not the root node!");
                        // We walked all the way to the top, and never found a previous element.  This 
                        // can happen with code like:
                        //
                        //      / b;
                        //
                        // We will have an empty identifier token as the first token in the tree.  In
                        // this case, return null so that the position of the empty token will be 
                        // considered to be 0.
                        return null;
                    }
                    for (var i = 0, n = TypeScript.childCount(parent); i < n; i++) {
                        if (TypeScript.childAt(parent, i) === current) {
                            break;
                        }
                    }
                    TypeScript.Debug.assert(i !== n, "Could not find current element in parent's child list!");
                    for (var j = i - 1; j >= 0; j--) {
                        var sibling = TypeScript.childAt(parent, j);
                        if (sibling && TypeScript.fullWidth(sibling) > 0) {
                            return sibling;
                        }
                    }
                    // We couldn't find a non-zero-width sibling.  We were either the first element, or
                    // all preceding elements are empty.  So, move up to our parent so we we can find
                    // its preceding sibling.
                    current = current.parent;
                }
            };
            EmptyToken.prototype.fullStart = function () {
                return this.position();
            };
            EmptyToken.prototype.text = function () {
                return "";
            };
            EmptyToken.prototype.fullText = function () {
                return "";
            };
            EmptyToken.prototype.hasLeadingTrivia = function () {
                return false;
            };
            EmptyToken.prototype.hasTrailingTrivia = function () {
                return false;
            };
            EmptyToken.prototype.hasLeadingComment = function () {
                return false;
            };
            EmptyToken.prototype.hasTrailingComment = function () {
                return false;
            };
            EmptyToken.prototype.hasSkippedToken = function () {
                return false;
            };
            EmptyToken.prototype.leadingTriviaWidth = function () {
                return 0;
            };
            EmptyToken.prototype.trailingTriviaWidth = function () {
                return 0;
            };
            EmptyToken.prototype.leadingTrivia = function () {
                return Syntax.emptyTriviaList;
            };
            EmptyToken.prototype.trailingTrivia = function () {
                return Syntax.emptyTriviaList;
            };
            return EmptyToken;
        })();
        var RealizedToken = (function () {
            function RealizedToken(fullStart, kind, isKeywordConvertedToIdentifier, leadingTrivia, text, trailingTrivia) {
                this._fullStart = fullStart;
                this._kind = kind;
                this._isKeywordConvertedToIdentifier = isKeywordConvertedToIdentifier;
                this._text = text;
                this._leadingTrivia = leadingTrivia.clone();
                this._trailingTrivia = trailingTrivia.clone();
                if (!this._leadingTrivia.isShared()) {
                    this._leadingTrivia.parent = this;
                }
                if (!this._trailingTrivia.isShared()) {
                    this._trailingTrivia.parent = this;
                }
            }
            RealizedToken.prototype.setFullStart = function (fullStart) {
                this._fullStart = fullStart;
            };
            RealizedToken.prototype.kind = function () {
                return this._kind;
            };
            RealizedToken.prototype.clone = function () {
                return new RealizedToken(this._fullStart, this.kind(), this._isKeywordConvertedToIdentifier, this._leadingTrivia, this._text, this._trailingTrivia);
            };
            // Realized tokens are created from the parser.  They are *never* incrementally reusable.
            RealizedToken.prototype.isIncrementallyUnusable = function () {
                return true;
            };
            RealizedToken.prototype.isKeywordConvertedToIdentifier = function () {
                return this._isKeywordConvertedToIdentifier;
            };
            RealizedToken.prototype.fullStart = function () {
                return this._fullStart;
            };
            RealizedToken.prototype.fullWidth = function () {
                return this._leadingTrivia.fullWidth() + this._text.length + this._trailingTrivia.fullWidth();
            };
            RealizedToken.prototype.text = function () {
                return this._text;
            };
            RealizedToken.prototype.fullText = function () {
                return this._leadingTrivia.fullText() + this.text() + this._trailingTrivia.fullText();
            };
            RealizedToken.prototype.hasLeadingTrivia = function () {
                return this._leadingTrivia.count() > 0;
            };
            RealizedToken.prototype.hasTrailingTrivia = function () {
                return this._trailingTrivia.count() > 0;
            };
            RealizedToken.prototype.hasLeadingComment = function () {
                return this._leadingTrivia.hasComment();
            };
            RealizedToken.prototype.hasTrailingComment = function () {
                return this._trailingTrivia.hasComment();
            };
            RealizedToken.prototype.leadingTriviaWidth = function () {
                return this._leadingTrivia.fullWidth();
            };
            RealizedToken.prototype.trailingTriviaWidth = function () {
                return this._trailingTrivia.fullWidth();
            };
            RealizedToken.prototype.hasSkippedToken = function () {
                return this._leadingTrivia.hasSkippedToken() || this._trailingTrivia.hasSkippedToken();
            };
            RealizedToken.prototype.leadingTrivia = function () {
                return this._leadingTrivia;
            };
            RealizedToken.prototype.trailingTrivia = function () {
                return this._trailingTrivia;
            };
            return RealizedToken;
        })();
        var ConvertedKeywordToken = (function () {
            function ConvertedKeywordToken(underlyingToken) {
                this.underlyingToken = underlyingToken;
            }
            ConvertedKeywordToken.prototype.kind = function () {
                return 11 /* IdentifierName */;
            };
            ConvertedKeywordToken.prototype.setFullStart = function (fullStart) {
                this.underlyingToken.setFullStart(fullStart);
            };
            ConvertedKeywordToken.prototype.fullStart = function () {
                return this.underlyingToken.fullStart();
            };
            ConvertedKeywordToken.prototype.fullWidth = function () {
                return this.underlyingToken.fullWidth();
            };
            ConvertedKeywordToken.prototype.text = function () {
                return this.underlyingToken.text();
            };
            ConvertedKeywordToken.prototype.syntaxTreeText = function (text) {
                var result = text || TypeScript.syntaxTree(this).text;
                TypeScript.Debug.assert(result);
                return result;
            };
            ConvertedKeywordToken.prototype.fullText = function (text) {
                return this.underlyingToken.fullText(this.syntaxTreeText(text));
            };
            ConvertedKeywordToken.prototype.hasLeadingTrivia = function () {
                return this.underlyingToken.hasLeadingTrivia();
            };
            ConvertedKeywordToken.prototype.hasTrailingTrivia = function () {
                return this.underlyingToken.hasTrailingTrivia();
            };
            ConvertedKeywordToken.prototype.hasLeadingComment = function () {
                return this.underlyingToken.hasLeadingComment();
            };
            ConvertedKeywordToken.prototype.hasTrailingComment = function () {
                return this.underlyingToken.hasTrailingComment();
            };
            ConvertedKeywordToken.prototype.hasSkippedToken = function () {
                return this.underlyingToken.hasSkippedToken();
            };
            ConvertedKeywordToken.prototype.leadingTrivia = function (text) {
                var result = this.underlyingToken.leadingTrivia(this.syntaxTreeText(text));
                result.parent = this;
                return result;
            };
            ConvertedKeywordToken.prototype.trailingTrivia = function (text) {
                var result = this.underlyingToken.trailingTrivia(this.syntaxTreeText(text));
                result.parent = this;
                return result;
            };
            ConvertedKeywordToken.prototype.leadingTriviaWidth = function (text) {
                return this.underlyingToken.leadingTriviaWidth(this.syntaxTreeText(text));
            };
            ConvertedKeywordToken.prototype.trailingTriviaWidth = function (text) {
                return this.underlyingToken.trailingTriviaWidth(this.syntaxTreeText(text));
            };
            ConvertedKeywordToken.prototype.isKeywordConvertedToIdentifier = function () {
                return true;
            };
            ConvertedKeywordToken.prototype.isIncrementallyUnusable = function () {
                // We're incrementally unusable if our underlying token is unusable.
                // For example, we may have: this.public \
                // In this case we will keyword converted to an identifier that is still unusable because
                // it has a trailing skipped token.
                return this.underlyingToken.isIncrementallyUnusable();
            };
            ConvertedKeywordToken.prototype.clone = function () {
                return new ConvertedKeywordToken(this.underlyingToken);
            };
            return ConvertedKeywordToken;
        })();
    })(Syntax = TypeScript.Syntax || (TypeScript.Syntax = {}));
})(TypeScript || (TypeScript = {}));
///<reference path='references.ts' />
var TypeScript;
(function (TypeScript) {
    var Syntax;
    (function (Syntax) {
        var AbstractTrivia = (function () {
            function AbstractTrivia(_kind) {
                this._kind = _kind;
            }
            AbstractTrivia.prototype.kind = function () {
                return this._kind;
            };
            AbstractTrivia.prototype.clone = function () {
                throw TypeScript.Errors.abstract();
            };
            AbstractTrivia.prototype.fullStart = function () {
                throw TypeScript.Errors.abstract();
            };
            AbstractTrivia.prototype.fullWidth = function () {
                throw TypeScript.Errors.abstract();
            };
            AbstractTrivia.prototype.fullText = function () {
                throw TypeScript.Errors.abstract();
            };
            AbstractTrivia.prototype.skippedToken = function () {
                throw TypeScript.Errors.abstract();
            };
            AbstractTrivia.prototype.isWhitespace = function () {
                return this.kind() === 4 /* WhitespaceTrivia */;
            };
            AbstractTrivia.prototype.isComment = function () {
                return this.kind() === 7 /* SingleLineCommentTrivia */ || this.kind() === 6 /* MultiLineCommentTrivia */;
            };
            AbstractTrivia.prototype.isNewLine = function () {
                return this.kind() === 5 /* NewLineTrivia */;
            };
            AbstractTrivia.prototype.isSkippedToken = function () {
                return this.kind() === 8 /* SkippedTokenTrivia */;
            };
            return AbstractTrivia;
        })();
        var SkippedTokenTrivia = (function (_super) {
            __extends(SkippedTokenTrivia, _super);
            function SkippedTokenTrivia(_skippedToken, _fullText) {
                _super.call(this, 8 /* SkippedTokenTrivia */);
                this._skippedToken = _skippedToken;
                this._fullText = _fullText;
                _skippedToken.parent = this;
            }
            SkippedTokenTrivia.prototype.clone = function () {
                return new SkippedTokenTrivia(this._skippedToken.clone(), this._fullText);
            };
            SkippedTokenTrivia.prototype.fullStart = function () {
                return this._skippedToken.fullStart();
            };
            SkippedTokenTrivia.prototype.fullWidth = function () {
                return this.fullText().length;
            };
            SkippedTokenTrivia.prototype.fullText = function () {
                return this._fullText;
            };
            SkippedTokenTrivia.prototype.skippedToken = function () {
                return this._skippedToken;
            };
            return SkippedTokenTrivia;
        })(AbstractTrivia);
        var DeferredTrivia = (function (_super) {
            __extends(DeferredTrivia, _super);
            function DeferredTrivia(kind, _text, _fullStart, _fullWidth) {
                _super.call(this, kind);
                this._text = _text;
                this._fullStart = _fullStart;
                this._fullWidth = _fullWidth;
            }
            DeferredTrivia.prototype.clone = function () {
                return new DeferredTrivia(this.kind(), this._text, this._fullStart, this._fullWidth);
            };
            DeferredTrivia.prototype.fullStart = function () {
                return this._fullStart;
            };
            DeferredTrivia.prototype.fullWidth = function () {
                return this._fullWidth;
            };
            DeferredTrivia.prototype.fullText = function () {
                return this._text.substr(this._fullStart, this._fullWidth);
            };
            DeferredTrivia.prototype.skippedToken = function () {
                throw TypeScript.Errors.invalidOperation();
            };
            return DeferredTrivia;
        })(AbstractTrivia);
        function deferredTrivia(kind, text, fullStart, fullWidth) {
            return new DeferredTrivia(kind, text, fullStart, fullWidth);
        }
        Syntax.deferredTrivia = deferredTrivia;
        function skippedTokenTrivia(token, text) {
            TypeScript.Debug.assert(!token.hasLeadingTrivia());
            TypeScript.Debug.assert(!token.hasTrailingTrivia());
            TypeScript.Debug.assert(token.fullWidth() > 0);
            return new SkippedTokenTrivia(token, token.fullText(text));
        }
        Syntax.skippedTokenTrivia = skippedTokenTrivia;
        // Breaks a multiline trivia up into individual line components.  If the trivia doesn't span
        // any lines, then the result will be a single string with the entire text of the trivia. 
        // Otherwise, there will be one entry in the array for each line spanned by the trivia.  Each
        // entry will contain the line separator at the end of the string.
        function splitMultiLineCommentTriviaIntoMultipleLines(trivia) {
            // Debug.assert(trivia.kind === SyntaxKind.MultiLineCommentTrivia);
            var result = [];
            var triviaText = trivia.fullText();
            var currentIndex = 0;
            for (var i = 0; i < triviaText.length; i++) {
                var ch = triviaText.charCodeAt(i);
                switch (ch) {
                    case 13 /* carriageReturn */:
                        if (i < triviaText.length - 1 && triviaText.charCodeAt(i + 1) === 10 /* lineFeed */) {
                            // Consume the \r
                            i++;
                        }
                    case 10 /* lineFeed */:
                    case 8233 /* paragraphSeparator */:
                    case 8232 /* lineSeparator */:
                        // Eat from the last starting position through to the end of the newline.
                        result.push(triviaText.substring(currentIndex, i + 1));
                        // Set the current index to *after* the newline.
                        currentIndex = i + 1;
                        continue;
                }
            }
            result.push(triviaText.substring(currentIndex));
            return result;
        }
        Syntax.splitMultiLineCommentTriviaIntoMultipleLines = splitMultiLineCommentTriviaIntoMultipleLines;
    })(Syntax = TypeScript.Syntax || (TypeScript.Syntax = {}));
})(TypeScript || (TypeScript = {}));
///<reference path='references.ts' />
var TypeScript;
(function (TypeScript) {
    var Syntax;
    (function (Syntax) {
        var EmptyTriviaList = (function () {
            function EmptyTriviaList() {
            }
            EmptyTriviaList.prototype.kind = function () {
                return 3 /* TriviaList */;
            };
            EmptyTriviaList.prototype.isShared = function () {
                return true;
            };
            EmptyTriviaList.prototype.count = function () {
                return 0;
            };
            EmptyTriviaList.prototype.syntaxTriviaAt = function (index) {
                throw TypeScript.Errors.argumentOutOfRange("index");
            };
            EmptyTriviaList.prototype.last = function () {
                throw TypeScript.Errors.argumentOutOfRange("index");
            };
            EmptyTriviaList.prototype.fullWidth = function () {
                return 0;
            };
            EmptyTriviaList.prototype.fullText = function () {
                return "";
            };
            EmptyTriviaList.prototype.hasComment = function () {
                return false;
            };
            EmptyTriviaList.prototype.hasNewLine = function () {
                return false;
            };
            EmptyTriviaList.prototype.hasSkippedToken = function () {
                return false;
            };
            EmptyTriviaList.prototype.toArray = function () {
                return [];
            };
            EmptyTriviaList.prototype.clone = function () {
                return this;
            };
            return EmptyTriviaList;
        })();
        ;
        Syntax.emptyTriviaList = new EmptyTriviaList();
        function isComment(trivia) {
            return trivia.kind() === 6 /* MultiLineCommentTrivia */ || trivia.kind() === 7 /* SingleLineCommentTrivia */;
        }
        var SingletonSyntaxTriviaList = (function () {
            function SingletonSyntaxTriviaList(item) {
                this.item = item.clone();
                this.item.parent = this;
            }
            SingletonSyntaxTriviaList.prototype.kind = function () {
                return 3 /* TriviaList */;
            };
            SingletonSyntaxTriviaList.prototype.isShared = function () {
                return false;
            };
            SingletonSyntaxTriviaList.prototype.count = function () {
                return 1;
            };
            SingletonSyntaxTriviaList.prototype.syntaxTriviaAt = function (index) {
                if (index !== 0) {
                    throw TypeScript.Errors.argumentOutOfRange("index");
                }
                return this.item;
            };
            SingletonSyntaxTriviaList.prototype.last = function () {
                return this.item;
            };
            SingletonSyntaxTriviaList.prototype.fullWidth = function () {
                return this.item.fullWidth();
            };
            SingletonSyntaxTriviaList.prototype.fullText = function () {
                return this.item.fullText();
            };
            SingletonSyntaxTriviaList.prototype.hasComment = function () {
                return isComment(this.item);
            };
            SingletonSyntaxTriviaList.prototype.hasNewLine = function () {
                return this.item.kind() === 5 /* NewLineTrivia */;
            };
            SingletonSyntaxTriviaList.prototype.hasSkippedToken = function () {
                return this.item.kind() === 8 /* SkippedTokenTrivia */;
            };
            SingletonSyntaxTriviaList.prototype.toArray = function () {
                return [this.item];
            };
            SingletonSyntaxTriviaList.prototype.clone = function () {
                return new SingletonSyntaxTriviaList(this.item.clone());
            };
            return SingletonSyntaxTriviaList;
        })();
        var NormalSyntaxTriviaList = (function () {
            function NormalSyntaxTriviaList(trivia) {
                var _this = this;
                this.trivia = trivia.map(function (t) {
                    var cloned = t.clone();
                    cloned.parent = _this;
                    return cloned;
                });
            }
            NormalSyntaxTriviaList.prototype.kind = function () {
                return 3 /* TriviaList */;
            };
            NormalSyntaxTriviaList.prototype.isShared = function () {
                return false;
            };
            NormalSyntaxTriviaList.prototype.count = function () {
                return this.trivia.length;
            };
            NormalSyntaxTriviaList.prototype.syntaxTriviaAt = function (index) {
                if (index < 0 || index >= this.trivia.length) {
                    throw TypeScript.Errors.argumentOutOfRange("index");
                }
                return this.trivia[index];
            };
            NormalSyntaxTriviaList.prototype.last = function () {
                return this.trivia[this.trivia.length - 1];
            };
            NormalSyntaxTriviaList.prototype.fullWidth = function () {
                return TypeScript.ArrayUtilities.sum(this.trivia, function (t) { return t.fullWidth(); });
            };
            NormalSyntaxTriviaList.prototype.fullText = function () {
                var result = [];
                for (var i = 0, n = this.trivia.length; i < n; i++) {
                    result.push(this.trivia[i].fullText());
                }
                return result.join("");
            };
            NormalSyntaxTriviaList.prototype.hasComment = function () {
                for (var i = 0; i < this.trivia.length; i++) {
                    if (isComment(this.trivia[i])) {
                        return true;
                    }
                }
                return false;
            };
            NormalSyntaxTriviaList.prototype.hasNewLine = function () {
                for (var i = 0; i < this.trivia.length; i++) {
                    if (this.trivia[i].kind() === 5 /* NewLineTrivia */) {
                        return true;
                    }
                }
                return false;
            };
            NormalSyntaxTriviaList.prototype.hasSkippedToken = function () {
                for (var i = 0; i < this.trivia.length; i++) {
                    if (this.trivia[i].kind() === 8 /* SkippedTokenTrivia */) {
                        return true;
                    }
                }
                return false;
            };
            NormalSyntaxTriviaList.prototype.toArray = function () {
                return this.trivia.slice(0);
            };
            NormalSyntaxTriviaList.prototype.clone = function () {
                return new NormalSyntaxTriviaList(this.trivia.map(function (t) { return t.clone(); }));
            };
            return NormalSyntaxTriviaList;
        })();
        function triviaList(trivia) {
            if (trivia === undefined || trivia === null || trivia.length === 0) {
                return Syntax.emptyTriviaList;
            }
            if (trivia.length === 1) {
                return new SingletonSyntaxTriviaList(trivia[0]);
            }
            return new NormalSyntaxTriviaList(trivia);
        }
        Syntax.triviaList = triviaList;
    })(Syntax = TypeScript.Syntax || (TypeScript.Syntax = {}));
})(TypeScript || (TypeScript = {}));
///<reference path='references.ts' />
var TypeScript;
(function (TypeScript) {
    var SyntaxUtilities = (function () {
        function SyntaxUtilities() {
        }
        SyntaxUtilities.isAnyFunctionExpressionOrDeclaration = function (ast) {
            switch (ast.kind()) {
                case 220 /* SimpleArrowFunctionExpression */:
                case 219 /* ParenthesizedArrowFunctionExpression */:
                case 223 /* FunctionExpression */:
                case 130 /* FunctionDeclaration */:
                case 136 /* MemberFunctionDeclaration */:
                case 242 /* FunctionPropertyAssignment */:
                case 138 /* ConstructorDeclaration */:
                case 140 /* GetAccessor */:
                case 141 /* SetAccessor */:
                    return true;
            }
            return false;
        };
        SyntaxUtilities.isLastTokenOnLine = function (token, text) {
            var _nextToken = TypeScript.nextToken(token, text);
            if (_nextToken === null) {
                return true;
            }
            var lineMap = text.lineMap();
            var tokenLine = lineMap.getLineNumberFromPosition(TypeScript.end(token, text));
            var nextTokenLine = lineMap.getLineNumberFromPosition(TypeScript.start(_nextToken, text));
            return tokenLine !== nextTokenLine;
        };
        SyntaxUtilities.isLeftHandSizeExpression = function (element) {
            if (element) {
                switch (element.kind()) {
                    case 213 /* MemberAccessExpression */:
                    case 222 /* ElementAccessExpression */:
                    case 217 /* ObjectCreationExpression */:
                    case 214 /* InvocationExpression */:
                    case 215 /* ArrayLiteralExpression */:
                    case 218 /* ParenthesizedExpression */:
                    case 216 /* ObjectLiteralExpression */:
                    case 223 /* FunctionExpression */:
                    case 11 /* IdentifierName */:
                    case 12 /* RegularExpressionLiteral */:
                    case 13 /* NumericLiteral */:
                    case 14 /* StringLiteral */:
                    case 24 /* FalseKeyword */:
                    case 32 /* NullKeyword */:
                    case 35 /* ThisKeyword */:
                    case 37 /* TrueKeyword */:
                    case 50 /* SuperKeyword */:
                        return true;
                }
            }
            return false;
        };
        SyntaxUtilities.isExpression = function (element) {
            if (element) {
                switch (element.kind()) {
                    case 11 /* IdentifierName */:
                    case 12 /* RegularExpressionLiteral */:
                    case 13 /* NumericLiteral */:
                    case 14 /* StringLiteral */:
                    case 24 /* FalseKeyword */:
                    case 32 /* NullKeyword */:
                    case 35 /* ThisKeyword */:
                    case 37 /* TrueKeyword */:
                    case 50 /* SuperKeyword */:
                    case 165 /* PlusExpression */:
                    case 166 /* NegateExpression */:
                    case 167 /* BitwiseNotExpression */:
                    case 168 /* LogicalNotExpression */:
                    case 169 /* PreIncrementExpression */:
                    case 170 /* PreDecrementExpression */:
                    case 171 /* DeleteExpression */:
                    case 172 /* TypeOfExpression */:
                    case 173 /* VoidExpression */:
                    case 174 /* CommaExpression */:
                    case 175 /* AssignmentExpression */:
                    case 176 /* AddAssignmentExpression */:
                    case 177 /* SubtractAssignmentExpression */:
                    case 178 /* MultiplyAssignmentExpression */:
                    case 179 /* DivideAssignmentExpression */:
                    case 180 /* ModuloAssignmentExpression */:
                    case 181 /* AndAssignmentExpression */:
                    case 182 /* ExclusiveOrAssignmentExpression */:
                    case 183 /* OrAssignmentExpression */:
                    case 184 /* LeftShiftAssignmentExpression */:
                    case 185 /* SignedRightShiftAssignmentExpression */:
                    case 186 /* UnsignedRightShiftAssignmentExpression */:
                    case 187 /* ConditionalExpression */:
                    case 188 /* LogicalOrExpression */:
                    case 189 /* LogicalAndExpression */:
                    case 190 /* BitwiseOrExpression */:
                    case 191 /* BitwiseExclusiveOrExpression */:
                    case 192 /* BitwiseAndExpression */:
                    case 193 /* EqualsWithTypeConversionExpression */:
                    case 194 /* NotEqualsWithTypeConversionExpression */:
                    case 195 /* EqualsExpression */:
                    case 196 /* NotEqualsExpression */:
                    case 197 /* LessThanExpression */:
                    case 198 /* GreaterThanExpression */:
                    case 199 /* LessThanOrEqualExpression */:
                    case 200 /* GreaterThanOrEqualExpression */:
                    case 201 /* InstanceOfExpression */:
                    case 202 /* InExpression */:
                    case 203 /* LeftShiftExpression */:
                    case 204 /* SignedRightShiftExpression */:
                    case 205 /* UnsignedRightShiftExpression */:
                    case 206 /* MultiplyExpression */:
                    case 207 /* DivideExpression */:
                    case 208 /* ModuloExpression */:
                    case 209 /* AddExpression */:
                    case 210 /* SubtractExpression */:
                    case 211 /* PostIncrementExpression */:
                    case 212 /* PostDecrementExpression */:
                    case 213 /* MemberAccessExpression */:
                    case 214 /* InvocationExpression */:
                    case 215 /* ArrayLiteralExpression */:
                    case 216 /* ObjectLiteralExpression */:
                    case 217 /* ObjectCreationExpression */:
                    case 218 /* ParenthesizedExpression */:
                    case 219 /* ParenthesizedArrowFunctionExpression */:
                    case 220 /* SimpleArrowFunctionExpression */:
                    case 221 /* CastExpression */:
                    case 222 /* ElementAccessExpression */:
                    case 223 /* FunctionExpression */:
                    case 224 /* OmittedExpression */:
                        return true;
                }
            }
            return false;
        };
        SyntaxUtilities.isSwitchClause = function (element) {
            if (element) {
                switch (element.kind()) {
                    case 234 /* CaseSwitchClause */:
                    case 235 /* DefaultSwitchClause */:
                        return true;
                }
            }
            return false;
        };
        SyntaxUtilities.isTypeMember = function (element) {
            if (element) {
                switch (element.kind()) {
                    case 144 /* ConstructSignature */:
                    case 146 /* MethodSignature */:
                    case 145 /* IndexSignature */:
                    case 142 /* PropertySignature */:
                    case 143 /* CallSignature */:
                        return true;
                }
            }
            return false;
        };
        SyntaxUtilities.isClassElement = function (element) {
            if (element) {
                switch (element.kind()) {
                    case 138 /* ConstructorDeclaration */:
                    case 139 /* IndexMemberDeclaration */:
                    case 136 /* MemberFunctionDeclaration */:
                    case 140 /* GetAccessor */:
                    case 141 /* SetAccessor */:
                    case 136 /* MemberFunctionDeclaration */:
                    case 137 /* MemberVariableDeclaration */:
                        return true;
                }
            }
            return false;
        };
        SyntaxUtilities.isModuleElement = function (element) {
            if (element) {
                switch (element.kind()) {
                    case 134 /* ImportDeclaration */:
                    case 135 /* ExportAssignment */:
                    case 132 /* ClassDeclaration */:
                    case 129 /* InterfaceDeclaration */:
                    case 131 /* ModuleDeclaration */:
                    case 133 /* EnumDeclaration */:
                    case 130 /* FunctionDeclaration */:
                    case 149 /* VariableStatement */:
                    case 147 /* Block */:
                    case 148 /* IfStatement */:
                    case 150 /* ExpressionStatement */:
                    case 158 /* ThrowStatement */:
                    case 151 /* ReturnStatement */:
                    case 152 /* SwitchStatement */:
                    case 153 /* BreakStatement */:
                    case 154 /* ContinueStatement */:
                    case 156 /* ForInStatement */:
                    case 155 /* ForStatement */:
                    case 159 /* WhileStatement */:
                    case 164 /* WithStatement */:
                    case 157 /* EmptyStatement */:
                    case 160 /* TryStatement */:
                    case 161 /* LabeledStatement */:
                    case 162 /* DoStatement */:
                    case 163 /* DebuggerStatement */:
                        return true;
                }
            }
            return false;
        };
        SyntaxUtilities.isStatement = function (element) {
            if (element) {
                switch (element.kind()) {
                    case 130 /* FunctionDeclaration */:
                    case 149 /* VariableStatement */:
                    case 147 /* Block */:
                    case 148 /* IfStatement */:
                    case 150 /* ExpressionStatement */:
                    case 158 /* ThrowStatement */:
                    case 151 /* ReturnStatement */:
                    case 152 /* SwitchStatement */:
                    case 153 /* BreakStatement */:
                    case 154 /* ContinueStatement */:
                    case 156 /* ForInStatement */:
                    case 155 /* ForStatement */:
                    case 159 /* WhileStatement */:
                    case 164 /* WithStatement */:
                    case 157 /* EmptyStatement */:
                    case 160 /* TryStatement */:
                    case 161 /* LabeledStatement */:
                    case 162 /* DoStatement */:
                    case 163 /* DebuggerStatement */:
                        return true;
                }
            }
            return false;
        };
        SyntaxUtilities.isAngleBracket = function (positionedElement) {
            var element = positionedElement;
            var parent = positionedElement.parent;
            if (parent !== null && (element.kind() === 80 /* LessThanToken */ || element.kind() === 81 /* GreaterThanToken */)) {
                switch (parent.kind()) {
                    case 229 /* TypeArgumentList */:
                    case 230 /* TypeParameterList */:
                    case 221 /* CastExpression */:
                        return true;
                }
            }
            return false;
        };
        SyntaxUtilities.getToken = function (list, kind) {
            for (var i = 0, n = list.length; i < n; i++) {
                var token = list[i];
                if (token.kind() === kind) {
                    return token;
                }
            }
            return null;
        };
        SyntaxUtilities.containsToken = function (list, kind) {
            return SyntaxUtilities.getToken(list, kind) !== null;
        };
        SyntaxUtilities.hasExportKeyword = function (moduleElement) {
            return SyntaxUtilities.getExportKeyword(moduleElement) !== null;
        };
        SyntaxUtilities.getExportKeyword = function (moduleElement) {
            switch (moduleElement.kind()) {
                case 131 /* ModuleDeclaration */:
                case 132 /* ClassDeclaration */:
                case 130 /* FunctionDeclaration */:
                case 149 /* VariableStatement */:
                case 133 /* EnumDeclaration */:
                case 129 /* InterfaceDeclaration */:
                case 134 /* ImportDeclaration */:
                    return SyntaxUtilities.getToken(moduleElement.modifiers, 47 /* ExportKeyword */);
                default:
                    return null;
            }
        };
        SyntaxUtilities.isAmbientDeclarationSyntax = function (positionNode) {
            if (!positionNode) {
                return false;
            }
            var node = positionNode;
            switch (node.kind()) {
                case 131 /* ModuleDeclaration */:
                case 132 /* ClassDeclaration */:
                case 130 /* FunctionDeclaration */:
                case 149 /* VariableStatement */:
                case 133 /* EnumDeclaration */:
                    if (SyntaxUtilities.containsToken(node.modifiers, 63 /* DeclareKeyword */)) {
                        return true;
                    }
                case 134 /* ImportDeclaration */:
                case 138 /* ConstructorDeclaration */:
                case 136 /* MemberFunctionDeclaration */:
                case 140 /* GetAccessor */:
                case 141 /* SetAccessor */:
                case 137 /* MemberVariableDeclaration */:
                    if (SyntaxUtilities.isClassElement(node) || SyntaxUtilities.isModuleElement(node)) {
                        return SyntaxUtilities.isAmbientDeclarationSyntax(TypeScript.Syntax.containingNode(positionNode));
                    }
                case 244 /* EnumElement */:
                    return SyntaxUtilities.isAmbientDeclarationSyntax(TypeScript.Syntax.containingNode(TypeScript.Syntax.containingNode(positionNode)));
                default:
                    return SyntaxUtilities.isAmbientDeclarationSyntax(TypeScript.Syntax.containingNode(positionNode));
            }
        };
        return SyntaxUtilities;
    })();
    TypeScript.SyntaxUtilities = SyntaxUtilities;
})(TypeScript || (TypeScript = {}));
///<reference path='references.ts' />
var TypeScript;
(function (TypeScript) {
    function visitNodeOrToken(visitor, element) {
        if (element === null) {
            return null;
        }
        if (TypeScript.isToken(element)) {
            return visitor.visitToken(element);
        }
        switch (element.kind()) {
            case 120 /* SourceUnit */:
                return visitor.visitSourceUnit(element);
            case 121 /* QualifiedName */:
                return visitor.visitQualifiedName(element);
            case 122 /* ObjectType */:
                return visitor.visitObjectType(element);
            case 123 /* FunctionType */:
                return visitor.visitFunctionType(element);
            case 124 /* ArrayType */:
                return visitor.visitArrayType(element);
            case 125 /* ConstructorType */:
                return visitor.visitConstructorType(element);
            case 126 /* GenericType */:
                return visitor.visitGenericType(element);
            case 127 /* TypeQuery */:
                return visitor.visitTypeQuery(element);
            case 128 /* TupleType */:
                return visitor.visitTupleType(element);
            case 129 /* InterfaceDeclaration */:
                return visitor.visitInterfaceDeclaration(element);
            case 130 /* FunctionDeclaration */:
                return visitor.visitFunctionDeclaration(element);
            case 131 /* ModuleDeclaration */:
                return visitor.visitModuleDeclaration(element);
            case 132 /* ClassDeclaration */:
                return visitor.visitClassDeclaration(element);
            case 133 /* EnumDeclaration */:
                return visitor.visitEnumDeclaration(element);
            case 134 /* ImportDeclaration */:
                return visitor.visitImportDeclaration(element);
            case 135 /* ExportAssignment */:
                return visitor.visitExportAssignment(element);
            case 136 /* MemberFunctionDeclaration */:
                return visitor.visitMemberFunctionDeclaration(element);
            case 137 /* MemberVariableDeclaration */:
                return visitor.visitMemberVariableDeclaration(element);
            case 138 /* ConstructorDeclaration */:
                return visitor.visitConstructorDeclaration(element);
            case 139 /* IndexMemberDeclaration */:
                return visitor.visitIndexMemberDeclaration(element);
            case 140 /* GetAccessor */:
                return visitor.visitGetAccessor(element);
            case 141 /* SetAccessor */:
                return visitor.visitSetAccessor(element);
            case 142 /* PropertySignature */:
                return visitor.visitPropertySignature(element);
            case 143 /* CallSignature */:
                return visitor.visitCallSignature(element);
            case 144 /* ConstructSignature */:
                return visitor.visitConstructSignature(element);
            case 145 /* IndexSignature */:
                return visitor.visitIndexSignature(element);
            case 146 /* MethodSignature */:
                return visitor.visitMethodSignature(element);
            case 147 /* Block */:
                return visitor.visitBlock(element);
            case 148 /* IfStatement */:
                return visitor.visitIfStatement(element);
            case 149 /* VariableStatement */:
                return visitor.visitVariableStatement(element);
            case 150 /* ExpressionStatement */:
                return visitor.visitExpressionStatement(element);
            case 151 /* ReturnStatement */:
                return visitor.visitReturnStatement(element);
            case 152 /* SwitchStatement */:
                return visitor.visitSwitchStatement(element);
            case 153 /* BreakStatement */:
                return visitor.visitBreakStatement(element);
            case 154 /* ContinueStatement */:
                return visitor.visitContinueStatement(element);
            case 155 /* ForStatement */:
                return visitor.visitForStatement(element);
            case 156 /* ForInStatement */:
                return visitor.visitForInStatement(element);
            case 157 /* EmptyStatement */:
                return visitor.visitEmptyStatement(element);
            case 158 /* ThrowStatement */:
                return visitor.visitThrowStatement(element);
            case 159 /* WhileStatement */:
                return visitor.visitWhileStatement(element);
            case 160 /* TryStatement */:
                return visitor.visitTryStatement(element);
            case 161 /* LabeledStatement */:
                return visitor.visitLabeledStatement(element);
            case 162 /* DoStatement */:
                return visitor.visitDoStatement(element);
            case 163 /* DebuggerStatement */:
                return visitor.visitDebuggerStatement(element);
            case 164 /* WithStatement */:
                return visitor.visitWithStatement(element);
            case 169 /* PreIncrementExpression */:
            case 170 /* PreDecrementExpression */:
            case 165 /* PlusExpression */:
            case 166 /* NegateExpression */:
            case 167 /* BitwiseNotExpression */:
            case 168 /* LogicalNotExpression */:
                return visitor.visitPrefixUnaryExpression(element);
            case 171 /* DeleteExpression */:
                return visitor.visitDeleteExpression(element);
            case 172 /* TypeOfExpression */:
                return visitor.visitTypeOfExpression(element);
            case 173 /* VoidExpression */:
                return visitor.visitVoidExpression(element);
            case 187 /* ConditionalExpression */:
                return visitor.visitConditionalExpression(element);
            case 206 /* MultiplyExpression */:
            case 207 /* DivideExpression */:
            case 208 /* ModuloExpression */:
            case 209 /* AddExpression */:
            case 210 /* SubtractExpression */:
            case 203 /* LeftShiftExpression */:
            case 204 /* SignedRightShiftExpression */:
            case 205 /* UnsignedRightShiftExpression */:
            case 197 /* LessThanExpression */:
            case 198 /* GreaterThanExpression */:
            case 199 /* LessThanOrEqualExpression */:
            case 200 /* GreaterThanOrEqualExpression */:
            case 201 /* InstanceOfExpression */:
            case 202 /* InExpression */:
            case 193 /* EqualsWithTypeConversionExpression */:
            case 194 /* NotEqualsWithTypeConversionExpression */:
            case 195 /* EqualsExpression */:
            case 196 /* NotEqualsExpression */:
            case 192 /* BitwiseAndExpression */:
            case 191 /* BitwiseExclusiveOrExpression */:
            case 190 /* BitwiseOrExpression */:
            case 189 /* LogicalAndExpression */:
            case 188 /* LogicalOrExpression */:
            case 183 /* OrAssignmentExpression */:
            case 181 /* AndAssignmentExpression */:
            case 182 /* ExclusiveOrAssignmentExpression */:
            case 184 /* LeftShiftAssignmentExpression */:
            case 185 /* SignedRightShiftAssignmentExpression */:
            case 186 /* UnsignedRightShiftAssignmentExpression */:
            case 176 /* AddAssignmentExpression */:
            case 177 /* SubtractAssignmentExpression */:
            case 178 /* MultiplyAssignmentExpression */:
            case 179 /* DivideAssignmentExpression */:
            case 180 /* ModuloAssignmentExpression */:
            case 175 /* AssignmentExpression */:
            case 174 /* CommaExpression */:
                return visitor.visitBinaryExpression(element);
            case 211 /* PostIncrementExpression */:
            case 212 /* PostDecrementExpression */:
                return visitor.visitPostfixUnaryExpression(element);
            case 213 /* MemberAccessExpression */:
                return visitor.visitMemberAccessExpression(element);
            case 214 /* InvocationExpression */:
                return visitor.visitInvocationExpression(element);
            case 215 /* ArrayLiteralExpression */:
                return visitor.visitArrayLiteralExpression(element);
            case 216 /* ObjectLiteralExpression */:
                return visitor.visitObjectLiteralExpression(element);
            case 217 /* ObjectCreationExpression */:
                return visitor.visitObjectCreationExpression(element);
            case 218 /* ParenthesizedExpression */:
                return visitor.visitParenthesizedExpression(element);
            case 219 /* ParenthesizedArrowFunctionExpression */:
                return visitor.visitParenthesizedArrowFunctionExpression(element);
            case 220 /* SimpleArrowFunctionExpression */:
                return visitor.visitSimpleArrowFunctionExpression(element);
            case 221 /* CastExpression */:
                return visitor.visitCastExpression(element);
            case 222 /* ElementAccessExpression */:
                return visitor.visitElementAccessExpression(element);
            case 223 /* FunctionExpression */:
                return visitor.visitFunctionExpression(element);
            case 224 /* OmittedExpression */:
                return visitor.visitOmittedExpression(element);
            case 225 /* VariableDeclaration */:
                return visitor.visitVariableDeclaration(element);
            case 226 /* VariableDeclarator */:
                return visitor.visitVariableDeclarator(element);
            case 227 /* ArgumentList */:
                return visitor.visitArgumentList(element);
            case 228 /* ParameterList */:
                return visitor.visitParameterList(element);
            case 229 /* TypeArgumentList */:
                return visitor.visitTypeArgumentList(element);
            case 230 /* TypeParameterList */:
                return visitor.visitTypeParameterList(element);
            case 231 /* ExtendsHeritageClause */:
            case 232 /* ImplementsHeritageClause */:
                return visitor.visitHeritageClause(element);
            case 233 /* EqualsValueClause */:
                return visitor.visitEqualsValueClause(element);
            case 234 /* CaseSwitchClause */:
                return visitor.visitCaseSwitchClause(element);
            case 235 /* DefaultSwitchClause */:
                return visitor.visitDefaultSwitchClause(element);
            case 236 /* ElseClause */:
                return visitor.visitElseClause(element);
            case 237 /* CatchClause */:
                return visitor.visitCatchClause(element);
            case 238 /* FinallyClause */:
                return visitor.visitFinallyClause(element);
            case 239 /* TypeParameter */:
                return visitor.visitTypeParameter(element);
            case 240 /* Constraint */:
                return visitor.visitConstraint(element);
            case 241 /* SimplePropertyAssignment */:
                return visitor.visitSimplePropertyAssignment(element);
            case 242 /* FunctionPropertyAssignment */:
                return visitor.visitFunctionPropertyAssignment(element);
            case 243 /* Parameter */:
                return visitor.visitParameter(element);
            case 244 /* EnumElement */:
                return visitor.visitEnumElement(element);
            case 245 /* TypeAnnotation */:
                return visitor.visitTypeAnnotation(element);
            case 246 /* ExternalModuleReference */:
                return visitor.visitExternalModuleReference(element);
            case 247 /* ModuleNameModuleReference */:
                return visitor.visitModuleNameModuleReference(element);
        }
        throw TypeScript.Errors.invalidOperation();
    }
    TypeScript.visitNodeOrToken = visitNodeOrToken;
})(TypeScript || (TypeScript = {}));
///<reference path='references.ts' />
var TypeScript;
(function (TypeScript) {
    var SyntaxWalker = (function () {
        function SyntaxWalker() {
        }
        SyntaxWalker.prototype.visitToken = function (token) {
        };
        SyntaxWalker.prototype.visitNode = function (node) {
            TypeScript.visitNodeOrToken(this, node);
        };
        SyntaxWalker.prototype.visitNodeOrToken = function (nodeOrToken) {
            if (TypeScript.isToken(nodeOrToken)) {
                this.visitToken(nodeOrToken);
            }
            else {
                this.visitNode(nodeOrToken);
            }
        };
        SyntaxWalker.prototype.visitOptionalToken = function (token) {
            if (token === null) {
                return;
            }
            this.visitToken(token);
        };
        SyntaxWalker.prototype.visitOptionalNode = function (node) {
            if (node === null) {
                return;
            }
            this.visitNode(node);
        };
        SyntaxWalker.prototype.visitOptionalNodeOrToken = function (nodeOrToken) {
            if (nodeOrToken === null) {
                return;
            }
            this.visitNodeOrToken(nodeOrToken);
        };
        SyntaxWalker.prototype.visitList = function (list) {
            for (var i = 0, n = list.length; i < n; i++) {
                this.visitNodeOrToken(list[i]);
            }
        };
        SyntaxWalker.prototype.visitSeparatedList = function (list) {
            for (var i = 0, n = TypeScript.childCount(list); i < n; i++) {
                var item = TypeScript.childAt(list, i);
                this.visitNodeOrToken(item);
            }
        };
        SyntaxWalker.prototype.visitSourceUnit = function (node) {
            this.visitList(node.moduleElements);
            this.visitToken(node.endOfFileToken);
        };
        SyntaxWalker.prototype.visitQualifiedName = function (node) {
            this.visitNodeOrToken(node.left);
            this.visitToken(node.dotToken);
            this.visitToken(node.right);
        };
        SyntaxWalker.prototype.visitObjectType = function (node) {
            this.visitToken(node.openBraceToken);
            this.visitSeparatedList(node.typeMembers);
            this.visitToken(node.closeBraceToken);
        };
        SyntaxWalker.prototype.visitFunctionType = function (node) {
            this.visitOptionalNode(node.typeParameterList);
            this.visitNode(node.parameterList);
            this.visitToken(node.equalsGreaterThanToken);
            this.visitNodeOrToken(node.type);
        };
        SyntaxWalker.prototype.visitArrayType = function (node) {
            this.visitNodeOrToken(node.type);
            this.visitToken(node.openBracketToken);
            this.visitToken(node.closeBracketToken);
        };
        SyntaxWalker.prototype.visitConstructorType = function (node) {
            this.visitToken(node.newKeyword);
            this.visitOptionalNode(node.typeParameterList);
            this.visitNode(node.parameterList);
            this.visitToken(node.equalsGreaterThanToken);
            this.visitNodeOrToken(node.type);
        };
        SyntaxWalker.prototype.visitGenericType = function (node) {
            this.visitNodeOrToken(node.name);
            this.visitNode(node.typeArgumentList);
        };
        SyntaxWalker.prototype.visitTypeQuery = function (node) {
            this.visitToken(node.typeOfKeyword);
            this.visitNodeOrToken(node.name);
        };
        SyntaxWalker.prototype.visitTupleType = function (node) {
            this.visitToken(node.openBracketToken);
            this.visitSeparatedList(node.types);
            this.visitToken(node.closeBracketToken);
        };
        SyntaxWalker.prototype.visitInterfaceDeclaration = function (node) {
            this.visitList(node.modifiers);
            this.visitToken(node.interfaceKeyword);
            this.visitToken(node.identifier);
            this.visitOptionalNode(node.typeParameterList);
            this.visitList(node.heritageClauses);
            this.visitNode(node.body);
        };
        SyntaxWalker.prototype.visitFunctionDeclaration = function (node) {
            this.visitList(node.modifiers);
            this.visitToken(node.functionKeyword);
            this.visitToken(node.identifier);
            this.visitNode(node.callSignature);
            this.visitOptionalNode(node.block);
            this.visitOptionalToken(node.semicolonToken);
        };
        SyntaxWalker.prototype.visitModuleDeclaration = function (node) {
            this.visitList(node.modifiers);
            this.visitToken(node.moduleKeyword);
            this.visitOptionalNodeOrToken(node.name);
            this.visitOptionalToken(node.stringLiteral);
            this.visitToken(node.openBraceToken);
            this.visitList(node.moduleElements);
            this.visitToken(node.closeBraceToken);
        };
        SyntaxWalker.prototype.visitClassDeclaration = function (node) {
            this.visitList(node.modifiers);
            this.visitToken(node.classKeyword);
            this.visitToken(node.identifier);
            this.visitOptionalNode(node.typeParameterList);
            this.visitList(node.heritageClauses);
            this.visitToken(node.openBraceToken);
            this.visitList(node.classElements);
            this.visitToken(node.closeBraceToken);
        };
        SyntaxWalker.prototype.visitEnumDeclaration = function (node) {
            this.visitList(node.modifiers);
            this.visitToken(node.enumKeyword);
            this.visitToken(node.identifier);
            this.visitToken(node.openBraceToken);
            this.visitSeparatedList(node.enumElements);
            this.visitToken(node.closeBraceToken);
        };
        SyntaxWalker.prototype.visitImportDeclaration = function (node) {
            this.visitList(node.modifiers);
            this.visitToken(node.importKeyword);
            this.visitToken(node.identifier);
            this.visitToken(node.equalsToken);
            this.visitNodeOrToken(node.moduleReference);
            this.visitOptionalToken(node.semicolonToken);
        };
        SyntaxWalker.prototype.visitExportAssignment = function (node) {
            this.visitToken(node.exportKeyword);
            this.visitToken(node.equalsToken);
            this.visitToken(node.identifier);
            this.visitOptionalToken(node.semicolonToken);
        };
        SyntaxWalker.prototype.visitMemberFunctionDeclaration = function (node) {
            this.visitList(node.modifiers);
            this.visitToken(node.propertyName);
            this.visitNode(node.callSignature);
            this.visitOptionalNode(node.block);
            this.visitOptionalToken(node.semicolonToken);
        };
        SyntaxWalker.prototype.visitMemberVariableDeclaration = function (node) {
            this.visitList(node.modifiers);
            this.visitNode(node.variableDeclarator);
            this.visitOptionalToken(node.semicolonToken);
        };
        SyntaxWalker.prototype.visitConstructorDeclaration = function (node) {
            this.visitList(node.modifiers);
            this.visitToken(node.constructorKeyword);
            this.visitNode(node.callSignature);
            this.visitOptionalNode(node.block);
            this.visitOptionalToken(node.semicolonToken);
        };
        SyntaxWalker.prototype.visitIndexMemberDeclaration = function (node) {
            this.visitList(node.modifiers);
            this.visitNode(node.indexSignature);
            this.visitOptionalToken(node.semicolonToken);
        };
        SyntaxWalker.prototype.visitGetAccessor = function (node) {
            this.visitList(node.modifiers);
            this.visitToken(node.getKeyword);
            this.visitToken(node.propertyName);
            this.visitNode(node.callSignature);
            this.visitNode(node.block);
        };
        SyntaxWalker.prototype.visitSetAccessor = function (node) {
            this.visitList(node.modifiers);
            this.visitToken(node.setKeyword);
            this.visitToken(node.propertyName);
            this.visitNode(node.callSignature);
            this.visitNode(node.block);
        };
        SyntaxWalker.prototype.visitPropertySignature = function (node) {
            this.visitToken(node.propertyName);
            this.visitOptionalToken(node.questionToken);
            this.visitOptionalNode(node.typeAnnotation);
        };
        SyntaxWalker.prototype.visitCallSignature = function (node) {
            this.visitOptionalNode(node.typeParameterList);
            this.visitNode(node.parameterList);
            this.visitOptionalNode(node.typeAnnotation);
        };
        SyntaxWalker.prototype.visitConstructSignature = function (node) {
            this.visitToken(node.newKeyword);
            this.visitNode(node.callSignature);
        };
        SyntaxWalker.prototype.visitIndexSignature = function (node) {
            this.visitToken(node.openBracketToken);
            this.visitSeparatedList(node.parameters);
            this.visitToken(node.closeBracketToken);
            this.visitOptionalNode(node.typeAnnotation);
        };
        SyntaxWalker.prototype.visitMethodSignature = function (node) {
            this.visitToken(node.propertyName);
            this.visitOptionalToken(node.questionToken);
            this.visitNode(node.callSignature);
        };
        SyntaxWalker.prototype.visitBlock = function (node) {
            this.visitToken(node.openBraceToken);
            this.visitList(node.statements);
            this.visitToken(node.closeBraceToken);
        };
        SyntaxWalker.prototype.visitIfStatement = function (node) {
            this.visitToken(node.ifKeyword);
            this.visitToken(node.openParenToken);
            this.visitNodeOrToken(node.condition);
            this.visitToken(node.closeParenToken);
            this.visitNodeOrToken(node.statement);
            this.visitOptionalNode(node.elseClause);
        };
        SyntaxWalker.prototype.visitVariableStatement = function (node) {
            this.visitList(node.modifiers);
            this.visitNode(node.variableDeclaration);
            this.visitOptionalToken(node.semicolonToken);
        };
        SyntaxWalker.prototype.visitExpressionStatement = function (node) {
            this.visitNodeOrToken(node.expression);
            this.visitOptionalToken(node.semicolonToken);
        };
        SyntaxWalker.prototype.visitReturnStatement = function (node) {
            this.visitToken(node.returnKeyword);
            this.visitOptionalNodeOrToken(node.expression);
            this.visitOptionalToken(node.semicolonToken);
        };
        SyntaxWalker.prototype.visitSwitchStatement = function (node) {
            this.visitToken(node.switchKeyword);
            this.visitToken(node.openParenToken);
            this.visitNodeOrToken(node.expression);
            this.visitToken(node.closeParenToken);
            this.visitToken(node.openBraceToken);
            this.visitList(node.switchClauses);
            this.visitToken(node.closeBraceToken);
        };
        SyntaxWalker.prototype.visitBreakStatement = function (node) {
            this.visitToken(node.breakKeyword);
            this.visitOptionalToken(node.identifier);
            this.visitOptionalToken(node.semicolonToken);
        };
        SyntaxWalker.prototype.visitContinueStatement = function (node) {
            this.visitToken(node.continueKeyword);
            this.visitOptionalToken(node.identifier);
            this.visitOptionalToken(node.semicolonToken);
        };
        SyntaxWalker.prototype.visitForStatement = function (node) {
            this.visitToken(node.forKeyword);
            this.visitToken(node.openParenToken);
            this.visitOptionalNode(node.variableDeclaration);
            this.visitOptionalNodeOrToken(node.initializer);
            this.visitToken(node.firstSemicolonToken);
            this.visitOptionalNodeOrToken(node.condition);
            this.visitToken(node.secondSemicolonToken);
            this.visitOptionalNodeOrToken(node.incrementor);
            this.visitToken(node.closeParenToken);
            this.visitNodeOrToken(node.statement);
        };
        SyntaxWalker.prototype.visitForInStatement = function (node) {
            this.visitToken(node.forKeyword);
            this.visitToken(node.openParenToken);
            this.visitOptionalNode(node.variableDeclaration);
            this.visitOptionalNodeOrToken(node.left);
            this.visitToken(node.inKeyword);
            this.visitNodeOrToken(node.expression);
            this.visitToken(node.closeParenToken);
            this.visitNodeOrToken(node.statement);
        };
        SyntaxWalker.prototype.visitEmptyStatement = function (node) {
            this.visitToken(node.semicolonToken);
        };
        SyntaxWalker.prototype.visitThrowStatement = function (node) {
            this.visitToken(node.throwKeyword);
            this.visitNodeOrToken(node.expression);
            this.visitOptionalToken(node.semicolonToken);
        };
        SyntaxWalker.prototype.visitWhileStatement = function (node) {
            this.visitToken(node.whileKeyword);
            this.visitToken(node.openParenToken);
            this.visitNodeOrToken(node.condition);
            this.visitToken(node.closeParenToken);
            this.visitNodeOrToken(node.statement);
        };
        SyntaxWalker.prototype.visitTryStatement = function (node) {
            this.visitToken(node.tryKeyword);
            this.visitNode(node.block);
            this.visitOptionalNode(node.catchClause);
            this.visitOptionalNode(node.finallyClause);
        };
        SyntaxWalker.prototype.visitLabeledStatement = function (node) {
            this.visitToken(node.identifier);
            this.visitToken(node.colonToken);
            this.visitNodeOrToken(node.statement);
        };
        SyntaxWalker.prototype.visitDoStatement = function (node) {
            this.visitToken(node.doKeyword);
            this.visitNodeOrToken(node.statement);
            this.visitToken(node.whileKeyword);
            this.visitToken(node.openParenToken);
            this.visitNodeOrToken(node.condition);
            this.visitToken(node.closeParenToken);
            this.visitOptionalToken(node.semicolonToken);
        };
        SyntaxWalker.prototype.visitDebuggerStatement = function (node) {
            this.visitToken(node.debuggerKeyword);
            this.visitOptionalToken(node.semicolonToken);
        };
        SyntaxWalker.prototype.visitWithStatement = function (node) {
            this.visitToken(node.withKeyword);
            this.visitToken(node.openParenToken);
            this.visitNodeOrToken(node.condition);
            this.visitToken(node.closeParenToken);
            this.visitNodeOrToken(node.statement);
        };
        SyntaxWalker.prototype.visitPrefixUnaryExpression = function (node) {
            this.visitToken(node.operatorToken);
            this.visitNodeOrToken(node.operand);
        };
        SyntaxWalker.prototype.visitDeleteExpression = function (node) {
            this.visitToken(node.deleteKeyword);
            this.visitNodeOrToken(node.expression);
        };
        SyntaxWalker.prototype.visitTypeOfExpression = function (node) {
            this.visitToken(node.typeOfKeyword);
            this.visitNodeOrToken(node.expression);
        };
        SyntaxWalker.prototype.visitVoidExpression = function (node) {
            this.visitToken(node.voidKeyword);
            this.visitNodeOrToken(node.expression);
        };
        SyntaxWalker.prototype.visitConditionalExpression = function (node) {
            this.visitNodeOrToken(node.condition);
            this.visitToken(node.questionToken);
            this.visitNodeOrToken(node.whenTrue);
            this.visitToken(node.colonToken);
            this.visitNodeOrToken(node.whenFalse);
        };
        SyntaxWalker.prototype.visitBinaryExpression = function (node) {
            this.visitNodeOrToken(node.left);
            this.visitToken(node.operatorToken);
            this.visitNodeOrToken(node.right);
        };
        SyntaxWalker.prototype.visitPostfixUnaryExpression = function (node) {
            this.visitNodeOrToken(node.operand);
            this.visitToken(node.operatorToken);
        };
        SyntaxWalker.prototype.visitMemberAccessExpression = function (node) {
            this.visitNodeOrToken(node.expression);
            this.visitToken(node.dotToken);
            this.visitToken(node.name);
        };
        SyntaxWalker.prototype.visitInvocationExpression = function (node) {
            this.visitNodeOrToken(node.expression);
            this.visitNode(node.argumentList);
        };
        SyntaxWalker.prototype.visitArrayLiteralExpression = function (node) {
            this.visitToken(node.openBracketToken);
            this.visitSeparatedList(node.expressions);
            this.visitToken(node.closeBracketToken);
        };
        SyntaxWalker.prototype.visitObjectLiteralExpression = function (node) {
            this.visitToken(node.openBraceToken);
            this.visitSeparatedList(node.propertyAssignments);
            this.visitToken(node.closeBraceToken);
        };
        SyntaxWalker.prototype.visitObjectCreationExpression = function (node) {
            this.visitToken(node.newKeyword);
            this.visitNodeOrToken(node.expression);
            this.visitOptionalNode(node.argumentList);
        };
        SyntaxWalker.prototype.visitParenthesizedExpression = function (node) {
            this.visitToken(node.openParenToken);
            this.visitNodeOrToken(node.expression);
            this.visitToken(node.closeParenToken);
        };
        SyntaxWalker.prototype.visitParenthesizedArrowFunctionExpression = function (node) {
            this.visitNode(node.callSignature);
            this.visitToken(node.equalsGreaterThanToken);
            this.visitOptionalNode(node.block);
            this.visitOptionalNodeOrToken(node.expression);
        };
        SyntaxWalker.prototype.visitSimpleArrowFunctionExpression = function (node) {
            this.visitNode(node.parameter);
            this.visitToken(node.equalsGreaterThanToken);
            this.visitOptionalNode(node.block);
            this.visitOptionalNodeOrToken(node.expression);
        };
        SyntaxWalker.prototype.visitCastExpression = function (node) {
            this.visitToken(node.lessThanToken);
            this.visitNodeOrToken(node.type);
            this.visitToken(node.greaterThanToken);
            this.visitNodeOrToken(node.expression);
        };
        SyntaxWalker.prototype.visitElementAccessExpression = function (node) {
            this.visitNodeOrToken(node.expression);
            this.visitToken(node.openBracketToken);
            this.visitNodeOrToken(node.argumentExpression);
            this.visitToken(node.closeBracketToken);
        };
        SyntaxWalker.prototype.visitFunctionExpression = function (node) {
            this.visitToken(node.functionKeyword);
            this.visitOptionalToken(node.identifier);
            this.visitNode(node.callSignature);
            this.visitNode(node.block);
        };
        SyntaxWalker.prototype.visitOmittedExpression = function (node) {
        };
        SyntaxWalker.prototype.visitVariableDeclaration = function (node) {
            this.visitToken(node.varKeyword);
            this.visitSeparatedList(node.variableDeclarators);
        };
        SyntaxWalker.prototype.visitVariableDeclarator = function (node) {
            this.visitToken(node.propertyName);
            this.visitOptionalNode(node.typeAnnotation);
            this.visitOptionalNode(node.equalsValueClause);
        };
        SyntaxWalker.prototype.visitArgumentList = function (node) {
            this.visitOptionalNode(node.typeArgumentList);
            this.visitToken(node.openParenToken);
            this.visitSeparatedList(node.arguments);
            this.visitToken(node.closeParenToken);
        };
        SyntaxWalker.prototype.visitParameterList = function (node) {
            this.visitToken(node.openParenToken);
            this.visitSeparatedList(node.parameters);
            this.visitToken(node.closeParenToken);
        };
        SyntaxWalker.prototype.visitTypeArgumentList = function (node) {
            this.visitToken(node.lessThanToken);
            this.visitSeparatedList(node.typeArguments);
            this.visitToken(node.greaterThanToken);
        };
        SyntaxWalker.prototype.visitTypeParameterList = function (node) {
            this.visitToken(node.lessThanToken);
            this.visitSeparatedList(node.typeParameters);
            this.visitToken(node.greaterThanToken);
        };
        SyntaxWalker.prototype.visitHeritageClause = function (node) {
            this.visitToken(node.extendsOrImplementsKeyword);
            this.visitSeparatedList(node.typeNames);
        };
        SyntaxWalker.prototype.visitEqualsValueClause = function (node) {
            this.visitToken(node.equalsToken);
            this.visitNodeOrToken(node.value);
        };
        SyntaxWalker.prototype.visitCaseSwitchClause = function (node) {
            this.visitToken(node.caseKeyword);
            this.visitNodeOrToken(node.expression);
            this.visitToken(node.colonToken);
            this.visitList(node.statements);
        };
        SyntaxWalker.prototype.visitDefaultSwitchClause = function (node) {
            this.visitToken(node.defaultKeyword);
            this.visitToken(node.colonToken);
            this.visitList(node.statements);
        };
        SyntaxWalker.prototype.visitElseClause = function (node) {
            this.visitToken(node.elseKeyword);
            this.visitNodeOrToken(node.statement);
        };
        SyntaxWalker.prototype.visitCatchClause = function (node) {
            this.visitToken(node.catchKeyword);
            this.visitToken(node.openParenToken);
            this.visitToken(node.identifier);
            this.visitOptionalNode(node.typeAnnotation);
            this.visitToken(node.closeParenToken);
            this.visitNode(node.block);
        };
        SyntaxWalker.prototype.visitFinallyClause = function (node) {
            this.visitToken(node.finallyKeyword);
            this.visitNode(node.block);
        };
        SyntaxWalker.prototype.visitTypeParameter = function (node) {
            this.visitToken(node.identifier);
            this.visitOptionalNode(node.constraint);
        };
        SyntaxWalker.prototype.visitConstraint = function (node) {
            this.visitToken(node.extendsKeyword);
            this.visitNodeOrToken(node.typeOrExpression);
        };
        SyntaxWalker.prototype.visitSimplePropertyAssignment = function (node) {
            this.visitToken(node.propertyName);
            this.visitToken(node.colonToken);
            this.visitNodeOrToken(node.expression);
        };
        SyntaxWalker.prototype.visitFunctionPropertyAssignment = function (node) {
            this.visitToken(node.propertyName);
            this.visitNode(node.callSignature);
            this.visitNode(node.block);
        };
        SyntaxWalker.prototype.visitParameter = function (node) {
            this.visitOptionalToken(node.dotDotDotToken);
            this.visitList(node.modifiers);
            this.visitToken(node.identifier);
            this.visitOptionalToken(node.questionToken);
            this.visitOptionalNode(node.typeAnnotation);
            this.visitOptionalNode(node.equalsValueClause);
        };
        SyntaxWalker.prototype.visitEnumElement = function (node) {
            this.visitToken(node.propertyName);
            this.visitOptionalNode(node.equalsValueClause);
        };
        SyntaxWalker.prototype.visitTypeAnnotation = function (node) {
            this.visitToken(node.colonToken);
            this.visitNodeOrToken(node.type);
        };
        SyntaxWalker.prototype.visitExternalModuleReference = function (node) {
            this.visitToken(node.requireKeyword);
            this.visitToken(node.openParenToken);
            this.visitToken(node.stringLiteral);
            this.visitToken(node.closeParenToken);
        };
        SyntaxWalker.prototype.visitModuleNameModuleReference = function (node) {
            this.visitNodeOrToken(node.moduleName);
        };
        return SyntaxWalker;
    })();
    TypeScript.SyntaxWalker = SyntaxWalker;
})(TypeScript || (TypeScript = {}));
///<reference path='references.ts' />
var TypeScript;
(function (TypeScript) {
    var DepthLimitedWalker = (function (_super) {
        __extends(DepthLimitedWalker, _super);
        function DepthLimitedWalker(maximumDepth) {
            _super.call(this);
            this._depth = 0;
            this._maximumDepth = 0;
            this._maximumDepth = maximumDepth;
        }
        DepthLimitedWalker.prototype.visitNode = function (node) {
            if (this._depth < this._maximumDepth) {
                this._depth++;
                _super.prototype.visitNode.call(this, node);
                this._depth--;
            }
        };
        return DepthLimitedWalker;
    })(TypeScript.SyntaxWalker);
    TypeScript.DepthLimitedWalker = DepthLimitedWalker;
})(TypeScript || (TypeScript = {}));
///<reference path='references.ts' />
var TypeScript;
(function (TypeScript) {
    var Parser;
    (function (Parser) {
        // The factory used to produce parse tree nodes.  Injected normally by the 
        // TypeScript.Syntax.Abstract or TypeScript.Syntax.Conrete modules.
        Parser.syntaxFactory;
        var arrayPool = [];
        var arrayPoolCount = 0;
        function getArray() {
            if (arrayPoolCount === 0) {
                return [];
            }
            arrayPoolCount--;
            var result = arrayPool[arrayPoolCount];
            arrayPool[arrayPoolCount] = null;
            return result;
        }
        function returnZeroLengthArray(array) {
            if (array.length === 0) {
                returnArray(array);
            }
        }
        function returnArray(array) {
            array.length = 0;
            arrayPool[arrayPoolCount] = array;
            arrayPoolCount++;
        }
        // Contains the actual logic to parse typescript/javascript.  This is the code that generally
        // represents the logic necessary to handle all the language grammar constructs.  When the 
        // language changes, this should generally only be the place necessary to fix up.
        function createParseSyntaxTree() {
            // Name of the file we're parsing.
            var fileName;
            // Underlying source where we pull nodes and tokens from.
            var source;
            var languageVersion;
            // TODO: do we need to store/restore this when speculative parsing?  I don't think so.  The
            // parsing logic already handles storing/restoring this and should work properly even if we're
            // speculative parsing.
            var listParsingState = 0;
            // Whether or not we are in strict parsing mode.  All that changes in strict parsing mode is
            // that some tokens that would be considered identifiers may be considered keywords.  When 
            // rewinding, we need to store and restore this as the mode may have changed.
            //
            // TODO: do we need to store/restore this when speculative parsing?  I don't think so.  The
            // parsing logic already handles storing/restoring this and should work properly even if we're
            // speculative parsing.
            var isInStrictMode = false;
            // Current state of the parser.  If we need to rewind we will store and reset these values as
            // appropriate.
            // Diagnostics created when parsing invalid code.  Any diagnosics created when speculative 
            // parsing need to removed when rewinding.  To do this we store the count of diagnostics when 
            // we start speculative parsing.  And if we rewind, we restore this to the same count that we 
            // started at.
            var diagnostics = [];
            var parseNodeData = 0;
            function parseSyntaxTree(_source, isDeclaration) {
                // First, set up our state.
                fileName = _source.fileName;
                source = _source;
                languageVersion = source.languageVersion;
                // Now actually parse the tree.
                var result = parseSyntaxTreeWorker(isDeclaration);
                // Now, clear out our state so that our singleton parser doesn't keep things alive.
                diagnostics = [];
                parseNodeData = 0 /* None */;
                fileName = null;
                source.release();
                source = null;
                _source = null;
                return result;
            }
            function parseSyntaxTreeWorker(isDeclaration) {
                var sourceUnit = parseSourceUnit();
                var allDiagnostics = source.tokenDiagnostics().concat(diagnostics);
                allDiagnostics.sort(function (a, b) { return a.start() - b.start(); });
                return new TypeScript.SyntaxTree(Parser.syntaxFactory.isConcrete, sourceUnit, isDeclaration, allDiagnostics, fileName, source.text, languageVersion);
            }
            function getRewindPoint() {
                var rewindPoint = source.getRewindPoint();
                rewindPoint.diagnosticsCount = diagnostics.length;
                // Values we keep around for debug asserting purposes.
                rewindPoint.isInStrictMode = isInStrictMode;
                rewindPoint.listParsingState = listParsingState;
                return rewindPoint;
            }
            function rewind(rewindPoint) {
                source.rewind(rewindPoint);
                diagnostics.length = rewindPoint.diagnosticsCount;
            }
            function releaseRewindPoint(rewindPoint) {
                // Debug.assert(listParsingState === rewindPoint.listParsingState);
                // Debug.assert(isInStrictMode === rewindPoint.isInStrictMode);
                source.releaseRewindPoint(rewindPoint);
            }
            function currentNode() {
                var node = source.currentNode();
                // We can only reuse a node if it was parsed under the same strict mode that we're 
                // currently in.  i.e. if we originally parsed a node in non-strict mode, but then
                // the user added 'using strict' at the top of the file, then we can't use that node
                // again as the presense of strict mode may cause us to parse the tokens in the file
                // differetly.
                //
                // Note: we *can* reuse tokens when the strict mode changes.  That's because tokens
                // are unaffected by strict mode.  It's just the parser will decide what to do with it
                // differently depending on what mode it is in.
                if (node === null || TypeScript.parsedInStrictMode(node) !== isInStrictMode) {
                    return null;
                }
                return node;
            }
            function currentToken() {
                return source.currentToken();
            }
            function currentContextualToken() {
                // We're mutating the source here.  We are potentially overwriting the original token we
                // scanned with a regex token.  So we have to clear our state.
                return source.currentContextualToken();
            }
            function peekToken(n) {
                return source.peekToken(n);
            }
            function consumeToken(token) {
                source.consumeToken(token);
                return token;
            }
            function consumeNode(node) {
                source.consumeNode(node);
            }
            //this method is called very frequently
            //we should keep it simple so that it can be inlined.
            function eatToken(kind) {
                var token = currentToken();
                if (token.kind() === kind) {
                    return consumeToken(token);
                }
                //slow part of EatToken(SyntaxKind kind)
                return createMissingToken(kind, token);
            }
            // Eats the token if it is there.  Otherwise does nothing.  Will not report errors.
            function tryEatToken(kind) {
                var _currentToken = currentToken();
                if (_currentToken.kind() === kind) {
                    return consumeToken(_currentToken);
                }
                return null;
            }
            // An identifier is basically any word, unless it is a reserved keyword.  so 'foo' is an 
            // identifier and 'return' is not.  Note: a word may or may not be an identifier depending 
            // on the state of the parser.  For example, 'yield' is an identifier *unless* the parser 
            // is in strict mode.
            function isIdentifier(token) {
                var tokenKind = token.kind();
                if (tokenKind === 11 /* IdentifierName */) {
                    return true;
                }
                // Keywords are only identifiers if they're FutureReservedStrictWords and we're in 
                // strict mode.  *Or* if it's a typescript 'keyword'. 
                if (tokenKind >= TypeScript.SyntaxKind.FirstFutureReservedStrictKeyword) {
                    if (tokenKind <= TypeScript.SyntaxKind.LastFutureReservedStrictKeyword) {
                        // Could be a keyword or identifier.  It's an identifier if we're not in strict
                        // mode.
                        return !isInStrictMode;
                    }
                    // If it's typescript keyword, then it's actually a javascript identifier.
                    return tokenKind <= TypeScript.SyntaxKind.LastTypeScriptKeyword;
                }
                // Anything else is not an identifier.
                return false;
            }
            // This method should be called when the grammar calls for an *IdentifierName* and not an
            // *Identifier*.
            function eatIdentifierNameToken() {
                var token = currentToken();
                // If we have an identifier name, then consume and return it.
                var tokenKind = token.kind();
                if (tokenKind === 11 /* IdentifierName */) {
                    return consumeToken(token);
                }
                // If we have a keyword, then it can be used as an identifier name.  However, we need 
                // to convert it to an identifier so that no later parts of the systems see it as a 
                // keyword.
                if (TypeScript.SyntaxFacts.isAnyKeyword(tokenKind)) {
                    return TypeScript.Syntax.convertKeywordToIdentifier(consumeToken(token));
                }
                return createMissingToken(11 /* IdentifierName */, token);
            }
            function eatOptionalIdentifierToken() {
                return isIdentifier(currentToken()) ? eatIdentifierToken() : null;
            }
            // This method should be called when the grammar calls for an *Identifier* and not an
            // *IdentifierName*.
            function eatIdentifierToken(diagnosticCode) {
                var token = currentToken();
                if (isIdentifier(token)) {
                    consumeToken(token);
                    if (token.kind() === 11 /* IdentifierName */) {
                        return token;
                    }
                    return TypeScript.Syntax.convertKeywordToIdentifier(token);
                }
                return createMissingToken(11 /* IdentifierName */, token, diagnosticCode);
            }
            function previousTokenHasTrailingNewLine(token) {
                var tokenFullStart = token.fullStart();
                if (tokenFullStart === 0) {
                    // First token in the document.  Thus it has no 'previous' token, and there is 
                    // no preceding newline.
                    return false;
                }
                // If our previous token ended with a newline, then *by definition* we must have started
                // at the beginning of a line.  
                var lineNumber = source.text.lineMap().getLineNumberFromPosition(tokenFullStart);
                var lineStart = source.text.lineMap().getLineStartPosition(lineNumber);
                return lineStart == tokenFullStart;
            }
            function canEatAutomaticSemicolon(allowWithoutNewLine) {
                var token = currentToken();
                // An automatic semicolon is always allowed if we're at the end of the file.
                var tokenKind = token.kind();
                if (tokenKind === 10 /* EndOfFileToken */) {
                    return true;
                }
                // Or if the next token is a close brace (regardless of which line it is on).
                if (tokenKind === 71 /* CloseBraceToken */) {
                    return true;
                }
                if (allowWithoutNewLine) {
                    return true;
                }
                // It is also allowed if there is a newline between the last token seen and the next one.
                if (previousTokenHasTrailingNewLine(token)) {
                    return true;
                }
                return false;
            }
            function canEatExplicitOrAutomaticSemicolon(allowWithoutNewline) {
                var token = currentToken();
                if (token.kind() === 78 /* SemicolonToken */) {
                    return true;
                }
                return canEatAutomaticSemicolon(allowWithoutNewline);
            }
            function eatExplicitOrAutomaticSemicolon(allowWithoutNewline) {
                var token = currentToken();
                // If we see a semicolon, then we can definitely eat it.
                if (token.kind() === 78 /* SemicolonToken */) {
                    return consumeToken(token);
                }
                // Check if an automatic semicolon could go here.  If so, then there's no problem and
                // we can proceed without error.  Return 'null' as there's no actual token for this 
                // position. 
                if (canEatAutomaticSemicolon(allowWithoutNewline)) {
                    return null;
                }
                // No semicolon could be consumed here at all.  Just call the standard eating function
                // so we get the token and the error for it.
                return eatToken(78 /* SemicolonToken */);
            }
            function createMissingToken(expectedKind, actual, diagnosticCode) {
                var diagnostic = getExpectedTokenDiagnostic(expectedKind, actual, diagnosticCode);
                addDiagnostic(diagnostic);
                // The missing token will be at the full start of the current token.  That way empty tokens
                // will always be between real tokens and not inside an actual token.
                return TypeScript.Syntax.emptyToken(expectedKind);
            }
            function getExpectedTokenDiagnostic(expectedKind, actual, diagnosticCode) {
                var token = currentToken();
                var args = null;
                // If a specialized diagnostic message was provided, just use that.
                if (!diagnosticCode) {
                    // They wanted something specific, just report that that token was missing.
                    if (TypeScript.SyntaxFacts.isAnyKeyword(expectedKind) || TypeScript.SyntaxFacts.isAnyPunctuation(expectedKind)) {
                        diagnosticCode = TypeScript.DiagnosticCode._0_expected;
                        args = [TypeScript.SyntaxFacts.getText(expectedKind)];
                    }
                    else {
                        // They wanted an identifier.
                        // If the user supplied a keyword, give them a specialized message.
                        if (actual !== null && TypeScript.SyntaxFacts.isAnyKeyword(actual.kind())) {
                            diagnosticCode = TypeScript.DiagnosticCode.Identifier_expected_0_is_a_keyword;
                            args = [TypeScript.SyntaxFacts.getText(actual.kind())];
                        }
                        else {
                            // Otherwise just report that an identifier was expected.
                            diagnosticCode = TypeScript.DiagnosticCode.Identifier_expected;
                        }
                    }
                }
                return new TypeScript.Diagnostic(fileName, source.text.lineMap(), TypeScript.start(token, source.text), TypeScript.width(token), diagnosticCode, args);
            }
            function getBinaryExpressionPrecedence(tokenKind) {
                switch (tokenKind) {
                    case 104 /* BarBarToken */:
                        return 2 /* LogicalOrExpressionPrecedence */;
                    case 103 /* AmpersandAmpersandToken */:
                        return 3 /* LogicalAndExpressionPrecedence */;
                    case 99 /* BarToken */:
                        return 4 /* BitwiseOrExpressionPrecedence */;
                    case 100 /* CaretToken */:
                        return 5 /* BitwiseExclusiveOrExpressionPrecedence */;
                    case 98 /* AmpersandToken */:
                        return 6 /* BitwiseAndExpressionPrecedence */;
                    case 84 /* EqualsEqualsToken */:
                    case 86 /* ExclamationEqualsToken */:
                    case 87 /* EqualsEqualsEqualsToken */:
                    case 88 /* ExclamationEqualsEqualsToken */:
                        return 7 /* EqualityExpressionPrecedence */;
                    case 80 /* LessThanToken */:
                    case 81 /* GreaterThanToken */:
                    case 82 /* LessThanEqualsToken */:
                    case 83 /* GreaterThanEqualsToken */:
                    case 30 /* InstanceOfKeyword */:
                    case 29 /* InKeyword */:
                        return 8 /* RelationalExpressionPrecedence */;
                    case 95 /* LessThanLessThanToken */:
                    case 96 /* GreaterThanGreaterThanToken */:
                    case 97 /* GreaterThanGreaterThanGreaterThanToken */:
                        return 9 /* ShiftExpressionPrecdence */;
                    case 89 /* PlusToken */:
                    case 90 /* MinusToken */:
                        return 10 /* AdditiveExpressionPrecedence */;
                    case 91 /* AsteriskToken */:
                    case 118 /* SlashToken */:
                    case 92 /* PercentToken */:
                        return 11 /* MultiplicativeExpressionPrecedence */;
                }
                throw TypeScript.Errors.invalidOperation();
            }
            function addSkippedTokenAfterNodeOrToken(nodeOrToken, skippedToken) {
                if (TypeScript.isToken(nodeOrToken)) {
                    return addSkippedTokenAfterToken(nodeOrToken, skippedToken);
                }
                else if (TypeScript.isNode(nodeOrToken)) {
                    return addSkippedTokenAfterNode(nodeOrToken, skippedToken);
                }
                else {
                    throw TypeScript.Errors.invalidOperation();
                }
            }
            function replaceTokenInParent(node, oldToken, newToken) {
                // oldToken may be parented by a node or a list.
                replaceTokenInParentWorker(oldToken, newToken);
                var parent = oldToken.parent;
                newToken.parent = parent;
                while (true) {
                    // Parent must be a list or a node.  All of those have a 'data' element.
                    TypeScript.Debug.assert(TypeScript.isNode(parent) || TypeScript.isList(parent) || TypeScript.isSeparatedList(parent));
                    var dataElement = parent;
                    if (dataElement.data) {
                        dataElement.data &= 4 /* NodeParsedInStrictModeMask */;
                    }
                    if (parent === node) {
                        break;
                    }
                    parent = parent.parent;
                }
            }
            function replaceTokenInParentWorker(oldToken, newToken) {
                var parent = oldToken.parent;
                if (TypeScript.isNode(parent)) {
                    var node = parent;
                    for (var key in node) {
                        if (node[key] === oldToken) {
                            node[key] = newToken;
                            return;
                        }
                    }
                }
                else if (TypeScript.isList(parent)) {
                    var list1 = parent;
                    for (var i = 0, n = list1.length; i < n; i++) {
                        if (list1[i] === oldToken) {
                            list1[i] = newToken;
                            return;
                        }
                    }
                }
                else if (TypeScript.isSeparatedList(parent)) {
                    var list2 = parent;
                    for (var i = 0, n = TypeScript.childCount(list2); i < n; i++) {
                        if (TypeScript.childAt(list2, i) === oldToken) {
                            if (i % 2 === 0) {
                                list2[i / 2] = newToken;
                            }
                            else {
                                list2.separators[(i - 1) / 2] = newToken;
                            }
                            return;
                        }
                    }
                }
                throw TypeScript.Errors.invalidOperation();
            }
            function addSkippedTokenAfterNode(node, skippedToken) {
                var oldToken = TypeScript.lastToken(node);
                var newToken = addSkippedTokenAfterToken(oldToken, skippedToken);
                replaceTokenInParent(node, oldToken, newToken);
                return node;
            }
            function addSkippedTokensBeforeNode(node, skippedTokens) {
                if (skippedTokens.length > 0) {
                    var oldToken = TypeScript.firstToken(node);
                    var newToken = addSkippedTokensBeforeToken(oldToken, skippedTokens);
                    replaceTokenInParent(node, oldToken, newToken);
                }
                return node;
            }
            function addSkippedTokensBeforeToken(token, skippedTokens) {
                // Debug.assert(token.fullWidth() > 0 || token.kind() === SyntaxKind.EndOfFileToken);
                // Debug.assert(skippedTokens.length > 0);
                var leadingTrivia = [];
                for (var i = 0, n = skippedTokens.length; i < n; i++) {
                    var skippedToken = skippedTokens[i];
                    addSkippedTokenToTriviaArray(leadingTrivia, skippedToken);
                }
                addTriviaTo(token.leadingTrivia(source.text), leadingTrivia);
                var updatedToken = TypeScript.Syntax.withLeadingTrivia(token, TypeScript.Syntax.triviaList(leadingTrivia), source.text);
                // We've prepending this token with new leading trivia.  This means the full start of
                // the token is not where the scanner originally thought it was, but is instead at the
                // start of the first skipped token.
                updatedToken.setFullStart(skippedTokens[0].fullStart());
                // Don't need this array anymore.  Give it back so we can reuse it.
                returnArray(skippedTokens);
                return updatedToken;
            }
            function addSkippedTokensAfterToken(token, skippedTokens) {
                // Debug.assert(token.fullWidth() > 0);
                if (skippedTokens.length === 0) {
                    returnArray(skippedTokens);
                    return token;
                }
                var trailingTrivia = token.trailingTrivia(source.text).toArray();
                for (var i = 0, n = skippedTokens.length; i < n; i++) {
                    addSkippedTokenToTriviaArray(trailingTrivia, skippedTokens[i]);
                }
                // Don't need this array anymore.  Give it back so we can reuse it.
                returnArray(skippedTokens);
                return TypeScript.Syntax.withTrailingTrivia(token, TypeScript.Syntax.triviaList(trailingTrivia), source.text);
            }
            function addSkippedTokenAfterToken(token, skippedToken) {
                // Debug.assert(token.fullWidth() > 0);
                var trailingTrivia = token.trailingTrivia(source.text).toArray();
                addSkippedTokenToTriviaArray(trailingTrivia, skippedToken);
                return TypeScript.Syntax.withTrailingTrivia(token, TypeScript.Syntax.triviaList(trailingTrivia), source.text);
            }
            function addSkippedTokenToTriviaArray(array, skippedToken) {
                // Debug.assert(skippedToken.text().length > 0);
                // first, add the leading trivia of the skipped token to the array
                addTriviaTo(skippedToken.leadingTrivia(source.text), array);
                // now, add the text of the token as skipped text to the trivia array.
                var trimmedToken = TypeScript.Syntax.withTrailingTrivia(TypeScript.Syntax.withLeadingTrivia(skippedToken, TypeScript.Syntax.emptyTriviaList, source.text), TypeScript.Syntax.emptyTriviaList, source.text);
                // Because we removed the leading trivia from the skipped token, the full start of the
                // trimmed token is the start of the skipped token.
                trimmedToken.setFullStart(TypeScript.start(skippedToken, source.text));
                array.push(TypeScript.Syntax.skippedTokenTrivia(trimmedToken, source.text));
                // Finally, add the trailing trivia of the skipped token to the trivia array.
                addTriviaTo(skippedToken.trailingTrivia(source.text), array);
            }
            function addTriviaTo(list, array) {
                for (var i = 0, n = list.count(); i < n; i++) {
                    array.push(list.syntaxTriviaAt(i));
                }
            }
            function setStrictMode(_isInStrictMode) {
                isInStrictMode = _isInStrictMode;
                parseNodeData = _isInStrictMode ? 4 /* NodeParsedInStrictModeMask */ : 0;
            }
            function parseSourceUnit() {
                var savedIsInStrictMode = isInStrictMode;
                var skippedTokens = getArray();
                var moduleElements = parseSyntaxList(0 /* SourceUnit_ModuleElements */, skippedTokens, updateStrictModeState);
                setStrictMode(savedIsInStrictMode);
                var sourceUnit = new Parser.syntaxFactory.SourceUnitSyntax(parseNodeData, moduleElements, currentToken());
                sourceUnit = addSkippedTokensBeforeNode(sourceUnit, skippedTokens);
                if (TypeScript.Debug.shouldAssert(2 /* Aggressive */)) {
                    TypeScript.Debug.assert(TypeScript.fullWidth(sourceUnit) === source.text.length());
                    if (TypeScript.Debug.shouldAssert(3 /* VeryAggressive */)) {
                        TypeScript.Debug.assert(TypeScript.fullText(sourceUnit) === source.text.substr(0, source.text.length()));
                    }
                }
                return sourceUnit;
            }
            function updateStrictModeState(items) {
                if (!isInStrictMode) {
                    for (var i = 0; i < items.length; i++) {
                        var item = items[i];
                        if (!TypeScript.SyntaxFacts.isDirectivePrologueElement(item)) {
                            return;
                        }
                    }
                    setStrictMode(TypeScript.SyntaxFacts.isUseStrictDirective(items[items.length - 1]));
                }
            }
            function isModuleElement(inErrorRecovery) {
                if (TypeScript.SyntaxUtilities.isModuleElement(currentNode())) {
                    return true;
                }
                var _modifierCount = modifierCount();
                return isInterfaceEnumClassModuleImportOrExport(_modifierCount) || isStatement(_modifierCount, inErrorRecovery);
            }
            function tryParseModuleElement(inErrorRecovery) {
                var node = currentNode();
                if (TypeScript.SyntaxUtilities.isModuleElement(node)) {
                    consumeNode(node);
                    return node;
                }
                var _currentToken = currentToken();
                var _modifierCount = modifierCount();
                if (_modifierCount) {
                    switch (peekToken(_modifierCount).kind()) {
                        case 49 /* ImportKeyword */:
                            return parseImportDeclaration();
                        case 65 /* ModuleKeyword */:
                            return parseModuleDeclaration();
                        case 52 /* InterfaceKeyword */:
                            return parseInterfaceDeclaration();
                        case 44 /* ClassKeyword */:
                            return parseClassDeclaration();
                        case 46 /* EnumKeyword */:
                            return parseEnumDeclaration();
                    }
                }
                // No modifiers.  If we see 'class, enum, import and export' we could technically 
                // aggressively consume them as they can't start another construct.  However, it's 
                // not uncommon in error recovery to run into a situation where we see those keywords,
                // but the code was using it as the name of an object property.  To avoid overzealously
                // consuming these, we only parse them out if we can see enough context to 'prove' that
                // they really do start the module element
                var nextToken = peekToken(1);
                var currentTokenKind = _currentToken.kind();
                switch (currentTokenKind) {
                    case 65 /* ModuleKeyword */:
                        if (isIdentifier(nextToken) || nextToken.kind() === 14 /* StringLiteral */) {
                            return parseModuleDeclaration();
                        }
                        break;
                    case 49 /* ImportKeyword */:
                        if (isIdentifier(nextToken)) {
                            return parseImportDeclaration();
                        }
                        break;
                    case 44 /* ClassKeyword */:
                        if (isIdentifier(nextToken)) {
                            return parseClassDeclaration();
                        }
                        break;
                    case 46 /* EnumKeyword */:
                        if (isIdentifier(nextToken)) {
                            return parseEnumDeclaration();
                        }
                        break;
                    case 52 /* InterfaceKeyword */:
                        if (isIdentifier(nextToken)) {
                            return parseInterfaceDeclaration();
                        }
                        break;
                    case 47 /* ExportKeyword */:
                        // 'export' could be a modifier on a statement (like export var ...).  So we 
                        // only want to parse out an export assignment here if we actually see the equals.
                        if (nextToken.kind() === 107 /* EqualsToken */) {
                            return parseExportAssignment();
                        }
                        break;
                }
                return tryParseStatementWorker(_currentToken, currentTokenKind, _modifierCount, inErrorRecovery);
            }
            function parseImportDeclaration() {
                return new Parser.syntaxFactory.ImportDeclarationSyntax(parseNodeData, parseModifiers(), eatToken(49 /* ImportKeyword */), eatIdentifierToken(), eatToken(107 /* EqualsToken */), parseModuleReference(), eatExplicitOrAutomaticSemicolon(false));
            }
            function parseExportAssignment() {
                return new Parser.syntaxFactory.ExportAssignmentSyntax(parseNodeData, eatToken(47 /* ExportKeyword */), eatToken(107 /* EqualsToken */), eatIdentifierToken(), eatExplicitOrAutomaticSemicolon(false));
            }
            function parseModuleReference() {
                return isExternalModuleReference() ? parseExternalModuleReference() : parseModuleNameModuleReference();
            }
            function isExternalModuleReference() {
                return currentToken().kind() === 66 /* RequireKeyword */ && peekToken(1).kind() === 72 /* OpenParenToken */;
            }
            function parseExternalModuleReference() {
                return new Parser.syntaxFactory.ExternalModuleReferenceSyntax(parseNodeData, eatToken(66 /* RequireKeyword */), eatToken(72 /* OpenParenToken */), eatToken(14 /* StringLiteral */), eatToken(73 /* CloseParenToken */));
            }
            function parseModuleNameModuleReference() {
                return new Parser.syntaxFactory.ModuleNameModuleReferenceSyntax(parseNodeData, parseName(false));
            }
            function tryParseTypeArgumentList(inExpression) {
                var _currentToken = currentToken();
                if (_currentToken.kind() !== 80 /* LessThanToken */) {
                    return null;
                }
                if (!inExpression) {
                    // if we're not in an expression, this must be a type argument list.  Just parse
                    // it out as such.
                    var lessThanToken = consumeToken(_currentToken);
                    var skippedTokens = getArray();
                    var typeArguments = parseSeparatedSyntaxList(19 /* TypeArgumentList_Types */, skippedTokens);
                    lessThanToken = addSkippedTokensAfterToken(lessThanToken, skippedTokens);
                    return new Parser.syntaxFactory.TypeArgumentListSyntax(parseNodeData, lessThanToken, typeArguments, eatToken(81 /* GreaterThanToken */));
                }
                // If we're in an expression, then we only want to consume this as a type argument list
                // if we're sure that it's a type arg list and not an arithmetic expression.
                var rewindPoint = getRewindPoint();
                // We've seen a '<'.  Try to parse it out as a type argument list.
                var lessThanToken = consumeToken(_currentToken);
                var skippedTokens = getArray();
                var typeArguments = parseSeparatedSyntaxList(19 /* TypeArgumentList_Types */, skippedTokens);
                var lessThanToken = addSkippedTokensAfterToken(lessThanToken, skippedTokens);
                var greaterThanToken = eatToken(81 /* GreaterThanToken */);
                // We're in a context where '<' could be the start of a type argument list, or part
                // of an arithmetic expression.  We'll presume it's the latter unless we see the '>'
                // and a following token that guarantees that it's supposed to be a type argument list.
                if (greaterThanToken.fullWidth() === 0 || !canFollowTypeArgumentListInExpression(currentToken().kind())) {
                    rewind(rewindPoint);
                    releaseRewindPoint(rewindPoint);
                    return null;
                }
                else {
                    releaseRewindPoint(rewindPoint);
                    return new Parser.syntaxFactory.TypeArgumentListSyntax(parseNodeData, lessThanToken, typeArguments, greaterThanToken);
                }
            }
            function canFollowTypeArgumentListInExpression(kind) {
                switch (kind) {
                    case 72 /* OpenParenToken */:
                    case 76 /* DotToken */:
                    case 73 /* CloseParenToken */:
                    case 75 /* CloseBracketToken */:
                    case 106 /* ColonToken */:
                    case 78 /* SemicolonToken */:
                    case 79 /* CommaToken */:
                    case 105 /* QuestionToken */:
                    case 84 /* EqualsEqualsToken */:
                    case 87 /* EqualsEqualsEqualsToken */:
                    case 86 /* ExclamationEqualsToken */:
                    case 88 /* ExclamationEqualsEqualsToken */:
                    case 103 /* AmpersandAmpersandToken */:
                    case 104 /* BarBarToken */:
                    case 100 /* CaretToken */:
                    case 98 /* AmpersandToken */:
                    case 99 /* BarToken */:
                    case 71 /* CloseBraceToken */:
                    case 10 /* EndOfFileToken */:
                        // these cases can't legally follow a type arg list.  However, they're not legal 
                        // expressions either.  The user is probably in the middle of a generic type. So
                        // treat it as such.
                        return true;
                    default:
                        // Anything else treat as an expression.
                        return false;
                }
            }
            function parseName(allowIdentifierName) {
                return tryParseName(allowIdentifierName) || eatIdentifierToken();
            }
            function eatRightSideOfName(allowIdentifierNames) {
                var _currentToken = currentToken();
                // Technically a keyword is valid here as all keywords are identifier names.
                // However, often we'll encounter this in error situations when the keyword
                // is actually starting another valid construct.
                // So, we check for the following specific case:
                //      name.
                //      keyword identifierNameOrKeyword
                // Note: the newlines are important here.  For example, if that above code 
                // were rewritten into:
                //      name.keyword
                //      identifierNameOrKeyword
                // Then we would consider it valid.  That's because ASI would take effect and
                // the code would be implicitly: "name.keyword; identifierNameOrKeyword".  
                // In the first case though, ASI will not take effect because there is not a
                // line terminator after the keyword.
                if (TypeScript.SyntaxFacts.isAnyKeyword(_currentToken.kind()) && previousTokenHasTrailingNewLine(_currentToken)) {
                    var token1 = peekToken(1);
                    if (!TypeScript.existsNewLineBetweenTokens(_currentToken, token1, source.text) && TypeScript.SyntaxFacts.isIdentifierNameOrAnyKeyword(token1)) {
                        return createMissingToken(11 /* IdentifierName */, _currentToken);
                    }
                }
                return allowIdentifierNames ? eatIdentifierNameToken() : eatIdentifierToken();
            }
            function tryParseName(allowIdentifierNames) {
                var token0 = currentToken();
                var shouldContinue = isIdentifier(token0);
                if (!shouldContinue) {
                    return null;
                }
                // Call eatIdentifierName to convert the token to an identifier if it is as keyword.
                var current = eatIdentifierToken();
                while (shouldContinue && currentToken().kind() === 76 /* DotToken */) {
                    var dotToken = consumeToken(currentToken());
                    var identifierName = eatRightSideOfName(allowIdentifierNames);
                    current = new Parser.syntaxFactory.QualifiedNameSyntax(parseNodeData, current, dotToken, identifierName);
                    shouldContinue = identifierName.fullWidth() > 0;
                }
                return current;
            }
            function parseEnumDeclaration() {
                var modifiers = parseModifiers();
                var enumKeyword = eatToken(46 /* EnumKeyword */);
                var identifier = eatIdentifierToken();
                var openBraceToken = eatToken(70 /* OpenBraceToken */);
                var enumElements = TypeScript.Syntax.emptySeparatedList();
                if (openBraceToken.fullWidth() > 0) {
                    var skippedTokens = getArray();
                    enumElements = parseSeparatedSyntaxList(8 /* EnumDeclaration_EnumElements */, skippedTokens);
                    openBraceToken = addSkippedTokensAfterToken(openBraceToken, skippedTokens);
                }
                return new Parser.syntaxFactory.EnumDeclarationSyntax(parseNodeData, modifiers, enumKeyword, identifier, openBraceToken, enumElements, eatToken(71 /* CloseBraceToken */));
            }
            function isEnumElement(inErrorRecovery) {
                var node = currentNode();
                if (node !== null && node.kind() === 244 /* EnumElement */) {
                    return true;
                }
                return isPropertyName(currentToken(), inErrorRecovery);
            }
            function tryParseEnumElementEqualsValueClause() {
                return isEqualsValueClause(false) ? parseEqualsValueClause(true) : null;
            }
            function tryParseEnumElement(inErrorRecovery) {
                var node = currentNode();
                if (node !== null && node.kind() === 244 /* EnumElement */) {
                    consumeNode(node);
                    return node;
                }
                if (!isPropertyName(currentToken(), inErrorRecovery)) {
                    return null;
                }
                return new Parser.syntaxFactory.EnumElementSyntax(parseNodeData, eatPropertyName(), tryParseEnumElementEqualsValueClause());
            }
            function isModifierKind(kind) {
                switch (kind) {
                    case 47 /* ExportKeyword */:
                    case 57 /* PublicKeyword */:
                    case 55 /* PrivateKeyword */:
                    case 56 /* ProtectedKeyword */:
                    case 58 /* StaticKeyword */:
                    case 63 /* DeclareKeyword */:
                        return true;
                }
                return false;
            }
            function isModifier(token, index) {
                if (isModifierKind(token.kind())) {
                    // These are modifiers only if we see an actual keyword, identifier, string literal
                    // or number following.
                    // Note: we also allow [ for error conditions.  
                    // [   is for:     static [a: number]
                    var nextToken = peekToken(index + 1);
                    var nextTokenKind = nextToken.kind();
                    switch (nextTokenKind) {
                        case 11 /* IdentifierName */:
                        case 74 /* OpenBracketToken */:
                        case 13 /* NumericLiteral */:
                        case 14 /* StringLiteral */:
                            return true;
                        default:
                            return TypeScript.SyntaxFacts.isAnyKeyword(nextTokenKind);
                    }
                }
                return false;
            }
            function modifierCount() {
                var modifierCount = 0;
                while (isModifier(peekToken(modifierCount), modifierCount)) {
                    modifierCount++;
                }
                return modifierCount;
            }
            function parseModifiers() {
                var tokens = getArray();
                while (true) {
                    var token = currentToken();
                    if (isModifier(token, 0)) {
                        tokens.push(consumeToken(token));
                        continue;
                    }
                    break;
                }
                var result = TypeScript.Syntax.list(tokens);
                // If the tokens array is greater than one, then we can't return it.  It will have been 
                // copied directly into the syntax list.
                returnZeroLengthArray(tokens);
                return result;
            }
            function parseHeritageClauses() {
                var heritageClauses = TypeScript.Syntax.emptyList();
                if (isHeritageClause()) {
                    // NOTE: we can pass "null" for the skipped tokens here as we know we can't get
                    // any leading skipped tokens. We have an 'extends' or 'implements' keyword, so 
                    // any skipped tokeds will get attached to that instead.
                    heritageClauses = parseSyntaxList(10 /* ClassOrInterfaceDeclaration_HeritageClauses */, null);
                }
                return heritageClauses;
            }
            function tryParseHeritageClauseTypeName() {
                return isHeritageClauseTypeName() ? tryParseNameOrGenericType() : null;
            }
            function parseClassDeclaration() {
                var modifiers = parseModifiers();
                var classKeyword = eatToken(44 /* ClassKeyword */);
                var identifier = eatIdentifierToken();
                var typeParameterList = tryParseTypeParameterList(false);
                var heritageClauses = parseHeritageClauses();
                var openBraceToken = eatToken(70 /* OpenBraceToken */);
                var classElements = TypeScript.Syntax.emptyList();
                if (openBraceToken.fullWidth() > 0) {
                    var skippedTokens = getArray();
                    classElements = parseSyntaxList(1 /* ClassDeclaration_ClassElements */, skippedTokens);
                    openBraceToken = addSkippedTokensAfterToken(openBraceToken, skippedTokens);
                }
                ;
                return new Parser.syntaxFactory.ClassDeclarationSyntax(parseNodeData, modifiers, classKeyword, identifier, typeParameterList, heritageClauses, openBraceToken, classElements, eatToken(71 /* CloseBraceToken */));
            }
            function isAccessor(modifierCount, inErrorRecovery) {
                var tokenKind = peekToken(modifierCount).kind();
                if (tokenKind !== 64 /* GetKeyword */ && tokenKind !== 68 /* SetKeyword */) {
                    return false;
                }
                return isPropertyName(peekToken(modifierCount + 1), inErrorRecovery);
            }
            function parseAccessor(checkForStrictMode) {
                var modifiers = parseModifiers();
                var _currenToken = currentToken();
                var tokenKind = _currenToken.kind();
                if (tokenKind === 64 /* GetKeyword */) {
                    return parseGetMemberAccessorDeclaration(modifiers, _currenToken, checkForStrictMode);
                }
                else if (tokenKind === 68 /* SetKeyword */) {
                    return parseSetMemberAccessorDeclaration(modifiers, _currenToken, checkForStrictMode);
                }
                else {
                    throw TypeScript.Errors.invalidOperation();
                }
            }
            function parseGetMemberAccessorDeclaration(modifiers, getKeyword, checkForStrictMode) {
                return new Parser.syntaxFactory.GetAccessorSyntax(parseNodeData, modifiers, consumeToken(getKeyword), eatPropertyName(), parseCallSignature(false), parseBlock(false, checkForStrictMode));
            }
            function parseSetMemberAccessorDeclaration(modifiers, setKeyword, checkForStrictMode) {
                return new Parser.syntaxFactory.SetAccessorSyntax(parseNodeData, modifiers, consumeToken(setKeyword), eatPropertyName(), parseCallSignature(false), parseBlock(false, checkForStrictMode));
            }
            function isClassElement(inErrorRecovery) {
                if (TypeScript.SyntaxUtilities.isClassElement(currentNode())) {
                    return true;
                }
                // Note: the order of these calls is important.  Specifically, isMemberVariableDeclaration
                // checks for a subset of the conditions of the previous two calls.
                var _modifierCount = modifierCount();
                return isConstructorDeclaration(_modifierCount) || isMemberFunctionDeclaration(_modifierCount, inErrorRecovery) || isAccessor(_modifierCount, inErrorRecovery) || isMemberVariableDeclaration(_modifierCount, inErrorRecovery) || isIndexMemberDeclaration(_modifierCount);
            }
            function tryParseClassElement(inErrorRecovery) {
                var node = currentNode();
                if (TypeScript.SyntaxUtilities.isClassElement(node)) {
                    consumeNode(node);
                    return node;
                }
                var _modifierCount = modifierCount();
                if (isConstructorDeclaration(_modifierCount)) {
                    return parseConstructorDeclaration();
                }
                else if (isMemberFunctionDeclaration(_modifierCount, inErrorRecovery)) {
                    return parseMemberFunctionDeclaration();
                }
                else if (isAccessor(_modifierCount, inErrorRecovery)) {
                    return parseAccessor(false);
                }
                else if (isMemberVariableDeclaration(_modifierCount, inErrorRecovery)) {
                    return parseMemberVariableDeclaration();
                }
                else if (isIndexMemberDeclaration(_modifierCount)) {
                    return parseIndexMemberDeclaration();
                }
                else {
                    return null;
                }
            }
            function isConstructorDeclaration(modifierCount) {
                // Note: we deviate slightly from the spec here.  If we see 'constructor' then we 
                // assume this is a constructor.  That means, if a user writes "public constructor;"
                // it won't be viewed as a member.  As a workaround, they can simply write:
                //      public 'constructor';
                return peekToken(modifierCount).kind() === 62 /* ConstructorKeyword */;
            }
            function parseConstructorDeclaration() {
                var modifiers = parseModifiers();
                var constructorKeyword = eatToken(62 /* ConstructorKeyword */);
                var callSignature = parseCallSignature(false);
                var semicolonToken = null;
                var block = null;
                if (isBlock()) {
                    block = parseBlock(false, true);
                }
                else {
                    semicolonToken = eatExplicitOrAutomaticSemicolon(false);
                }
                return new Parser.syntaxFactory.ConstructorDeclarationSyntax(parseNodeData, modifiers, constructorKeyword, callSignature, block, semicolonToken);
            }
            function isMemberFunctionDeclaration(modifierCount, inErrorRecovery) {
                return isPropertyName(peekToken(modifierCount), inErrorRecovery) && isCallSignature(modifierCount + 1);
            }
            function parseMemberFunctionDeclaration() {
                var modifiers = parseModifiers();
                var propertyName = eatPropertyName();
                var callSignature = parseCallSignature(false);
                // If we got an errant => then we want to parse what's coming up without requiring an
                // open brace.
                var parseBlockEvenWithNoOpenBrace = tryAddUnexpectedEqualsGreaterThanToken(callSignature);
                var block = null;
                var semicolon = null;
                if (parseBlockEvenWithNoOpenBrace || isBlock()) {
                    block = parseBlock(parseBlockEvenWithNoOpenBrace, true);
                }
                else {
                    semicolon = eatExplicitOrAutomaticSemicolon(false);
                }
                return new Parser.syntaxFactory.MemberFunctionDeclarationSyntax(parseNodeData, modifiers, propertyName, callSignature, block, semicolon);
            }
            function isDefinitelyMemberVariablePropertyName(index) {
                // keywords are also property names.  Only accept a keyword as a property 
                // name if is of the form:
                //      public;
                //      public=
                //      public:
                //      public }
                //      public <eof>
                //      public <newline>
                if (TypeScript.SyntaxFacts.isAnyKeyword(peekToken(index).kind())) {
                    var nextToken = peekToken(index + 1);
                    switch (nextToken.kind()) {
                        case 78 /* SemicolonToken */:
                        case 107 /* EqualsToken */:
                        case 106 /* ColonToken */:
                        case 71 /* CloseBraceToken */:
                        case 10 /* EndOfFileToken */:
                            return true;
                        default:
                            return previousTokenHasTrailingNewLine(nextToken);
                    }
                }
                else {
                    // If was a property name and not a keyword, then we're good to go.
                    return true;
                }
            }
            function isMemberVariableDeclaration(modifierCount, inErrorRecover) {
                return isPropertyName(peekToken(modifierCount), inErrorRecover) && isDefinitelyMemberVariablePropertyName(modifierCount);
            }
            function parseMemberVariableDeclaration() {
                return new Parser.syntaxFactory.MemberVariableDeclarationSyntax(parseNodeData, parseModifiers(), tryParseVariableDeclarator(true, true), eatExplicitOrAutomaticSemicolon(false));
            }
            function isIndexMemberDeclaration(modifierCount) {
                return isIndexSignature(modifierCount);
            }
            function parseIndexMemberDeclaration() {
                return new Parser.syntaxFactory.IndexMemberDeclarationSyntax(parseNodeData, parseModifiers(), parseIndexSignature(), eatExplicitOrAutomaticSemicolon(false));
            }
            function tryAddUnexpectedEqualsGreaterThanToken(callSignature) {
                var token0 = currentToken();
                var hasEqualsGreaterThanToken = token0.kind() === 85 /* EqualsGreaterThanToken */;
                if (hasEqualsGreaterThanToken) {
                    // We can only do this if the call signature actually contains a final token that we 
                    // could add the => to.
                    var _lastToken = TypeScript.lastToken(callSignature);
                    if (_lastToken && _lastToken.fullWidth() > 0) {
                        // Previously the language allowed "function f() => expr;" as a shorthand for 
                        // "function f() { return expr; }.
                        // 
                        // Detect if the user is typing this and attempt recovery.
                        var diagnostic = new TypeScript.Diagnostic(fileName, source.text.lineMap(), TypeScript.start(token0, source.text), TypeScript.width(token0), TypeScript.DiagnosticCode.Unexpected_token_0_expected, [TypeScript.SyntaxFacts.getText(70 /* OpenBraceToken */)]);
                        addDiagnostic(diagnostic);
                        consumeToken(token0);
                        // Note: we only do this if we're creating a concrete syntax tree (which contains
                        // everything, including skipped tokens, in it).
                        if (Parser.syntaxFactory.isConcrete) {
                            addSkippedTokenAfterNode(callSignature, token0);
                        }
                        return true;
                    }
                }
                return false;
            }
            function isFunctionDeclaration(modifierCount) {
                return peekToken(modifierCount).kind() === 27 /* FunctionKeyword */;
            }
            function parseFunctionDeclaration() {
                var modifiers = parseModifiers();
                var functionKeyword = eatToken(27 /* FunctionKeyword */);
                var identifier = eatIdentifierToken();
                var callSignature = parseCallSignature(false);
                // If we got an errant => then we want to parse what's coming up without requiring an
                // open brace.
                var parseBlockEvenWithNoOpenBrace = tryAddUnexpectedEqualsGreaterThanToken(callSignature);
                var semicolonToken = null;
                var block = null;
                // Parse a block if we're on a bock, or if we saw a '=>'
                if (parseBlockEvenWithNoOpenBrace || isBlock()) {
                    block = parseBlock(parseBlockEvenWithNoOpenBrace, true);
                }
                else {
                    semicolonToken = eatExplicitOrAutomaticSemicolon(false);
                }
                return new Parser.syntaxFactory.FunctionDeclarationSyntax(parseNodeData, modifiers, functionKeyword, identifier, callSignature, block, semicolonToken);
            }
            function parseModuleDeclaration() {
                var modifiers = parseModifiers();
                var moduleKeyword = eatToken(65 /* ModuleKeyword */);
                var moduleName = null;
                var stringLiteral = null;
                if (currentToken().kind() === 14 /* StringLiteral */) {
                    stringLiteral = eatToken(14 /* StringLiteral */);
                }
                else {
                    moduleName = parseName(false);
                }
                var openBraceToken = eatToken(70 /* OpenBraceToken */);
                var moduleElements = TypeScript.Syntax.emptyList();
                if (openBraceToken.fullWidth() > 0) {
                    var skippedTokens = getArray();
                    moduleElements = parseSyntaxList(2 /* ModuleDeclaration_ModuleElements */, skippedTokens);
                    openBraceToken = addSkippedTokensAfterToken(openBraceToken, skippedTokens);
                }
                return new Parser.syntaxFactory.ModuleDeclarationSyntax(parseNodeData, modifiers, moduleKeyword, moduleName, stringLiteral, openBraceToken, moduleElements, eatToken(71 /* CloseBraceToken */));
            }
            function parseInterfaceDeclaration() {
                return new Parser.syntaxFactory.InterfaceDeclarationSyntax(parseNodeData, parseModifiers(), eatToken(52 /* InterfaceKeyword */), eatIdentifierToken(), tryParseTypeParameterList(false), parseHeritageClauses(), parseObjectType());
            }
            function parseObjectType() {
                var openBraceToken = eatToken(70 /* OpenBraceToken */);
                var typeMembers = TypeScript.Syntax.emptySeparatedList();
                if (openBraceToken.fullWidth() > 0) {
                    var skippedTokens = getArray();
                    typeMembers = parseSeparatedSyntaxList(9 /* ObjectType_TypeMembers */, skippedTokens);
                    openBraceToken = addSkippedTokensAfterToken(openBraceToken, skippedTokens);
                }
                return new Parser.syntaxFactory.ObjectTypeSyntax(parseNodeData, openBraceToken, typeMembers, eatToken(71 /* CloseBraceToken */));
            }
            function parseTupleType(currentToken) {
                var openBracket = consumeToken(currentToken);
                var types = TypeScript.Syntax.emptySeparatedList();
                if (openBracket.fullWidth() > 0) {
                    var skippedTokens = getArray();
                    types = parseSeparatedSyntaxList(21 /* TupleType_Types */, skippedTokens);
                    openBracket = addSkippedTokensAfterToken(openBracket, skippedTokens);
                }
                return new Parser.syntaxFactory.TupleTypeSyntax(parseNodeData, openBracket, types, eatToken(75 /* CloseBracketToken */));
            }
            function isTypeMember(inErrorRecovery) {
                if (TypeScript.SyntaxUtilities.isTypeMember(currentNode())) {
                    return true;
                }
                return isCallSignature(0) || isConstructSignature() || isIndexSignature(0) || isMethodSignature(inErrorRecovery) || isPropertySignature(inErrorRecovery);
            }
            function tryParseTypeMember(inErrorRecovery) {
                var node = currentNode();
                if (TypeScript.SyntaxUtilities.isTypeMember(node)) {
                    consumeNode(node);
                    return node;
                }
                if (isCallSignature(0)) {
                    return parseCallSignature(false);
                }
                else if (isConstructSignature()) {
                    return parseConstructSignature();
                }
                else if (isIndexSignature(0)) {
                    return parseIndexSignature();
                }
                else if (isMethodSignature(inErrorRecovery)) {
                    // Note: it is important that isFunctionSignature is called before isPropertySignature.
                    // isPropertySignature checks for a subset of isFunctionSignature.
                    return parseMethodSignature();
                }
                else if (isPropertySignature(inErrorRecovery)) {
                    return parsePropertySignature();
                }
                else {
                    return null;
                }
            }
            function parseConstructSignature() {
                return new Parser.syntaxFactory.ConstructSignatureSyntax(parseNodeData, eatToken(31 /* NewKeyword */), parseCallSignature(false));
            }
            function parseIndexSignature() {
                var openBracketToken = eatToken(74 /* OpenBracketToken */);
                var skippedTokens = getArray();
                var parameters = parseSeparatedSyntaxList(18 /* IndexSignature_Parameters */, skippedTokens);
                openBracketToken = addSkippedTokensAfterToken(openBracketToken, skippedTokens);
                return new Parser.syntaxFactory.IndexSignatureSyntax(parseNodeData, openBracketToken, parameters, eatToken(75 /* CloseBracketToken */), parseOptionalTypeAnnotation(false));
            }
            function parseMethodSignature() {
                return new Parser.syntaxFactory.MethodSignatureSyntax(parseNodeData, eatPropertyName(), tryEatToken(105 /* QuestionToken */), parseCallSignature(false));
            }
            function parsePropertySignature() {
                return new Parser.syntaxFactory.PropertySignatureSyntax(parseNodeData, eatPropertyName(), tryEatToken(105 /* QuestionToken */), parseOptionalTypeAnnotation(false));
            }
            function isCallSignature(peekIndex) {
                var tokenKind = peekToken(peekIndex).kind();
                return tokenKind === 72 /* OpenParenToken */ || tokenKind === 80 /* LessThanToken */;
            }
            function isConstructSignature() {
                if (currentToken().kind() !== 31 /* NewKeyword */) {
                    return false;
                }
                return isCallSignature(1);
            }
            function isIndexSignature(peekIndex) {
                return peekToken(peekIndex).kind() === 74 /* OpenBracketToken */;
            }
            function isMethodSignature(inErrorRecovery) {
                if (isPropertyName(currentToken(), inErrorRecovery)) {
                    // id(
                    if (isCallSignature(1)) {
                        return true;
                    }
                    // id?(
                    if (peekToken(1).kind() === 105 /* QuestionToken */ && isCallSignature(2)) {
                        return true;
                    }
                }
                return false;
            }
            function isPropertySignature(inErrorRecovery) {
                var _currentToken = currentToken();
                // Keywords can start properties.  However, they're often intended to start something
                // else.  If we see a modifier before something that can be a property, then don't
                // try parse it out as a property.  For example, if we have:
                //
                //      public foo
                //
                // Then don't parse 'public' as a property name.  Note: if you have:
                //
                //      public
                //      foo
                //
                // Then we *should* parse it as a property name, as ASI takes effect here.
                if (isModifier(_currentToken, 0)) {
                    if (!TypeScript.existsNewLineBetweenTokens(_currentToken, peekToken(1), source.text) && isPropertyName(peekToken(1), inErrorRecovery)) {
                        return false;
                    }
                }
                // Note: property names also start function signatures.  So it's important that we call this
                // after we calll isFunctionSignature.
                return isPropertyName(_currentToken, inErrorRecovery);
            }
            function isHeritageClause() {
                var tokenKind = currentToken().kind();
                return tokenKind === 48 /* ExtendsKeyword */ || tokenKind === 51 /* ImplementsKeyword */;
            }
            function isNotHeritageClauseTypeName() {
                var tokenKind = currentToken().kind();
                if (tokenKind === 51 /* ImplementsKeyword */ || tokenKind === 48 /* ExtendsKeyword */) {
                    return isIdentifier(peekToken(1));
                }
                return false;
            }
            function isHeritageClauseTypeName() {
                if (isIdentifier(currentToken())) {
                    // We want to make sure that the "extends" in "extends foo" or the "implements" in
                    // "implements foo" is not considered a type name.
                    return !isNotHeritageClauseTypeName();
                }
                return false;
            }
            function tryParseHeritageClause() {
                var extendsOrImplementsKeyword = currentToken();
                var tokenKind = extendsOrImplementsKeyword.kind();
                if (tokenKind !== 48 /* ExtendsKeyword */ && tokenKind !== 51 /* ImplementsKeyword */) {
                    return null;
                }
                consumeToken(extendsOrImplementsKeyword);
                var skippedTokens = getArray();
                var typeNames = parseSeparatedSyntaxList(11 /* HeritageClause_TypeNameList */, skippedTokens);
                extendsOrImplementsKeyword = addSkippedTokensAfterToken(extendsOrImplementsKeyword, skippedTokens);
                return new Parser.syntaxFactory.HeritageClauseSyntax(parseNodeData, extendsOrImplementsKeyword, typeNames);
            }
            function isInterfaceEnumClassModuleImportOrExport(modifierCount) {
                var _currentToken = currentToken();
                if (modifierCount) {
                    switch (peekToken(modifierCount).kind()) {
                        case 49 /* ImportKeyword */:
                        case 65 /* ModuleKeyword */:
                        case 52 /* InterfaceKeyword */:
                        case 44 /* ClassKeyword */:
                        case 46 /* EnumKeyword */:
                            return true;
                    }
                }
                // no modifiers.  While certain of these keywords are javascript keywords as well, it
                // is possible to run into them in some circumstances in error recovery where we don't
                // want to consider them the start of the module element construct.  For example, they
                // might be hte name in an object literal.  Because of that, we check the next token to
                // make sure it really is the start of a module element.
                var nextToken = peekToken(1);
                switch (_currentToken.kind()) {
                    case 65 /* ModuleKeyword */:
                        if (isIdentifier(nextToken) || nextToken.kind() === 14 /* StringLiteral */) {
                            return true;
                        }
                        break;
                    case 49 /* ImportKeyword */:
                    case 44 /* ClassKeyword */:
                    case 46 /* EnumKeyword */:
                    case 52 /* InterfaceKeyword */:
                        if (isIdentifier(nextToken)) {
                            return true;
                        }
                        break;
                    case 47 /* ExportKeyword */:
                        if (nextToken.kind() === 107 /* EqualsToken */) {
                            return true;
                        }
                        break;
                }
                return false;
            }
            function isStatement(modifierCount, inErrorRecovery) {
                if (TypeScript.SyntaxUtilities.isStatement(currentNode())) {
                    return true;
                }
                var _currentToken = currentToken();
                var currentTokenKind = _currentToken.kind();
                switch (currentTokenKind) {
                    case 57 /* PublicKeyword */:
                    case 55 /* PrivateKeyword */:
                    case 56 /* ProtectedKeyword */:
                    case 58 /* StaticKeyword */:
                        // None of the above are actually keywords.  And they might show up in a real
                        // statement (i.e. "public();").  However, if we see 'public <identifier>' then 
                        // that can't possibly be a statement (and instead will be a class element), 
                        // and we should not parse it out here.
                        var token1 = peekToken(1);
                        if (TypeScript.SyntaxFacts.isIdentifierNameOrAnyKeyword(token1)) {
                            // Definitely not a statement.
                            return false;
                        }
                        break;
                    case 28 /* IfKeyword */:
                    case 70 /* OpenBraceToken */:
                    case 33 /* ReturnKeyword */:
                    case 34 /* SwitchKeyword */:
                    case 36 /* ThrowKeyword */:
                    case 15 /* BreakKeyword */:
                    case 18 /* ContinueKeyword */:
                    case 26 /* ForKeyword */:
                    case 42 /* WhileKeyword */:
                    case 43 /* WithKeyword */:
                    case 22 /* DoKeyword */:
                    case 38 /* TryKeyword */:
                    case 19 /* DebuggerKeyword */:
                        return true;
                }
                // Check for common things that might appear where we expect a statement, but which we 
                // do not want to consume.  This can happen when the user does not terminate their 
                // existing block properly.  We don't want to accidently consume these as expression 
                // below.
                if (isInterfaceEnumClassModuleImportOrExport(modifierCount)) {
                    return false;
                }
                // More complicated cases.
                return isLabeledStatement(_currentToken) || isVariableStatement(modifierCount) || isFunctionDeclaration(modifierCount) || isEmptyStatement(_currentToken, inErrorRecovery) || isExpressionStatement(_currentToken);
            }
            function parseStatement(inErrorRecovery) {
                return tryParseStatement(inErrorRecovery) || parseExpressionStatement();
            }
            function tryParseStatement(inErrorRecovery) {
                var node = currentNode();
                if (TypeScript.SyntaxUtilities.isStatement(node)) {
                    consumeNode(node);
                    return node;
                }
                var _currentToken = currentToken();
                var currentTokenKind = _currentToken.kind();
                return tryParseStatementWorker(_currentToken, currentTokenKind, modifierCount(), inErrorRecovery);
            }
            function tryParseStatementWorker(_currentToken, currentTokenKind, modifierCount, inErrorRecovery) {
                switch (currentTokenKind) {
                    case 57 /* PublicKeyword */:
                    case 55 /* PrivateKeyword */:
                    case 56 /* ProtectedKeyword */:
                    case 58 /* StaticKeyword */:
                        // None of the above are actually keywords.  And they might show up in a real
                        // statement (i.e. "public();").  However, if we see 'public <identifier>' then 
                        // that can't possibly be a statement (and instead will be a class element), 
                        // and we should not parse it out here.
                        if (TypeScript.SyntaxFacts.isIdentifierNameOrAnyKeyword(peekToken(1))) {
                            // Definitely not a statement.
                            return null;
                        }
                        else {
                            break;
                        }
                    case 28 /* IfKeyword */:
                        return parseIfStatement(_currentToken);
                    case 70 /* OpenBraceToken */:
                        return parseBlock(false, false);
                    case 33 /* ReturnKeyword */:
                        return parseReturnStatement(_currentToken);
                    case 34 /* SwitchKeyword */:
                        return parseSwitchStatement(_currentToken);
                    case 36 /* ThrowKeyword */:
                        return parseThrowStatement(_currentToken);
                    case 15 /* BreakKeyword */:
                        return parseBreakStatement(_currentToken);
                    case 18 /* ContinueKeyword */:
                        return parseContinueStatement(_currentToken);
                    case 26 /* ForKeyword */:
                        return parseForOrForInStatement(_currentToken);
                    case 42 /* WhileKeyword */:
                        return parseWhileStatement(_currentToken);
                    case 43 /* WithKeyword */:
                        return parseWithStatement(_currentToken);
                    case 22 /* DoKeyword */:
                        return parseDoStatement(_currentToken);
                    case 38 /* TryKeyword */:
                        return parseTryStatement(_currentToken);
                    case 19 /* DebuggerKeyword */:
                        return parseDebuggerStatement(_currentToken);
                }
                // Check for common things that might appear where we expect a statement, but which we 
                // do not want to consume.  This can happen when the user does not terminate their 
                // existing block properly.  We don't want to accidently consume these as expression 
                // below.
                if (isInterfaceEnumClassModuleImportOrExport(modifierCount)) {
                    return null;
                }
                else if (isVariableStatement(modifierCount)) {
                    return parseVariableStatement();
                }
                else if (isLabeledStatement(_currentToken)) {
                    return parseLabeledStatement(_currentToken);
                }
                else if (isFunctionDeclaration(modifierCount)) {
                    return parseFunctionDeclaration();
                }
                else if (isEmptyStatement(_currentToken, inErrorRecovery)) {
                    return parseEmptyStatement(_currentToken);
                }
                else if (isExpressionStatement(_currentToken)) {
                    return parseExpressionStatement();
                }
                else {
                    return null;
                }
            }
            function parseDebuggerStatement(debuggerKeyword) {
                return new Parser.syntaxFactory.DebuggerStatementSyntax(parseNodeData, consumeToken(debuggerKeyword), eatExplicitOrAutomaticSemicolon(false));
            }
            function parseDoStatement(doKeyword) {
                // From: https://mail.mozilla.org/pipermail/es-discuss/2011-August/016188.html
                // 157 min --- All allen at wirfs-brock.com CONF --- "do{;}while(false)false" prohibited in 
                // spec but allowed in consensus reality. Approved -- this is the de-facto standard whereby
                //  do;while(0)x will have a semicolon inserted before x.
                return new Parser.syntaxFactory.DoStatementSyntax(parseNodeData, consumeToken(doKeyword), parseStatement(false), eatToken(42 /* WhileKeyword */), eatToken(72 /* OpenParenToken */), parseExpression(true), eatToken(73 /* CloseParenToken */), eatExplicitOrAutomaticSemicolon(true));
            }
            function isLabeledStatement(currentToken) {
                return isIdentifier(currentToken) && peekToken(1).kind() === 106 /* ColonToken */;
            }
            function parseLabeledStatement(identifierToken) {
                return new Parser.syntaxFactory.LabeledStatementSyntax(parseNodeData, consumeToken(identifierToken), eatToken(106 /* ColonToken */), parseStatement(false));
            }
            function parseTryStatement(tryKeyword) {
                var tryKeyword = consumeToken(tryKeyword);
                var savedListParsingState = listParsingState;
                listParsingState |= (1 << 6 /* TryBlock_Statements */);
                var block = parseBlock(false, false);
                listParsingState = savedListParsingState;
                var catchClause = null;
                if (currentToken().kind() === 17 /* CatchKeyword */) {
                    catchClause = parseCatchClause();
                }
                // If we don't have a catch clause, then we must have a finally clause.  Try to parse
                // one out no matter what.
                var finallyClause = null;
                if (catchClause === null || currentToken().kind() === 25 /* FinallyKeyword */) {
                    finallyClause = parseFinallyClause();
                }
                return new Parser.syntaxFactory.TryStatementSyntax(parseNodeData, tryKeyword, block, catchClause, finallyClause);
            }
            function parseCatchClauseBlock() {
                var savedListParsingState = listParsingState;
                listParsingState |= (1 << 7 /* CatchBlock_Statements */);
                var block = parseBlock(false, false);
                listParsingState = savedListParsingState;
                return block;
            }
            function parseCatchClause() {
                return new Parser.syntaxFactory.CatchClauseSyntax(parseNodeData, eatToken(17 /* CatchKeyword */), eatToken(72 /* OpenParenToken */), eatIdentifierToken(), parseOptionalTypeAnnotation(false), eatToken(73 /* CloseParenToken */), parseCatchClauseBlock());
            }
            function parseFinallyClause() {
                return new Parser.syntaxFactory.FinallyClauseSyntax(parseNodeData, eatToken(25 /* FinallyKeyword */), parseBlock(false, false));
            }
            function parseWithStatement(withKeyword) {
                return new Parser.syntaxFactory.WithStatementSyntax(parseNodeData, consumeToken(withKeyword), eatToken(72 /* OpenParenToken */), parseExpression(true), eatToken(73 /* CloseParenToken */), parseStatement(false));
            }
            function parseWhileStatement(whileKeyword) {
                return new Parser.syntaxFactory.WhileStatementSyntax(parseNodeData, consumeToken(whileKeyword), eatToken(72 /* OpenParenToken */), parseExpression(true), eatToken(73 /* CloseParenToken */), parseStatement(false));
            }
            function isEmptyStatement(currentToken, inErrorRecovery) {
                // If we're in error recovery, then we don't want to treat ';' as an empty statement.
                // The problem is that ';' can show up in far too many contexts, and if we see one 
                // and assume it's a statement, then we may bail out innapropriately from whatever 
                // we're parsing.  For example, if we have a semicolon in the middle of a class, then
                // we really don't want to assume the class is over and we're on a statement in the
                // outer module.  We just want to consume and move on.
                if (inErrorRecovery) {
                    return false;
                }
                return currentToken.kind() === 78 /* SemicolonToken */;
            }
            function parseEmptyStatement(semicolonToken) {
                return new Parser.syntaxFactory.EmptyStatementSyntax(parseNodeData, consumeToken(semicolonToken));
            }
            function parseForOrForInStatement(forKeyword) {
                // Debug.assert(isForOrForInStatement());
                consumeToken(forKeyword);
                var openParenToken = eatToken(72 /* OpenParenToken */);
                var _currentToken = currentToken();
                var tokenKind = _currentToken.kind();
                if (tokenKind === 40 /* VarKeyword */) {
                    // for ( var VariableDeclarationListNoIn; Expressionopt ; Expressionopt ) Statement
                    // for ( var VariableDeclarationNoIn in Expression ) Statement
                    return parseForOrForInStatementWithVariableDeclaration(forKeyword, openParenToken);
                }
                else if (tokenKind === 78 /* SemicolonToken */) {
                    // for ( ; Expressionopt ; Expressionopt ) Statement
                    return parseForStatementWithNoVariableDeclarationOrInitializer(forKeyword, openParenToken);
                }
                else {
                    // for ( ExpressionNoInopt; Expressionopt ; Expressionopt ) Statement
                    // for ( LeftHandSideExpression in Expression ) Statement
                    return parseForOrForInStatementWithInitializer(forKeyword, openParenToken);
                }
            }
            function parseForOrForInStatementWithVariableDeclaration(forKeyword, openParenToken) {
                // Debug.assert(forKeyword.kind === SyntaxKind.ForKeyword && openParenToken.kind() === SyntaxKind.OpenParenToken);
                // Debug.assert(currentToken().kind() === SyntaxKind.VarKeyword);
                // for ( var VariableDeclarationListNoIn; Expressionopt ; Expressionopt ) Statement
                // for ( var VariableDeclarationNoIn in Expression ) Statement
                var variableDeclaration = parseVariableDeclaration(false);
                return currentToken().kind() === 29 /* InKeyword */ ? parseForInStatementWithVariableDeclarationOrInitializer(forKeyword, openParenToken, variableDeclaration, null) : parseForStatementWithVariableDeclarationOrInitializer(forKeyword, openParenToken, variableDeclaration, null);
            }
            function parseForInStatementWithVariableDeclarationOrInitializer(forKeyword, openParenToken, variableDeclaration, initializer) {
                // for ( var VariableDeclarationNoIn in Expression ) Statement
                return new Parser.syntaxFactory.ForInStatementSyntax(parseNodeData, forKeyword, openParenToken, variableDeclaration, initializer, eatToken(29 /* InKeyword */), parseExpression(true), eatToken(73 /* CloseParenToken */), parseStatement(false));
            }
            function parseForOrForInStatementWithInitializer(forKeyword, openParenToken) {
                // Debug.assert(forKeyword.kind() === SyntaxKind.ForKeyword && openParenToken.kind() === SyntaxKind.OpenParenToken);
                // for ( ExpressionNoInopt; Expressionopt ; Expressionopt ) Statement
                // for ( LeftHandSideExpression in Expression ) Statement
                var initializer = parseExpression(false);
                return currentToken().kind() === 29 /* InKeyword */ ? parseForInStatementWithVariableDeclarationOrInitializer(forKeyword, openParenToken, null, initializer) : parseForStatementWithVariableDeclarationOrInitializer(forKeyword, openParenToken, null, initializer);
            }
            function parseForStatementWithNoVariableDeclarationOrInitializer(forKeyword, openParenToken) {
                // Debug.assert(forKeyword.kind() === SyntaxKind.ForKeyword && openParenToken.kind() === SyntaxKind.OpenParenToken);
                // Debug.assert(currentToken().kind() === SyntaxKind.SemicolonToken);
                // for ( ; Expressionopt ; Expressionopt ) Statement
                return parseForStatementWithVariableDeclarationOrInitializer(forKeyword, openParenToken, null, null);
            }
            function tryParseForStatementCondition() {
                var tokenKind = currentToken().kind();
                if (tokenKind !== 78 /* SemicolonToken */ && tokenKind !== 73 /* CloseParenToken */ && tokenKind !== 10 /* EndOfFileToken */) {
                    return parseExpression(true);
                }
                return null;
            }
            function tryParseForStatementIncrementor() {
                var tokenKind = currentToken().kind();
                if (tokenKind !== 73 /* CloseParenToken */ && tokenKind !== 10 /* EndOfFileToken */) {
                    return parseExpression(true);
                }
                return null;
            }
            function parseForStatementWithVariableDeclarationOrInitializer(forKeyword, openParenToken, variableDeclaration, initializer) {
                // NOTE: From the es5 section on Automatic Semicolon Insertion.
                // a semicolon is never inserted automatically if the semicolon would then ... become 
                // one of the two semicolons in the header of a for statement
                return new Parser.syntaxFactory.ForStatementSyntax(parseNodeData, forKeyword, openParenToken, variableDeclaration, initializer, eatToken(78 /* SemicolonToken */), tryParseForStatementCondition(), eatToken(78 /* SemicolonToken */), tryParseForStatementIncrementor(), eatToken(73 /* CloseParenToken */), parseStatement(false));
            }
            function tryEatBreakOrContinueLabel() {
                // If there is no newline after the break keyword, then we can consume an optional 
                // identifier.
                var identifier = null;
                if (!canEatExplicitOrAutomaticSemicolon(false)) {
                    if (isIdentifier(currentToken())) {
                        return eatIdentifierToken();
                    }
                }
                return null;
            }
            function parseBreakStatement(breakKeyword) {
                return new Parser.syntaxFactory.BreakStatementSyntax(parseNodeData, consumeToken(breakKeyword), tryEatBreakOrContinueLabel(), eatExplicitOrAutomaticSemicolon(false));
            }
            function parseContinueStatement(continueKeyword) {
                return new Parser.syntaxFactory.ContinueStatementSyntax(parseNodeData, consumeToken(continueKeyword), tryEatBreakOrContinueLabel(), eatExplicitOrAutomaticSemicolon(false));
            }
            function parseSwitchStatement(switchKeyword) {
                // Debug.assert(isSwitchStatement());
                consumeToken(switchKeyword);
                var openParenToken = eatToken(72 /* OpenParenToken */);
                var expression = parseExpression(true);
                var closeParenToken = eatToken(73 /* CloseParenToken */);
                var openBraceToken = eatToken(70 /* OpenBraceToken */);
                var switchClauses = TypeScript.Syntax.emptyList();
                if (openBraceToken.fullWidth() > 0) {
                    var skippedTokens = getArray();
                    switchClauses = parseSyntaxList(3 /* SwitchStatement_SwitchClauses */, skippedTokens);
                    openBraceToken = addSkippedTokensAfterToken(openBraceToken, skippedTokens);
                }
                return new Parser.syntaxFactory.SwitchStatementSyntax(parseNodeData, switchKeyword, openParenToken, expression, closeParenToken, openBraceToken, switchClauses, eatToken(71 /* CloseBraceToken */));
            }
            function isSwitchClause() {
                if (TypeScript.SyntaxUtilities.isSwitchClause(currentNode())) {
                    return true;
                }
                var currentTokenKind = currentToken().kind();
                return currentTokenKind === 16 /* CaseKeyword */ || currentTokenKind === 20 /* DefaultKeyword */;
            }
            function tryParseSwitchClause() {
                // Debug.assert(isSwitchClause());
                var node = currentNode();
                if (TypeScript.SyntaxUtilities.isSwitchClause(node)) {
                    consumeNode(node);
                    return node;
                }
                var _currentToken = currentToken();
                var kind = _currentToken.kind();
                if (kind === 16 /* CaseKeyword */) {
                    return parseCaseSwitchClause(_currentToken);
                }
                else if (kind === 20 /* DefaultKeyword */) {
                    return parseDefaultSwitchClause(_currentToken);
                }
                else {
                    return null;
                }
            }
            function parseCaseSwitchClause(caseKeyword) {
                // Debug.assert(isCaseSwitchClause());
                consumeToken(caseKeyword);
                var expression = parseExpression(true);
                var colonToken = eatToken(106 /* ColonToken */);
                var statements = TypeScript.Syntax.emptyList();
                // TODO: allow parsing of the list evne if there's no colon.  However, we have to make 
                // sure we add any skipped tokens to the right previous node or token.
                if (colonToken.fullWidth() > 0) {
                    var skippedTokens = getArray();
                    statements = parseSyntaxList(4 /* SwitchClause_Statements */, skippedTokens);
                    colonToken = addSkippedTokensAfterToken(colonToken, skippedTokens);
                }
                return new Parser.syntaxFactory.CaseSwitchClauseSyntax(parseNodeData, caseKeyword, expression, colonToken, statements);
            }
            function parseDefaultSwitchClause(defaultKeyword) {
                // Debug.assert(isDefaultSwitchClause());
                consumeToken(defaultKeyword);
                var colonToken = eatToken(106 /* ColonToken */);
                var statements = TypeScript.Syntax.emptyList();
                // TODO: Allow parsing without a colon here.  However, ensure that we attach any skipped 
                // tokens to the defaultKeyword.
                if (colonToken.fullWidth() > 0) {
                    var skippedTokens = getArray();
                    statements = parseSyntaxList(4 /* SwitchClause_Statements */, skippedTokens);
                    colonToken = addSkippedTokensAfterToken(colonToken, skippedTokens);
                }
                return new Parser.syntaxFactory.DefaultSwitchClauseSyntax(parseNodeData, defaultKeyword, colonToken, statements);
            }
            function parseThrowStatementExpression() {
                // Because of automatic semicolon insertion, we need to report error if this 
                // throw could be terminated with a semicolon.  Note: we can't call 'parseExpression'
                // directly as that might consume an expression on the following line.  
                return canEatExplicitOrAutomaticSemicolon(false) ? createMissingToken(11 /* IdentifierName */, null) : parseExpression(true);
            }
            function parseThrowStatement(throwKeyword) {
                return new Parser.syntaxFactory.ThrowStatementSyntax(parseNodeData, consumeToken(throwKeyword), parseThrowStatementExpression(), eatExplicitOrAutomaticSemicolon(false));
            }
            function tryParseReturnStatementExpression() {
                return !canEatExplicitOrAutomaticSemicolon(false) ? parseExpression(true) : null;
            }
            function parseReturnStatement(returnKeyword) {
                return new Parser.syntaxFactory.ReturnStatementSyntax(parseNodeData, consumeToken(returnKeyword), tryParseReturnStatementExpression(), eatExplicitOrAutomaticSemicolon(false));
            }
            function isExpressionStatement(currentToken) {
                // As per the gramar, neither { nor 'function' can start an expression statement.
                var tokenKind = currentToken.kind();
                return tokenKind !== 70 /* OpenBraceToken */ && tokenKind !== 27 /* FunctionKeyword */ && isExpression(currentToken);
            }
            function isAssignmentOrOmittedExpression() {
                var _currentToken = currentToken();
                return _currentToken.kind() === 79 /* CommaToken */ || isExpression(_currentToken);
            }
            function tryParseAssignmentOrOmittedExpression() {
                // Debug.assert(isAssignmentOrOmittedExpression());
                if (currentToken().kind() === 79 /* CommaToken */) {
                    return new Parser.syntaxFactory.OmittedExpressionSyntax(parseNodeData);
                }
                return tryParseAssignmentExpressionOrHigher(false, true);
            }
            function isExpression(currentToken) {
                switch (currentToken.kind()) {
                    case 13 /* NumericLiteral */:
                    case 14 /* StringLiteral */:
                    case 12 /* RegularExpressionLiteral */:
                    case 74 /* OpenBracketToken */:
                    case 72 /* OpenParenToken */:
                    case 80 /* LessThanToken */:
                    case 93 /* PlusPlusToken */:
                    case 94 /* MinusMinusToken */:
                    case 89 /* PlusToken */:
                    case 90 /* MinusToken */:
                    case 102 /* TildeToken */:
                    case 101 /* ExclamationToken */:
                    case 70 /* OpenBraceToken */:
                    case 85 /* EqualsGreaterThanToken */:
                    case 118 /* SlashToken */:
                    case 119 /* SlashEqualsToken */:
                    case 50 /* SuperKeyword */:
                    case 35 /* ThisKeyword */:
                    case 37 /* TrueKeyword */:
                    case 24 /* FalseKeyword */:
                    case 32 /* NullKeyword */:
                    case 31 /* NewKeyword */:
                    case 21 /* DeleteKeyword */:
                    case 41 /* VoidKeyword */:
                    case 39 /* TypeOfKeyword */:
                    case 27 /* FunctionKeyword */:
                        return true;
                }
                return isIdentifier(currentToken);
            }
            function parseExpressionStatement() {
                return new Parser.syntaxFactory.ExpressionStatementSyntax(parseNodeData, parseExpression(true), eatExplicitOrAutomaticSemicolon(false));
            }
            function parseIfStatement(ifKeyword) {
                return new Parser.syntaxFactory.IfStatementSyntax(parseNodeData, consumeToken(ifKeyword), eatToken(72 /* OpenParenToken */), parseExpression(true), eatToken(73 /* CloseParenToken */), parseStatement(false), parseOptionalElseClause());
            }
            function parseOptionalElseClause() {
                return currentToken().kind() === 23 /* ElseKeyword */ ? parseElseClause() : null;
            }
            function parseElseClause() {
                return new Parser.syntaxFactory.ElseClauseSyntax(parseNodeData, eatToken(23 /* ElseKeyword */), parseStatement(false));
            }
            function isVariableStatement(modifierCount) {
                return peekToken(modifierCount).kind() === 40 /* VarKeyword */;
            }
            function parseVariableStatement() {
                return new Parser.syntaxFactory.VariableStatementSyntax(parseNodeData, parseModifiers(), parseVariableDeclaration(true), eatExplicitOrAutomaticSemicolon(false));
            }
            function parseVariableDeclaration(allowIn) {
                // Debug.assert(currentToken().kind() === SyntaxKind.VarKeyword);
                var varKeyword = eatToken(40 /* VarKeyword */);
                // Debug.assert(varKeyword.fullWidth() > 0);
                var listParsingState = allowIn ? 12 /* VariableDeclaration_VariableDeclarators_AllowIn */ : 13 /* VariableDeclaration_VariableDeclarators_DisallowIn */;
                var skippedTokens = getArray();
                var variableDeclarators = parseSeparatedSyntaxList(listParsingState, skippedTokens);
                varKeyword = addSkippedTokensAfterToken(varKeyword, skippedTokens);
                return new Parser.syntaxFactory.VariableDeclarationSyntax(parseNodeData, varKeyword, variableDeclarators);
            }
            function isVariableDeclarator() {
                var node = currentNode();
                if (node !== null && node.kind() === 226 /* VariableDeclarator */) {
                    return true;
                }
                return isIdentifier(currentToken());
            }
            function canReuseVariableDeclaratorNode(node) {
                if (node === null || node.kind() !== 226 /* VariableDeclarator */) {
                    return false;
                }
                // Very subtle incremental parsing bug.  Consider the following code:
                //
                //      var v = new List < A, B
                //
                // This is actually legal code.  It's a list of variable declarators "v = new List<A" 
                // on one side and "B" on the other. If you then change that to:
                //
                //      var v = new List < A, B >()
                // 
                // then we have a problem.  "v = new List<A" doesn't intersect the change range, so we
                // start reparsing at "B" and we completely fail to handle this properly.
                //
                // In order to prevent this, we do not allow a variable declarator to be reused if it
                // has an initializer.
                var variableDeclarator = node;
                return variableDeclarator.equalsValueClause === null;
            }
            function tryParseVariableDeclarator(allowIn, allowPropertyName) {
                // TODO(cyrusn): What if the 'allowIn' context has changed between when we last parsed 
                // and now?  We could end up with an incorrect tree.  For example, say we had in the old 
                // tree "var i = a in b".  Then, in the new tree the declarator portion moved into:
                // "for (var i = a in b".  We would not want to reuse the declarator as the "in b" portion 
                // would need to be consumed by the for declaration instead.  Need to see if it is possible
                // to hit this case.
                var node = currentNode();
                if (canReuseVariableDeclaratorNode(node)) {
                    consumeNode(node);
                    return node;
                }
                if (allowPropertyName) {
                }
                if (!allowPropertyName && !isIdentifier(currentToken())) {
                    return null;
                }
                var propertyName = allowPropertyName ? eatPropertyName() : eatIdentifierToken();
                var equalsValueClause = null;
                var typeAnnotation = null;
                if (propertyName.fullWidth() > 0) {
                    typeAnnotation = parseOptionalTypeAnnotation(false);
                    if (isEqualsValueClause(false)) {
                        equalsValueClause = parseEqualsValueClause(allowIn);
                    }
                }
                return new Parser.syntaxFactory.VariableDeclaratorSyntax(parseNodeData, propertyName, typeAnnotation, equalsValueClause);
            }
            function isEqualsValueClause(inParameter) {
                var token0 = currentToken();
                if (token0.kind() === 107 /* EqualsToken */) {
                    return true;
                }
                // It's not uncommon during typing for the user to miss writing the '=' token.  Check if
                // there is no newline after the last token and if we're on an expression.  If so, parse
                // this as an equals-value clause with a missing equals.
                if (!previousTokenHasTrailingNewLine(token0)) {
                    var tokenKind = token0.kind();
                    // The 'isExpression' call below returns true for "=>".  That's because it smartly
                    // assumes that there is just a missing identifier and the user wanted a lambda.  
                    // While this is sensible, we don't want to allow that here as that would mean we're
                    // glossing over multiple erorrs and we're probably making things worse.  So don't
                    // treat this as an equals value clause and let higher up code handle things.
                    if (tokenKind === 85 /* EqualsGreaterThanToken */) {
                        return false;
                    }
                    // There are two places where we allow equals-value clauses.  The first is in a 
                    // variable declarator.  The second is with a parameter.  For variable declarators
                    // it's more likely that a { would be a allowed (as an object literal).  While this
                    // is also allowed for parameters, the risk is that we consume the { as an object
                    // literal when it really will be for the block following the parameter.
                    if (tokenKind === 70 /* OpenBraceToken */ && inParameter) {
                        return false;
                    }
                    return isExpression(token0);
                }
                return false;
            }
            function parseEqualsValueClause(allowIn) {
                return new Parser.syntaxFactory.EqualsValueClauseSyntax(parseNodeData, eatToken(107 /* EqualsToken */), tryParseAssignmentExpressionOrHigher(true, allowIn));
            }
            function parseExpression(allowIn) {
                // Expression[in]:
                //      AssignmentExpression[in] 
                //      Expression[in] , AssignmentExpression[in]
                var leftOperand = tryParseAssignmentExpressionOrHigher(true, allowIn);
                while (true) {
                    var _currentToken = currentToken();
                    if (_currentToken.kind() !== 79 /* CommaToken */) {
                        break;
                    }
                    leftOperand = new Parser.syntaxFactory.BinaryExpressionSyntax(parseNodeData, leftOperand, consumeToken(_currentToken), tryParseAssignmentExpressionOrHigher(true, allowIn));
                }
                return leftOperand;
            }
            // Called when you need to parse an expression, but you do not want to allow 'CommaExpressions'.
            // i.e. if you have "var a = 1, b = 2" then when we parse '1' we want to parse with higher 
            // precedence than 'comma'.  Otherwise we'll get: "var a = (1, (b = 2))", instead of
            // "var a = (1), b = (2)");
            function tryParseAssignmentExpressionOrHigher(force, allowIn) {
                // Augmented by TypeScript:
                //
                //  AssignmentExpression[in]:
                //      1) ConditionalExpression[in]
                //      2) LeftHandSideExpression = AssignmentExpression[in]
                //      3) LeftHandSideExpression AssignmentOperator AssignmentExpression[in]
                //      4) ArrowFunctionExpression <-- added by TypeScript
                //
                // Open spec question.  Right now, there is no 'ArrowFunctionExpression[in]' variant.
                // Thus, if the user has:
                //
                //      for (var a = () => b in c) {}
                //
                // Then we will fail to parse (because the 'in' will be consumed as part of the body of
                // the lambda, and not as part of the 'for' statement).  This is likely not an issue
                // whatsoever as there seems to be no good reason why anyone would ever write code like
                // the above.
                //
                // Note: for ease of implementation we treat productions '2' and '3' as the same thing. 
                // (i.e. they're both BinaryExpressions with an assignment operator in it).
                // First, check if we have production '4' (an arrow function).  Note that if we do, we
                // must *not* recurse for productsion 1, 2 or 3. An ArrowFunction is not a 
                // LeftHandSideExpression, nor does it start a ConditionalExpression.  So we are done 
                // with AssignmentExpression if we see one.
                var _currentToken = currentToken();
                var arrowFunction = tryParseAnyArrowFunctionExpression(_currentToken);
                if (arrowFunction !== null) {
                    return arrowFunction;
                }
                // Now try to see if we're in production '1', '2' or '3'.  A conditional expression can
                // start with a LogicalOrExpression, while the assignment productions can only start with
                // LeftHandSideExpressions.
                //
                // So, first, we try to just parse out a BinaryExpression.  If we get something that is a 
                // LeftHandSide or higher, then we can try to parse out the assignment expression part.  
                // Otherwise, we try to parse out the conditional expression bit.  We want to allow any 
                // binary expression here, so we pass in the 'lowest' precedence here so that it matches
                // and consumes anything.
                var leftOperand = tryParseBinaryExpressionOrHigher(_currentToken, force, 1 /* Lowest */, allowIn);
                if (leftOperand === null) {
                    return null;
                }
                if (TypeScript.SyntaxUtilities.isLeftHandSizeExpression(leftOperand)) {
                    // Note: we call currentOperatorToken so that we get an appropriately merged token
                    // for cases like > > =  becoming >>=
                    var operatorToken = currentOperatorToken();
                    // Check for recursive assignment expressions.
                    if (TypeScript.SyntaxFacts.isAssignmentOperatorToken(operatorToken.kind())) {
                        return new Parser.syntaxFactory.BinaryExpressionSyntax(parseNodeData, leftOperand, consumeToken(operatorToken), tryParseAssignmentExpressionOrHigher(true, allowIn));
                    }
                }
                // It wasn't an assignment or a lambda.  This is a conditional expression:
                return parseConditionalExpressionRest(allowIn, leftOperand);
            }
            function tryParseAnyArrowFunctionExpression(_currentToken) {
                return isSimpleArrowFunctionExpression(_currentToken) ? parseSimpleArrowFunctionExpression() : tryParseParenthesizedArrowFunctionExpression();
            }
            function tryParseUnaryExpressionOrHigher(_currentToken, force) {
                var currentTokenKind = _currentToken.kind();
                switch (currentTokenKind) {
                    case 89 /* PlusToken */:
                    case 90 /* MinusToken */:
                    case 102 /* TildeToken */:
                    case 101 /* ExclamationToken */:
                    case 93 /* PlusPlusToken */:
                    case 94 /* MinusMinusToken */:
                        return new Parser.syntaxFactory.PrefixUnaryExpressionSyntax(parseNodeData, consumeToken(_currentToken), tryParseUnaryExpressionOrHigher(currentToken(), true));
                    case 39 /* TypeOfKeyword */:
                        return parseTypeOfExpression(_currentToken);
                    case 41 /* VoidKeyword */:
                        return parseVoidExpression(_currentToken);
                    case 21 /* DeleteKeyword */:
                        return parseDeleteExpression(_currentToken);
                    case 80 /* LessThanToken */:
                        return parseCastExpression(_currentToken);
                    default:
                        return tryParsePostfixExpressionOrHigher(_currentToken, force);
                }
            }
            function tryParseBinaryExpressionOrHigher(_currentToken, force, precedence, allowIn) {
                // The binary expressions are incredibly left recursive in their definitions. We 
                // clearly can't implement that through recursion.  So, instead, we first bottom out 
                // of all the recursion by jumping to this production and consuming a UnaryExpression 
                // first.
                //
                // MultiplicativeExpression: See 11.5 
                //      UnaryExpression 
                var leftOperand = tryParseUnaryExpressionOrHigher(_currentToken, force);
                if (leftOperand === null) {
                    return null;
                }
                // We then pop up the stack consuming the other side of the binary exprssion if it exists.
                return parseBinaryExpressionRest(precedence, allowIn, leftOperand);
            }
            function parseConditionalExpressionRest(allowIn, leftOperand) {
                // Note: we are passed in an expression which was produced from parseBinaryExpressionOrHigher.
                var _currentToken = currentToken();
                // Now check for conditional expression.
                if (_currentToken.kind() !== 105 /* QuestionToken */) {
                    return leftOperand;
                }
                // Note: we explicitly do *not* pass 'allowIn' to the whenTrue part.  An 'in' expression is always
                // allowed in the 'true' part of a conditional expression.
                return new Parser.syntaxFactory.ConditionalExpressionSyntax(parseNodeData, leftOperand, consumeToken(_currentToken), tryParseAssignmentExpressionOrHigher(true, true), eatToken(106 /* ColonToken */), tryParseAssignmentExpressionOrHigher(true, allowIn));
            }
            function parseBinaryExpressionRest(precedence, allowIn, leftOperand) {
                while (true) {
                    // We either have a binary operator here, or we're finished.  We call 
                    // currentOperatorToken versus currentToken here so that we merge token sequences
                    // like > and = into >=
                    var operatorToken = currentOperatorToken();
                    var tokenKind = operatorToken.kind();
                    // Only proceed if we see binary expression token.  However we don't parse 
                    // assignment expressions or comma expressions here.  Those are taken care of 
                    // respectively in parseAssignmentExpression and parseExpression.
                    if (!TypeScript.SyntaxFacts.isBinaryExpressionOperatorToken(tokenKind) || tokenKind === 79 /* CommaToken */ || TypeScript.SyntaxFacts.isAssignmentOperatorToken(tokenKind)) {
                        break;
                    }
                    // also, if it's the 'in' operator, only allow if our caller allows it.
                    if (tokenKind === 29 /* InKeyword */ && !allowIn) {
                        break;
                    }
                    var newPrecedence = getBinaryExpressionPrecedence(tokenKind);
                    // All binary operators must have precedence > 0
                    // Debug.assert(newPrecedence > 0);
                    // Check the precedence to see if we should "take" this operator
                    if (newPrecedence <= precedence) {
                        break;
                    }
                    // Precedence is okay, so we'll "take" this operator.
                    // Now skip the operator token we're on.
                    leftOperand = new Parser.syntaxFactory.BinaryExpressionSyntax(parseNodeData, leftOperand, consumeToken(operatorToken), tryParseBinaryExpressionOrHigher(currentToken(), true, newPrecedence, allowIn));
                }
                return leftOperand;
            }
            function currentOperatorToken() {
                var token0 = currentToken();
                // If we see a > we need to see if we can actually merge this contextually into a 
                // >>  >>>  >=  >>=  >>>=  token.
                if (token0.kind() === 81 /* GreaterThanToken */) {
                    return currentContextualToken();
                }
                return token0;
            }
            function tryParseMemberExpressionOrHigher(_currentToken, force, inObjectCreation) {
                // Note: to make our lives simpler, we decompose the the NewExpression productions and
                // place ObjectCreationExpression and FunctionExpression into PrimaryExpression.
                // like so:
                //
                //   PrimaryExpression : See 11.1 
                //      this
                //      Identifier
                //      Literal
                //      ArrayLiteral
                //      ObjectLiteral
                //      (Expression) 
                //      FunctionExpression
                //      new MemberExpression Arguments?
                //
                //   MemberExpression : See 11.2 
                //      PrimaryExpression 
                //      MemberExpression[Expression]
                //      MemberExpression.IdentifierName
                //
                //   CallExpression : See 11.2 
                //      MemberExpression 
                //      CallExpression Arguments
                //      CallExpression[Expression]
                //      CallExpression.IdentifierName 
                //
                // Technically this is ambiguous.  i.e. CallExpression defines:
                //
                //   CallExpression:
                //      CallExpression Arguments
                // 
                // If you see: "new Foo()"
                //
                // Then that could be treated as a single ObjectCreationExpression, or it could be 
                // treated as the invocation of "new Foo".  We disambiguate that in code (to match
                // the original grammar) by making sure that if we see an ObjectCreationExpression
                // we always consume arguments if they are there. So we treat "new Foo()" as an
                // object creation only, and not at all as an invocation)  Another way to think 
                // about this is that for every "new" that we see, we will consume an argument list if
                // it is there as part of the *associated* object creation node.  Any additional
                // argument lists we see, will become invocation expressions.
                //
                // Because there are no other places in the grammar now that refer to FunctionExpression
                // or ObjectCreationExpression, it is safe to push down into the PrimaryExpression
                // production.
                //
                // Because CallExpression and MemberExpression are left recursive, we need to bottom out
                // of the recursion immediately.  So we parse out a primary expression to start with.
                var expression = tryParsePrimaryExpression(_currentToken, force);
                if (expression === null) {
                    return null;
                }
                return parseMemberExpressionRest(expression, inObjectCreation);
            }
            function parseCallExpressionRest(expression) {
                while (true) {
                    var _currentToken = currentToken();
                    var currentTokenKind = _currentToken.kind();
                    switch (currentTokenKind) {
                        case 72 /* OpenParenToken */:
                            expression = new Parser.syntaxFactory.InvocationExpressionSyntax(parseNodeData, expression, parseArgumentList(null));
                            continue;
                        case 80 /* LessThanToken */:
                            // See if this is the start of a generic invocation.  If so, consume it and
                            // keep checking for postfix expressions.  Otherwise, it's just a '<' that's 
                            // part of an arithmetic expression.  Break out so we consume it higher in the
                            // stack.
                            var argumentList = tryParseArgumentList();
                            if (argumentList === null) {
                                break;
                            }
                            expression = new Parser.syntaxFactory.InvocationExpressionSyntax(parseNodeData, expression, argumentList);
                            continue;
                        case 74 /* OpenBracketToken */:
                            expression = parseElementAccessExpression(expression, _currentToken, false);
                            continue;
                        case 76 /* DotToken */:
                            expression = new Parser.syntaxFactory.MemberAccessExpressionSyntax(parseNodeData, expression, consumeToken(_currentToken), eatIdentifierNameToken());
                            continue;
                    }
                    return expression;
                }
            }
            function parseMemberExpressionRest(expression, inObjectCreation) {
                while (true) {
                    var _currentToken = currentToken();
                    var currentTokenKind = _currentToken.kind();
                    switch (currentTokenKind) {
                        case 74 /* OpenBracketToken */:
                            expression = parseElementAccessExpression(expression, _currentToken, inObjectCreation);
                            continue;
                        case 76 /* DotToken */:
                            expression = new Parser.syntaxFactory.MemberAccessExpressionSyntax(parseNodeData, expression, consumeToken(_currentToken), eatIdentifierNameToken());
                            continue;
                    }
                    return expression;
                }
            }
            function tryParseLeftHandSideExpressionOrHigher(_currentToken, force) {
                // Original Ecma:
                // LeftHandSideExpression: See 11.2 
                //      NewExpression
                //      CallExpression 
                //
                // Our simplification:
                //
                // LeftHandSideExpression: See 11.2 
                //      MemberExpression  
                //      CallExpression 
                //
                // See comment in parseMemberExpressionOrHigher on how we replaced NewExpression with
                // MemberExpression to make our lives easier.
                //
                // to best understand the below code, it's important to see how CallExpression expands
                // out into its own productions:
                //
                // CallExpression:
                //      MemberExpression Arguments 
                //      CallExpression Arguments
                //      CallExpression[Expression]
                //      CallExpression.IdentifierName
                //      super   (   ArgumentListopt   )
                //      super.IdentifierName
                //
                // Because of the recursion in these calls, we need to bottom out first.  There are two 
                // bottom out states we can run into.  Either we see 'super' which must start either of
                // the last two CallExpression productions.  Or we have a MemberExpression which either
                // completes the LeftHandSideExpression, or starts the beginning of the first four
                // CallExpression productions.
                var expression = null;
                if (_currentToken.kind() === 50 /* SuperKeyword */) {
                    expression = parseSuperExpression(_currentToken);
                }
                else {
                    expression = tryParseMemberExpressionOrHigher(_currentToken, force, false);
                    if (expression === null) {
                        return null;
                    }
                }
                // Now, we *may* be complete.  However, we might have consumed the start of a 
                // CallExpression.  As such, we need to consume the rest of it here to be complete.
                return parseCallExpressionRest(expression);
            }
            function parseSuperExpression(superToken) {
                var expression = consumeToken(superToken);
                // If we have seen "super" it must be followed by '(' or '.'.
                // If it wasn't then just try to parse out a '.' and report an error.
                var currentTokenKind = currentToken().kind();
                return currentTokenKind === 72 /* OpenParenToken */ || currentTokenKind === 76 /* DotToken */ ? expression : new Parser.syntaxFactory.MemberAccessExpressionSyntax(parseNodeData, expression, eatToken(76 /* DotToken */), eatIdentifierNameToken());
            }
            function tryParsePostfixExpressionOrHigher(_currentToken, force) {
                var expression = tryParseLeftHandSideExpressionOrHigher(_currentToken, force);
                if (expression === null) {
                    return null;
                }
                var _currentToken = currentToken();
                var currentTokenKind = _currentToken.kind();
                switch (currentTokenKind) {
                    case 93 /* PlusPlusToken */:
                    case 94 /* MinusMinusToken */:
                        // Because of automatic semicolon insertion, we should only consume the ++ or -- 
                        // if it is on the same line as the previous token.
                        if (previousTokenHasTrailingNewLine(_currentToken)) {
                            break;
                        }
                        return new Parser.syntaxFactory.PostfixUnaryExpressionSyntax(parseNodeData, expression, consumeToken(_currentToken));
                }
                return expression;
            }
            function tryParseGenericArgumentList() {
                // Debug.assert(currentToken().kind() === SyntaxKind.LessThanToken);
                // If we have a '<', then only parse this as a arugment list if the type arguments
                // are complete and we have an open paren.  if we don't, rewind and return nothing.
                var rewindPoint = getRewindPoint();
                var typeArgumentList = tryParseTypeArgumentList(true);
                var token0 = currentToken();
                var tokenKind = token0.kind();
                var isOpenParen = tokenKind === 72 /* OpenParenToken */;
                var isDot = tokenKind === 76 /* DotToken */;
                var isOpenParenOrDot = isOpenParen || isDot;
                var argumentList = null;
                if (typeArgumentList === null || !isOpenParenOrDot) {
                    // Wasn't generic.  Rewind to where we started so this can be parsed as an 
                    // arithmetic expression.
                    rewind(rewindPoint);
                    releaseRewindPoint(rewindPoint);
                    return null;
                }
                else {
                    releaseRewindPoint(rewindPoint);
                    // It's not uncommon for a user to type: "Foo<T>."
                    //
                    // This is not legal in typescript (as an parameter list must follow the type
                    // arguments).  We want to give a good error message for this as otherwise
                    // we'll bail out here and give a poor error message when we try to parse this
                    // as an arithmetic expression.
                    if (isDot) {
                        // A parameter list must follow a generic type argument list.
                        var diagnostic = new TypeScript.Diagnostic(fileName, source.text.lineMap(), TypeScript.start(token0, source.text), TypeScript.width(token0), TypeScript.DiagnosticCode.A_parameter_list_must_follow_a_generic_type_argument_list_expected, null);
                        addDiagnostic(diagnostic);
                        return new Parser.syntaxFactory.ArgumentListSyntax(parseNodeData, typeArgumentList, TypeScript.Syntax.emptyToken(72 /* OpenParenToken */), TypeScript.Syntax.emptySeparatedList(), TypeScript.Syntax.emptyToken(73 /* CloseParenToken */));
                    }
                    else {
                        return parseArgumentList(typeArgumentList);
                    }
                }
            }
            function tryParseArgumentList() {
                var tokenKind = currentToken().kind();
                if (tokenKind === 80 /* LessThanToken */) {
                    return tryParseGenericArgumentList();
                }
                if (tokenKind === 72 /* OpenParenToken */) {
                    return parseArgumentList(null);
                }
                return null;
            }
            function parseArgumentList(typeArgumentList) {
                var openParenToken = eatToken(72 /* OpenParenToken */);
                // Don't use the name 'arguments' it prevents V8 from optimizing this method.
                var _arguments = TypeScript.Syntax.emptySeparatedList();
                if (openParenToken.fullWidth() > 0) {
                    var skippedTokens = getArray();
                    _arguments = parseSeparatedSyntaxList(14 /* ArgumentList_AssignmentExpressions */, skippedTokens);
                    openParenToken = addSkippedTokensAfterToken(openParenToken, skippedTokens);
                }
                return new Parser.syntaxFactory.ArgumentListSyntax(parseNodeData, typeArgumentList, openParenToken, _arguments, eatToken(73 /* CloseParenToken */));
            }
            function tryParseArgumentListExpression() {
                // Generally while parsing lists, we don't want to 'force' the parser to parse
                // the item.  That way, if the expected item isn't htere, we can bail out and
                // move to a higher stage of list parsing.  However, it's extremely common to 
                // see something like "Foo(, a".  in this case, even though there isn't an expression
                // after the open paren, we still want to force parsing an expression (which will
                // cause a missing identiifer to be created), so that we will then consume the
                // comma and the following list items).
                var force = currentToken().kind() === 79 /* CommaToken */;
                return tryParseAssignmentExpressionOrHigher(force, true);
            }
            function parseElementAccessArgumentExpression(openBracketToken, inObjectCreation) {
                // It's not uncommon for a user to write: "new Type[]".  Check for that common pattern
                // and report a better error message.
                if (inObjectCreation && currentToken().kind() === 75 /* CloseBracketToken */) {
                    var errorStart = TypeScript.start(openBracketToken, source.text);
                    var errorEnd = TypeScript.end(currentToken(), source.text);
                    var diagnostic = new TypeScript.Diagnostic(fileName, source.text.lineMap(), errorStart, errorEnd - errorStart, TypeScript.DiagnosticCode.new_T_cannot_be_used_to_create_an_array_Use_new_Array_T_instead, null);
                    addDiagnostic(diagnostic);
                    return TypeScript.Syntax.emptyToken(11 /* IdentifierName */);
                }
                else {
                    return parseExpression(true);
                }
            }
            function parseElementAccessExpression(expression, openBracketToken, inObjectCreation) {
                // Debug.assert(currentToken().kind() === SyntaxKind.OpenBracketToken);
                return new Parser.syntaxFactory.ElementAccessExpressionSyntax(parseNodeData, expression, consumeToken(openBracketToken), parseElementAccessArgumentExpression(openBracketToken, inObjectCreation), eatToken(75 /* CloseBracketToken */));
            }
            function tryParsePrimaryExpression(_currentToken, force) {
                if (isIdentifier(_currentToken)) {
                    return eatIdentifierToken();
                }
                var currentTokenKind = _currentToken.kind();
                switch (currentTokenKind) {
                    case 35 /* ThisKeyword */:
                    case 37 /* TrueKeyword */:
                    case 24 /* FalseKeyword */:
                    case 32 /* NullKeyword */:
                    case 13 /* NumericLiteral */:
                    case 12 /* RegularExpressionLiteral */:
                    case 14 /* StringLiteral */:
                        return consumeToken(_currentToken);
                    case 27 /* FunctionKeyword */:
                        return parseFunctionExpression(_currentToken);
                    case 74 /* OpenBracketToken */:
                        return parseArrayLiteralExpression(_currentToken);
                    case 70 /* OpenBraceToken */:
                        return parseObjectLiteralExpression(_currentToken);
                    case 72 /* OpenParenToken */:
                        return parseParenthesizedExpression(_currentToken);
                    case 31 /* NewKeyword */:
                        return parseObjectCreationExpression(_currentToken);
                    case 118 /* SlashToken */:
                    case 119 /* SlashEqualsToken */:
                        // If we see a standalone / or /= and we're expecting a term, then try to reparse
                        // it as a regular expression.
                        var result = tryReparseDivideAsRegularExpression();
                        // If we get a result, then use it. Otherwise, create a missing identifier so
                        // that parsing can continue.  Note: we do this even if 'force' is false.  That's
                        // because we *do* want to consider a standalone / as an expression that should be
                        // returned from tryParseExpression even when 'force' is set to false.
                        return result || eatIdentifierToken(TypeScript.DiagnosticCode.Expression_expected);
                }
                if (!force) {
                    return null;
                }
                // Nothing else worked, report an error and produce a missing token.
                return eatIdentifierToken(TypeScript.DiagnosticCode.Expression_expected);
            }
            function tryReparseDivideAsRegularExpression() {
                // If we see a / or /= token, then that may actually be the start of a regex in certain 
                // contexts.
                // var currentToken = this.currentToken();
                // Debug.assert(SyntaxFacts.isAnyDivideToken(currentToken.kind()));
                // Ok, from our quick lexical check, this could be a place where a regular expression could
                // go.  Now we have to do a bunch of work.  Ask the source to retrive the token at the 
                // current position again.  But this time allow it to retrieve it as a regular expression.
                var currentToken = currentContextualToken();
                // Note: we *must* have gotten a /, /= or regular expression.  Or else something went *very*
                // wrong with our logic above.
                // Debug.assert(SyntaxFacts.isAnyDivideOrRegularExpressionToken(currentToken.kind()));
                var tokenKind = currentToken.kind();
                if (tokenKind === 118 /* SlashToken */ || tokenKind === 119 /* SlashEqualsToken */) {
                    // Still came back as a / or /=.   This is not a regular expression literal.
                    return null;
                }
                else if (tokenKind === 12 /* RegularExpressionLiteral */) {
                    return consumeToken(currentToken);
                }
                else {
                    throw TypeScript.Errors.invalidOperation();
                }
            }
            function parseTypeOfExpression(typeOfKeyword) {
                return new Parser.syntaxFactory.TypeOfExpressionSyntax(parseNodeData, consumeToken(typeOfKeyword), tryParseUnaryExpressionOrHigher(currentToken(), true));
            }
            function parseDeleteExpression(deleteKeyword) {
                return new Parser.syntaxFactory.DeleteExpressionSyntax(parseNodeData, consumeToken(deleteKeyword), tryParseUnaryExpressionOrHigher(currentToken(), true));
            }
            function parseVoidExpression(voidKeyword) {
                return new Parser.syntaxFactory.VoidExpressionSyntax(parseNodeData, consumeToken(voidKeyword), tryParseUnaryExpressionOrHigher(currentToken(), true));
            }
            function parseFunctionExpression(functionKeyword) {
                return new Parser.syntaxFactory.FunctionExpressionSyntax(parseNodeData, consumeToken(functionKeyword), eatOptionalIdentifierToken(), parseCallSignature(false), parseBlock(false, true));
            }
            function parseObjectCreationExpression(newKeyword) {
                // ObjectCreationExpression
                //      new MemberExpression Arguments?
                //
                // Note: if we see arguments we absolutely take them and attach them tightly to this
                // object creation expression.
                //
                // See comment in tryParseMemberExpressionOrHigher for a more complete explanation of
                // this decision.
                return new Parser.syntaxFactory.ObjectCreationExpressionSyntax(parseNodeData, consumeToken(newKeyword), tryParseMemberExpressionOrHigher(currentToken(), true, true), tryParseArgumentList());
            }
            function parseCastExpression(lessThanToken) {
                return new Parser.syntaxFactory.CastExpressionSyntax(parseNodeData, consumeToken(lessThanToken), parseType(), eatToken(81 /* GreaterThanToken */), tryParseUnaryExpressionOrHigher(currentToken(), true));
            }
            function parseParenthesizedExpression(openParenToken) {
                return new Parser.syntaxFactory.ParenthesizedExpressionSyntax(parseNodeData, consumeToken(openParenToken), parseExpression(true), eatToken(73 /* CloseParenToken */));
            }
            function tryParseParenthesizedArrowFunctionExpression() {
                var tokenKind = currentToken().kind();
                if (tokenKind !== 72 /* OpenParenToken */ && tokenKind !== 80 /* LessThanToken */) {
                    return null;
                }
                // Because arrow functions and parenthesized expressions look similar, we have to check far
                // enough ahead to be sure we've actually got an arrow function. For example, both nodes can
                // start with:
                //    (a = b, c = d, ..., e = f).
                //So we effectively need infinite lookahead to decide which node we're in.
                //
                // First, check for things that definitely have enough information to let us know it's an
                // arrow function.
                if (isDefinitelyArrowFunctionExpression()) {
                    // We have something like "() =>" or "(a) =>".  Definitely a lambda, so parse it
                    // unilaterally as such.
                    return tryParseParenthesizedArrowFunctionExpressionWorker(false);
                }
                // Now, look for cases where we're sure it's not an arrow function.  This will help save us
                // a costly parse.
                if (!isPossiblyArrowFunctionExpression()) {
                    return null;
                }
                // Then, try to actually parse it as a arrow function, and only return if we see an => 
                var rewindPoint = getRewindPoint();
                var arrowFunction = tryParseParenthesizedArrowFunctionExpressionWorker(true);
                if (arrowFunction === null) {
                    rewind(rewindPoint);
                }
                releaseRewindPoint(rewindPoint);
                return arrowFunction;
            }
            function tryParseParenthesizedArrowFunctionExpressionWorker(requireArrow) {
                var _currentToken = currentToken();
                // Debug.assert(currentToken.kind() === SyntaxKind.OpenParenToken || currentToken.kind() === SyntaxKind.LessThanToken);
                var callSignature = parseCallSignature(true);
                if (requireArrow && currentToken().kind() !== 85 /* EqualsGreaterThanToken */) {
                    return null;
                }
                var equalsGreaterThanToken = eatToken(85 /* EqualsGreaterThanToken */);
                var block = tryParseArrowFunctionBlock();
                var expression = null;
                if (block === null) {
                    expression = tryParseAssignmentExpressionOrHigher(true, true);
                }
                return new Parser.syntaxFactory.ParenthesizedArrowFunctionExpressionSyntax(parseNodeData, callSignature, equalsGreaterThanToken, block, expression);
            }
            function tryParseArrowFunctionBlock() {
                if (isBlock()) {
                    return parseBlock(false, false);
                }
                else {
                    // We didn't have a block.  However, we may be in an error situation.  For example,
                    // if the user wrote:
                    //
                    //  a => 
                    //      var v = 0;
                    //  }
                    //
                    // (i.e. they're missing the open brace).  See if that's the case so we can try to 
                    // recover better.  If we don't do this, then the next close curly we see may end
                    // up preemptively closing the containing construct.
                    var _modifierCount = modifierCount();
                    if (isStatement(_modifierCount, false) && !isExpressionStatement(currentToken()) && !isFunctionDeclaration(_modifierCount)) {
                        // We've seen a statement (and it isn't an expressionStatement like 'foo()'), 
                        // so treat this like a block with a missing open brace.
                        return parseBlock(true, false);
                    }
                    else {
                        return null;
                    }
                }
            }
            function isSimpleArrowFunctionExpression(_currentToken) {
                // ERROR RECOVERY TWEAK:
                // If we see a standalone => try to parse it as an arrow function as that's likely what
                // the user intended to write.
                if (_currentToken.kind() === 85 /* EqualsGreaterThanToken */) {
                    return true;
                }
                return isIdentifier(_currentToken) && peekToken(1).kind() === 85 /* EqualsGreaterThanToken */;
            }
            function parseSimpleArrowFunctionExpression() {
                // Debug.assert(isSimpleArrowFunctionExpression());
                var parameter = eatSimpleParameter();
                var equalsGreaterThanToken = eatToken(85 /* EqualsGreaterThanToken */);
                var block = tryParseArrowFunctionBlock();
                var expression = null;
                if (block === null) {
                    expression = tryParseAssignmentExpressionOrHigher(true, true);
                }
                return new Parser.syntaxFactory.SimpleArrowFunctionExpressionSyntax(parseNodeData, parameter, equalsGreaterThanToken, block, expression);
            }
            function isBlock() {
                return currentToken().kind() === 70 /* OpenBraceToken */;
            }
            function isDefinitelyArrowFunctionExpression() {
                var token0 = currentToken();
                if (token0.kind() !== 72 /* OpenParenToken */) {
                    // If it didn't start with an (, then it could be generic.  That's too complicated 
                    // and we can't say it's 'definitely' an arrow function.             
                    return false;
                }
                var token1 = peekToken(1);
                var token1Kind = token1.kind();
                var token2;
                if (token1Kind === 73 /* CloseParenToken */) {
                    // ()
                    // Definitely an arrow function.  Could never be a parenthesized expression.  
                    // *However*, because of error situations, we could end up with things like "().foo".
                    // In this case, we don't want to think of this as the start of an arrow function.
                    // To prevent this, we are a little stricter, and we require that we at least see:
                    //      "():"  or  "() =>"  or "() {}".  Note: the last one is illegal.  However it
                    // most likely is a missing => and not a parenthesized expression.
                    token2 = peekToken(2);
                    var token2Kind = token2.kind();
                    return token2Kind === 106 /* ColonToken */ || token2Kind === 85 /* EqualsGreaterThanToken */ || token2Kind === 70 /* OpenBraceToken */;
                }
                if (token1Kind === 77 /* DotDotDotToken */) {
                    // (...
                    // Definitely an arrow function.  Could never be a parenthesized expression.
                    return true;
                }
                token2 = peekToken(2);
                token2Kind = token2.kind();
                if (TypeScript.SyntaxFacts.isAccessibilityModifier(token1Kind)) {
                    if (isIdentifier(token2)) {
                        // "(public id" or "(function id".  Definitely an arrow function.  Could never 
                        // be a parenthesized expression.  Note: this will be an *illegal* arrow 
                        // function (as accessibility modifiers are not allowed in it).  However, that
                        // will be reported by the grammar checker walker.
                        return true;
                    }
                }
                if (!isIdentifier(token1)) {
                    // All other arrow functions must start with (id
                    // so this is definitely not an arrow function.
                    return false;
                }
                // (id
                //
                // Lots of options here.  Check for things that make us certain it's an
                // arrow function.
                if (token2Kind === 106 /* ColonToken */) {
                    // (id:
                    // Definitely an arrow function.  Could never be a parenthesized expression.
                    return true;
                }
                var token3 = peekToken(3);
                var token3Kind = token3.kind();
                if (token2Kind === 105 /* QuestionToken */) {
                    // (id?
                    // Could be an arrow function, or a parenthesized conditional expression.
                    // Check for the things that could only be arrow functions.
                    if (token3Kind === 106 /* ColonToken */ || token3Kind === 73 /* CloseParenToken */ || token3Kind === 79 /* CommaToken */) {
                        // (id?:
                        // (id?)
                        // (id?,
                        // These are the only cases where this could be an arrow function.
                        // And none of them can be parenthesized expression.
                        return true;
                    }
                }
                if (token2Kind === 73 /* CloseParenToken */) {
                    // (id)
                    // Could be an arrow function, or a parenthesized conditional expression.
                    if (token3Kind === 85 /* EqualsGreaterThanToken */) {
                        // (id) =>
                        // Definitely an arrow function.  Could not be a parenthesized expression.
                        return true;
                    }
                }
                // TODO: Add more cases if you're sure that there is enough information to know to 
                // parse this as an arrow function.  Note: be very careful here.
                // Anything else wasn't clear enough.  Try to parse the expression as an arrow function and bail out
                // if we fail.
                return false;
            }
            function isPossiblyArrowFunctionExpression() {
                var token0 = currentToken();
                if (token0.kind() !== 72 /* OpenParenToken */) {
                    // If it didn't start with an (, then it could be generic.  That's too complicated 
                    // and we have to say it's possibly an arrow function.
                    return true;
                }
                var token1 = peekToken(1);
                if (!isIdentifier(token1)) {
                    // All other arrow functions must start with (id
                    // so this is definitely not an arrow function.
                    return false;
                }
                var token2 = peekToken(2);
                var token2Kind = token2.kind();
                if (token2Kind === 107 /* EqualsToken */) {
                    // (id =
                    //
                    // This *could* be an arrow function.  i.e. (id = 0) => { }
                    // Or it could be a parenthesized expression.  So we'll have to actually
                    // try to parse it.
                    return true;
                }
                if (token2Kind === 79 /* CommaToken */) {
                    // (id,
                    // This *could* be an arrow function.  i.e. (id, id2) => { }
                    // Or it could be a parenthesized expression (as javascript supports
                    // the comma operator).  So we'll have to actually try to parse it.
                    return true;
                }
                if (token2Kind === 73 /* CloseParenToken */) {
                    // (id)
                    var token3 = peekToken(3);
                    if (token3.kind() === 106 /* ColonToken */) {
                        // (id):
                        //
                        // This could be an arrow function. i.e. (id): number => { }
                        // Or it could be parenthesized exprssion: foo ? (id) :
                        // So we'll have to actually try to parse it.
                        return true;
                    }
                }
                // Nothing else could be an arrow function.
                return false;
            }
            function parseObjectLiteralExpression(openBraceToken) {
                // Debug.assert(currentToken().kind() === SyntaxKind.OpenBraceToken);
                consumeToken(openBraceToken);
                // Debug.assert(openBraceToken.fullWidth() > 0);
                var skippedTokens = getArray();
                var propertyAssignments = parseSeparatedSyntaxList(15 /* ObjectLiteralExpression_PropertyAssignments */, skippedTokens);
                openBraceToken = addSkippedTokensAfterToken(openBraceToken, skippedTokens);
                return new Parser.syntaxFactory.ObjectLiteralExpressionSyntax(parseNodeData, openBraceToken, propertyAssignments, eatToken(71 /* CloseBraceToken */));
            }
            function tryParsePropertyAssignment(inErrorRecovery) {
                // Debug.assert(isPropertyAssignment(/*inErrorRecovery:*/ false));
                if (isAccessor(modifierCount(), inErrorRecovery)) {
                    return parseAccessor(true);
                }
                else if (isFunctionPropertyAssignment(inErrorRecovery)) {
                    return parseFunctionPropertyAssignment();
                }
                else if (isSimplePropertyAssignment(inErrorRecovery)) {
                    return parseSimplePropertyAssignment();
                }
                else {
                    return null;
                }
            }
            function isPropertyAssignment(inErrorRecovery) {
                return isAccessor(modifierCount(), inErrorRecovery) || isFunctionPropertyAssignment(inErrorRecovery) || isSimplePropertyAssignment(inErrorRecovery);
            }
            function eatPropertyName() {
                var _currentToken = currentToken();
                return TypeScript.SyntaxFacts.isIdentifierNameOrAnyKeyword(_currentToken) ? eatIdentifierNameToken() : consumeToken(_currentToken);
            }
            function isFunctionPropertyAssignment(inErrorRecovery) {
                return isPropertyName(currentToken(), inErrorRecovery) && isCallSignature(1);
            }
            function parseFunctionPropertyAssignment() {
                return new Parser.syntaxFactory.FunctionPropertyAssignmentSyntax(parseNodeData, eatPropertyName(), parseCallSignature(false), parseBlock(false, true));
            }
            function isSimplePropertyAssignment(inErrorRecovery) {
                return isPropertyName(currentToken(), inErrorRecovery);
            }
            function parseSimplePropertyAssignment() {
                return new Parser.syntaxFactory.SimplePropertyAssignmentSyntax(parseNodeData, eatPropertyName(), eatToken(106 /* ColonToken */), tryParseAssignmentExpressionOrHigher(true, true));
            }
            function isPropertyName(token, inErrorRecovery) {
                // NOTE: we do *not* want to check "isIdentifier" here.  Any IdentifierName is 
                // allowed here, even reserved words like keywords.
                if (TypeScript.SyntaxFacts.isIdentifierNameOrAnyKeyword(token)) {
                    // Except: if we're in error recovery, then we don't want to consider keywords. 
                    // After all, if we have:
                    //
                    //      { a: 1
                    //      return
                    //
                    // we don't want consider 'return' to be the next property in the object literal.
                    if (inErrorRecovery) {
                        return isIdentifier(token);
                    }
                    else {
                        return true;
                    }
                }
                var kind = token.kind();
                return kind === 14 /* StringLiteral */ || kind === 13 /* NumericLiteral */;
            }
            function parseArrayLiteralExpression(openBracketToken) {
                // Debug.assert(currentToken().kind() === SyntaxKind.OpenBracketToken);
                consumeToken(openBracketToken);
                // Debug.assert(openBracketToken.fullWidth() > 0);
                var skippedTokens = getArray();
                var expressions = parseSeparatedSyntaxList(16 /* ArrayLiteralExpression_AssignmentExpressions */, skippedTokens);
                openBracketToken = addSkippedTokensAfterToken(openBracketToken, skippedTokens);
                return new Parser.syntaxFactory.ArrayLiteralExpressionSyntax(parseNodeData, openBracketToken, expressions, eatToken(75 /* CloseBracketToken */));
            }
            function parseBlock(parseBlockEvenWithNoOpenBrace, checkForStrictMode) {
                var openBraceToken = eatToken(70 /* OpenBraceToken */);
                var statements = TypeScript.Syntax.emptyList();
                if (parseBlockEvenWithNoOpenBrace || openBraceToken.fullWidth() > 0) {
                    var savedIsInStrictMode = isInStrictMode;
                    var processItems = checkForStrictMode ? updateStrictModeState : null;
                    var skippedTokens = getArray();
                    var statements = parseSyntaxList(5 /* Block_Statements */, skippedTokens, processItems);
                    openBraceToken = addSkippedTokensAfterToken(openBraceToken, skippedTokens);
                    setStrictMode(savedIsInStrictMode);
                }
                return new Parser.syntaxFactory.BlockSyntax(parseNodeData, openBraceToken, statements, eatToken(71 /* CloseBraceToken */));
            }
            function parseCallSignature(requireCompleteTypeParameterList) {
                return new Parser.syntaxFactory.CallSignatureSyntax(parseNodeData, tryParseTypeParameterList(requireCompleteTypeParameterList), parseParameterList(), parseOptionalTypeAnnotation(false));
            }
            function tryParseTypeParameterList(requireCompleteTypeParameterList) {
                var _currentToken = currentToken();
                if (_currentToken.kind() !== 80 /* LessThanToken */) {
                    return null;
                }
                var rewindPoint = getRewindPoint();
                var lessThanToken = consumeToken(_currentToken);
                var skippedTokens = getArray();
                var typeParameters = parseSeparatedSyntaxList(20 /* TypeParameterList_TypeParameters */, skippedTokens);
                lessThanToken = addSkippedTokensAfterToken(lessThanToken, skippedTokens);
                var greaterThanToken = eatToken(81 /* GreaterThanToken */);
                // return null if we were required to have a '>' token and we did not  have one.
                if (requireCompleteTypeParameterList && greaterThanToken.fullWidth() === 0) {
                    rewind(rewindPoint);
                    releaseRewindPoint(rewindPoint);
                    return null;
                }
                else {
                    releaseRewindPoint(rewindPoint);
                    return new Parser.syntaxFactory.TypeParameterListSyntax(parseNodeData, lessThanToken, typeParameters, greaterThanToken);
                }
            }
            function isTypeParameter() {
                return isIdentifier(currentToken());
            }
            function tryParseTypeParameter() {
                // Debug.assert(isTypeParameter());
                if (!isIdentifier(currentToken())) {
                    return null;
                }
                return new Parser.syntaxFactory.TypeParameterSyntax(parseNodeData, eatIdentifierToken(), tryParseConstraint());
            }
            function tryParseConstraint() {
                if (currentToken().kind() !== 48 /* ExtendsKeyword */) {
                    return null;
                }
                return new Parser.syntaxFactory.ConstraintSyntax(parseNodeData, eatToken(48 /* ExtendsKeyword */), parseTypeOrExpression());
            }
            function tryParseParameterList() {
                if (currentToken().kind() === 72 /* OpenParenToken */) {
                    var token1 = peekToken(1);
                    if (token1.kind() === 73 /* CloseParenToken */ || isParameterHelper(token1)) {
                        return parseParameterList();
                    }
                }
                return null;
            }
            function parseParameterList() {
                var openParenToken = eatToken(72 /* OpenParenToken */);
                var parameters = TypeScript.Syntax.emptySeparatedList();
                if (openParenToken.fullWidth() > 0) {
                    var skippedTokens = getArray();
                    parameters = parseSeparatedSyntaxList(17 /* ParameterList_Parameters */, skippedTokens);
                    openParenToken = addSkippedTokensAfterToken(openParenToken, skippedTokens);
                }
                return new Parser.syntaxFactory.ParameterListSyntax(parseNodeData, openParenToken, parameters, eatToken(73 /* CloseParenToken */));
            }
            function parseOptionalTypeAnnotation(allowStringLiteral) {
                return currentToken().kind() === 106 /* ColonToken */ ? parseTypeAnnotation(allowStringLiteral) : null;
            }
            function parseTypeAnnotationType(allowStringLiteral) {
                if (allowStringLiteral) {
                    var _currentToken = currentToken();
                    if (_currentToken.kind() === 14 /* StringLiteral */) {
                        return consumeToken(_currentToken);
                    }
                }
                return parseType();
            }
            function parseTypeAnnotation(allowStringLiteral) {
                return new Parser.syntaxFactory.TypeAnnotationSyntax(parseNodeData, consumeToken(currentToken()), parseTypeAnnotationType(allowStringLiteral));
            }
            function isType() {
                var _currentToken = currentToken();
                switch (_currentToken.kind()) {
                    case 39 /* TypeOfKeyword */:
                    case 60 /* AnyKeyword */:
                    case 67 /* NumberKeyword */:
                    case 61 /* BooleanKeyword */:
                    case 69 /* StringKeyword */:
                    case 41 /* VoidKeyword */:
                    case 70 /* OpenBraceToken */:
                    case 72 /* OpenParenToken */:
                    case 80 /* LessThanToken */:
                    case 31 /* NewKeyword */:
                        return true;
                    default:
                        return isIdentifier(_currentToken);
                }
            }
            function parseTypeOrExpression() {
                var result = tryParseType();
                if (result) {
                    return result;
                }
                var _currentToken = currentToken();
                if (isExpression(_currentToken)) {
                    // We parse out an expression here, but we very specifically ask for a unary 
                    // expression, and not just any expression.  That's because if we have:
                    //
                    //      <X extends "">
                    //
                    // We do not want the  >  to be consumed as part of the "" expression.  By starting
                    // at 'unary' expression and not 'binary' expression, we ensure that we don't accidently
                    // consume the >.
                    return tryParseUnaryExpressionOrHigher(_currentToken, true);
                }
                return eatIdentifierToken(TypeScript.DiagnosticCode.Type_expected);
            }
            function parseType() {
                return tryParseType() || eatIdentifierToken(TypeScript.DiagnosticCode.Type_expected);
            }
            function tryParseType() {
                // First consume any underlying element type.
                var type = tryParseNonArrayType();
                while (type) {
                    var _currentToken = currentToken();
                    if (previousTokenHasTrailingNewLine(_currentToken) || _currentToken.kind() !== 74 /* OpenBracketToken */) {
                        break;
                    }
                    type = new Parser.syntaxFactory.ArrayTypeSyntax(parseNodeData, type, consumeToken(_currentToken), eatToken(75 /* CloseBracketToken */));
                }
                return type;
            }
            function parseTypeQuery(typeOfKeyword) {
                return new Parser.syntaxFactory.TypeQuerySyntax(parseNodeData, consumeToken(typeOfKeyword), parseName(true));
            }
            function tryParseNonArrayType() {
                var _currentToken = currentToken();
                switch (_currentToken.kind()) {
                    case 60 /* AnyKeyword */:
                    case 67 /* NumberKeyword */:
                    case 61 /* BooleanKeyword */:
                    case 69 /* StringKeyword */:
                        // if any of these are followed by '.', then this is actually a module name,
                        // and these keywords will be reinterpreted as an identifier.
                        if (peekToken(1).kind() === 76 /* DotToken */) {
                            break;
                        }
                        return consumeToken(_currentToken);
                    case 72 /* OpenParenToken */:
                    case 80 /* LessThanToken */:
                        return tryParseFunctionType();
                    case 41 /* VoidKeyword */:
                        return consumeToken(_currentToken);
                    case 70 /* OpenBraceToken */:
                        return parseObjectType();
                    case 31 /* NewKeyword */:
                        return parseConstructorType();
                    case 39 /* TypeOfKeyword */:
                        return parseTypeQuery(_currentToken);
                    case 74 /* OpenBracketToken */:
                        return parseTupleType(_currentToken);
                }
                return tryParseNameOrGenericType();
            }
            function tryParseNameOrGenericType() {
                var name = tryParseName(false);
                if (name === null) {
                    return null;
                }
                // TypeReference:
                //      TypeName   [no LineTerminator here]   TypeArgumentsopt
                //
                // Only consume type arguments if they appear on the same line.
                if (previousTokenHasTrailingNewLine(currentToken())) {
                    return name;
                }
                var typeArgumentList = tryParseTypeArgumentList(false);
                return typeArgumentList === null ? name : new Parser.syntaxFactory.GenericTypeSyntax(parseNodeData, name, typeArgumentList);
            }
            function tryParseFunctionType() {
                var typeParameterList = tryParseTypeParameterList(false);
                var parameterList = null;
                if (typeParameterList === null) {
                    parameterList = tryParseParameterList();
                    if (parameterList === null) {
                        return null;
                    }
                }
                else {
                    parameterList = parseParameterList();
                }
                return new Parser.syntaxFactory.FunctionTypeSyntax(parseNodeData, typeParameterList, parameterList, eatToken(85 /* EqualsGreaterThanToken */), parseType());
            }
            function parseConstructorType() {
                return new Parser.syntaxFactory.ConstructorTypeSyntax(parseNodeData, eatToken(31 /* NewKeyword */), tryParseTypeParameterList(false), parseParameterList(), eatToken(85 /* EqualsGreaterThanToken */), parseType());
            }
            function isParameter() {
                if (currentNode() !== null && currentNode().kind() === 243 /* Parameter */) {
                    return true;
                }
                return isParameterHelper(currentToken());
            }
            function isParameterHelper(token) {
                var tokenKind = token.kind();
                return tokenKind === 77 /* DotDotDotToken */ || isModifierKind(tokenKind) || isIdentifier(token);
            }
            function eatSimpleParameter() {
                return new Parser.syntaxFactory.ParameterSyntax(parseNodeData, null, TypeScript.Syntax.emptyList(), eatIdentifierToken(), null, null, null);
            }
            function tryParseParameter() {
                var node = currentNode();
                if (node !== null && node.kind() === 243 /* Parameter */) {
                    consumeNode(node);
                    return node;
                }
                var dotDotDotToken = tryEatToken(77 /* DotDotDotToken */);
                var modifiers = parseModifiers();
                // If we're not forcing, and we don't see anything to indicate this is a parameter, then 
                // bail out.
                var _currentToken = currentToken();
                if (!isIdentifier(_currentToken) && dotDotDotToken === null && modifiers.length === 0) {
                    // ERROR RECOVERY:
                    // If we see a modifier alone in a parameter list, like:      foo(static)
                    //
                    // then treat it like modifier, and continue parsing the parameter.
                    if (isModifierKind(_currentToken.kind())) {
                        modifiers = TypeScript.Syntax.list([consumeToken(_currentToken)]);
                    }
                    else {
                        return null;
                    }
                }
                var identifier = eatIdentifierToken();
                var questionToken = tryEatToken(105 /* QuestionToken */);
                var typeAnnotation = parseOptionalTypeAnnotation(true);
                var equalsValueClause = null;
                if (isEqualsValueClause(true)) {
                    equalsValueClause = parseEqualsValueClause(true);
                }
                return new Parser.syntaxFactory.ParameterSyntax(parseNodeData, dotDotDotToken, modifiers, identifier, questionToken, typeAnnotation, equalsValueClause);
            }
            function parseSyntaxList(currentListType, skippedTokens, processItems) {
                if (processItems === void 0) { processItems = null; }
                var savedListParsingState = listParsingState;
                listParsingState |= (1 << currentListType);
                var result = parseSyntaxListWorker(currentListType, skippedTokens, processItems);
                listParsingState = savedListParsingState;
                return result;
            }
            function parseSeparatedSyntaxList(currentListType, skippedTokens) {
                var savedListParsingState = listParsingState;
                listParsingState |= (1 << currentListType);
                var result = parseSeparatedSyntaxListWorker(currentListType, skippedTokens);
                listParsingState = savedListParsingState;
                return result;
            }
            // Returns true if we should abort parsing.
            function abortParsingListOrMoveToNextToken(currentListType, nodes, separators, skippedTokens) {
                // Ok.  We're at a token that is not a terminator for the list and wasn't the start of 
                // an item in the list. Definitely report an error for this token.
                reportUnexpectedTokenDiagnostic(currentListType);
                for (var state = ListParsingState.LastListParsingState; state >= ListParsingState.FirstListParsingState; state--) {
                    if ((listParsingState & (1 << state)) !== 0) {
                        if (isExpectedListTerminator(state) || isExpectedListItem(state, true)) {
                            // Abort parsing this list.
                            return true;
                        }
                    }
                }
                // Otherwise, if none of the lists we're in can capture this token, then we need to 
                // unilaterally skip it.  Note: we've already reported an error above.
                addSkippedTokenToList(nodes, separators, skippedTokens, consumeToken(currentToken()));
                // Continue parsing this list.  Attach this token to whatever we've seen already.
                return false;
            }
            function addSkippedTokenToList(nodes, separators, skippedTokens, skippedToken) {
                // Now, add this skipped token to the last item we successfully parsed in the list.  Or
                // add it to the list of skipped tokens if we haven't parsed anything.  Our caller will
                // have to deal with them.
                //
                // Note: we only bother doing this if we're creating a concrete syntax tree.
                if (Parser.syntaxFactory.isConcrete) {
                    var length = nodes.length + (separators ? separators.length : 0);
                    for (var i = length - 1; i >= 0; i--) {
                        var array = separators && (i % 2 === 1) ? separators : nodes;
                        var arrayIndex = separators ? TypeScript.IntegerUtilities.integerDivide(i, 2) : i;
                        var item = array[arrayIndex];
                        var _lastToken = TypeScript.lastToken(item);
                        if (_lastToken && _lastToken.fullWidth() > 0) {
                            array[arrayIndex] = addSkippedTokenAfterNodeOrToken(item, skippedToken);
                            return;
                        }
                    }
                    // Didn't have anything in the list we could add to.  Add to the skipped items array
                    // for our caller to handle.
                    skippedTokens.push(skippedToken);
                }
            }
            function tryParseExpectedListItem(currentListType, inErrorRecovery, items, processItems) {
                var item = tryParseExpectedListItemWorker(currentListType, inErrorRecovery);
                if (item === null) {
                    return false;
                }
                // Debug.assert(item !== null);
                items.push(item);
                if (processItems !== null) {
                    processItems(items);
                }
                return true;
            }
            function listIsTerminated(currentListType) {
                return isExpectedListTerminator(currentListType) || currentToken().kind() === 10 /* EndOfFileToken */;
            }
            function parseSyntaxListWorker(currentListType, skippedTokens, processItems) {
                var items = getArray();
                while (true) {
                    // Try to parse an item of the list.  If we fail then decide if we need to abort or 
                    // continue parsing.
                    var succeeded = tryParseExpectedListItem(currentListType, false, items, processItems);
                    if (!succeeded) {
                        // We weren't able to parse out a list element.
                        // That may have been because the list is complete.  In that case, break out 
                        // and return the items we were able parse.
                        if (listIsTerminated(currentListType)) {
                            break;
                        }
                        // List wasn't complete and we didn't get an item.  Figure out if we should bail out
                        // or skip a token and continue.
                        var abort = abortParsingListOrMoveToNextToken(currentListType, items, null, skippedTokens);
                        if (abort) {
                            break;
                        }
                    }
                }
                var result = TypeScript.Syntax.list(items);
                // Can't return if it has more then 1 element.  In that case, the list will have been
                // copied into the SyntaxList.
                returnZeroLengthArray(items);
                return result;
            }
            function parseSeparatedSyntaxListWorker(currentListType, skippedTokens) {
                var nodes = getArray();
                var separators = getArray();
                // Debug.assert(nodes.length === 0);
                // Debug.assert(separators.length === 0);
                // Debug.assert(skippedTokens.length === 0);
                // Debug.assert(<any>skippedTokens !== nodes);
                // Debug.assert(skippedTokens !== separators);
                // Debug.assert(<any>nodes !== separators);
                var _separatorKind = currentListType === 9 /* ObjectType_TypeMembers */ ? 78 /* SemicolonToken */ : 79 /* CommaToken */;
                var allowAutomaticSemicolonInsertion = _separatorKind === 78 /* SemicolonToken */;
                var inErrorRecovery = false;
                while (true) {
                    // Try to parse an item of the list.  If we fail then decide if we need to abort or 
                    // continue parsing.
                    // Debug.assert(oldItemsCount % 2 === 0);
                    var succeeded = tryParseExpectedListItem(currentListType, inErrorRecovery, nodes, null);
                    if (!succeeded) {
                        // We weren't able to parse out a list element.
                        // Debug.assert(items === null || items.length % 2 === 0);
                        // That may have been because the list is complete.  In that case, break out 
                        // and return the items we were able parse.
                        if (listIsTerminated(currentListType)) {
                            break;
                        }
                        // List wasn't complete and we didn't get an item.  Figure out if we should bail out
                        // or skip a token and continue.
                        var abort = abortParsingListOrMoveToNextToken(currentListType, nodes, separators, skippedTokens);
                        if (abort) {
                            break;
                        }
                        else {
                            // We just skipped a token.  We're now in error recovery mode.
                            inErrorRecovery = true;
                            continue;
                        }
                    }
                    // Debug.assert(newItemsCount % 2 === 1);
                    // We were able to successfully parse out a list item.  So we're no longer in error
                    // recovery.
                    inErrorRecovery = false;
                    // Now, we have to see if we have a separator or not.  If we do have a separator
                    // we've got to consume it and continue trying to parse list items.  Note: we always
                    // allow 'comma' as a separator (for error tolerance).  We will later do a post pass
                    // to report when a comma was used improperly in a list that needed semicolons.
                    var _currentToken = currentToken();
                    var tokenKind = _currentToken.kind();
                    if (tokenKind === _separatorKind || tokenKind === 79 /* CommaToken */) {
                        // Consume the last separator and continue parsing list elements.
                        separators.push(consumeToken(_currentToken));
                        continue;
                    }
                    // We didn't see the expected separator.  There are two reasons this might happen.
                    // First, we may actually be at the end of the list.  If we are, then we're done
                    // parsing list elements.  
                    if (listIsTerminated(currentListType)) {
                        break;
                    }
                    // Otherwise, it might be a case where we can parse out an implicit semicolon.
                    // Note: it's important that we check this *after* the check above for
                    // 'listIsTerminated'.  Consider the following case:
                    //
                    //      {
                    //          a       // <-- just finished parsing 'a'
                    //      }
                    //
                    // Automatic semicolon insertion rules state: "When, as the program is parsed from
                    // left to right, a token (called the offending token) is encountered that is not 
                    // allowed by any production of the grammar".  So we should only ever insert a 
                    // semicolon if we couldn't consume something normally.  in the above case, we can
                    // consume the '}' just fine.  So ASI doesn't apply.
                    if (allowAutomaticSemicolonInsertion && canEatAutomaticSemicolon(false)) {
                        var semicolonToken = eatExplicitOrAutomaticSemicolon(false) || TypeScript.Syntax.emptyToken(78 /* SemicolonToken */);
                        separators.push(semicolonToken);
                        continue;
                    }
                    // We weren't at the end of the list.  And thre was no separator we could parse out.
                    // Try parse the separator we expected, and continue parsing more list elements.
                    // This time mark that we're in error recovery mode though.
                    //
                    // Note: trying to eat this token will emit the appropriate diagnostic.
                    separators.push(eatToken(_separatorKind));
                    // Now that we're in 'error recovery' mode we cantweak some parsing rules as 
                    // appropriate.  For example, if we have:
                    //
                    //      var v = { a
                    //      return
                    //
                    // Then we'll be missing the comma.  As such, we want to parse 'return' in a less
                    // tolerant manner.  Normally 'return' could be a property in an object literal.
                    // However, in error recovery mode, we do *not* want it to be.
                    //
                    // Continue trying to parse out list elements.
                    inErrorRecovery = true;
                }
                var result = TypeScript.Syntax.separatedList(nodes, separators);
                // Can't return if it has more then 0 elements.  In that case, the list will have been
                // copied into the SyntaxList.
                returnZeroLengthArray(nodes);
                returnZeroLengthArray(separators);
                return result;
            }
            function reportUnexpectedTokenDiagnostic(listType) {
                var token = currentToken();
                var diagnostic = new TypeScript.Diagnostic(fileName, source.text.lineMap(), TypeScript.start(token, source.text), TypeScript.width(token), TypeScript.DiagnosticCode.Unexpected_token_0_expected, [getExpectedListElementType(listType)]);
                addDiagnostic(diagnostic);
            }
            function addDiagnostic(diagnostic) {
                // Except: if we already have a diagnostic for this position, don't report another one.
                if (diagnostics.length > 0 && diagnostics[diagnostics.length - 1].start() === diagnostic.start()) {
                    return;
                }
                diagnostics.push(diagnostic);
            }
            function isExpectedListTerminator(currentListType) {
                switch (currentListType) {
                    case 0 /* SourceUnit_ModuleElements */:
                        return isExpectedSourceUnit_ModuleElementsTerminator();
                    case 1 /* ClassDeclaration_ClassElements */:
                        return isExpectedClassDeclaration_ClassElementsTerminator();
                    case 2 /* ModuleDeclaration_ModuleElements */:
                        return isExpectedModuleDeclaration_ModuleElementsTerminator();
                    case 3 /* SwitchStatement_SwitchClauses */:
                        return isExpectedSwitchStatement_SwitchClausesTerminator();
                    case 4 /* SwitchClause_Statements */:
                        return isExpectedSwitchClause_StatementsTerminator();
                    case 5 /* Block_Statements */:
                        return isExpectedBlock_StatementsTerminator();
                    case 6 /* TryBlock_Statements */:
                        return isExpectedTryBlock_StatementsTerminator();
                    case 7 /* CatchBlock_Statements */:
                        return isExpectedCatchBlock_StatementsTerminator();
                    case 8 /* EnumDeclaration_EnumElements */:
                        return isExpectedEnumDeclaration_EnumElementsTerminator();
                    case 9 /* ObjectType_TypeMembers */:
                        return isExpectedObjectType_TypeMembersTerminator();
                    case 10 /* ClassOrInterfaceDeclaration_HeritageClauses */:
                        return isExpectedClassOrInterfaceDeclaration_HeritageClausesTerminator();
                    case 11 /* HeritageClause_TypeNameList */:
                        return isExpectedHeritageClause_TypeNameListTerminator();
                    case 12 /* VariableDeclaration_VariableDeclarators_AllowIn */:
                        return isExpectedVariableDeclaration_VariableDeclarators_AllowInTerminator();
                    case 13 /* VariableDeclaration_VariableDeclarators_DisallowIn */:
                        return isExpectedVariableDeclaration_VariableDeclarators_DisallowInTerminator();
                    case 14 /* ArgumentList_AssignmentExpressions */:
                        return isExpectedArgumentList_AssignmentExpressionsTerminator();
                    case 15 /* ObjectLiteralExpression_PropertyAssignments */:
                        return isExpectedObjectLiteralExpression_PropertyAssignmentsTerminator();
                    case 16 /* ArrayLiteralExpression_AssignmentExpressions */:
                        return isExpectedLiteralExpression_AssignmentExpressionsTerminator();
                    case 17 /* ParameterList_Parameters */:
                        return isExpectedParameterList_ParametersTerminator();
                    case 18 /* IndexSignature_Parameters */:
                        return isExpectedIndexSignature_ParametersTerminator();
                    case 19 /* TypeArgumentList_Types */:
                        return isExpectedTypeArgumentList_TypesTerminator();
                    case 20 /* TypeParameterList_TypeParameters */:
                        return isExpectedTypeParameterList_TypeParametersTerminator();
                    case 21 /* TupleType_Types */:
                        return isExpectedTupleType_TypesTerminator();
                    default:
                        throw TypeScript.Errors.invalidOperation();
                }
            }
            function isExpectedSourceUnit_ModuleElementsTerminator() {
                return currentToken().kind() === 10 /* EndOfFileToken */;
            }
            function isExpectedEnumDeclaration_EnumElementsTerminator() {
                return currentToken().kind() === 71 /* CloseBraceToken */;
            }
            function isExpectedModuleDeclaration_ModuleElementsTerminator() {
                return currentToken().kind() === 71 /* CloseBraceToken */;
            }
            function isExpectedObjectType_TypeMembersTerminator() {
                return currentToken().kind() === 71 /* CloseBraceToken */;
            }
            function isExpectedObjectLiteralExpression_PropertyAssignmentsTerminator() {
                return currentToken().kind() === 71 /* CloseBraceToken */;
            }
            function isExpectedLiteralExpression_AssignmentExpressionsTerminator() {
                return currentToken().kind() === 75 /* CloseBracketToken */;
            }
            function isExpectedTypeArgumentList_TypesTerminator() {
                var token = currentToken();
                var tokenKind = token.kind();
                if (tokenKind === 81 /* GreaterThanToken */) {
                    return true;
                }
                // If we're at a token that can follow the type argument list, then we'll also consider
                // the list terminated.
                if (canFollowTypeArgumentListInExpression(tokenKind)) {
                    return true;
                }
                // TODO: add more cases as necessary for error tolerance.
                return false;
            }
            function isExpectedTupleType_TypesTerminator() {
                var token = currentToken();
                var tokenKind = token.kind();
                if (tokenKind === 75 /* CloseBracketToken */) {
                    return true;
                }
                // TODO: add more cases as necessary for error tolerance.
                return false;
            }
            function isExpectedTypeParameterList_TypeParametersTerminator() {
                var tokenKind = currentToken().kind();
                if (tokenKind === 81 /* GreaterThanToken */) {
                    return true;
                }
                // These commonly follow type parameter lists.
                if (tokenKind === 72 /* OpenParenToken */ || tokenKind === 70 /* OpenBraceToken */ || tokenKind === 48 /* ExtendsKeyword */ || tokenKind === 51 /* ImplementsKeyword */) {
                    return true;
                }
                // TODO: add more cases as necessary for error tolerance.
                return false;
            }
            function isExpectedParameterList_ParametersTerminator() {
                var tokenKind = currentToken().kind();
                if (tokenKind === 73 /* CloseParenToken */) {
                    return true;
                }
                // We may also see a { in an error case.  i.e.:
                // function (a, b, c  {
                if (tokenKind === 70 /* OpenBraceToken */) {
                    return true;
                }
                // We may also see a => in an error case.  i.e.:
                // (f: number => { ... }
                if (tokenKind === 85 /* EqualsGreaterThanToken */) {
                    return true;
                }
                return false;
            }
            function isExpectedIndexSignature_ParametersTerminator() {
                var tokenKind = currentToken().kind();
                if (tokenKind === 75 /* CloseBracketToken */) {
                    return true;
                }
                // We may also see a { in an error case.  i.e.:
                // function (a, b, c  {
                if (tokenKind === 70 /* OpenBraceToken */) {
                    return true;
                }
                return false;
            }
            function isExpectedVariableDeclaration_VariableDeclarators_DisallowInTerminator() {
                // This is the case when we're parsing variable declarations in a for/for-in statement.
                var tokenKind = currentToken().kind();
                if (tokenKind === 78 /* SemicolonToken */ || tokenKind === 73 /* CloseParenToken */) {
                    return true;
                }
                if (tokenKind === 29 /* InKeyword */) {
                    return true;
                }
                return false;
            }
            function isExpectedVariableDeclaration_VariableDeclarators_AllowInTerminator() {
                //// This is the case when we're parsing variable declarations in a variable statement.
                // ERROR RECOVERY TWEAK:
                // For better error recovery, if we see a => then we just stop immediately.  We've got an
                // arrow function here and it's going to be very unlikely that we'll resynchronize and get
                // another variable declaration.
                if (currentToken().kind() === 85 /* EqualsGreaterThanToken */) {
                    return true;
                }
                // We're done when we can eat a semicolon.
                return canEatExplicitOrAutomaticSemicolon(false);
            }
            function isExpectedClassOrInterfaceDeclaration_HeritageClausesTerminator() {
                var tokenKind = currentToken().kind();
                if (tokenKind === 70 /* OpenBraceToken */ || tokenKind === 71 /* CloseBraceToken */) {
                    return true;
                }
                return false;
            }
            function isExpectedHeritageClause_TypeNameListTerminator() {
                var tokenKind = currentToken().kind();
                if (tokenKind === 48 /* ExtendsKeyword */ || tokenKind === 51 /* ImplementsKeyword */) {
                    return true;
                }
                if (isExpectedClassOrInterfaceDeclaration_HeritageClausesTerminator()) {
                    return true;
                }
                return false;
            }
            function isExpectedArgumentList_AssignmentExpressionsTerminator() {
                var token0 = currentToken();
                var tokenKind = token0.kind();
                return tokenKind === 73 /* CloseParenToken */ || tokenKind === 78 /* SemicolonToken */;
            }
            function isExpectedClassDeclaration_ClassElementsTerminator() {
                return currentToken().kind() === 71 /* CloseBraceToken */;
            }
            function isExpectedSwitchStatement_SwitchClausesTerminator() {
                return currentToken().kind() === 71 /* CloseBraceToken */;
            }
            function isExpectedSwitchClause_StatementsTerminator() {
                return currentToken().kind() === 71 /* CloseBraceToken */ || isSwitchClause();
            }
            function isExpectedBlock_StatementsTerminator() {
                return currentToken().kind() === 71 /* CloseBraceToken */;
            }
            function isExpectedTryBlock_StatementsTerminator() {
                var tokenKind = currentToken().kind();
                return tokenKind === 17 /* CatchKeyword */ || tokenKind === 25 /* FinallyKeyword */;
            }
            function isExpectedCatchBlock_StatementsTerminator() {
                return currentToken().kind() === 25 /* FinallyKeyword */;
            }
            function isExpectedListItem(currentListType, inErrorRecovery) {
                switch (currentListType) {
                    case 0 /* SourceUnit_ModuleElements */:
                        return isModuleElement(inErrorRecovery);
                    case 1 /* ClassDeclaration_ClassElements */:
                        return isClassElement(inErrorRecovery);
                    case 2 /* ModuleDeclaration_ModuleElements */:
                        return isModuleElement(inErrorRecovery);
                    case 3 /* SwitchStatement_SwitchClauses */:
                        return isSwitchClause();
                    case 4 /* SwitchClause_Statements */:
                        return isStatement(modifierCount(), inErrorRecovery);
                    case 5 /* Block_Statements */:
                        return isStatement(modifierCount(), inErrorRecovery);
                    case 6 /* TryBlock_Statements */:
                        return false;
                    case 7 /* CatchBlock_Statements */:
                        return false;
                    case 8 /* EnumDeclaration_EnumElements */:
                        return isEnumElement(inErrorRecovery);
                    case 9 /* ObjectType_TypeMembers */:
                        return isTypeMember(inErrorRecovery);
                    case 10 /* ClassOrInterfaceDeclaration_HeritageClauses */:
                        return isHeritageClause();
                    case 11 /* HeritageClause_TypeNameList */:
                        return isHeritageClauseTypeName();
                    case 12 /* VariableDeclaration_VariableDeclarators_AllowIn */:
                        return isVariableDeclarator();
                    case 13 /* VariableDeclaration_VariableDeclarators_DisallowIn */:
                        return isVariableDeclarator();
                    case 14 /* ArgumentList_AssignmentExpressions */:
                        return isExpectedArgumentList_AssignmentExpression();
                    case 15 /* ObjectLiteralExpression_PropertyAssignments */:
                        return isPropertyAssignment(inErrorRecovery);
                    case 16 /* ArrayLiteralExpression_AssignmentExpressions */:
                        return isAssignmentOrOmittedExpression();
                    case 17 /* ParameterList_Parameters */:
                        return isParameter();
                    case 18 /* IndexSignature_Parameters */:
                        return isParameter();
                    case 19 /* TypeArgumentList_Types */:
                        return isType();
                    case 20 /* TypeParameterList_TypeParameters */:
                        return isTypeParameter();
                    case 21 /* TupleType_Types */:
                        return isType();
                    default:
                        throw TypeScript.Errors.invalidOperation();
                }
            }
            function isExpectedArgumentList_AssignmentExpression() {
                var _currentToken = currentToken();
                if (isExpression(_currentToken)) {
                    return true;
                }
                // If we're on a comma then the user has written something like "Foo(a,," or "Foo(,".
                // Instead of skipping the comma, create an empty expression to go before the comma 
                // so that the tree is more well formed and doesn't have skipped tokens.
                if (_currentToken.kind() === 79 /* CommaToken */) {
                    return true;
                }
                return false;
            }
            function tryParseExpectedListItemWorker(currentListType, inErrorRecovery) {
                switch (currentListType) {
                    case 0 /* SourceUnit_ModuleElements */:
                        return tryParseModuleElement(inErrorRecovery);
                    case 1 /* ClassDeclaration_ClassElements */:
                        return tryParseClassElement(inErrorRecovery);
                    case 2 /* ModuleDeclaration_ModuleElements */:
                        return tryParseModuleElement(inErrorRecovery);
                    case 3 /* SwitchStatement_SwitchClauses */:
                        return tryParseSwitchClause();
                    case 4 /* SwitchClause_Statements */:
                        return tryParseStatement(inErrorRecovery);
                    case 5 /* Block_Statements */:
                        return tryParseStatement(inErrorRecovery);
                    case 6 /* TryBlock_Statements */:
                        return tryParseStatement(inErrorRecovery);
                    case 7 /* CatchBlock_Statements */:
                        return tryParseStatement(inErrorRecovery);
                    case 8 /* EnumDeclaration_EnumElements */:
                        return tryParseEnumElement(inErrorRecovery);
                    case 9 /* ObjectType_TypeMembers */:
                        return tryParseTypeMember(inErrorRecovery);
                    case 10 /* ClassOrInterfaceDeclaration_HeritageClauses */:
                        return tryParseHeritageClause();
                    case 11 /* HeritageClause_TypeNameList */:
                        return tryParseHeritageClauseTypeName();
                    case 12 /* VariableDeclaration_VariableDeclarators_AllowIn */:
                        return tryParseVariableDeclarator(true, false);
                    case 13 /* VariableDeclaration_VariableDeclarators_DisallowIn */:
                        return tryParseVariableDeclarator(false, false);
                    case 14 /* ArgumentList_AssignmentExpressions */:
                        return tryParseArgumentListExpression();
                    case 15 /* ObjectLiteralExpression_PropertyAssignments */:
                        return tryParsePropertyAssignment(inErrorRecovery);
                    case 16 /* ArrayLiteralExpression_AssignmentExpressions */:
                        return tryParseAssignmentOrOmittedExpression();
                    case 17 /* ParameterList_Parameters */:
                        return tryParseParameter();
                    case 18 /* IndexSignature_Parameters */:
                        return tryParseParameter();
                    case 19 /* TypeArgumentList_Types */:
                        return tryParseType();
                    case 20 /* TypeParameterList_TypeParameters */:
                        return tryParseTypeParameter();
                    case 21 /* TupleType_Types */:
                        return tryParseType();
                    default:
                        throw TypeScript.Errors.invalidOperation();
                }
            }
            function getExpectedListElementType(currentListType) {
                switch (currentListType) {
                    case 0 /* SourceUnit_ModuleElements */:
                        return TypeScript.getLocalizedText(TypeScript.DiagnosticCode.module_class_interface_enum_import_or_statement, null);
                    case 10 /* ClassOrInterfaceDeclaration_HeritageClauses */:
                        return '{';
                    case 1 /* ClassDeclaration_ClassElements */:
                        return TypeScript.getLocalizedText(TypeScript.DiagnosticCode.constructor_function_accessor_or_variable, null);
                    case 2 /* ModuleDeclaration_ModuleElements */:
                        return TypeScript.getLocalizedText(TypeScript.DiagnosticCode.module_class_interface_enum_import_or_statement, null);
                    case 3 /* SwitchStatement_SwitchClauses */:
                        return TypeScript.getLocalizedText(TypeScript.DiagnosticCode.case_or_default_clause, null);
                    case 4 /* SwitchClause_Statements */:
                        return TypeScript.getLocalizedText(TypeScript.DiagnosticCode.statement, null);
                    case 5 /* Block_Statements */:
                        return TypeScript.getLocalizedText(TypeScript.DiagnosticCode.statement, null);
                    case 12 /* VariableDeclaration_VariableDeclarators_AllowIn */:
                        return TypeScript.getLocalizedText(TypeScript.DiagnosticCode.identifier, null);
                    case 13 /* VariableDeclaration_VariableDeclarators_DisallowIn */:
                        return TypeScript.getLocalizedText(TypeScript.DiagnosticCode.identifier, null);
                    case 8 /* EnumDeclaration_EnumElements */:
                        return TypeScript.getLocalizedText(TypeScript.DiagnosticCode.identifier, null);
                    case 9 /* ObjectType_TypeMembers */:
                        return TypeScript.getLocalizedText(TypeScript.DiagnosticCode.call_construct_index_property_or_function_signature, null);
                    case 14 /* ArgumentList_AssignmentExpressions */:
                        return TypeScript.getLocalizedText(TypeScript.DiagnosticCode.expression, null);
                    case 11 /* HeritageClause_TypeNameList */:
                        return TypeScript.getLocalizedText(TypeScript.DiagnosticCode.type_name, null);
                    case 15 /* ObjectLiteralExpression_PropertyAssignments */:
                        return TypeScript.getLocalizedText(TypeScript.DiagnosticCode.property_or_accessor, null);
                    case 17 /* ParameterList_Parameters */:
                        return TypeScript.getLocalizedText(TypeScript.DiagnosticCode.parameter, null);
                    case 18 /* IndexSignature_Parameters */:
                        return TypeScript.getLocalizedText(TypeScript.DiagnosticCode.parameter, null);
                    case 19 /* TypeArgumentList_Types */:
                        return TypeScript.getLocalizedText(TypeScript.DiagnosticCode.type, null);
                    case 20 /* TypeParameterList_TypeParameters */:
                        return TypeScript.getLocalizedText(TypeScript.DiagnosticCode.type_parameter, null);
                    case 21 /* TupleType_Types */:
                        return TypeScript.getLocalizedText(TypeScript.DiagnosticCode.type, null);
                    case 16 /* ArrayLiteralExpression_AssignmentExpressions */:
                        return TypeScript.getLocalizedText(TypeScript.DiagnosticCode.expression, null);
                    default:
                        throw TypeScript.Errors.invalidOperation();
                }
            }
            return parseSyntaxTree;
        }
        // The precedence of expressions in typescript.  While we're parsing an expression, we will 
        // continue to consume and form new trees if the precedence is *strictly* greater than our current
        // precedence.  For example, if we have: a + b * c, we will first parse 'a' with precedence 1 (Lowest). 
        // We will then see the + with precedence 10.  10 is greater than 1 so we will decide to create
        // a binary expression with the result of parsing the sub expression "b * c".  We'll then parse
        // the term 'b' (passing in precedence 10).  We will then see the * with precedence 11.  11 is
        // greater than 10, so we will create a binary expression from "b" and "c", return that, and 
        // join it with "a" producing:
        //
        //      +
        //     / \
        //    a   *
        //       / \
        //      b   c
        //
        // If we instead had: "a * b + c", we would first parser 'a' with precedence 1 (lowest).  We would then see 
        // the * with precedence 11.  11 is greater than 1 so we will decide to create a binary expression
        // with the result of parsing the sub expression "b + c".  We'll then parse the term 'b' (passing in
        // precedence 11).  We will then see the + with precedence 10.  10 is less than 11, so we won't 
        // continue parsing subexpressions and will just return the expression 'b'.  The caller will join 
        // that into "a * b" (and will be back at precedence 1). It will then see the + with precedence 10.
        // 10 is greater than 1 so it will parse the sub expression and make a binary expression out of it
        // producing:
        //
        //        +
        //       / \
        //      *   c
        //     / \
        //    a   b
        //
        // Note: because all these binary expressions have left-to-right precedence, if we see a * b * c 
        // then we parse it as:
        //
        //        *
        //       / \
        //      *   c
        //     / \
        //    a   b
        //
        // The code to do this uses the above logic.  It will see an operator with the same precedence,
        // and so it won't consume it.
        var BinaryExpressionPrecedence;
        (function (BinaryExpressionPrecedence) {
            BinaryExpressionPrecedence[BinaryExpressionPrecedence["Lowest"] = 1] = "Lowest";
            // Intuitively, logical || have the lowest precedence.  "a || b && c" is "a || (b && c)", not
            // "(a || b) && c"
            BinaryExpressionPrecedence[BinaryExpressionPrecedence["LogicalOrExpressionPrecedence"] = 2] = "LogicalOrExpressionPrecedence";
            BinaryExpressionPrecedence[BinaryExpressionPrecedence["LogicalAndExpressionPrecedence"] = 3] = "LogicalAndExpressionPrecedence";
            BinaryExpressionPrecedence[BinaryExpressionPrecedence["BitwiseOrExpressionPrecedence"] = 4] = "BitwiseOrExpressionPrecedence";
            BinaryExpressionPrecedence[BinaryExpressionPrecedence["BitwiseExclusiveOrExpressionPrecedence"] = 5] = "BitwiseExclusiveOrExpressionPrecedence";
            BinaryExpressionPrecedence[BinaryExpressionPrecedence["BitwiseAndExpressionPrecedence"] = 6] = "BitwiseAndExpressionPrecedence";
            BinaryExpressionPrecedence[BinaryExpressionPrecedence["EqualityExpressionPrecedence"] = 7] = "EqualityExpressionPrecedence";
            BinaryExpressionPrecedence[BinaryExpressionPrecedence["RelationalExpressionPrecedence"] = 8] = "RelationalExpressionPrecedence";
            BinaryExpressionPrecedence[BinaryExpressionPrecedence["ShiftExpressionPrecdence"] = 9] = "ShiftExpressionPrecdence";
            BinaryExpressionPrecedence[BinaryExpressionPrecedence["AdditiveExpressionPrecedence"] = 10] = "AdditiveExpressionPrecedence";
            // Intuitively, multiplicative expressions have the highest precedence.  After all, if you have:
            //   a + b * c
            //
            // Then you have "a + (b * c)" not "(a + b) * c"
            BinaryExpressionPrecedence[BinaryExpressionPrecedence["MultiplicativeExpressionPrecedence"] = 11] = "MultiplicativeExpressionPrecedence";
        })(BinaryExpressionPrecedence || (BinaryExpressionPrecedence = {}));
        // The current state of the parser wrt to list parsing.  The way to read these is as:
        // CurrentProduction_SubList.  i.e. "Block_Statements" means "we're parsing a Block, and we're 
        // currently parsing list of statements within it".  This is used by the list parsing mechanism
        // to parse the elements of the lists, and recover from errors we encounter when we run into 
        // unexpected code.
        // 
        // For example, when we are in ArgumentList_Arguments, we will continue trying to consume code 
        // as long as "isArgument" is true.  If we run into a token for which "isArgument" is not true 
        // we will do the following:
        //
        // If the token is a StopToken for ArgumentList_Arguments (like ")" ) then we will stop parsing
        // the list of arguments with no error.
        //
        // Otherwise, we *do* report an error for this unexpected token, and then enter error recovery 
        // mode to decide how to try to recover from this unexpected token.
        //
        // Error recovery will walk up the list of states we're in seeing if the token is a stop token
        // for that construct *or* could start another element within what construct.  For example, if
        // the unexpected token was '}' then that would be a stop token for Block_Statements. 
        // Alternatively, if the unexpected token was 'return', then that would be a start token for 
        // the next statment in Block_Statements.
        // 
        // If either of those cases are true, We will then return *without* consuming  that token. 
        // (Remember, we've already reported an error).  Now we're just letting the higher up parse 
        // constructs eventually try to consume that token.
        //
        // If none of the higher up states consider this a stop or start token, then we will simply 
        // consume the token and add it to our list of 'skipped tokens'.  We will then repeat the 
        // above algorithm until we resynchronize at some point.
        var ListParsingState;
        (function (ListParsingState) {
            ListParsingState[ListParsingState["SourceUnit_ModuleElements"] = 0] = "SourceUnit_ModuleElements";
            ListParsingState[ListParsingState["ClassDeclaration_ClassElements"] = 1] = "ClassDeclaration_ClassElements";
            ListParsingState[ListParsingState["ModuleDeclaration_ModuleElements"] = 2] = "ModuleDeclaration_ModuleElements";
            ListParsingState[ListParsingState["SwitchStatement_SwitchClauses"] = 3] = "SwitchStatement_SwitchClauses";
            ListParsingState[ListParsingState["SwitchClause_Statements"] = 4] = "SwitchClause_Statements";
            ListParsingState[ListParsingState["Block_Statements"] = 5] = "Block_Statements";
            ListParsingState[ListParsingState["TryBlock_Statements"] = 6] = "TryBlock_Statements";
            ListParsingState[ListParsingState["CatchBlock_Statements"] = 7] = "CatchBlock_Statements";
            ListParsingState[ListParsingState["EnumDeclaration_EnumElements"] = 8] = "EnumDeclaration_EnumElements";
            ListParsingState[ListParsingState["ObjectType_TypeMembers"] = 9] = "ObjectType_TypeMembers";
            ListParsingState[ListParsingState["ClassOrInterfaceDeclaration_HeritageClauses"] = 10] = "ClassOrInterfaceDeclaration_HeritageClauses";
            ListParsingState[ListParsingState["HeritageClause_TypeNameList"] = 11] = "HeritageClause_TypeNameList";
            ListParsingState[ListParsingState["VariableDeclaration_VariableDeclarators_AllowIn"] = 12] = "VariableDeclaration_VariableDeclarators_AllowIn";
            ListParsingState[ListParsingState["VariableDeclaration_VariableDeclarators_DisallowIn"] = 13] = "VariableDeclaration_VariableDeclarators_DisallowIn";
            ListParsingState[ListParsingState["ArgumentList_AssignmentExpressions"] = 14] = "ArgumentList_AssignmentExpressions";
            ListParsingState[ListParsingState["ObjectLiteralExpression_PropertyAssignments"] = 15] = "ObjectLiteralExpression_PropertyAssignments";
            ListParsingState[ListParsingState["ArrayLiteralExpression_AssignmentExpressions"] = 16] = "ArrayLiteralExpression_AssignmentExpressions";
            ListParsingState[ListParsingState["ParameterList_Parameters"] = 17] = "ParameterList_Parameters";
            ListParsingState[ListParsingState["IndexSignature_Parameters"] = 18] = "IndexSignature_Parameters";
            ListParsingState[ListParsingState["TypeArgumentList_Types"] = 19] = "TypeArgumentList_Types";
            ListParsingState[ListParsingState["TypeParameterList_TypeParameters"] = 20] = "TypeParameterList_TypeParameters";
            ListParsingState[ListParsingState["TupleType_Types"] = 21] = "TupleType_Types";
            ListParsingState[ListParsingState["FirstListParsingState"] = ListParsingState.SourceUnit_ModuleElements] = "FirstListParsingState";
            ListParsingState[ListParsingState["LastListParsingState"] = ListParsingState.TupleType_Types] = "LastListParsingState";
        })(ListParsingState || (ListParsingState = {}));
        // We keep the parser around as a singleton.  This is because calling createParser is actually
        // expensive in V8 currently.  We then clear it after a parse so that it doesn't  keep state 
        // alive unintentionally.
        var parseSyntaxTree = createParseSyntaxTree();
        function parse(fileName, text, languageVersion, isDeclaration) {
            return parseSource(TypeScript.Scanner.createParserSource(fileName, text, languageVersion), isDeclaration);
        }
        Parser.parse = parse;
        function parseSource(source, isDeclaration) {
            return parseSyntaxTree(source, isDeclaration);
        }
        Parser.parseSource = parseSource;
    })(Parser = TypeScript.Parser || (TypeScript.Parser = {}));
})(TypeScript || (TypeScript = {}));
///<reference path='references.ts' />
var TypeScript;
(function (TypeScript) {
    var Syntax;
    (function (Syntax) {
        var Concrete;
        (function (Concrete) {
            // Inject this module as the factory for producing syntax nodes in the parser.
            TypeScript.Parser.syntaxFactory = Concrete;
            Concrete.isConcrete = true;
            var SourceUnitSyntax = (function (_super) {
                __extends(SourceUnitSyntax, _super);
                function SourceUnitSyntax(data, moduleElements, endOfFileToken) {
                    _super.call(this, data);
                    this.syntaxTree = null;
                    this.parent = null, this.moduleElements = moduleElements, this.endOfFileToken = endOfFileToken, !TypeScript.isShared(moduleElements) && (moduleElements.parent = this), endOfFileToken.parent = this;
                }
                return SourceUnitSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.SourceUnitSyntax = SourceUnitSyntax;
            var QualifiedNameSyntax = (function (_super) {
                __extends(QualifiedNameSyntax, _super);
                function QualifiedNameSyntax(data, left, dotToken, right) {
                    _super.call(this, data);
                    this.left = left, this.dotToken = dotToken, this.right = right, left.parent = this, dotToken.parent = this, right.parent = this;
                }
                return QualifiedNameSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.QualifiedNameSyntax = QualifiedNameSyntax;
            var ObjectTypeSyntax = (function (_super) {
                __extends(ObjectTypeSyntax, _super);
                function ObjectTypeSyntax(data, openBraceToken, typeMembers, closeBraceToken) {
                    _super.call(this, data);
                    this.openBraceToken = openBraceToken, this.typeMembers = typeMembers, this.closeBraceToken = closeBraceToken, openBraceToken.parent = this, !TypeScript.isShared(typeMembers) && (typeMembers.parent = this), closeBraceToken.parent = this;
                }
                return ObjectTypeSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.ObjectTypeSyntax = ObjectTypeSyntax;
            var FunctionTypeSyntax = (function (_super) {
                __extends(FunctionTypeSyntax, _super);
                function FunctionTypeSyntax(data, typeParameterList, parameterList, equalsGreaterThanToken, type) {
                    _super.call(this, data);
                    this.typeParameterList = typeParameterList, this.parameterList = parameterList, this.equalsGreaterThanToken = equalsGreaterThanToken, this.type = type, typeParameterList && (typeParameterList.parent = this), parameterList.parent = this, equalsGreaterThanToken.parent = this, type.parent = this;
                }
                return FunctionTypeSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.FunctionTypeSyntax = FunctionTypeSyntax;
            var ArrayTypeSyntax = (function (_super) {
                __extends(ArrayTypeSyntax, _super);
                function ArrayTypeSyntax(data, type, openBracketToken, closeBracketToken) {
                    _super.call(this, data);
                    this.type = type, this.openBracketToken = openBracketToken, this.closeBracketToken = closeBracketToken, type.parent = this, openBracketToken.parent = this, closeBracketToken.parent = this;
                }
                return ArrayTypeSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.ArrayTypeSyntax = ArrayTypeSyntax;
            var ConstructorTypeSyntax = (function (_super) {
                __extends(ConstructorTypeSyntax, _super);
                function ConstructorTypeSyntax(data, newKeyword, typeParameterList, parameterList, equalsGreaterThanToken, type) {
                    _super.call(this, data);
                    this.newKeyword = newKeyword, this.typeParameterList = typeParameterList, this.parameterList = parameterList, this.equalsGreaterThanToken = equalsGreaterThanToken, this.type = type, newKeyword.parent = this, typeParameterList && (typeParameterList.parent = this), parameterList.parent = this, equalsGreaterThanToken.parent = this, type.parent = this;
                }
                return ConstructorTypeSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.ConstructorTypeSyntax = ConstructorTypeSyntax;
            var GenericTypeSyntax = (function (_super) {
                __extends(GenericTypeSyntax, _super);
                function GenericTypeSyntax(data, name, typeArgumentList) {
                    _super.call(this, data);
                    this.name = name, this.typeArgumentList = typeArgumentList, name.parent = this, typeArgumentList.parent = this;
                }
                return GenericTypeSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.GenericTypeSyntax = GenericTypeSyntax;
            var TypeQuerySyntax = (function (_super) {
                __extends(TypeQuerySyntax, _super);
                function TypeQuerySyntax(data, typeOfKeyword, name) {
                    _super.call(this, data);
                    this.typeOfKeyword = typeOfKeyword, this.name = name, typeOfKeyword.parent = this, name.parent = this;
                }
                return TypeQuerySyntax;
            })(TypeScript.SyntaxNode);
            Concrete.TypeQuerySyntax = TypeQuerySyntax;
            var TupleTypeSyntax = (function (_super) {
                __extends(TupleTypeSyntax, _super);
                function TupleTypeSyntax(data, openBracketToken, types, closeBracketToken) {
                    _super.call(this, data);
                    this.openBracketToken = openBracketToken, this.types = types, this.closeBracketToken = closeBracketToken, openBracketToken.parent = this, !TypeScript.isShared(types) && (types.parent = this), closeBracketToken.parent = this;
                }
                return TupleTypeSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.TupleTypeSyntax = TupleTypeSyntax;
            var InterfaceDeclarationSyntax = (function (_super) {
                __extends(InterfaceDeclarationSyntax, _super);
                function InterfaceDeclarationSyntax(data, modifiers, interfaceKeyword, identifier, typeParameterList, heritageClauses, body) {
                    _super.call(this, data);
                    this.modifiers = modifiers, this.interfaceKeyword = interfaceKeyword, this.identifier = identifier, this.typeParameterList = typeParameterList, this.heritageClauses = heritageClauses, this.body = body, !TypeScript.isShared(modifiers) && (modifiers.parent = this), interfaceKeyword.parent = this, identifier.parent = this, typeParameterList && (typeParameterList.parent = this), !TypeScript.isShared(heritageClauses) && (heritageClauses.parent = this), body.parent = this;
                }
                return InterfaceDeclarationSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.InterfaceDeclarationSyntax = InterfaceDeclarationSyntax;
            var FunctionDeclarationSyntax = (function (_super) {
                __extends(FunctionDeclarationSyntax, _super);
                function FunctionDeclarationSyntax(data, modifiers, functionKeyword, identifier, callSignature, block, semicolonToken) {
                    _super.call(this, data);
                    this.modifiers = modifiers, this.functionKeyword = functionKeyword, this.identifier = identifier, this.callSignature = callSignature, this.block = block, this.semicolonToken = semicolonToken, !TypeScript.isShared(modifiers) && (modifiers.parent = this), functionKeyword.parent = this, identifier.parent = this, callSignature.parent = this, block && (block.parent = this), semicolonToken && (semicolonToken.parent = this);
                }
                return FunctionDeclarationSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.FunctionDeclarationSyntax = FunctionDeclarationSyntax;
            var ModuleDeclarationSyntax = (function (_super) {
                __extends(ModuleDeclarationSyntax, _super);
                function ModuleDeclarationSyntax(data, modifiers, moduleKeyword, name, stringLiteral, openBraceToken, moduleElements, closeBraceToken) {
                    _super.call(this, data);
                    this.modifiers = modifiers, this.moduleKeyword = moduleKeyword, this.name = name, this.stringLiteral = stringLiteral, this.openBraceToken = openBraceToken, this.moduleElements = moduleElements, this.closeBraceToken = closeBraceToken, !TypeScript.isShared(modifiers) && (modifiers.parent = this), moduleKeyword.parent = this, name && (name.parent = this), stringLiteral && (stringLiteral.parent = this), openBraceToken.parent = this, !TypeScript.isShared(moduleElements) && (moduleElements.parent = this), closeBraceToken.parent = this;
                }
                return ModuleDeclarationSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.ModuleDeclarationSyntax = ModuleDeclarationSyntax;
            var ClassDeclarationSyntax = (function (_super) {
                __extends(ClassDeclarationSyntax, _super);
                function ClassDeclarationSyntax(data, modifiers, classKeyword, identifier, typeParameterList, heritageClauses, openBraceToken, classElements, closeBraceToken) {
                    _super.call(this, data);
                    this.modifiers = modifiers, this.classKeyword = classKeyword, this.identifier = identifier, this.typeParameterList = typeParameterList, this.heritageClauses = heritageClauses, this.openBraceToken = openBraceToken, this.classElements = classElements, this.closeBraceToken = closeBraceToken, !TypeScript.isShared(modifiers) && (modifiers.parent = this), classKeyword.parent = this, identifier.parent = this, typeParameterList && (typeParameterList.parent = this), !TypeScript.isShared(heritageClauses) && (heritageClauses.parent = this), openBraceToken.parent = this, !TypeScript.isShared(classElements) && (classElements.parent = this), closeBraceToken.parent = this;
                }
                return ClassDeclarationSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.ClassDeclarationSyntax = ClassDeclarationSyntax;
            var EnumDeclarationSyntax = (function (_super) {
                __extends(EnumDeclarationSyntax, _super);
                function EnumDeclarationSyntax(data, modifiers, enumKeyword, identifier, openBraceToken, enumElements, closeBraceToken) {
                    _super.call(this, data);
                    this.modifiers = modifiers, this.enumKeyword = enumKeyword, this.identifier = identifier, this.openBraceToken = openBraceToken, this.enumElements = enumElements, this.closeBraceToken = closeBraceToken, !TypeScript.isShared(modifiers) && (modifiers.parent = this), enumKeyword.parent = this, identifier.parent = this, openBraceToken.parent = this, !TypeScript.isShared(enumElements) && (enumElements.parent = this), closeBraceToken.parent = this;
                }
                return EnumDeclarationSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.EnumDeclarationSyntax = EnumDeclarationSyntax;
            var ImportDeclarationSyntax = (function (_super) {
                __extends(ImportDeclarationSyntax, _super);
                function ImportDeclarationSyntax(data, modifiers, importKeyword, identifier, equalsToken, moduleReference, semicolonToken) {
                    _super.call(this, data);
                    this.modifiers = modifiers, this.importKeyword = importKeyword, this.identifier = identifier, this.equalsToken = equalsToken, this.moduleReference = moduleReference, this.semicolonToken = semicolonToken, !TypeScript.isShared(modifiers) && (modifiers.parent = this), importKeyword.parent = this, identifier.parent = this, equalsToken.parent = this, moduleReference.parent = this, semicolonToken && (semicolonToken.parent = this);
                }
                return ImportDeclarationSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.ImportDeclarationSyntax = ImportDeclarationSyntax;
            var ExportAssignmentSyntax = (function (_super) {
                __extends(ExportAssignmentSyntax, _super);
                function ExportAssignmentSyntax(data, exportKeyword, equalsToken, identifier, semicolonToken) {
                    _super.call(this, data);
                    this.exportKeyword = exportKeyword, this.equalsToken = equalsToken, this.identifier = identifier, this.semicolonToken = semicolonToken, exportKeyword.parent = this, equalsToken.parent = this, identifier.parent = this, semicolonToken && (semicolonToken.parent = this);
                }
                return ExportAssignmentSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.ExportAssignmentSyntax = ExportAssignmentSyntax;
            var MemberFunctionDeclarationSyntax = (function (_super) {
                __extends(MemberFunctionDeclarationSyntax, _super);
                function MemberFunctionDeclarationSyntax(data, modifiers, propertyName, callSignature, block, semicolonToken) {
                    _super.call(this, data);
                    this.modifiers = modifiers, this.propertyName = propertyName, this.callSignature = callSignature, this.block = block, this.semicolonToken = semicolonToken, !TypeScript.isShared(modifiers) && (modifiers.parent = this), propertyName.parent = this, callSignature.parent = this, block && (block.parent = this), semicolonToken && (semicolonToken.parent = this);
                }
                return MemberFunctionDeclarationSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.MemberFunctionDeclarationSyntax = MemberFunctionDeclarationSyntax;
            var MemberVariableDeclarationSyntax = (function (_super) {
                __extends(MemberVariableDeclarationSyntax, _super);
                function MemberVariableDeclarationSyntax(data, modifiers, variableDeclarator, semicolonToken) {
                    _super.call(this, data);
                    this.modifiers = modifiers, this.variableDeclarator = variableDeclarator, this.semicolonToken = semicolonToken, !TypeScript.isShared(modifiers) && (modifiers.parent = this), variableDeclarator.parent = this, semicolonToken && (semicolonToken.parent = this);
                }
                return MemberVariableDeclarationSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.MemberVariableDeclarationSyntax = MemberVariableDeclarationSyntax;
            var ConstructorDeclarationSyntax = (function (_super) {
                __extends(ConstructorDeclarationSyntax, _super);
                function ConstructorDeclarationSyntax(data, modifiers, constructorKeyword, callSignature, block, semicolonToken) {
                    _super.call(this, data);
                    this.modifiers = modifiers, this.constructorKeyword = constructorKeyword, this.callSignature = callSignature, this.block = block, this.semicolonToken = semicolonToken, !TypeScript.isShared(modifiers) && (modifiers.parent = this), constructorKeyword.parent = this, callSignature.parent = this, block && (block.parent = this), semicolonToken && (semicolonToken.parent = this);
                }
                return ConstructorDeclarationSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.ConstructorDeclarationSyntax = ConstructorDeclarationSyntax;
            var IndexMemberDeclarationSyntax = (function (_super) {
                __extends(IndexMemberDeclarationSyntax, _super);
                function IndexMemberDeclarationSyntax(data, modifiers, indexSignature, semicolonToken) {
                    _super.call(this, data);
                    this.modifiers = modifiers, this.indexSignature = indexSignature, this.semicolonToken = semicolonToken, !TypeScript.isShared(modifiers) && (modifiers.parent = this), indexSignature.parent = this, semicolonToken && (semicolonToken.parent = this);
                }
                return IndexMemberDeclarationSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.IndexMemberDeclarationSyntax = IndexMemberDeclarationSyntax;
            var GetAccessorSyntax = (function (_super) {
                __extends(GetAccessorSyntax, _super);
                function GetAccessorSyntax(data, modifiers, getKeyword, propertyName, callSignature, block) {
                    _super.call(this, data);
                    this.modifiers = modifiers, this.getKeyword = getKeyword, this.propertyName = propertyName, this.callSignature = callSignature, this.block = block, !TypeScript.isShared(modifiers) && (modifiers.parent = this), getKeyword.parent = this, propertyName.parent = this, callSignature.parent = this, block.parent = this;
                }
                return GetAccessorSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.GetAccessorSyntax = GetAccessorSyntax;
            var SetAccessorSyntax = (function (_super) {
                __extends(SetAccessorSyntax, _super);
                function SetAccessorSyntax(data, modifiers, setKeyword, propertyName, callSignature, block) {
                    _super.call(this, data);
                    this.modifiers = modifiers, this.setKeyword = setKeyword, this.propertyName = propertyName, this.callSignature = callSignature, this.block = block, !TypeScript.isShared(modifiers) && (modifiers.parent = this), setKeyword.parent = this, propertyName.parent = this, callSignature.parent = this, block.parent = this;
                }
                return SetAccessorSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.SetAccessorSyntax = SetAccessorSyntax;
            var PropertySignatureSyntax = (function (_super) {
                __extends(PropertySignatureSyntax, _super);
                function PropertySignatureSyntax(data, propertyName, questionToken, typeAnnotation) {
                    _super.call(this, data);
                    this.propertyName = propertyName, this.questionToken = questionToken, this.typeAnnotation = typeAnnotation, propertyName.parent = this, questionToken && (questionToken.parent = this), typeAnnotation && (typeAnnotation.parent = this);
                }
                return PropertySignatureSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.PropertySignatureSyntax = PropertySignatureSyntax;
            var CallSignatureSyntax = (function (_super) {
                __extends(CallSignatureSyntax, _super);
                function CallSignatureSyntax(data, typeParameterList, parameterList, typeAnnotation) {
                    _super.call(this, data);
                    this.typeParameterList = typeParameterList, this.parameterList = parameterList, this.typeAnnotation = typeAnnotation, typeParameterList && (typeParameterList.parent = this), parameterList.parent = this, typeAnnotation && (typeAnnotation.parent = this);
                }
                return CallSignatureSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.CallSignatureSyntax = CallSignatureSyntax;
            var ConstructSignatureSyntax = (function (_super) {
                __extends(ConstructSignatureSyntax, _super);
                function ConstructSignatureSyntax(data, newKeyword, callSignature) {
                    _super.call(this, data);
                    this.newKeyword = newKeyword, this.callSignature = callSignature, newKeyword.parent = this, callSignature.parent = this;
                }
                return ConstructSignatureSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.ConstructSignatureSyntax = ConstructSignatureSyntax;
            var IndexSignatureSyntax = (function (_super) {
                __extends(IndexSignatureSyntax, _super);
                function IndexSignatureSyntax(data, openBracketToken, parameters, closeBracketToken, typeAnnotation) {
                    _super.call(this, data);
                    this.openBracketToken = openBracketToken, this.parameters = parameters, this.closeBracketToken = closeBracketToken, this.typeAnnotation = typeAnnotation, openBracketToken.parent = this, !TypeScript.isShared(parameters) && (parameters.parent = this), closeBracketToken.parent = this, typeAnnotation && (typeAnnotation.parent = this);
                }
                return IndexSignatureSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.IndexSignatureSyntax = IndexSignatureSyntax;
            var MethodSignatureSyntax = (function (_super) {
                __extends(MethodSignatureSyntax, _super);
                function MethodSignatureSyntax(data, propertyName, questionToken, callSignature) {
                    _super.call(this, data);
                    this.propertyName = propertyName, this.questionToken = questionToken, this.callSignature = callSignature, propertyName.parent = this, questionToken && (questionToken.parent = this), callSignature.parent = this;
                }
                return MethodSignatureSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.MethodSignatureSyntax = MethodSignatureSyntax;
            var BlockSyntax = (function (_super) {
                __extends(BlockSyntax, _super);
                function BlockSyntax(data, openBraceToken, statements, closeBraceToken) {
                    _super.call(this, data);
                    this.openBraceToken = openBraceToken, this.statements = statements, this.closeBraceToken = closeBraceToken, openBraceToken.parent = this, !TypeScript.isShared(statements) && (statements.parent = this), closeBraceToken.parent = this;
                }
                return BlockSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.BlockSyntax = BlockSyntax;
            var IfStatementSyntax = (function (_super) {
                __extends(IfStatementSyntax, _super);
                function IfStatementSyntax(data, ifKeyword, openParenToken, condition, closeParenToken, statement, elseClause) {
                    _super.call(this, data);
                    this.ifKeyword = ifKeyword, this.openParenToken = openParenToken, this.condition = condition, this.closeParenToken = closeParenToken, this.statement = statement, this.elseClause = elseClause, ifKeyword.parent = this, openParenToken.parent = this, condition.parent = this, closeParenToken.parent = this, statement.parent = this, elseClause && (elseClause.parent = this);
                }
                return IfStatementSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.IfStatementSyntax = IfStatementSyntax;
            var VariableStatementSyntax = (function (_super) {
                __extends(VariableStatementSyntax, _super);
                function VariableStatementSyntax(data, modifiers, variableDeclaration, semicolonToken) {
                    _super.call(this, data);
                    this.modifiers = modifiers, this.variableDeclaration = variableDeclaration, this.semicolonToken = semicolonToken, !TypeScript.isShared(modifiers) && (modifiers.parent = this), variableDeclaration.parent = this, semicolonToken && (semicolonToken.parent = this);
                }
                return VariableStatementSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.VariableStatementSyntax = VariableStatementSyntax;
            var ExpressionStatementSyntax = (function (_super) {
                __extends(ExpressionStatementSyntax, _super);
                function ExpressionStatementSyntax(data, expression, semicolonToken) {
                    _super.call(this, data);
                    this.expression = expression, this.semicolonToken = semicolonToken, expression.parent = this, semicolonToken && (semicolonToken.parent = this);
                }
                return ExpressionStatementSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.ExpressionStatementSyntax = ExpressionStatementSyntax;
            var ReturnStatementSyntax = (function (_super) {
                __extends(ReturnStatementSyntax, _super);
                function ReturnStatementSyntax(data, returnKeyword, expression, semicolonToken) {
                    _super.call(this, data);
                    this.returnKeyword = returnKeyword, this.expression = expression, this.semicolonToken = semicolonToken, returnKeyword.parent = this, expression && (expression.parent = this), semicolonToken && (semicolonToken.parent = this);
                }
                return ReturnStatementSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.ReturnStatementSyntax = ReturnStatementSyntax;
            var SwitchStatementSyntax = (function (_super) {
                __extends(SwitchStatementSyntax, _super);
                function SwitchStatementSyntax(data, switchKeyword, openParenToken, expression, closeParenToken, openBraceToken, switchClauses, closeBraceToken) {
                    _super.call(this, data);
                    this.switchKeyword = switchKeyword, this.openParenToken = openParenToken, this.expression = expression, this.closeParenToken = closeParenToken, this.openBraceToken = openBraceToken, this.switchClauses = switchClauses, this.closeBraceToken = closeBraceToken, switchKeyword.parent = this, openParenToken.parent = this, expression.parent = this, closeParenToken.parent = this, openBraceToken.parent = this, !TypeScript.isShared(switchClauses) && (switchClauses.parent = this), closeBraceToken.parent = this;
                }
                return SwitchStatementSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.SwitchStatementSyntax = SwitchStatementSyntax;
            var BreakStatementSyntax = (function (_super) {
                __extends(BreakStatementSyntax, _super);
                function BreakStatementSyntax(data, breakKeyword, identifier, semicolonToken) {
                    _super.call(this, data);
                    this.breakKeyword = breakKeyword, this.identifier = identifier, this.semicolonToken = semicolonToken, breakKeyword.parent = this, identifier && (identifier.parent = this), semicolonToken && (semicolonToken.parent = this);
                }
                return BreakStatementSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.BreakStatementSyntax = BreakStatementSyntax;
            var ContinueStatementSyntax = (function (_super) {
                __extends(ContinueStatementSyntax, _super);
                function ContinueStatementSyntax(data, continueKeyword, identifier, semicolonToken) {
                    _super.call(this, data);
                    this.continueKeyword = continueKeyword, this.identifier = identifier, this.semicolonToken = semicolonToken, continueKeyword.parent = this, identifier && (identifier.parent = this), semicolonToken && (semicolonToken.parent = this);
                }
                return ContinueStatementSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.ContinueStatementSyntax = ContinueStatementSyntax;
            var ForStatementSyntax = (function (_super) {
                __extends(ForStatementSyntax, _super);
                function ForStatementSyntax(data, forKeyword, openParenToken, variableDeclaration, initializer, firstSemicolonToken, condition, secondSemicolonToken, incrementor, closeParenToken, statement) {
                    _super.call(this, data);
                    this.forKeyword = forKeyword, this.openParenToken = openParenToken, this.variableDeclaration = variableDeclaration, this.initializer = initializer, this.firstSemicolonToken = firstSemicolonToken, this.condition = condition, this.secondSemicolonToken = secondSemicolonToken, this.incrementor = incrementor, this.closeParenToken = closeParenToken, this.statement = statement, forKeyword.parent = this, openParenToken.parent = this, variableDeclaration && (variableDeclaration.parent = this), initializer && (initializer.parent = this), firstSemicolonToken.parent = this, condition && (condition.parent = this), secondSemicolonToken.parent = this, incrementor && (incrementor.parent = this), closeParenToken.parent = this, statement.parent = this;
                }
                return ForStatementSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.ForStatementSyntax = ForStatementSyntax;
            var ForInStatementSyntax = (function (_super) {
                __extends(ForInStatementSyntax, _super);
                function ForInStatementSyntax(data, forKeyword, openParenToken, variableDeclaration, left, inKeyword, expression, closeParenToken, statement) {
                    _super.call(this, data);
                    this.forKeyword = forKeyword, this.openParenToken = openParenToken, this.variableDeclaration = variableDeclaration, this.left = left, this.inKeyword = inKeyword, this.expression = expression, this.closeParenToken = closeParenToken, this.statement = statement, forKeyword.parent = this, openParenToken.parent = this, variableDeclaration && (variableDeclaration.parent = this), left && (left.parent = this), inKeyword.parent = this, expression.parent = this, closeParenToken.parent = this, statement.parent = this;
                }
                return ForInStatementSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.ForInStatementSyntax = ForInStatementSyntax;
            var EmptyStatementSyntax = (function (_super) {
                __extends(EmptyStatementSyntax, _super);
                function EmptyStatementSyntax(data, semicolonToken) {
                    _super.call(this, data);
                    this.semicolonToken = semicolonToken, semicolonToken.parent = this;
                }
                return EmptyStatementSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.EmptyStatementSyntax = EmptyStatementSyntax;
            var ThrowStatementSyntax = (function (_super) {
                __extends(ThrowStatementSyntax, _super);
                function ThrowStatementSyntax(data, throwKeyword, expression, semicolonToken) {
                    _super.call(this, data);
                    this.throwKeyword = throwKeyword, this.expression = expression, this.semicolonToken = semicolonToken, throwKeyword.parent = this, expression.parent = this, semicolonToken && (semicolonToken.parent = this);
                }
                return ThrowStatementSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.ThrowStatementSyntax = ThrowStatementSyntax;
            var WhileStatementSyntax = (function (_super) {
                __extends(WhileStatementSyntax, _super);
                function WhileStatementSyntax(data, whileKeyword, openParenToken, condition, closeParenToken, statement) {
                    _super.call(this, data);
                    this.whileKeyword = whileKeyword, this.openParenToken = openParenToken, this.condition = condition, this.closeParenToken = closeParenToken, this.statement = statement, whileKeyword.parent = this, openParenToken.parent = this, condition.parent = this, closeParenToken.parent = this, statement.parent = this;
                }
                return WhileStatementSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.WhileStatementSyntax = WhileStatementSyntax;
            var TryStatementSyntax = (function (_super) {
                __extends(TryStatementSyntax, _super);
                function TryStatementSyntax(data, tryKeyword, block, catchClause, finallyClause) {
                    _super.call(this, data);
                    this.tryKeyword = tryKeyword, this.block = block, this.catchClause = catchClause, this.finallyClause = finallyClause, tryKeyword.parent = this, block.parent = this, catchClause && (catchClause.parent = this), finallyClause && (finallyClause.parent = this);
                }
                return TryStatementSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.TryStatementSyntax = TryStatementSyntax;
            var LabeledStatementSyntax = (function (_super) {
                __extends(LabeledStatementSyntax, _super);
                function LabeledStatementSyntax(data, identifier, colonToken, statement) {
                    _super.call(this, data);
                    this.identifier = identifier, this.colonToken = colonToken, this.statement = statement, identifier.parent = this, colonToken.parent = this, statement.parent = this;
                }
                return LabeledStatementSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.LabeledStatementSyntax = LabeledStatementSyntax;
            var DoStatementSyntax = (function (_super) {
                __extends(DoStatementSyntax, _super);
                function DoStatementSyntax(data, doKeyword, statement, whileKeyword, openParenToken, condition, closeParenToken, semicolonToken) {
                    _super.call(this, data);
                    this.doKeyword = doKeyword, this.statement = statement, this.whileKeyword = whileKeyword, this.openParenToken = openParenToken, this.condition = condition, this.closeParenToken = closeParenToken, this.semicolonToken = semicolonToken, doKeyword.parent = this, statement.parent = this, whileKeyword.parent = this, openParenToken.parent = this, condition.parent = this, closeParenToken.parent = this, semicolonToken && (semicolonToken.parent = this);
                }
                return DoStatementSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.DoStatementSyntax = DoStatementSyntax;
            var DebuggerStatementSyntax = (function (_super) {
                __extends(DebuggerStatementSyntax, _super);
                function DebuggerStatementSyntax(data, debuggerKeyword, semicolonToken) {
                    _super.call(this, data);
                    this.debuggerKeyword = debuggerKeyword, this.semicolonToken = semicolonToken, debuggerKeyword.parent = this, semicolonToken && (semicolonToken.parent = this);
                }
                return DebuggerStatementSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.DebuggerStatementSyntax = DebuggerStatementSyntax;
            var WithStatementSyntax = (function (_super) {
                __extends(WithStatementSyntax, _super);
                function WithStatementSyntax(data, withKeyword, openParenToken, condition, closeParenToken, statement) {
                    _super.call(this, data);
                    this.withKeyword = withKeyword, this.openParenToken = openParenToken, this.condition = condition, this.closeParenToken = closeParenToken, this.statement = statement, withKeyword.parent = this, openParenToken.parent = this, condition.parent = this, closeParenToken.parent = this, statement.parent = this;
                }
                return WithStatementSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.WithStatementSyntax = WithStatementSyntax;
            var PrefixUnaryExpressionSyntax = (function (_super) {
                __extends(PrefixUnaryExpressionSyntax, _super);
                function PrefixUnaryExpressionSyntax(data, operatorToken, operand) {
                    _super.call(this, data);
                    this.operatorToken = operatorToken, this.operand = operand, operatorToken.parent = this, operand.parent = this;
                }
                PrefixUnaryExpressionSyntax.prototype.kind = function () {
                    return TypeScript.SyntaxFacts.getPrefixUnaryExpressionFromOperatorToken(this.operatorToken.kind());
                };
                return PrefixUnaryExpressionSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.PrefixUnaryExpressionSyntax = PrefixUnaryExpressionSyntax;
            var DeleteExpressionSyntax = (function (_super) {
                __extends(DeleteExpressionSyntax, _super);
                function DeleteExpressionSyntax(data, deleteKeyword, expression) {
                    _super.call(this, data);
                    this.deleteKeyword = deleteKeyword, this.expression = expression, deleteKeyword.parent = this, expression.parent = this;
                }
                return DeleteExpressionSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.DeleteExpressionSyntax = DeleteExpressionSyntax;
            var TypeOfExpressionSyntax = (function (_super) {
                __extends(TypeOfExpressionSyntax, _super);
                function TypeOfExpressionSyntax(data, typeOfKeyword, expression) {
                    _super.call(this, data);
                    this.typeOfKeyword = typeOfKeyword, this.expression = expression, typeOfKeyword.parent = this, expression.parent = this;
                }
                return TypeOfExpressionSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.TypeOfExpressionSyntax = TypeOfExpressionSyntax;
            var VoidExpressionSyntax = (function (_super) {
                __extends(VoidExpressionSyntax, _super);
                function VoidExpressionSyntax(data, voidKeyword, expression) {
                    _super.call(this, data);
                    this.voidKeyword = voidKeyword, this.expression = expression, voidKeyword.parent = this, expression.parent = this;
                }
                return VoidExpressionSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.VoidExpressionSyntax = VoidExpressionSyntax;
            var ConditionalExpressionSyntax = (function (_super) {
                __extends(ConditionalExpressionSyntax, _super);
                function ConditionalExpressionSyntax(data, condition, questionToken, whenTrue, colonToken, whenFalse) {
                    _super.call(this, data);
                    this.condition = condition, this.questionToken = questionToken, this.whenTrue = whenTrue, this.colonToken = colonToken, this.whenFalse = whenFalse, condition.parent = this, questionToken.parent = this, whenTrue.parent = this, colonToken.parent = this, whenFalse.parent = this;
                }
                return ConditionalExpressionSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.ConditionalExpressionSyntax = ConditionalExpressionSyntax;
            var BinaryExpressionSyntax = (function (_super) {
                __extends(BinaryExpressionSyntax, _super);
                function BinaryExpressionSyntax(data, left, operatorToken, right) {
                    _super.call(this, data);
                    this.left = left, this.operatorToken = operatorToken, this.right = right, left.parent = this, operatorToken.parent = this, right.parent = this;
                }
                BinaryExpressionSyntax.prototype.kind = function () {
                    return TypeScript.SyntaxFacts.getBinaryExpressionFromOperatorToken(this.operatorToken.kind());
                };
                return BinaryExpressionSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.BinaryExpressionSyntax = BinaryExpressionSyntax;
            var PostfixUnaryExpressionSyntax = (function (_super) {
                __extends(PostfixUnaryExpressionSyntax, _super);
                function PostfixUnaryExpressionSyntax(data, operand, operatorToken) {
                    _super.call(this, data);
                    this.operand = operand, this.operatorToken = operatorToken, operand.parent = this, operatorToken.parent = this;
                }
                PostfixUnaryExpressionSyntax.prototype.kind = function () {
                    return TypeScript.SyntaxFacts.getPostfixUnaryExpressionFromOperatorToken(this.operatorToken.kind());
                };
                return PostfixUnaryExpressionSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.PostfixUnaryExpressionSyntax = PostfixUnaryExpressionSyntax;
            var MemberAccessExpressionSyntax = (function (_super) {
                __extends(MemberAccessExpressionSyntax, _super);
                function MemberAccessExpressionSyntax(data, expression, dotToken, name) {
                    _super.call(this, data);
                    this.expression = expression, this.dotToken = dotToken, this.name = name, expression.parent = this, dotToken.parent = this, name.parent = this;
                }
                return MemberAccessExpressionSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.MemberAccessExpressionSyntax = MemberAccessExpressionSyntax;
            var InvocationExpressionSyntax = (function (_super) {
                __extends(InvocationExpressionSyntax, _super);
                function InvocationExpressionSyntax(data, expression, argumentList) {
                    _super.call(this, data);
                    this.expression = expression, this.argumentList = argumentList, expression.parent = this, argumentList.parent = this;
                }
                return InvocationExpressionSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.InvocationExpressionSyntax = InvocationExpressionSyntax;
            var ArrayLiteralExpressionSyntax = (function (_super) {
                __extends(ArrayLiteralExpressionSyntax, _super);
                function ArrayLiteralExpressionSyntax(data, openBracketToken, expressions, closeBracketToken) {
                    _super.call(this, data);
                    this.openBracketToken = openBracketToken, this.expressions = expressions, this.closeBracketToken = closeBracketToken, openBracketToken.parent = this, !TypeScript.isShared(expressions) && (expressions.parent = this), closeBracketToken.parent = this;
                }
                return ArrayLiteralExpressionSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.ArrayLiteralExpressionSyntax = ArrayLiteralExpressionSyntax;
            var ObjectLiteralExpressionSyntax = (function (_super) {
                __extends(ObjectLiteralExpressionSyntax, _super);
                function ObjectLiteralExpressionSyntax(data, openBraceToken, propertyAssignments, closeBraceToken) {
                    _super.call(this, data);
                    this.openBraceToken = openBraceToken, this.propertyAssignments = propertyAssignments, this.closeBraceToken = closeBraceToken, openBraceToken.parent = this, !TypeScript.isShared(propertyAssignments) && (propertyAssignments.parent = this), closeBraceToken.parent = this;
                }
                return ObjectLiteralExpressionSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.ObjectLiteralExpressionSyntax = ObjectLiteralExpressionSyntax;
            var ObjectCreationExpressionSyntax = (function (_super) {
                __extends(ObjectCreationExpressionSyntax, _super);
                function ObjectCreationExpressionSyntax(data, newKeyword, expression, argumentList) {
                    _super.call(this, data);
                    this.newKeyword = newKeyword, this.expression = expression, this.argumentList = argumentList, newKeyword.parent = this, expression.parent = this, argumentList && (argumentList.parent = this);
                }
                return ObjectCreationExpressionSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.ObjectCreationExpressionSyntax = ObjectCreationExpressionSyntax;
            var ParenthesizedExpressionSyntax = (function (_super) {
                __extends(ParenthesizedExpressionSyntax, _super);
                function ParenthesizedExpressionSyntax(data, openParenToken, expression, closeParenToken) {
                    _super.call(this, data);
                    this.openParenToken = openParenToken, this.expression = expression, this.closeParenToken = closeParenToken, openParenToken.parent = this, expression.parent = this, closeParenToken.parent = this;
                }
                return ParenthesizedExpressionSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.ParenthesizedExpressionSyntax = ParenthesizedExpressionSyntax;
            var ParenthesizedArrowFunctionExpressionSyntax = (function (_super) {
                __extends(ParenthesizedArrowFunctionExpressionSyntax, _super);
                function ParenthesizedArrowFunctionExpressionSyntax(data, callSignature, equalsGreaterThanToken, block, expression) {
                    _super.call(this, data);
                    this.callSignature = callSignature, this.equalsGreaterThanToken = equalsGreaterThanToken, this.block = block, this.expression = expression, callSignature.parent = this, equalsGreaterThanToken.parent = this, block && (block.parent = this), expression && (expression.parent = this);
                }
                return ParenthesizedArrowFunctionExpressionSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.ParenthesizedArrowFunctionExpressionSyntax = ParenthesizedArrowFunctionExpressionSyntax;
            var SimpleArrowFunctionExpressionSyntax = (function (_super) {
                __extends(SimpleArrowFunctionExpressionSyntax, _super);
                function SimpleArrowFunctionExpressionSyntax(data, parameter, equalsGreaterThanToken, block, expression) {
                    _super.call(this, data);
                    this.parameter = parameter, this.equalsGreaterThanToken = equalsGreaterThanToken, this.block = block, this.expression = expression, parameter.parent = this, equalsGreaterThanToken.parent = this, block && (block.parent = this), expression && (expression.parent = this);
                }
                return SimpleArrowFunctionExpressionSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.SimpleArrowFunctionExpressionSyntax = SimpleArrowFunctionExpressionSyntax;
            var CastExpressionSyntax = (function (_super) {
                __extends(CastExpressionSyntax, _super);
                function CastExpressionSyntax(data, lessThanToken, type, greaterThanToken, expression) {
                    _super.call(this, data);
                    this.lessThanToken = lessThanToken, this.type = type, this.greaterThanToken = greaterThanToken, this.expression = expression, lessThanToken.parent = this, type.parent = this, greaterThanToken.parent = this, expression.parent = this;
                }
                return CastExpressionSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.CastExpressionSyntax = CastExpressionSyntax;
            var ElementAccessExpressionSyntax = (function (_super) {
                __extends(ElementAccessExpressionSyntax, _super);
                function ElementAccessExpressionSyntax(data, expression, openBracketToken, argumentExpression, closeBracketToken) {
                    _super.call(this, data);
                    this.expression = expression, this.openBracketToken = openBracketToken, this.argumentExpression = argumentExpression, this.closeBracketToken = closeBracketToken, expression.parent = this, openBracketToken.parent = this, argumentExpression.parent = this, closeBracketToken.parent = this;
                }
                return ElementAccessExpressionSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.ElementAccessExpressionSyntax = ElementAccessExpressionSyntax;
            var FunctionExpressionSyntax = (function (_super) {
                __extends(FunctionExpressionSyntax, _super);
                function FunctionExpressionSyntax(data, functionKeyword, identifier, callSignature, block) {
                    _super.call(this, data);
                    this.functionKeyword = functionKeyword, this.identifier = identifier, this.callSignature = callSignature, this.block = block, functionKeyword.parent = this, identifier && (identifier.parent = this), callSignature.parent = this, block.parent = this;
                }
                return FunctionExpressionSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.FunctionExpressionSyntax = FunctionExpressionSyntax;
            var OmittedExpressionSyntax = (function (_super) {
                __extends(OmittedExpressionSyntax, _super);
                function OmittedExpressionSyntax(data) {
                    _super.call(this, data);
                }
                return OmittedExpressionSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.OmittedExpressionSyntax = OmittedExpressionSyntax;
            var VariableDeclarationSyntax = (function (_super) {
                __extends(VariableDeclarationSyntax, _super);
                function VariableDeclarationSyntax(data, varKeyword, variableDeclarators) {
                    _super.call(this, data);
                    this.varKeyword = varKeyword, this.variableDeclarators = variableDeclarators, varKeyword.parent = this, !TypeScript.isShared(variableDeclarators) && (variableDeclarators.parent = this);
                }
                return VariableDeclarationSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.VariableDeclarationSyntax = VariableDeclarationSyntax;
            var VariableDeclaratorSyntax = (function (_super) {
                __extends(VariableDeclaratorSyntax, _super);
                function VariableDeclaratorSyntax(data, propertyName, typeAnnotation, equalsValueClause) {
                    _super.call(this, data);
                    this.propertyName = propertyName, this.typeAnnotation = typeAnnotation, this.equalsValueClause = equalsValueClause, propertyName.parent = this, typeAnnotation && (typeAnnotation.parent = this), equalsValueClause && (equalsValueClause.parent = this);
                }
                return VariableDeclaratorSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.VariableDeclaratorSyntax = VariableDeclaratorSyntax;
            var ArgumentListSyntax = (function (_super) {
                __extends(ArgumentListSyntax, _super);
                function ArgumentListSyntax(data, typeArgumentList, openParenToken, _arguments, closeParenToken) {
                    _super.call(this, data);
                    this.typeArgumentList = typeArgumentList, this.openParenToken = openParenToken, this.arguments = _arguments, this.closeParenToken = closeParenToken, typeArgumentList && (typeArgumentList.parent = this), openParenToken.parent = this, !TypeScript.isShared(_arguments) && (_arguments.parent = this), closeParenToken.parent = this;
                }
                return ArgumentListSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.ArgumentListSyntax = ArgumentListSyntax;
            var ParameterListSyntax = (function (_super) {
                __extends(ParameterListSyntax, _super);
                function ParameterListSyntax(data, openParenToken, parameters, closeParenToken) {
                    _super.call(this, data);
                    this.openParenToken = openParenToken, this.parameters = parameters, this.closeParenToken = closeParenToken, openParenToken.parent = this, !TypeScript.isShared(parameters) && (parameters.parent = this), closeParenToken.parent = this;
                }
                return ParameterListSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.ParameterListSyntax = ParameterListSyntax;
            var TypeArgumentListSyntax = (function (_super) {
                __extends(TypeArgumentListSyntax, _super);
                function TypeArgumentListSyntax(data, lessThanToken, typeArguments, greaterThanToken) {
                    _super.call(this, data);
                    this.lessThanToken = lessThanToken, this.typeArguments = typeArguments, this.greaterThanToken = greaterThanToken, lessThanToken.parent = this, !TypeScript.isShared(typeArguments) && (typeArguments.parent = this), greaterThanToken.parent = this;
                }
                return TypeArgumentListSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.TypeArgumentListSyntax = TypeArgumentListSyntax;
            var TypeParameterListSyntax = (function (_super) {
                __extends(TypeParameterListSyntax, _super);
                function TypeParameterListSyntax(data, lessThanToken, typeParameters, greaterThanToken) {
                    _super.call(this, data);
                    this.lessThanToken = lessThanToken, this.typeParameters = typeParameters, this.greaterThanToken = greaterThanToken, lessThanToken.parent = this, !TypeScript.isShared(typeParameters) && (typeParameters.parent = this), greaterThanToken.parent = this;
                }
                return TypeParameterListSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.TypeParameterListSyntax = TypeParameterListSyntax;
            var HeritageClauseSyntax = (function (_super) {
                __extends(HeritageClauseSyntax, _super);
                function HeritageClauseSyntax(data, extendsOrImplementsKeyword, typeNames) {
                    _super.call(this, data);
                    this.extendsOrImplementsKeyword = extendsOrImplementsKeyword, this.typeNames = typeNames, extendsOrImplementsKeyword.parent = this, !TypeScript.isShared(typeNames) && (typeNames.parent = this);
                }
                HeritageClauseSyntax.prototype.kind = function () {
                    return this.extendsOrImplementsKeyword.kind() === 48 /* ExtendsKeyword */ ? 231 /* ExtendsHeritageClause */ : 232 /* ImplementsHeritageClause */;
                };
                return HeritageClauseSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.HeritageClauseSyntax = HeritageClauseSyntax;
            var EqualsValueClauseSyntax = (function (_super) {
                __extends(EqualsValueClauseSyntax, _super);
                function EqualsValueClauseSyntax(data, equalsToken, value) {
                    _super.call(this, data);
                    this.equalsToken = equalsToken, this.value = value, equalsToken.parent = this, value.parent = this;
                }
                return EqualsValueClauseSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.EqualsValueClauseSyntax = EqualsValueClauseSyntax;
            var CaseSwitchClauseSyntax = (function (_super) {
                __extends(CaseSwitchClauseSyntax, _super);
                function CaseSwitchClauseSyntax(data, caseKeyword, expression, colonToken, statements) {
                    _super.call(this, data);
                    this.caseKeyword = caseKeyword, this.expression = expression, this.colonToken = colonToken, this.statements = statements, caseKeyword.parent = this, expression.parent = this, colonToken.parent = this, !TypeScript.isShared(statements) && (statements.parent = this);
                }
                return CaseSwitchClauseSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.CaseSwitchClauseSyntax = CaseSwitchClauseSyntax;
            var DefaultSwitchClauseSyntax = (function (_super) {
                __extends(DefaultSwitchClauseSyntax, _super);
                function DefaultSwitchClauseSyntax(data, defaultKeyword, colonToken, statements) {
                    _super.call(this, data);
                    this.defaultKeyword = defaultKeyword, this.colonToken = colonToken, this.statements = statements, defaultKeyword.parent = this, colonToken.parent = this, !TypeScript.isShared(statements) && (statements.parent = this);
                }
                return DefaultSwitchClauseSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.DefaultSwitchClauseSyntax = DefaultSwitchClauseSyntax;
            var ElseClauseSyntax = (function (_super) {
                __extends(ElseClauseSyntax, _super);
                function ElseClauseSyntax(data, elseKeyword, statement) {
                    _super.call(this, data);
                    this.elseKeyword = elseKeyword, this.statement = statement, elseKeyword.parent = this, statement.parent = this;
                }
                return ElseClauseSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.ElseClauseSyntax = ElseClauseSyntax;
            var CatchClauseSyntax = (function (_super) {
                __extends(CatchClauseSyntax, _super);
                function CatchClauseSyntax(data, catchKeyword, openParenToken, identifier, typeAnnotation, closeParenToken, block) {
                    _super.call(this, data);
                    this.catchKeyword = catchKeyword, this.openParenToken = openParenToken, this.identifier = identifier, this.typeAnnotation = typeAnnotation, this.closeParenToken = closeParenToken, this.block = block, catchKeyword.parent = this, openParenToken.parent = this, identifier.parent = this, typeAnnotation && (typeAnnotation.parent = this), closeParenToken.parent = this, block.parent = this;
                }
                return CatchClauseSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.CatchClauseSyntax = CatchClauseSyntax;
            var FinallyClauseSyntax = (function (_super) {
                __extends(FinallyClauseSyntax, _super);
                function FinallyClauseSyntax(data, finallyKeyword, block) {
                    _super.call(this, data);
                    this.finallyKeyword = finallyKeyword, this.block = block, finallyKeyword.parent = this, block.parent = this;
                }
                return FinallyClauseSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.FinallyClauseSyntax = FinallyClauseSyntax;
            var TypeParameterSyntax = (function (_super) {
                __extends(TypeParameterSyntax, _super);
                function TypeParameterSyntax(data, identifier, constraint) {
                    _super.call(this, data);
                    this.identifier = identifier, this.constraint = constraint, identifier.parent = this, constraint && (constraint.parent = this);
                }
                return TypeParameterSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.TypeParameterSyntax = TypeParameterSyntax;
            var ConstraintSyntax = (function (_super) {
                __extends(ConstraintSyntax, _super);
                function ConstraintSyntax(data, extendsKeyword, typeOrExpression) {
                    _super.call(this, data);
                    this.extendsKeyword = extendsKeyword, this.typeOrExpression = typeOrExpression, extendsKeyword.parent = this, typeOrExpression.parent = this;
                }
                return ConstraintSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.ConstraintSyntax = ConstraintSyntax;
            var SimplePropertyAssignmentSyntax = (function (_super) {
                __extends(SimplePropertyAssignmentSyntax, _super);
                function SimplePropertyAssignmentSyntax(data, propertyName, colonToken, expression) {
                    _super.call(this, data);
                    this.propertyName = propertyName, this.colonToken = colonToken, this.expression = expression, propertyName.parent = this, colonToken.parent = this, expression.parent = this;
                }
                return SimplePropertyAssignmentSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.SimplePropertyAssignmentSyntax = SimplePropertyAssignmentSyntax;
            var FunctionPropertyAssignmentSyntax = (function (_super) {
                __extends(FunctionPropertyAssignmentSyntax, _super);
                function FunctionPropertyAssignmentSyntax(data, propertyName, callSignature, block) {
                    _super.call(this, data);
                    this.propertyName = propertyName, this.callSignature = callSignature, this.block = block, propertyName.parent = this, callSignature.parent = this, block.parent = this;
                }
                return FunctionPropertyAssignmentSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.FunctionPropertyAssignmentSyntax = FunctionPropertyAssignmentSyntax;
            var ParameterSyntax = (function (_super) {
                __extends(ParameterSyntax, _super);
                function ParameterSyntax(data, dotDotDotToken, modifiers, identifier, questionToken, typeAnnotation, equalsValueClause) {
                    _super.call(this, data);
                    this.dotDotDotToken = dotDotDotToken, this.modifiers = modifiers, this.identifier = identifier, this.questionToken = questionToken, this.typeAnnotation = typeAnnotation, this.equalsValueClause = equalsValueClause, dotDotDotToken && (dotDotDotToken.parent = this), !TypeScript.isShared(modifiers) && (modifiers.parent = this), identifier.parent = this, questionToken && (questionToken.parent = this), typeAnnotation && (typeAnnotation.parent = this), equalsValueClause && (equalsValueClause.parent = this);
                }
                return ParameterSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.ParameterSyntax = ParameterSyntax;
            var EnumElementSyntax = (function (_super) {
                __extends(EnumElementSyntax, _super);
                function EnumElementSyntax(data, propertyName, equalsValueClause) {
                    _super.call(this, data);
                    this.propertyName = propertyName, this.equalsValueClause = equalsValueClause, propertyName.parent = this, equalsValueClause && (equalsValueClause.parent = this);
                }
                return EnumElementSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.EnumElementSyntax = EnumElementSyntax;
            var TypeAnnotationSyntax = (function (_super) {
                __extends(TypeAnnotationSyntax, _super);
                function TypeAnnotationSyntax(data, colonToken, type) {
                    _super.call(this, data);
                    this.colonToken = colonToken, this.type = type, colonToken.parent = this, type.parent = this;
                }
                return TypeAnnotationSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.TypeAnnotationSyntax = TypeAnnotationSyntax;
            var ExternalModuleReferenceSyntax = (function (_super) {
                __extends(ExternalModuleReferenceSyntax, _super);
                function ExternalModuleReferenceSyntax(data, requireKeyword, openParenToken, stringLiteral, closeParenToken) {
                    _super.call(this, data);
                    this.requireKeyword = requireKeyword, this.openParenToken = openParenToken, this.stringLiteral = stringLiteral, this.closeParenToken = closeParenToken, requireKeyword.parent = this, openParenToken.parent = this, stringLiteral.parent = this, closeParenToken.parent = this;
                }
                return ExternalModuleReferenceSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.ExternalModuleReferenceSyntax = ExternalModuleReferenceSyntax;
            var ModuleNameModuleReferenceSyntax = (function (_super) {
                __extends(ModuleNameModuleReferenceSyntax, _super);
                function ModuleNameModuleReferenceSyntax(data, moduleName) {
                    _super.call(this, data);
                    this.moduleName = moduleName, moduleName.parent = this;
                }
                return ModuleNameModuleReferenceSyntax;
            })(TypeScript.SyntaxNode);
            Concrete.ModuleNameModuleReferenceSyntax = ModuleNameModuleReferenceSyntax;
            SourceUnitSyntax.prototype.__kind = 120 /* SourceUnit */, QualifiedNameSyntax.prototype.__kind = 121 /* QualifiedName */, ObjectTypeSyntax.prototype.__kind = 122 /* ObjectType */, FunctionTypeSyntax.prototype.__kind = 123 /* FunctionType */, ArrayTypeSyntax.prototype.__kind = 124 /* ArrayType */, ConstructorTypeSyntax.prototype.__kind = 125 /* ConstructorType */, GenericTypeSyntax.prototype.__kind = 126 /* GenericType */, TypeQuerySyntax.prototype.__kind = 127 /* TypeQuery */, TupleTypeSyntax.prototype.__kind = 128 /* TupleType */, InterfaceDeclarationSyntax.prototype.__kind = 129 /* InterfaceDeclaration */, FunctionDeclarationSyntax.prototype.__kind = 130 /* FunctionDeclaration */, ModuleDeclarationSyntax.prototype.__kind = 131 /* ModuleDeclaration */, ClassDeclarationSyntax.prototype.__kind = 132 /* ClassDeclaration */, EnumDeclarationSyntax.prototype.__kind = 133 /* EnumDeclaration */, ImportDeclarationSyntax.prototype.__kind = 134 /* ImportDeclaration */, ExportAssignmentSyntax.prototype.__kind = 135 /* ExportAssignment */, MemberFunctionDeclarationSyntax.prototype.__kind = 136 /* MemberFunctionDeclaration */, MemberVariableDeclarationSyntax.prototype.__kind = 137 /* MemberVariableDeclaration */, ConstructorDeclarationSyntax.prototype.__kind = 138 /* ConstructorDeclaration */, IndexMemberDeclarationSyntax.prototype.__kind = 139 /* IndexMemberDeclaration */, GetAccessorSyntax.prototype.__kind = 140 /* GetAccessor */, SetAccessorSyntax.prototype.__kind = 141 /* SetAccessor */, PropertySignatureSyntax.prototype.__kind = 142 /* PropertySignature */, CallSignatureSyntax.prototype.__kind = 143 /* CallSignature */, ConstructSignatureSyntax.prototype.__kind = 144 /* ConstructSignature */, IndexSignatureSyntax.prototype.__kind = 145 /* IndexSignature */, MethodSignatureSyntax.prototype.__kind = 146 /* MethodSignature */, BlockSyntax.prototype.__kind = 147 /* Block */, IfStatementSyntax.prototype.__kind = 148 /* IfStatement */, VariableStatementSyntax.prototype.__kind = 149 /* VariableStatement */, ExpressionStatementSyntax.prototype.__kind = 150 /* ExpressionStatement */, ReturnStatementSyntax.prototype.__kind = 151 /* ReturnStatement */, SwitchStatementSyntax.prototype.__kind = 152 /* SwitchStatement */, BreakStatementSyntax.prototype.__kind = 153 /* BreakStatement */, ContinueStatementSyntax.prototype.__kind = 154 /* ContinueStatement */, ForStatementSyntax.prototype.__kind = 155 /* ForStatement */, ForInStatementSyntax.prototype.__kind = 156 /* ForInStatement */, EmptyStatementSyntax.prototype.__kind = 157 /* EmptyStatement */, ThrowStatementSyntax.prototype.__kind = 158 /* ThrowStatement */, WhileStatementSyntax.prototype.__kind = 159 /* WhileStatement */, TryStatementSyntax.prototype.__kind = 160 /* TryStatement */, LabeledStatementSyntax.prototype.__kind = 161 /* LabeledStatement */, DoStatementSyntax.prototype.__kind = 162 /* DoStatement */, DebuggerStatementSyntax.prototype.__kind = 163 /* DebuggerStatement */, WithStatementSyntax.prototype.__kind = 164 /* WithStatement */, DeleteExpressionSyntax.prototype.__kind = 171 /* DeleteExpression */, TypeOfExpressionSyntax.prototype.__kind = 172 /* TypeOfExpression */, VoidExpressionSyntax.prototype.__kind = 173 /* VoidExpression */, ConditionalExpressionSyntax.prototype.__kind = 187 /* ConditionalExpression */, MemberAccessExpressionSyntax.prototype.__kind = 213 /* MemberAccessExpression */, InvocationExpressionSyntax.prototype.__kind = 214 /* InvocationExpression */, ArrayLiteralExpressionSyntax.prototype.__kind = 215 /* ArrayLiteralExpression */, ObjectLiteralExpressionSyntax.prototype.__kind = 216 /* ObjectLiteralExpression */, ObjectCreationExpressionSyntax.prototype.__kind = 217 /* ObjectCreationExpression */, ParenthesizedExpressionSyntax.prototype.__kind = 218 /* ParenthesizedExpression */, ParenthesizedArrowFunctionExpressionSyntax.prototype.__kind = 219 /* ParenthesizedArrowFunctionExpression */, SimpleArrowFunctionExpressionSyntax.prototype.__kind = 220 /* SimpleArrowFunctionExpression */, CastExpressionSyntax.prototype.__kind = 221 /* CastExpression */, ElementAccessExpressionSyntax.prototype.__kind = 222 /* ElementAccessExpression */, FunctionExpressionSyntax.prototype.__kind = 223 /* FunctionExpression */, OmittedExpressionSyntax.prototype.__kind = 224 /* OmittedExpression */, VariableDeclarationSyntax.prototype.__kind = 225 /* VariableDeclaration */, VariableDeclaratorSyntax.prototype.__kind = 226 /* VariableDeclarator */, ArgumentListSyntax.prototype.__kind = 227 /* ArgumentList */, ParameterListSyntax.prototype.__kind = 228 /* ParameterList */, TypeArgumentListSyntax.prototype.__kind = 229 /* TypeArgumentList */, TypeParameterListSyntax.prototype.__kind = 230 /* TypeParameterList */, EqualsValueClauseSyntax.prototype.__kind = 233 /* EqualsValueClause */, CaseSwitchClauseSyntax.prototype.__kind = 234 /* CaseSwitchClause */, DefaultSwitchClauseSyntax.prototype.__kind = 235 /* DefaultSwitchClause */, ElseClauseSyntax.prototype.__kind = 236 /* ElseClause */, CatchClauseSyntax.prototype.__kind = 237 /* CatchClause */, FinallyClauseSyntax.prototype.__kind = 238 /* FinallyClause */, TypeParameterSyntax.prototype.__kind = 239 /* TypeParameter */, ConstraintSyntax.prototype.__kind = 240 /* Constraint */, SimplePropertyAssignmentSyntax.prototype.__kind = 241 /* SimplePropertyAssignment */, FunctionPropertyAssignmentSyntax.prototype.__kind = 242 /* FunctionPropertyAssignment */, ParameterSyntax.prototype.__kind = 243 /* Parameter */, EnumElementSyntax.prototype.__kind = 244 /* EnumElement */, TypeAnnotationSyntax.prototype.__kind = 245 /* TypeAnnotation */, ExternalModuleReferenceSyntax.prototype.__kind = 246 /* ExternalModuleReference */, ModuleNameModuleReferenceSyntax.prototype.__kind = 247 /* ModuleNameModuleReference */;
        })(Concrete = Syntax.Concrete || (Syntax.Concrete = {}));
    })(Syntax = TypeScript.Syntax || (TypeScript.Syntax = {}));
})(TypeScript || (TypeScript = {}));
///<reference path='references.ts' />
var TypeScript;
(function (TypeScript) {
    TypeScript.syntaxDiagnosticsTime = 0;
    var SyntaxTree = (function () {
        function SyntaxTree(isConcrete, sourceUnit, isDeclaration, diagnostics, fileName, text, languageVersion) {
            this.text = text;
            this._allDiagnostics = null;
            this._isConcrete = isConcrete;
            this._sourceUnit = sourceUnit;
            this._isDeclaration = isDeclaration;
            this._parserDiagnostics = diagnostics;
            this._fileName = fileName;
            this._lineMap = text.lineMap();
            this._languageVersion = languageVersion;
            sourceUnit.syntaxTree = this;
        }
        SyntaxTree.prototype.isConcrete = function () {
            return this._isConcrete;
        };
        SyntaxTree.prototype.sourceUnit = function () {
            return this._sourceUnit;
        };
        SyntaxTree.prototype.isDeclaration = function () {
            return this._isDeclaration;
        };
        SyntaxTree.prototype.computeDiagnostics = function () {
            if (this._parserDiagnostics.length > 0) {
                return this._parserDiagnostics;
            }
            // No parser reported diagnostics.  Check for any additional grammar diagnostics.
            var diagnostics = [];
            TypeScript.visitNodeOrToken(new GrammarCheckerWalker(this, diagnostics), this.sourceUnit());
            return diagnostics;
        };
        SyntaxTree.prototype.diagnostics = function () {
            if (this._allDiagnostics === null) {
                var start = new Date().getTime();
                this._allDiagnostics = this.computeDiagnostics();
                TypeScript.syntaxDiagnosticsTime += new Date().getTime() - start;
            }
            return this._allDiagnostics;
        };
        SyntaxTree.prototype.fileName = function () {
            return this._fileName;
        };
        SyntaxTree.prototype.lineMap = function () {
            return this._lineMap;
        };
        SyntaxTree.prototype.languageVersion = function () {
            return this._languageVersion;
        };
        SyntaxTree.prototype.cacheSyntaxTreeInfo = function () {
            // If we're not keeping around the syntax tree, store the diagnostics and line
            // map so they don't have to be recomputed.
            var sourceUnit = this.sourceUnit();
            var firstToken = firstSyntaxTreeToken(this);
            var leadingTrivia = firstToken.leadingTrivia(this.text);
            this._isExternalModule = externalModuleIndicatorSpanWorker(this, firstToken) !== null;
            var amdDependencies = [];
            for (var i = 0, n = leadingTrivia.count(); i < n; i++) {
                var trivia = leadingTrivia.syntaxTriviaAt(i);
                if (trivia.isComment()) {
                    var amdDependency = this.getAmdDependency(trivia.fullText());
                    if (amdDependency) {
                        amdDependencies.push(amdDependency);
                    }
                }
            }
            this._amdDependencies = amdDependencies;
        };
        SyntaxTree.prototype.getAmdDependency = function (comment) {
            var amdDependencyRegEx = /^\/\/\/\s*<amd-dependency\s+path=('|")(.+?)\1/gim;
            var match = amdDependencyRegEx.exec(comment);
            return match ? match[2] : null;
        };
        SyntaxTree.prototype.isExternalModule = function () {
            // October 11, 2013
            // External modules are written as separate source files that contain at least one 
            // external import declaration, export assignment, or top-level exported declaration.
            if (this._isExternalModule === undefined) {
                // force the info about isExternalModule to get created.
                this.cacheSyntaxTreeInfo();
                TypeScript.Debug.assert(this._isExternalModule !== undefined);
            }
            return this._isExternalModule;
        };
        SyntaxTree.prototype.amdDependencies = function () {
            if (this._amdDependencies === undefined) {
                this.cacheSyntaxTreeInfo();
                TypeScript.Debug.assert(this._amdDependencies !== undefined);
            }
            return this._amdDependencies;
        };
        return SyntaxTree;
    })();
    TypeScript.SyntaxTree = SyntaxTree;
    var GrammarCheckerWalker = (function (_super) {
        __extends(GrammarCheckerWalker, _super);
        function GrammarCheckerWalker(syntaxTree, diagnostics) {
            _super.call(this);
            this.syntaxTree = syntaxTree;
            this.diagnostics = diagnostics;
            this.inAmbientDeclaration = false;
            this.inBlock = false;
            this.inObjectLiteralExpression = false;
            this.text = syntaxTree.text;
        }
        GrammarCheckerWalker.prototype.pushDiagnostic = function (element, diagnosticKey, args) {
            if (args === void 0) { args = null; }
            this.diagnostics.push(new TypeScript.Diagnostic(this.syntaxTree.fileName(), this.syntaxTree.lineMap(), TypeScript.start(element, this.text), TypeScript.width(element), diagnosticKey, args));
        };
        GrammarCheckerWalker.prototype.visitCatchClause = function (node) {
            if (this.checkForCatchClauseTypeAnnotation(node) || this.checkForDisallowedEvalOrArguments(node, node.identifier)) {
                return;
            }
            _super.prototype.visitCatchClause.call(this, node);
        };
        GrammarCheckerWalker.prototype.checkForCatchClauseTypeAnnotation = function (node) {
            if (node.typeAnnotation) {
                this.pushDiagnostic(node.typeAnnotation.colonToken, TypeScript.DiagnosticCode.Catch_clause_parameter_cannot_have_a_type_annotation);
                return true;
            }
            return false;
        };
        GrammarCheckerWalker.prototype.checkParameterListOrder = function (node) {
            var seenOptionalParameter = false;
            var parameterCount = node.parameters.length;
            for (var i = 0; i < parameterCount; i++) {
                var parameter = node.parameters[i];
                if (parameter.dotDotDotToken) {
                    if (i !== (parameterCount - 1)) {
                        this.pushDiagnostic(parameter, TypeScript.DiagnosticCode.A_rest_parameter_must_be_last_in_a_parameter_list);
                        return true;
                    }
                    if (parameter.questionToken) {
                        this.pushDiagnostic(parameter, TypeScript.DiagnosticCode.A_rest_parameter_cannot_be_optional);
                        return true;
                    }
                    if (parameter.equalsValueClause) {
                        this.pushDiagnostic(parameter, TypeScript.DiagnosticCode.A_rest_parameter_cannot_have_an_initializer);
                        return true;
                    }
                }
                else if (parameter.questionToken || parameter.equalsValueClause) {
                    seenOptionalParameter = true;
                    if (parameter.questionToken && parameter.equalsValueClause) {
                        this.pushDiagnostic(parameter, TypeScript.DiagnosticCode.Parameter_cannot_have_question_mark_and_initializer);
                        return true;
                    }
                }
                else {
                    if (seenOptionalParameter) {
                        this.pushDiagnostic(parameter, TypeScript.DiagnosticCode.A_required_parameter_cannot_follow_an_optional_parameter);
                        return true;
                    }
                }
            }
            return false;
        };
        GrammarCheckerWalker.prototype.checkParameterListAcessibilityModifiers = function (node) {
            for (var i = 0, n = node.parameters.length; i < n; i++) {
                var parameter = node.parameters[i];
                if (this.checkParameterAccessibilityModifiers(node, parameter)) {
                    return true;
                }
            }
            return false;
        };
        GrammarCheckerWalker.prototype.checkParameterAccessibilityModifiers = function (parameterList, parameter) {
            if (parameter.modifiers.length > 0) {
                var modifiers = parameter.modifiers;
                for (var i = 0, n = modifiers.length; i < n; i++) {
                    var modifier = modifiers[i];
                    if (this.checkParameterAccessibilityModifier(parameterList, modifier, i)) {
                        return true;
                    }
                }
            }
            return false;
        };
        GrammarCheckerWalker.prototype.checkParameterAccessibilityModifier = function (parameterList, modifier, modifierIndex) {
            if (!TypeScript.SyntaxFacts.isAccessibilityModifier(modifier.kind())) {
                this.pushDiagnostic(modifier, TypeScript.DiagnosticCode._0_modifier_cannot_appear_on_a_parameter, [modifier.text()]);
                return true;
            }
            else {
                if (modifierIndex > 0) {
                    this.pushDiagnostic(modifier, TypeScript.DiagnosticCode.Accessibility_modifier_already_seen);
                    return true;
                }
            }
            return false;
        };
        GrammarCheckerWalker.prototype.checkForTrailingComma = function (list) {
            // If we have at least one child, and we have an even number of children, then that 
            // means we have an illegal trailing separator.
            if (TypeScript.childCount(list) === 0 || TypeScript.childCount(list) % 2 === 1) {
                return false;
            }
            var child = TypeScript.childAt(list, TypeScript.childCount(list) - 1);
            this.pushDiagnostic(child, TypeScript.DiagnosticCode.Trailing_comma_not_allowed);
            return true;
        };
        GrammarCheckerWalker.prototype.checkForAtLeastOneElement = function (parent, list, reportToken, listKind) {
            if (TypeScript.childCount(list) > 0) {
                return false;
            }
            this.pushDiagnostic(reportToken, TypeScript.DiagnosticCode._0_list_cannot_be_empty, [listKind]);
            return true;
        };
        GrammarCheckerWalker.prototype.visitParameterList = function (node) {
            if (this.checkParameterListAcessibilityModifiers(node) || this.checkParameterListOrder(node) || this.checkForTrailingComma(node.parameters)) {
                return;
            }
            _super.prototype.visitParameterList.call(this, node);
        };
        GrammarCheckerWalker.prototype.visitHeritageClause = function (node) {
            if (this.checkForTrailingComma(node.typeNames) || this.checkForAtLeastOneElement(node, node.typeNames, node.extendsOrImplementsKeyword, TypeScript.SyntaxFacts.getText(node.extendsOrImplementsKeyword.kind()))) {
                return;
            }
            _super.prototype.visitHeritageClause.call(this, node);
        };
        GrammarCheckerWalker.prototype.visitArgumentList = function (node) {
            if (this.checkForTrailingComma(node.arguments)) {
                return;
            }
            _super.prototype.visitArgumentList.call(this, node);
        };
        GrammarCheckerWalker.prototype.visitVariableDeclaration = function (node) {
            if (this.checkForAtLeastOneElement(node, node.variableDeclarators, node.varKeyword, TypeScript.getLocalizedText(TypeScript.DiagnosticCode.variable_declaration, null)) || this.checkForTrailingComma(node.variableDeclarators)) {
                return;
            }
            _super.prototype.visitVariableDeclaration.call(this, node);
        };
        GrammarCheckerWalker.prototype.visitTypeArgumentList = function (node) {
            if (this.checkForTrailingComma(node.typeArguments) || this.checkForAtLeastOneElement(node, node.typeArguments, node.lessThanToken, TypeScript.getLocalizedText(TypeScript.DiagnosticCode.type_argument, null))) {
                return;
            }
            _super.prototype.visitTypeArgumentList.call(this, node);
        };
        GrammarCheckerWalker.prototype.visitTupleType = function (node) {
            if (this.checkForTrailingComma(node.types) || this.checkForAtLeastOneElement(node, node.types, node.openBracketToken, TypeScript.getLocalizedText(TypeScript.DiagnosticCode.type, null))) {
                return;
            }
            _super.prototype.visitTupleType.call(this, node);
        };
        GrammarCheckerWalker.prototype.visitTypeParameterList = function (node) {
            if (this.checkForTrailingComma(node.typeParameters) || this.checkForAtLeastOneElement(node, node.typeParameters, node.lessThanToken, TypeScript.getLocalizedText(TypeScript.DiagnosticCode.type_parameter, null))) {
                return;
            }
            _super.prototype.visitTypeParameterList.call(this, node);
        };
        GrammarCheckerWalker.prototype.checkIndexSignatureParameter = function (node) {
            if (node.parameters.length !== 1) {
                this.pushDiagnostic(node.openBracketToken, TypeScript.DiagnosticCode.Index_signature_must_have_exactly_one_parameter);
                return true;
            }
            var parameter = node.parameters[0];
            if (parameter.dotDotDotToken) {
                this.pushDiagnostic(parameter, TypeScript.DiagnosticCode.Index_signatures_cannot_have_rest_parameters);
                return true;
            }
            else if (parameter.modifiers.length > 0) {
                this.pushDiagnostic(parameter, TypeScript.DiagnosticCode.Index_signature_parameter_cannot_have_accessibility_modifiers);
                return true;
            }
            else if (parameter.questionToken) {
                this.pushDiagnostic(parameter, TypeScript.DiagnosticCode.Index_signature_parameter_cannot_have_a_question_mark);
                return true;
            }
            else if (parameter.equalsValueClause) {
                this.pushDiagnostic(parameter, TypeScript.DiagnosticCode.Index_signature_parameter_cannot_have_an_initializer);
                return true;
            }
            else if (!parameter.typeAnnotation) {
                this.pushDiagnostic(parameter, TypeScript.DiagnosticCode.Index_signature_parameter_must_have_a_type_annotation);
                return true;
            }
            else if (parameter.typeAnnotation.type.kind() !== 69 /* StringKeyword */ && parameter.typeAnnotation.type.kind() !== 67 /* NumberKeyword */) {
                this.pushDiagnostic(parameter, TypeScript.DiagnosticCode.Index_signature_parameter_type_must_be_string_or_number);
                return true;
            }
            return false;
        };
        GrammarCheckerWalker.prototype.visitIndexSignature = function (node) {
            if (this.checkIndexSignatureParameter(node)) {
                return;
            }
            if (!node.typeAnnotation) {
                this.pushDiagnostic(node, TypeScript.DiagnosticCode.Index_signature_must_have_a_type_annotation);
                return;
            }
            _super.prototype.visitIndexSignature.call(this, node);
        };
        GrammarCheckerWalker.prototype.checkClassDeclarationHeritageClauses = function (node) {
            var seenExtendsClause = false;
            var seenImplementsClause = false;
            for (var i = 0, n = node.heritageClauses.length; i < n; i++) {
                TypeScript.Debug.assert(i <= 2);
                var heritageClause = node.heritageClauses[i];
                if (heritageClause.extendsOrImplementsKeyword.kind() === 48 /* ExtendsKeyword */) {
                    if (seenExtendsClause) {
                        this.pushDiagnostic(heritageClause, TypeScript.DiagnosticCode.extends_clause_already_seen);
                        return true;
                    }
                    if (seenImplementsClause) {
                        this.pushDiagnostic(heritageClause, TypeScript.DiagnosticCode.extends_clause_must_precede_implements_clause);
                        return true;
                    }
                    if (heritageClause.typeNames.length > 1) {
                        this.pushDiagnostic(heritageClause, TypeScript.DiagnosticCode.Classes_can_only_extend_a_single_class);
                        return true;
                    }
                    seenExtendsClause = true;
                }
                else {
                    TypeScript.Debug.assert(heritageClause.extendsOrImplementsKeyword.kind() === 51 /* ImplementsKeyword */);
                    if (seenImplementsClause) {
                        this.pushDiagnostic(heritageClause, TypeScript.DiagnosticCode.implements_clause_already_seen);
                        return true;
                    }
                    seenImplementsClause = true;
                }
            }
            return false;
        };
        GrammarCheckerWalker.prototype.checkForDisallowedDeclareModifier = function (modifiers) {
            if (this.inAmbientDeclaration) {
                // If we're already in an ambient declaration, then 'declare' is not allowed.
                var declareToken = TypeScript.SyntaxUtilities.getToken(modifiers, 63 /* DeclareKeyword */);
                if (declareToken) {
                    this.pushDiagnostic(declareToken, TypeScript.DiagnosticCode.A_declare_modifier_cannot_be_used_in_an_already_ambient_context);
                    return true;
                }
            }
            return false;
        };
        GrammarCheckerWalker.prototype.checkForRequiredDeclareModifier = function (moduleElement, reportToken, modifiers) {
            if (!this.inAmbientDeclaration && this.syntaxTree.isDeclaration()) {
                // We're at the top level in a declaration file, a 'declare' modifiers is required
                // on most module elements.
                if (!TypeScript.SyntaxUtilities.containsToken(modifiers, 63 /* DeclareKeyword */)) {
                    this.pushDiagnostic(reportToken, TypeScript.DiagnosticCode.A_declare_modifier_is_required_for_a_top_level_declaration_in_a_d_ts_file);
                    return true;
                }
            }
        };
        GrammarCheckerWalker.prototype.visitClassDeclaration = function (node) {
            if (this.checkForDisallowedDeclareModifier(node.modifiers) || this.checkForRequiredDeclareModifier(node, node.identifier, node.modifiers) || this.checkModuleElementModifiers(node.modifiers) || this.checkClassDeclarationHeritageClauses(node)) {
                return;
            }
            var savedInAmbientDeclaration = this.inAmbientDeclaration;
            this.inAmbientDeclaration = this.inAmbientDeclaration || this.syntaxTree.isDeclaration() || TypeScript.SyntaxUtilities.containsToken(node.modifiers, 63 /* DeclareKeyword */);
            _super.prototype.visitClassDeclaration.call(this, node);
            this.inAmbientDeclaration = savedInAmbientDeclaration;
        };
        GrammarCheckerWalker.prototype.checkInterfaceDeclarationHeritageClauses = function (node) {
            var seenExtendsClause = false;
            for (var i = 0, n = node.heritageClauses.length; i < n; i++) {
                TypeScript.Debug.assert(i <= 1);
                var heritageClause = node.heritageClauses[i];
                if (heritageClause.extendsOrImplementsKeyword.kind() === 48 /* ExtendsKeyword */) {
                    if (seenExtendsClause) {
                        this.pushDiagnostic(heritageClause, TypeScript.DiagnosticCode.extends_clause_already_seen);
                        return true;
                    }
                    seenExtendsClause = true;
                }
                else {
                    TypeScript.Debug.assert(heritageClause.extendsOrImplementsKeyword.kind() === 51 /* ImplementsKeyword */);
                    this.pushDiagnostic(heritageClause, TypeScript.DiagnosticCode.Interface_declaration_cannot_have_implements_clause);
                    return true;
                }
            }
            return false;
        };
        GrammarCheckerWalker.prototype.checkInterfaceModifiers = function (modifiers) {
            for (var i = 0, n = modifiers.length; i < n; i++) {
                var modifier = modifiers[i];
                if (modifier.kind() === 63 /* DeclareKeyword */) {
                    this.pushDiagnostic(modifier, TypeScript.DiagnosticCode.A_declare_modifier_cannot_be_used_with_an_interface_declaration);
                    return true;
                }
            }
            return false;
        };
        GrammarCheckerWalker.prototype.visitInterfaceDeclaration = function (node) {
            if (this.checkInterfaceModifiers(node.modifiers) || this.checkModuleElementModifiers(node.modifiers) || this.checkInterfaceDeclarationHeritageClauses(node)) {
                return;
            }
            _super.prototype.visitInterfaceDeclaration.call(this, node);
        };
        GrammarCheckerWalker.prototype.checkClassElementModifiers = function (list) {
            var seenAccessibilityModifier = false;
            var seenStaticModifier = false;
            for (var i = 0, n = list.length; i < n; i++) {
                var modifier = list[i];
                if (TypeScript.SyntaxFacts.isAccessibilityModifier(modifier.kind())) {
                    if (seenAccessibilityModifier) {
                        this.pushDiagnostic(modifier, TypeScript.DiagnosticCode.Accessibility_modifier_already_seen);
                        return true;
                    }
                    if (seenStaticModifier) {
                        var previousToken = list[i - 1];
                        this.pushDiagnostic(modifier, TypeScript.DiagnosticCode._0_modifier_must_precede_1_modifier, [modifier.text(), previousToken.text()]);
                        return true;
                    }
                    seenAccessibilityModifier = true;
                }
                else if (modifier.kind() === 58 /* StaticKeyword */) {
                    if (seenStaticModifier) {
                        this.pushDiagnostic(modifier, TypeScript.DiagnosticCode._0_modifier_already_seen, [modifier.text()]);
                        return true;
                    }
                    seenStaticModifier = true;
                }
                else {
                    this.pushDiagnostic(modifier, TypeScript.DiagnosticCode._0_modifier_cannot_appear_on_a_class_element, [modifier.text()]);
                    return true;
                }
            }
            return false;
        };
        GrammarCheckerWalker.prototype.visitMemberVariableDeclaration = function (node) {
            if (this.checkClassElementModifiers(node.modifiers)) {
                return;
            }
            _super.prototype.visitMemberVariableDeclaration.call(this, node);
        };
        GrammarCheckerWalker.prototype.visitMemberFunctionDeclaration = function (node) {
            if (this.checkClassElementModifiers(node.modifiers)) {
                return;
            }
            _super.prototype.visitMemberFunctionDeclaration.call(this, node);
        };
        GrammarCheckerWalker.prototype.checkGetAccessorParameter = function (node) {
            if (node.callSignature.parameterList.parameters.length !== 0) {
                this.pushDiagnostic(node.propertyName, TypeScript.DiagnosticCode.get_accessor_cannot_have_parameters);
                return true;
            }
            return false;
        };
        GrammarCheckerWalker.prototype.visitIndexMemberDeclaration = function (node) {
            if (this.checkIndexMemberModifiers(node)) {
                return;
            }
            _super.prototype.visitIndexMemberDeclaration.call(this, node);
        };
        GrammarCheckerWalker.prototype.checkIndexMemberModifiers = function (node) {
            if (node.modifiers.length > 0) {
                this.pushDiagnostic(TypeScript.childAt(node.modifiers, 0), TypeScript.DiagnosticCode.Modifiers_cannot_appear_here);
                return true;
            }
            return false;
        };
        GrammarCheckerWalker.prototype.checkEcmaScriptVersionIsAtLeast = function (parent, reportToken, languageVersion, diagnosticKey) {
            if (this.syntaxTree.languageVersion() < languageVersion) {
                this.pushDiagnostic(reportToken, diagnosticKey);
                return true;
            }
            return false;
        };
        GrammarCheckerWalker.prototype.visitObjectLiteralExpression = function (node) {
            var savedInObjectLiteralExpression = this.inObjectLiteralExpression;
            this.inObjectLiteralExpression = true;
            _super.prototype.visitObjectLiteralExpression.call(this, node);
            this.inObjectLiteralExpression = savedInObjectLiteralExpression;
        };
        GrammarCheckerWalker.prototype.visitGetAccessor = function (node) {
            if (this.checkForAccessorDeclarationInAmbientContext(node) || this.checkEcmaScriptVersionIsAtLeast(node, node.propertyName, 1 /* ES5 */, TypeScript.DiagnosticCode.Accessors_are_only_available_when_targeting_ECMAScript_5_and_higher) || this.checkForDisallowedModifiers(node, node.modifiers) || this.checkClassElementModifiers(node.modifiers) || this.checkForDisallowedAccessorTypeParameters(node.callSignature) || this.checkGetAccessorParameter(node)) {
                return;
            }
            _super.prototype.visitGetAccessor.call(this, node);
        };
        GrammarCheckerWalker.prototype.checkForDisallowedSetAccessorTypeAnnotation = function (accessor) {
            if (accessor.callSignature.typeAnnotation) {
                this.pushDiagnostic(accessor.callSignature.typeAnnotation, TypeScript.DiagnosticCode.Type_annotation_cannot_appear_on_a_set_accessor);
                return true;
            }
            return false;
        };
        GrammarCheckerWalker.prototype.checkForDisallowedAccessorTypeParameters = function (callSignature) {
            if (callSignature.typeParameterList !== null) {
                this.pushDiagnostic(callSignature.typeParameterList, TypeScript.DiagnosticCode.Type_parameters_cannot_appear_on_an_accessor);
                return true;
            }
            return false;
        };
        GrammarCheckerWalker.prototype.checkForAccessorDeclarationInAmbientContext = function (accessor) {
            if (this.inAmbientDeclaration) {
                this.pushDiagnostic(accessor, TypeScript.DiagnosticCode.Accessors_are_not_allowed_in_ambient_contexts);
                return true;
            }
            return false;
        };
        GrammarCheckerWalker.prototype.checkSetAccessorParameter = function (node) {
            var parameters = node.callSignature.parameterList.parameters;
            if (TypeScript.childCount(parameters) !== 1) {
                this.pushDiagnostic(node.propertyName, TypeScript.DiagnosticCode.set_accessor_must_have_exactly_one_parameter);
                return true;
            }
            var parameter = parameters[0];
            if (parameter.questionToken) {
                this.pushDiagnostic(parameter, TypeScript.DiagnosticCode.set_accessor_parameter_cannot_be_optional);
                return true;
            }
            if (parameter.equalsValueClause) {
                this.pushDiagnostic(parameter, TypeScript.DiagnosticCode.set_accessor_parameter_cannot_have_an_initializer);
                return true;
            }
            if (parameter.dotDotDotToken) {
                this.pushDiagnostic(parameter, TypeScript.DiagnosticCode.set_accessor_cannot_have_rest_parameter);
                return true;
            }
            return false;
        };
        GrammarCheckerWalker.prototype.visitSetAccessor = function (node) {
            if (this.checkForAccessorDeclarationInAmbientContext(node) || this.checkEcmaScriptVersionIsAtLeast(node, node.propertyName, 1 /* ES5 */, TypeScript.DiagnosticCode.Accessors_are_only_available_when_targeting_ECMAScript_5_and_higher) || this.checkForDisallowedModifiers(node, node.modifiers) || this.checkClassElementModifiers(node.modifiers) || this.checkForDisallowedAccessorTypeParameters(node.callSignature) || this.checkForDisallowedSetAccessorTypeAnnotation(node) || this.checkSetAccessorParameter(node)) {
                return;
            }
            _super.prototype.visitSetAccessor.call(this, node);
        };
        GrammarCheckerWalker.prototype.visitEnumDeclaration = function (node) {
            if (this.checkForDisallowedDeclareModifier(node.modifiers) || this.checkForRequiredDeclareModifier(node, node.identifier, node.modifiers) || this.checkModuleElementModifiers(node.modifiers), this.checkEnumElements(node)) {
                return;
            }
            var savedInAmbientDeclaration = this.inAmbientDeclaration;
            this.inAmbientDeclaration = this.inAmbientDeclaration || this.syntaxTree.isDeclaration() || TypeScript.SyntaxUtilities.containsToken(node.modifiers, 63 /* DeclareKeyword */);
            _super.prototype.visitEnumDeclaration.call(this, node);
            this.inAmbientDeclaration = savedInAmbientDeclaration;
        };
        GrammarCheckerWalker.prototype.checkEnumElements = function (node) {
            var previousValueWasComputed = false;
            for (var i = 0, n = TypeScript.childCount(node.enumElements); i < n; i++) {
                var child = TypeScript.childAt(node.enumElements, i);
                if (i % 2 === 0) {
                    var enumElement = child;
                    if (!enumElement.equalsValueClause && previousValueWasComputed) {
                        this.pushDiagnostic(enumElement, TypeScript.DiagnosticCode.Enum_member_must_have_initializer);
                        return true;
                    }
                    if (enumElement.equalsValueClause) {
                        var value = enumElement.equalsValueClause.value;
                        previousValueWasComputed = !TypeScript.Syntax.isIntegerLiteral(value);
                    }
                }
            }
            return false;
        };
        GrammarCheckerWalker.prototype.visitEnumElement = function (node) {
            if (this.inAmbientDeclaration && node.equalsValueClause) {
                var expression = node.equalsValueClause.value;
                if (!TypeScript.Syntax.isIntegerLiteral(expression)) {
                    this.pushDiagnostic(node.equalsValueClause.value, TypeScript.DiagnosticCode.Ambient_enum_elements_can_only_have_integer_literal_initializers);
                    return;
                }
            }
            _super.prototype.visitEnumElement.call(this, node);
        };
        GrammarCheckerWalker.prototype.visitInvocationExpression = function (node) {
            if (node.expression.kind() === 50 /* SuperKeyword */ && node.argumentList.typeArgumentList !== null) {
                this.pushDiagnostic(node, TypeScript.DiagnosticCode.super_invocation_cannot_have_type_arguments);
            }
            _super.prototype.visitInvocationExpression.call(this, node);
        };
        GrammarCheckerWalker.prototype.checkModuleElementModifiers = function (modifiers) {
            var seenExportModifier = false;
            var seenDeclareModifier = false;
            for (var i = 0, n = modifiers.length; i < n; i++) {
                var modifier = modifiers[i];
                if (TypeScript.SyntaxFacts.isAccessibilityModifier(modifier.kind()) || modifier.kind() === 58 /* StaticKeyword */) {
                    this.pushDiagnostic(modifier, TypeScript.DiagnosticCode._0_modifier_cannot_appear_on_a_module_element, [modifier.text()]);
                    return true;
                }
                if (modifier.kind() === 63 /* DeclareKeyword */) {
                    if (seenDeclareModifier) {
                        this.pushDiagnostic(modifier, TypeScript.DiagnosticCode.Accessibility_modifier_already_seen);
                        return;
                    }
                    seenDeclareModifier = true;
                }
                else if (modifier.kind() === 47 /* ExportKeyword */) {
                    if (seenExportModifier) {
                        this.pushDiagnostic(modifier, TypeScript.DiagnosticCode._0_modifier_already_seen, [modifier.text()]);
                        return;
                    }
                    if (seenDeclareModifier) {
                        this.pushDiagnostic(modifier, TypeScript.DiagnosticCode._0_modifier_must_precede_1_modifier, [TypeScript.SyntaxFacts.getText(47 /* ExportKeyword */), TypeScript.SyntaxFacts.getText(63 /* DeclareKeyword */)]);
                        return;
                    }
                    seenExportModifier = true;
                }
            }
            return false;
        };
        GrammarCheckerWalker.prototype.checkForDisallowedImportDeclaration = function (node) {
            if (!node.stringLiteral) {
                for (var i = 0, n = node.moduleElements.length; i < n; i++) {
                    var child = node.moduleElements[i];
                    if (child.kind() === 134 /* ImportDeclaration */) {
                        var importDeclaration = child;
                        if (importDeclaration.moduleReference.kind() === 246 /* ExternalModuleReference */) {
                            this.pushDiagnostic(importDeclaration, TypeScript.DiagnosticCode.Import_declarations_in_an_internal_module_cannot_reference_an_external_module);
                        }
                    }
                }
            }
            return false;
        };
        GrammarCheckerWalker.prototype.checkForDisallowedDeclareModifierOnImportDeclaration = function (modifiers) {
            var declareToken = TypeScript.SyntaxUtilities.getToken(modifiers, 63 /* DeclareKeyword */);
            if (declareToken) {
                this.pushDiagnostic(declareToken, TypeScript.DiagnosticCode.A_declare_modifier_cannot_be_used_with_an_import_declaration);
                return true;
            }
        };
        GrammarCheckerWalker.prototype.visitImportDeclaration = function (node) {
            if (this.checkForDisallowedDeclareModifierOnImportDeclaration(node.modifiers) || this.checkModuleElementModifiers(node.modifiers)) {
                return;
            }
            _super.prototype.visitImportDeclaration.call(this, node);
        };
        GrammarCheckerWalker.prototype.visitModuleDeclaration = function (node) {
            if (this.checkForDisallowedDeclareModifier(node.modifiers) || this.checkForRequiredDeclareModifier(node, node.stringLiteral ? node.stringLiteral : TypeScript.firstToken(node.name), node.modifiers) || this.checkModuleElementModifiers(node.modifiers) || this.checkForDisallowedImportDeclaration(node)) {
                return;
            }
            if (node.stringLiteral) {
                if (!this.inAmbientDeclaration && !TypeScript.SyntaxUtilities.containsToken(node.modifiers, 63 /* DeclareKeyword */)) {
                    this.pushDiagnostic(node.stringLiteral, TypeScript.DiagnosticCode.Only_ambient_modules_can_use_quoted_names);
                    return;
                }
            }
            if (!node.stringLiteral && this.checkForDisallowedExportAssignment(node)) {
                return;
            }
            var savedInAmbientDeclaration = this.inAmbientDeclaration;
            this.inAmbientDeclaration = this.inAmbientDeclaration || this.syntaxTree.isDeclaration() || TypeScript.SyntaxUtilities.containsToken(node.modifiers, 63 /* DeclareKeyword */);
            _super.prototype.visitModuleDeclaration.call(this, node);
            this.inAmbientDeclaration = savedInAmbientDeclaration;
        };
        GrammarCheckerWalker.prototype.checkForDisallowedExportAssignment = function (node) {
            for (var i = 0, n = node.moduleElements.length; i < n; i++) {
                var child = node.moduleElements[i];
                if (child.kind() === 135 /* ExportAssignment */) {
                    this.pushDiagnostic(child, TypeScript.DiagnosticCode.Export_assignment_cannot_be_used_in_internal_modules);
                    return true;
                }
            }
            return false;
        };
        GrammarCheckerWalker.prototype.visitBlock = function (node) {
            if (this.checkForBlockInAmbientContext(node)) {
                return;
            }
            var savedInBlock = this.inBlock;
            this.inBlock = true;
            _super.prototype.visitBlock.call(this, node);
            this.inBlock = savedInBlock;
        };
        GrammarCheckerWalker.prototype.checkForBlockInAmbientContext = function (node) {
            if (this.inAmbientDeclaration || this.syntaxTree.isDeclaration()) {
                // Provide a specialized message for a block as a statement versus the block as a 
                // function body.
                if (node.parent.kind() === 1 /* List */) {
                    this.pushDiagnostic(TypeScript.firstToken(node), TypeScript.DiagnosticCode.Statements_are_not_allowed_in_ambient_contexts);
                }
                else {
                    this.pushDiagnostic(TypeScript.firstToken(node), TypeScript.DiagnosticCode.A_function_implementation_cannot_be_declared_in_an_ambient_context);
                }
                return true;
            }
            return false;
        };
        GrammarCheckerWalker.prototype.checkForStatementInAmbientContxt = function (node) {
            if (this.inAmbientDeclaration || this.syntaxTree.isDeclaration()) {
                this.pushDiagnostic(TypeScript.firstToken(node), TypeScript.DiagnosticCode.Statements_are_not_allowed_in_ambient_contexts);
                return true;
            }
            return false;
        };
        GrammarCheckerWalker.prototype.visitBreakStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node) || this.checkBreakStatementTarget(node)) {
                return;
            }
            _super.prototype.visitBreakStatement.call(this, node);
        };
        GrammarCheckerWalker.prototype.visitContinueStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node) || this.checkContinueStatementTarget(node)) {
                return;
            }
            _super.prototype.visitContinueStatement.call(this, node);
        };
        GrammarCheckerWalker.prototype.checkBreakStatementTarget = function (node) {
            // Invalid break statements are considered syntax errors in ES5.
            // Note: the order here is important.  If the 'break' has a target, then it can jump to
            // any enclosing laballed statment.  If it has no target, it must be in an iteration or
            // swtich statement.
            if (node.identifier) {
                var breakableLabels = this.getEnclosingLabels(node, true, false);
                if (!TypeScript.ArrayUtilities.any(breakableLabels, function (s) { return TypeScript.tokenValueText(s.identifier) === TypeScript.tokenValueText(node.identifier); })) {
                    // The target of the continue statement wasn't to a reachable label.
                    //
                    // Let hte user know, with a specialized message if the target was to an
                    // unreachable label (as opposed to a non-existed label)
                    var breakableLabels = this.getEnclosingLabels(node, true, true);
                    if (TypeScript.ArrayUtilities.any(breakableLabels, function (s) { return TypeScript.tokenValueText(s.identifier) === TypeScript.tokenValueText(node.identifier); })) {
                        this.pushDiagnostic(node, TypeScript.DiagnosticCode.Jump_target_cannot_cross_function_boundary);
                    }
                    else {
                        this.pushDiagnostic(node, TypeScript.DiagnosticCode.Jump_target_not_found);
                    }
                    return true;
                }
            }
            else if (!this.inIterationStatement(node, false) && !this.inSwitchStatement(node)) {
                if (this.inIterationStatement(node, true)) {
                    this.pushDiagnostic(node, TypeScript.DiagnosticCode.Jump_target_cannot_cross_function_boundary);
                }
                else {
                    this.pushDiagnostic(node, TypeScript.DiagnosticCode.break_statement_can_only_be_used_within_an_enclosing_iteration_or_switch_statement);
                }
                return true;
            }
            return false;
        };
        GrammarCheckerWalker.prototype.inSwitchStatement = function (ast) {
            while (ast) {
                if (ast.kind() === 152 /* SwitchStatement */) {
                    return true;
                }
                if (TypeScript.SyntaxUtilities.isAnyFunctionExpressionOrDeclaration(ast)) {
                    return false;
                }
                ast = ast.parent;
            }
            return false;
        };
        GrammarCheckerWalker.prototype.isIterationStatement = function (ast) {
            switch (ast.kind()) {
                case 155 /* ForStatement */:
                case 156 /* ForInStatement */:
                case 159 /* WhileStatement */:
                case 162 /* DoStatement */:
                    return true;
            }
            return false;
        };
        GrammarCheckerWalker.prototype.inIterationStatement = function (element, crossFunctions) {
            while (element) {
                if (this.isIterationStatement(element)) {
                    return true;
                }
                if (!crossFunctions && TypeScript.SyntaxUtilities.isAnyFunctionExpressionOrDeclaration(element)) {
                    return false;
                }
                element = element.parent;
            }
            return false;
        };
        GrammarCheckerWalker.prototype.getEnclosingLabels = function (element, breakable, crossFunctions) {
            var result = [];
            element = element.parent;
            while (element) {
                if (element.kind() === 161 /* LabeledStatement */) {
                    var labeledStatement = element;
                    if (breakable) {
                        // Breakable labels can be placed on any construct
                        result.push(labeledStatement);
                    }
                    else {
                        // They're asking for continuable labels.  Continuable labels must be on
                        // a loop construct.
                        if (this.labelIsOnContinuableConstruct(labeledStatement.statement)) {
                            result.push(labeledStatement);
                        }
                    }
                }
                if (!crossFunctions && TypeScript.SyntaxUtilities.isAnyFunctionExpressionOrDeclaration(element)) {
                    break;
                }
                element = element.parent;
            }
            return result;
        };
        GrammarCheckerWalker.prototype.labelIsOnContinuableConstruct = function (statement) {
            switch (statement.kind()) {
                case 161 /* LabeledStatement */:
                    // Labels work transitively.  i.e. if you have:
                    //      foo:
                    //      bar:
                    //      while(...)
                    //
                    // Then both 'foo' and 'bar' are in the label set for 'while' and are thus
                    // continuable.
                    return this.labelIsOnContinuableConstruct(statement.statement);
                case 159 /* WhileStatement */:
                case 155 /* ForStatement */:
                case 156 /* ForInStatement */:
                case 162 /* DoStatement */:
                    return true;
                default:
                    return false;
            }
        };
        GrammarCheckerWalker.prototype.checkContinueStatementTarget = function (node) {
            // Invalid continue statements are considered syntax errors in ES5.
            if (!this.inIterationStatement(node, false)) {
                if (this.inIterationStatement(node, true)) {
                    this.pushDiagnostic(node, TypeScript.DiagnosticCode.Jump_target_cannot_cross_function_boundary);
                }
                else {
                    this.pushDiagnostic(node, TypeScript.DiagnosticCode.continue_statement_can_only_be_used_within_an_enclosing_iteration_statement);
                }
                return true;
            }
            else if (node.identifier) {
                var continuableLabels = this.getEnclosingLabels(node, false, false);
                if (!TypeScript.ArrayUtilities.any(continuableLabels, function (s) { return TypeScript.tokenValueText(s.identifier) === TypeScript.tokenValueText(node.identifier); })) {
                    // The target of the continue statement wasn't to a reachable label.
                    //
                    // Let hte user know, with a specialized message if the target was to an
                    // unreachable label (as opposed to a non-existed label)
                    var continuableLabels = this.getEnclosingLabels(node, false, true);
                    if (TypeScript.ArrayUtilities.any(continuableLabels, function (s) { return TypeScript.tokenValueText(s.identifier) === TypeScript.tokenValueText(node.identifier); })) {
                        this.pushDiagnostic(node, TypeScript.DiagnosticCode.Jump_target_cannot_cross_function_boundary);
                    }
                    else {
                        this.pushDiagnostic(node, TypeScript.DiagnosticCode.Jump_target_not_found);
                    }
                    return true;
                }
            }
            return false;
        };
        GrammarCheckerWalker.prototype.visitDebuggerStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                return;
            }
            _super.prototype.visitDebuggerStatement.call(this, node);
        };
        GrammarCheckerWalker.prototype.visitDoStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                return;
            }
            _super.prototype.visitDoStatement.call(this, node);
        };
        GrammarCheckerWalker.prototype.visitEmptyStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                return;
            }
            _super.prototype.visitEmptyStatement.call(this, node);
        };
        GrammarCheckerWalker.prototype.visitExpressionStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                return;
            }
            _super.prototype.visitExpressionStatement.call(this, node);
        };
        GrammarCheckerWalker.prototype.visitForInStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node) || this.checkForInStatementVariableDeclaration(node) || this.checkForInLeftHandSideExpression(node)) {
                return;
            }
            _super.prototype.visitForInStatement.call(this, node);
        };
        GrammarCheckerWalker.prototype.checkForInLeftHandSideExpression = function (node) {
            if (node.left && !TypeScript.SyntaxUtilities.isLeftHandSizeExpression(node.left)) {
                this.pushDiagnostic(node.left, TypeScript.DiagnosticCode.Invalid_left_hand_side_in_for_in_statement);
                return true;
            }
            return false;
        };
        GrammarCheckerWalker.prototype.checkForInStatementVariableDeclaration = function (node) {
            // The parser accepts a Variable Declaration in a ForInStatement, but the grammar only
            // allows a very restricted form.  Specifically, there must be only a single Variable
            // Declarator in the Declaration.
            if (node.variableDeclaration && node.variableDeclaration.variableDeclarators.length > 1) {
                this.pushDiagnostic(node.variableDeclaration, TypeScript.DiagnosticCode.Only_a_single_variable_declaration_is_allowed_in_a_for_in_statement);
                return true;
            }
            return false;
        };
        GrammarCheckerWalker.prototype.visitForStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                return;
            }
            _super.prototype.visitForStatement.call(this, node);
        };
        GrammarCheckerWalker.prototype.visitIfStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                return;
            }
            _super.prototype.visitIfStatement.call(this, node);
        };
        GrammarCheckerWalker.prototype.visitLabeledStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node) || this.checkForInvalidLabelIdentifier(node)) {
                return;
            }
            _super.prototype.visitLabeledStatement.call(this, node);
        };
        GrammarCheckerWalker.prototype.checkForInvalidLabelIdentifier = function (node) {
            // Invalid break statements are considered syntax errors in ES5.
            // Note that break/continue are treated differently.  ES5 says this about a break statement:
            // A program is considered syntactically incorrect if ...:
            //
            // The program contains a break statement with the optional Identifier, where Identifier 
            // does not appear in the label set of an enclosing (but not crossing function boundaries) 
            // **Statement.**
            // 
            // However, it says this about continue statements:
            //
            // The program contains a continue statement with the optional Identifier, where Identifier
            // does not appear in the label set of an enclosing (but not crossing function boundaries) 
            // **IterationStatement.**
            // In other words, you can 'break' to any enclosing statement.  But you can only 'continue'
            // to an enclosing *iteration* statement.
            var labelIdentifier = TypeScript.tokenValueText(node.identifier);
            var breakableLabels = this.getEnclosingLabels(node, true, false);
            // It is invalid to have a label enclosed in a label of the same name.
            var matchingLabel = TypeScript.ArrayUtilities.firstOrDefault(breakableLabels, function (s) { return TypeScript.tokenValueText(s.identifier) === labelIdentifier; });
            if (matchingLabel) {
                this.pushDiagnostic(node.identifier, TypeScript.DiagnosticCode.Duplicate_identifier_0, [labelIdentifier]);
                return true;
            }
            return false;
        };
        GrammarCheckerWalker.prototype.visitReturnStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node) || this.checkForReturnStatementNotInFunctionBody(node)) {
                return;
            }
            _super.prototype.visitReturnStatement.call(this, node);
        };
        GrammarCheckerWalker.prototype.checkForReturnStatementNotInFunctionBody = function (node) {
            for (var element = node; element; element = element.parent) {
                if (TypeScript.SyntaxUtilities.isAnyFunctionExpressionOrDeclaration(element)) {
                    return false;
                }
            }
            this.pushDiagnostic(TypeScript.firstToken(node), TypeScript.DiagnosticCode.return_statement_must_be_contained_within_a_function_body);
            return true;
        };
        GrammarCheckerWalker.prototype.visitSwitchStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                return;
            }
            _super.prototype.visitSwitchStatement.call(this, node);
        };
        GrammarCheckerWalker.prototype.visitThrowStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                return;
            }
            _super.prototype.visitThrowStatement.call(this, node);
        };
        GrammarCheckerWalker.prototype.visitTryStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                return;
            }
            _super.prototype.visitTryStatement.call(this, node);
        };
        GrammarCheckerWalker.prototype.visitWhileStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                return;
            }
            _super.prototype.visitWhileStatement.call(this, node);
        };
        GrammarCheckerWalker.prototype.visitWithStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node) || this.checkForWithInStrictMode(node)) {
                return;
            }
            _super.prototype.visitWithStatement.call(this, node);
        };
        GrammarCheckerWalker.prototype.checkForWithInStrictMode = function (node) {
            if (TypeScript.parsedInStrictMode(node)) {
                this.pushDiagnostic(TypeScript.firstToken(node), TypeScript.DiagnosticCode.with_statements_are_not_allowed_in_strict_mode);
                return true;
            }
            return false;
        };
        GrammarCheckerWalker.prototype.checkForDisallowedModifiers = function (parent, modifiers) {
            if (this.inBlock || this.inObjectLiteralExpression) {
                if (modifiers.length > 0) {
                    this.pushDiagnostic(TypeScript.childAt(modifiers, 0), TypeScript.DiagnosticCode.Modifiers_cannot_appear_here);
                    return true;
                }
            }
            return false;
        };
        GrammarCheckerWalker.prototype.visitFunctionDeclaration = function (node) {
            if (this.checkForDisallowedDeclareModifier(node.modifiers) || this.checkForDisallowedModifiers(node, node.modifiers) || this.checkForRequiredDeclareModifier(node, node.identifier, node.modifiers) || this.checkModuleElementModifiers(node.modifiers) || this.checkForDisallowedEvalOrArguments(node, node.identifier)) {
                return;
            }
            var savedInAmbientDeclaration = this.inAmbientDeclaration;
            this.inAmbientDeclaration = this.inAmbientDeclaration || this.syntaxTree.isDeclaration() || TypeScript.SyntaxUtilities.containsToken(node.modifiers, 63 /* DeclareKeyword */);
            _super.prototype.visitFunctionDeclaration.call(this, node);
            this.inAmbientDeclaration = savedInAmbientDeclaration;
        };
        GrammarCheckerWalker.prototype.visitFunctionExpression = function (node) {
            if (this.checkForDisallowedEvalOrArguments(node, node.identifier)) {
                return;
            }
            _super.prototype.visitFunctionExpression.call(this, node);
        };
        GrammarCheckerWalker.prototype.visitVariableStatement = function (node) {
            if (this.checkForDisallowedDeclareModifier(node.modifiers) || this.checkForDisallowedModifiers(node, node.modifiers) || this.checkForRequiredDeclareModifier(node, node.variableDeclaration.varKeyword, node.modifiers) || this.checkModuleElementModifiers(node.modifiers)) {
                return;
            }
            var savedInAmbientDeclaration = this.inAmbientDeclaration;
            this.inAmbientDeclaration = this.inAmbientDeclaration || this.syntaxTree.isDeclaration() || TypeScript.SyntaxUtilities.containsToken(node.modifiers, 63 /* DeclareKeyword */);
            _super.prototype.visitVariableStatement.call(this, node);
            this.inAmbientDeclaration = savedInAmbientDeclaration;
        };
        GrammarCheckerWalker.prototype.checkListSeparators = function (parent, list, kind) {
            for (var i = 0, n = TypeScript.childCount(list); i < n; i++) {
                var child = TypeScript.childAt(list, i);
                if (i % 2 === 1 && child.kind() !== kind) {
                    this.pushDiagnostic(child, TypeScript.DiagnosticCode._0_expected, [TypeScript.SyntaxFacts.getText(kind)]);
                }
            }
            return false;
        };
        GrammarCheckerWalker.prototype.visitObjectType = function (node) {
            if (this.checkListSeparators(node, node.typeMembers, 78 /* SemicolonToken */)) {
                return;
            }
            // All code in an object type is implicitly ambient. (i.e. parameters can't have initializer, etc.)
            var savedInAmbientDeclaration = this.inAmbientDeclaration;
            this.inAmbientDeclaration = true;
            _super.prototype.visitObjectType.call(this, node);
            this.inAmbientDeclaration = savedInAmbientDeclaration;
        };
        GrammarCheckerWalker.prototype.visitArrayType = function (node) {
            // All code in an object type is implicitly ambient. (i.e. parameters can't have initializer, etc.)
            var savedInAmbientDeclaration = this.inAmbientDeclaration;
            this.inAmbientDeclaration = true;
            _super.prototype.visitArrayType.call(this, node);
            this.inAmbientDeclaration = savedInAmbientDeclaration;
        };
        GrammarCheckerWalker.prototype.visitFunctionType = function (node) {
            // All code in an object type is implicitly ambient. (i.e. parameters can't have initializer, etc.)
            var savedInAmbientDeclaration = this.inAmbientDeclaration;
            this.inAmbientDeclaration = true;
            _super.prototype.visitFunctionType.call(this, node);
            this.inAmbientDeclaration = savedInAmbientDeclaration;
        };
        GrammarCheckerWalker.prototype.visitConstructorType = function (node) {
            // All code in an object type is implicitly ambient. (i.e. parameters can't have initializer, etc.)
            var savedInAmbientDeclaration = this.inAmbientDeclaration;
            this.inAmbientDeclaration = true;
            _super.prototype.visitConstructorType.call(this, node);
            this.inAmbientDeclaration = savedInAmbientDeclaration;
        };
        GrammarCheckerWalker.prototype.visitVariableDeclarator = function (node) {
            if (this.checkVariableDeclaratorInitializer(node) || this.checkVariableDeclaratorIdentifier(node)) {
                return;
            }
            _super.prototype.visitVariableDeclarator.call(this, node);
        };
        GrammarCheckerWalker.prototype.checkVariableDeclaratorIdentifier = function (node) {
            if (node.parent.kind() !== 137 /* MemberVariableDeclaration */) {
                if (this.checkForDisallowedEvalOrArguments(node, node.propertyName)) {
                    return true;
                }
            }
            return false;
        };
        GrammarCheckerWalker.prototype.checkVariableDeclaratorInitializer = function (node) {
            if (this.inAmbientDeclaration && node.equalsValueClause) {
                this.pushDiagnostic(TypeScript.firstToken(node.equalsValueClause.value), TypeScript.DiagnosticCode.Initializers_are_not_allowed_in_ambient_contexts);
                return true;
            }
            return false;
        };
        GrammarCheckerWalker.prototype.visitConstructorDeclaration = function (node) {
            if (this.checkClassElementModifiers(node.modifiers) || this.checkConstructorModifiers(node.modifiers) || this.checkConstructorTypeParameterList(node) || this.checkConstructorTypeAnnotation(node)) {
                return;
            }
            _super.prototype.visitConstructorDeclaration.call(this, node);
        };
        GrammarCheckerWalker.prototype.checkConstructorModifiers = function (modifiers) {
            for (var i = 0, n = modifiers.length; i < n; i++) {
                var child = modifiers[i];
                if (child.kind() !== 57 /* PublicKeyword */) {
                    this.pushDiagnostic(child, TypeScript.DiagnosticCode._0_modifier_cannot_appear_on_a_constructor_declaration, [TypeScript.SyntaxFacts.getText(child.kind())]);
                    return true;
                }
            }
            return false;
        };
        GrammarCheckerWalker.prototype.checkConstructorTypeParameterList = function (node) {
            if (node.callSignature.typeParameterList) {
                this.pushDiagnostic(node.callSignature.typeParameterList, TypeScript.DiagnosticCode.Type_parameters_cannot_appear_on_a_constructor_declaration);
                return true;
            }
            return false;
        };
        GrammarCheckerWalker.prototype.checkConstructorTypeAnnotation = function (node) {
            if (node.callSignature.typeAnnotation) {
                this.pushDiagnostic(node.callSignature.typeAnnotation, TypeScript.DiagnosticCode.Type_annotation_cannot_appear_on_a_constructor_declaration);
                return true;
            }
            return false;
        };
        GrammarCheckerWalker.prototype.visitBinaryExpression = function (node) {
            if (this.checkIllegalAssignment(node)) {
                return;
            }
            _super.prototype.visitBinaryExpression.call(this, node);
        };
        GrammarCheckerWalker.prototype.visitPrefixUnaryExpression = function (node) {
            if (TypeScript.parsedInStrictMode(node) && this.isPreIncrementOrDecrementExpression(node) && this.isEvalOrArguments(node.operand)) {
                this.pushDiagnostic(node.operatorToken, TypeScript.DiagnosticCode.Invalid_use_of_0_in_strict_mode, [this.getEvalOrArguments(node.operand)]);
            }
            _super.prototype.visitPrefixUnaryExpression.call(this, node);
        };
        GrammarCheckerWalker.prototype.visitPostfixUnaryExpression = function (node) {
            if (TypeScript.parsedInStrictMode(node) && this.isEvalOrArguments(node.operand)) {
                this.pushDiagnostic(node.operatorToken, TypeScript.DiagnosticCode.Invalid_use_of_0_in_strict_mode, [this.getEvalOrArguments(node.operand)]);
            }
            _super.prototype.visitPostfixUnaryExpression.call(this, node);
        };
        GrammarCheckerWalker.prototype.visitParameter = function (node) {
            if (this.checkForDisallowedEvalOrArguments(node, node.identifier)) {
                return;
            }
            _super.prototype.visitParameter.call(this, node);
        };
        GrammarCheckerWalker.prototype.checkForDisallowedEvalOrArguments = function (node, token) {
            if (token) {
                if (TypeScript.parsedInStrictMode(node) && this.isEvalOrArguments(token)) {
                    this.pushDiagnostic(token, TypeScript.DiagnosticCode.Invalid_use_of_0_in_strict_mode, [this.getEvalOrArguments(token)]);
                    return true;
                }
            }
            return false;
        };
        GrammarCheckerWalker.prototype.isPreIncrementOrDecrementExpression = function (node) {
            switch (node.kind()) {
                case 170 /* PreDecrementExpression */:
                case 169 /* PreIncrementExpression */:
                    return true;
            }
            return false;
        };
        GrammarCheckerWalker.prototype.visitDeleteExpression = function (node) {
            if (TypeScript.parsedInStrictMode(node) && node.expression.kind() === 11 /* IdentifierName */) {
                this.pushDiagnostic(TypeScript.firstToken(node), TypeScript.DiagnosticCode.delete_cannot_be_called_on_an_identifier_in_strict_mode);
                return;
            }
            _super.prototype.visitDeleteExpression.call(this, node);
        };
        GrammarCheckerWalker.prototype.checkIllegalAssignment = function (node) {
            if (TypeScript.parsedInStrictMode(node) && TypeScript.SyntaxFacts.isAssignmentOperatorToken(node.operatorToken.kind()) && this.isEvalOrArguments(node.left)) {
                this.pushDiagnostic(node.operatorToken, TypeScript.DiagnosticCode.Invalid_use_of_0_in_strict_mode, [this.getEvalOrArguments(node.left)]);
                return true;
            }
            return false;
        };
        GrammarCheckerWalker.prototype.getEvalOrArguments = function (expr) {
            if (expr.kind() === 11 /* IdentifierName */) {
                var text = TypeScript.tokenValueText(expr);
                if (text === "eval" || text === "arguments") {
                    return text;
                }
            }
            return null;
        };
        GrammarCheckerWalker.prototype.isEvalOrArguments = function (expr) {
            return this.getEvalOrArguments(expr) !== null;
        };
        GrammarCheckerWalker.prototype.visitConstraint = function (node) {
            if (this.checkConstraintType(node)) {
                return;
            }
            _super.prototype.visitConstraint.call(this, node);
        };
        GrammarCheckerWalker.prototype.checkConstraintType = function (node) {
            if (!TypeScript.SyntaxFacts.isType(node.typeOrExpression.kind())) {
                this.pushDiagnostic(node.typeOrExpression, TypeScript.DiagnosticCode.Type_expected);
                return true;
            }
            return false;
        };
        return GrammarCheckerWalker;
    })(TypeScript.SyntaxWalker);
    function firstSyntaxTreeToken(syntaxTree) {
        // We don't just access the firstToken of the tree here as the tree may be abstract and may
        // not have a firstToken in it.
        var scanner = TypeScript.Scanner.createScanner(syntaxTree.languageVersion(), syntaxTree.text, function () {
        });
        return scanner.scan(false);
    }
    function externalModuleIndicatorSpan(syntaxTree) {
        var firstToken = firstSyntaxTreeToken(syntaxTree);
        return externalModuleIndicatorSpanWorker(syntaxTree, firstToken);
    }
    TypeScript.externalModuleIndicatorSpan = externalModuleIndicatorSpan;
    function externalModuleIndicatorSpanWorker(syntaxTree, firstToken) {
        var leadingTrivia = firstToken.leadingTrivia(syntaxTree.text);
        return implicitImportSpan(leadingTrivia) || topLevelImportOrExportSpan(syntaxTree.sourceUnit());
    }
    TypeScript.externalModuleIndicatorSpanWorker = externalModuleIndicatorSpanWorker;
    function implicitImportSpan(sourceUnitLeadingTrivia) {
        for (var i = 0, n = sourceUnitLeadingTrivia.count(); i < n; i++) {
            var trivia = sourceUnitLeadingTrivia.syntaxTriviaAt(i);
            if (trivia.isComment()) {
                var span = implicitImportSpanWorker(trivia);
                if (span) {
                    return span;
                }
            }
        }
        return null;
    }
    function implicitImportSpanWorker(trivia) {
        var implicitImportRegEx = /^(\/\/\/\s*<implicit-import\s*)*\/>/gim;
        var match = implicitImportRegEx.exec(trivia.fullText());
        if (match) {
            return new TypeScript.TextSpan(trivia.fullStart(), trivia.fullWidth());
        }
        return null;
    }
    function topLevelImportOrExportSpan(node) {
        for (var i = 0, n = node.moduleElements.length; i < n; i++) {
            var moduleElement = node.moduleElements[i];
            var _firstToken = TypeScript.firstToken(moduleElement);
            if (_firstToken !== null && _firstToken.kind() === 47 /* ExportKeyword */) {
                return new TypeScript.TextSpan(TypeScript.start(_firstToken), TypeScript.width(_firstToken));
            }
            if (moduleElement.kind() === 134 /* ImportDeclaration */) {
                var importDecl = moduleElement;
                if (importDecl.moduleReference.kind() === 246 /* ExternalModuleReference */) {
                    var literal = importDecl.moduleReference.stringLiteral;
                    return new TypeScript.TextSpan(TypeScript.start(literal), TypeScript.width(literal));
                }
            }
        }
        return null;
    }
})(TypeScript || (TypeScript = {}));
///<reference path='references.ts' />
var TypeScript;
(function (TypeScript) {
    var Unicode = (function () {
        function Unicode() {
        }
        Unicode.lookupInUnicodeMap = function (code, map) {
            // Bail out quickly if it couldn't possibly be in the map.
            if (code < map[0]) {
                return false;
            }
            // Perform binary search in one of the unicode range maps
            var lo = 0;
            var hi = map.length;
            var mid;
            while (lo + 1 < hi) {
                mid = lo + (hi - lo) / 2;
                // mid has to be even to catch a range's beginning
                mid -= mid % 2;
                if (map[mid] <= code && code <= map[mid + 1]) {
                    return true;
                }
                if (code < map[mid]) {
                    hi = mid;
                }
                else {
                    lo = mid + 2;
                }
            }
            return false;
        };
        Unicode.isIdentifierStart = function (code, languageVersion) {
            if (languageVersion === 0 /* ES3 */) {
                return Unicode.lookupInUnicodeMap(code, Unicode.unicodeES3IdentifierStart);
            }
            else if (languageVersion === 1 /* ES5 */) {
                return Unicode.lookupInUnicodeMap(code, Unicode.unicodeES5IdentifierStart);
            }
            else {
                throw TypeScript.Errors.argumentOutOfRange("languageVersion");
            }
        };
        Unicode.isIdentifierPart = function (code, languageVersion) {
            if (languageVersion === 0 /* ES3 */) {
                return Unicode.lookupInUnicodeMap(code, Unicode.unicodeES3IdentifierPart);
            }
            else if (languageVersion === 1 /* ES5 */) {
                return Unicode.lookupInUnicodeMap(code, Unicode.unicodeES5IdentifierPart);
            }
            else {
                throw TypeScript.Errors.argumentOutOfRange("languageVersion");
            }
        };
        /*
            As per ECMAScript Language Specification 3th Edition, Section 7.6: Identifiers
            IdentifierStart ::
                Can contain Unicode 3.0.0  categories:
                “Uppercase letter (Lu)”,
                “Lowercase letter (Ll)”,
                “Titlecase letter (Lt)”,
                “Modifier letter (Lm)”,
                “Other letter (Lo)”, or
                “Letter number (Nl)”.
            IdentifierPart :: =
                Can contain IdentifierStart + Unicode 3.0.0  categories:
                “Non-spacing mark (Mn)”,
                “Combining spacing mark (Mc)”,
                “Decimal number (Nd)”, or
                “Connector punctuation (Pc)”.

            Codepoint ranges for ES3 Identifiers are extracted from the Unicode 3.0.0 specification at:
            http://www.unicode.org/Public/3.0-Update/UnicodeData-3.0.0.txt
        */
        Unicode.unicodeES3IdentifierStart = [170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 543, 546, 563, 592, 685, 688, 696, 699, 705, 720, 721, 736, 740, 750, 750, 890, 890, 902, 902, 904, 906, 908, 908, 910, 929, 931, 974, 976, 983, 986, 1011, 1024, 1153, 1164, 1220, 1223, 1224, 1227, 1228, 1232, 1269, 1272, 1273, 1329, 1366, 1369, 1369, 1377, 1415, 1488, 1514, 1520, 1522, 1569, 1594, 1600, 1610, 1649, 1747, 1749, 1749, 1765, 1766, 1786, 1788, 1808, 1808, 1810, 1836, 1920, 1957, 2309, 2361, 2365, 2365, 2384, 2384, 2392, 2401, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2524, 2525, 2527, 2529, 2544, 2545, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616, 2617, 2649, 2652, 2654, 2654, 2674, 2676, 2693, 2699, 2701, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2749, 2749, 2768, 2768, 2784, 2784, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2870, 2873, 2877, 2877, 2908, 2909, 2911, 2913, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 2997, 2999, 3001, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123, 3125, 3129, 3168, 3169, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3294, 3294, 3296, 3297, 3333, 3340, 3342, 3344, 3346, 3368, 3370, 3385, 3424, 3425, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3585, 3632, 3634, 3635, 3648, 3654, 3713, 3714, 3716, 3716, 3719, 3720, 3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757, 3760, 3762, 3763, 3773, 3773, 3776, 3780, 3782, 3782, 3804, 3805, 3840, 3840, 3904, 3911, 3913, 3946, 3976, 3979, 4096, 4129, 4131, 4135, 4137, 4138, 4176, 4181, 4256, 4293, 4304, 4342, 4352, 4441, 4447, 4514, 4520, 4601, 4608, 4614, 4616, 4678, 4680, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4742, 4744, 4744, 4746, 4749, 4752, 4782, 4784, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4814, 4816, 4822, 4824, 4846, 4848, 4878, 4880, 4880, 4882, 4885, 4888, 4894, 4896, 4934, 4936, 4954, 5024, 5108, 5121, 5740, 5743, 5750, 5761, 5786, 5792, 5866, 6016, 6067, 6176, 6263, 6272, 6312, 7680, 7835, 7840, 7929, 7936, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8319, 8319, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8473, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8495, 8497, 8499, 8505, 8544, 8579, 12293, 12295, 12321, 12329, 12337, 12341, 12344, 12346, 12353, 12436, 12445, 12446, 12449, 12538, 12540, 12542, 12549, 12588, 12593, 12686, 12704, 12727, 13312, 19893, 19968, 40869, 40960, 42124, 44032, 55203, 63744, 64045, 64256, 64262, 64275, 64279, 64285, 64285, 64287, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019, 65136, 65138, 65140, 65140, 65142, 65276, 65313, 65338, 65345, 65370, 65382, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500, ];
        Unicode.unicodeES3IdentifierPart = [170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 543, 546, 563, 592, 685, 688, 696, 699, 705, 720, 721, 736, 740, 750, 750, 768, 846, 864, 866, 890, 890, 902, 902, 904, 906, 908, 908, 910, 929, 931, 974, 976, 983, 986, 1011, 1024, 1153, 1155, 1158, 1164, 1220, 1223, 1224, 1227, 1228, 1232, 1269, 1272, 1273, 1329, 1366, 1369, 1369, 1377, 1415, 1425, 1441, 1443, 1465, 1467, 1469, 1471, 1471, 1473, 1474, 1476, 1476, 1488, 1514, 1520, 1522, 1569, 1594, 1600, 1621, 1632, 1641, 1648, 1747, 1749, 1756, 1759, 1768, 1770, 1773, 1776, 1788, 1808, 1836, 1840, 1866, 1920, 1968, 2305, 2307, 2309, 2361, 2364, 2381, 2384, 2388, 2392, 2403, 2406, 2415, 2433, 2435, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2492, 2492, 2494, 2500, 2503, 2504, 2507, 2509, 2519, 2519, 2524, 2525, 2527, 2531, 2534, 2545, 2562, 2562, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616, 2617, 2620, 2620, 2622, 2626, 2631, 2632, 2635, 2637, 2649, 2652, 2654, 2654, 2662, 2676, 2689, 2691, 2693, 2699, 2701, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2748, 2757, 2759, 2761, 2763, 2765, 2768, 2768, 2784, 2784, 2790, 2799, 2817, 2819, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2870, 2873, 2876, 2883, 2887, 2888, 2891, 2893, 2902, 2903, 2908, 2909, 2911, 2913, 2918, 2927, 2946, 2947, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 2997, 2999, 3001, 3006, 3010, 3014, 3016, 3018, 3021, 3031, 3031, 3047, 3055, 3073, 3075, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123, 3125, 3129, 3134, 3140, 3142, 3144, 3146, 3149, 3157, 3158, 3168, 3169, 3174, 3183, 3202, 3203, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3262, 3268, 3270, 3272, 3274, 3277, 3285, 3286, 3294, 3294, 3296, 3297, 3302, 3311, 3330, 3331, 3333, 3340, 3342, 3344, 3346, 3368, 3370, 3385, 3390, 3395, 3398, 3400, 3402, 3405, 3415, 3415, 3424, 3425, 3430, 3439, 3458, 3459, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3530, 3530, 3535, 3540, 3542, 3542, 3544, 3551, 3570, 3571, 3585, 3642, 3648, 3662, 3664, 3673, 3713, 3714, 3716, 3716, 3719, 3720, 3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757, 3769, 3771, 3773, 3776, 3780, 3782, 3782, 3784, 3789, 3792, 3801, 3804, 3805, 3840, 3840, 3864, 3865, 3872, 3881, 3893, 3893, 3895, 3895, 3897, 3897, 3902, 3911, 3913, 3946, 3953, 3972, 3974, 3979, 3984, 3991, 3993, 4028, 4038, 4038, 4096, 4129, 4131, 4135, 4137, 4138, 4140, 4146, 4150, 4153, 4160, 4169, 4176, 4185, 4256, 4293, 4304, 4342, 4352, 4441, 4447, 4514, 4520, 4601, 4608, 4614, 4616, 4678, 4680, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4742, 4744, 4744, 4746, 4749, 4752, 4782, 4784, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4814, 4816, 4822, 4824, 4846, 4848, 4878, 4880, 4880, 4882, 4885, 4888, 4894, 4896, 4934, 4936, 4954, 4969, 4977, 5024, 5108, 5121, 5740, 5743, 5750, 5761, 5786, 5792, 5866, 6016, 6099, 6112, 6121, 6160, 6169, 6176, 6263, 6272, 6313, 7680, 7835, 7840, 7929, 7936, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8255, 8256, 8319, 8319, 8400, 8412, 8417, 8417, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8473, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8495, 8497, 8499, 8505, 8544, 8579, 12293, 12295, 12321, 12335, 12337, 12341, 12344, 12346, 12353, 12436, 12441, 12442, 12445, 12446, 12449, 12542, 12549, 12588, 12593, 12686, 12704, 12727, 13312, 19893, 19968, 40869, 40960, 42124, 44032, 55203, 63744, 64045, 64256, 64262, 64275, 64279, 64285, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019, 65056, 65059, 65075, 65076, 65101, 65103, 65136, 65138, 65140, 65140, 65142, 65276, 65296, 65305, 65313, 65338, 65343, 65343, 65345, 65370, 65381, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500, ];
        /*
            As per ECMAScript Language Specification 5th Edition, Section 7.6: ISyntaxToken Names and Identifiers
            IdentifierStart ::
                Can contain Unicode 6.2  categories:
                “Uppercase letter (Lu)”,
                “Lowercase letter (Ll)”,
                “Titlecase letter (Lt)”,
                “Modifier letter (Lm)”,
                “Other letter (Lo)”, or
                “Letter number (Nl)”.
            IdentifierPart ::
                Can contain IdentifierStart + Unicode 6.2  categories:
                “Non-spacing mark (Mn)”,
                “Combining spacing mark (Mc)”,
                “Decimal number (Nd)”,
                “Connector punctuation (Pc)”,
                <ZWNJ>, or
                <ZWJ>.

            Codepoint ranges for ES5 Identifiers are extracted from the Unicode 6.2 specification at:
            http://www.unicode.org/Public/6.2.0/ucd/UnicodeData.txt
        */
        Unicode.unicodeES5IdentifierStart = [170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 705, 710, 721, 736, 740, 748, 748, 750, 750, 880, 884, 886, 887, 890, 893, 902, 902, 904, 906, 908, 908, 910, 929, 931, 1013, 1015, 1153, 1162, 1319, 1329, 1366, 1369, 1369, 1377, 1415, 1488, 1514, 1520, 1522, 1568, 1610, 1646, 1647, 1649, 1747, 1749, 1749, 1765, 1766, 1774, 1775, 1786, 1788, 1791, 1791, 1808, 1808, 1810, 1839, 1869, 1957, 1969, 1969, 1994, 2026, 2036, 2037, 2042, 2042, 2048, 2069, 2074, 2074, 2084, 2084, 2088, 2088, 2112, 2136, 2208, 2208, 2210, 2220, 2308, 2361, 2365, 2365, 2384, 2384, 2392, 2401, 2417, 2423, 2425, 2431, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2493, 2493, 2510, 2510, 2524, 2525, 2527, 2529, 2544, 2545, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616, 2617, 2649, 2652, 2654, 2654, 2674, 2676, 2693, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2749, 2749, 2768, 2768, 2784, 2785, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2869, 2873, 2877, 2877, 2908, 2909, 2911, 2913, 2929, 2929, 2947, 2947, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 3001, 3024, 3024, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123, 3125, 3129, 3133, 3133, 3160, 3161, 3168, 3169, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3261, 3261, 3294, 3294, 3296, 3297, 3313, 3314, 3333, 3340, 3342, 3344, 3346, 3386, 3389, 3389, 3406, 3406, 3424, 3425, 3450, 3455, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3585, 3632, 3634, 3635, 3648, 3654, 3713, 3714, 3716, 3716, 3719, 3720, 3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757, 3760, 3762, 3763, 3773, 3773, 3776, 3780, 3782, 3782, 3804, 3807, 3840, 3840, 3904, 3911, 3913, 3948, 3976, 3980, 4096, 4138, 4159, 4159, 4176, 4181, 4186, 4189, 4193, 4193, 4197, 4198, 4206, 4208, 4213, 4225, 4238, 4238, 4256, 4293, 4295, 4295, 4301, 4301, 4304, 4346, 4348, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4744, 4746, 4749, 4752, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4822, 4824, 4880, 4882, 4885, 4888, 4954, 4992, 5007, 5024, 5108, 5121, 5740, 5743, 5759, 5761, 5786, 5792, 5866, 5870, 5872, 5888, 5900, 5902, 5905, 5920, 5937, 5952, 5969, 5984, 5996, 5998, 6000, 6016, 6067, 6103, 6103, 6108, 6108, 6176, 6263, 6272, 6312, 6314, 6314, 6320, 6389, 6400, 6428, 6480, 6509, 6512, 6516, 6528, 6571, 6593, 6599, 6656, 6678, 6688, 6740, 6823, 6823, 6917, 6963, 6981, 6987, 7043, 7072, 7086, 7087, 7098, 7141, 7168, 7203, 7245, 7247, 7258, 7293, 7401, 7404, 7406, 7409, 7413, 7414, 7424, 7615, 7680, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8305, 8305, 8319, 8319, 8336, 8348, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8473, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8495, 8505, 8508, 8511, 8517, 8521, 8526, 8526, 8544, 8584, 11264, 11310, 11312, 11358, 11360, 11492, 11499, 11502, 11506, 11507, 11520, 11557, 11559, 11559, 11565, 11565, 11568, 11623, 11631, 11631, 11648, 11670, 11680, 11686, 11688, 11694, 11696, 11702, 11704, 11710, 11712, 11718, 11720, 11726, 11728, 11734, 11736, 11742, 11823, 11823, 12293, 12295, 12321, 12329, 12337, 12341, 12344, 12348, 12353, 12438, 12445, 12447, 12449, 12538, 12540, 12543, 12549, 12589, 12593, 12686, 12704, 12730, 12784, 12799, 13312, 19893, 19968, 40908, 40960, 42124, 42192, 42237, 42240, 42508, 42512, 42527, 42538, 42539, 42560, 42606, 42623, 42647, 42656, 42735, 42775, 42783, 42786, 42888, 42891, 42894, 42896, 42899, 42912, 42922, 43000, 43009, 43011, 43013, 43015, 43018, 43020, 43042, 43072, 43123, 43138, 43187, 43250, 43255, 43259, 43259, 43274, 43301, 43312, 43334, 43360, 43388, 43396, 43442, 43471, 43471, 43520, 43560, 43584, 43586, 43588, 43595, 43616, 43638, 43642, 43642, 43648, 43695, 43697, 43697, 43701, 43702, 43705, 43709, 43712, 43712, 43714, 43714, 43739, 43741, 43744, 43754, 43762, 43764, 43777, 43782, 43785, 43790, 43793, 43798, 43808, 43814, 43816, 43822, 43968, 44002, 44032, 55203, 55216, 55238, 55243, 55291, 63744, 64109, 64112, 64217, 64256, 64262, 64275, 64279, 64285, 64285, 64287, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019, 65136, 65140, 65142, 65276, 65313, 65338, 65345, 65370, 65382, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500, ];
        Unicode.unicodeES5IdentifierPart = [170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 705, 710, 721, 736, 740, 748, 748, 750, 750, 768, 884, 886, 887, 890, 893, 902, 902, 904, 906, 908, 908, 910, 929, 931, 1013, 1015, 1153, 1155, 1159, 1162, 1319, 1329, 1366, 1369, 1369, 1377, 1415, 1425, 1469, 1471, 1471, 1473, 1474, 1476, 1477, 1479, 1479, 1488, 1514, 1520, 1522, 1552, 1562, 1568, 1641, 1646, 1747, 1749, 1756, 1759, 1768, 1770, 1788, 1791, 1791, 1808, 1866, 1869, 1969, 1984, 2037, 2042, 2042, 2048, 2093, 2112, 2139, 2208, 2208, 2210, 2220, 2276, 2302, 2304, 2403, 2406, 2415, 2417, 2423, 2425, 2431, 2433, 2435, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2492, 2500, 2503, 2504, 2507, 2510, 2519, 2519, 2524, 2525, 2527, 2531, 2534, 2545, 2561, 2563, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616, 2617, 2620, 2620, 2622, 2626, 2631, 2632, 2635, 2637, 2641, 2641, 2649, 2652, 2654, 2654, 2662, 2677, 2689, 2691, 2693, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2748, 2757, 2759, 2761, 2763, 2765, 2768, 2768, 2784, 2787, 2790, 2799, 2817, 2819, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2869, 2873, 2876, 2884, 2887, 2888, 2891, 2893, 2902, 2903, 2908, 2909, 2911, 2915, 2918, 2927, 2929, 2929, 2946, 2947, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 3001, 3006, 3010, 3014, 3016, 3018, 3021, 3024, 3024, 3031, 3031, 3046, 3055, 3073, 3075, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123, 3125, 3129, 3133, 3140, 3142, 3144, 3146, 3149, 3157, 3158, 3160, 3161, 3168, 3171, 3174, 3183, 3202, 3203, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3260, 3268, 3270, 3272, 3274, 3277, 3285, 3286, 3294, 3294, 3296, 3299, 3302, 3311, 3313, 3314, 3330, 3331, 3333, 3340, 3342, 3344, 3346, 3386, 3389, 3396, 3398, 3400, 3402, 3406, 3415, 3415, 3424, 3427, 3430, 3439, 3450, 3455, 3458, 3459, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3530, 3530, 3535, 3540, 3542, 3542, 3544, 3551, 3570, 3571, 3585, 3642, 3648, 3662, 3664, 3673, 3713, 3714, 3716, 3716, 3719, 3720, 3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757, 3769, 3771, 3773, 3776, 3780, 3782, 3782, 3784, 3789, 3792, 3801, 3804, 3807, 3840, 3840, 3864, 3865, 3872, 3881, 3893, 3893, 3895, 3895, 3897, 3897, 3902, 3911, 3913, 3948, 3953, 3972, 3974, 3991, 3993, 4028, 4038, 4038, 4096, 4169, 4176, 4253, 4256, 4293, 4295, 4295, 4301, 4301, 4304, 4346, 4348, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4744, 4746, 4749, 4752, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4822, 4824, 4880, 4882, 4885, 4888, 4954, 4957, 4959, 4992, 5007, 5024, 5108, 5121, 5740, 5743, 5759, 5761, 5786, 5792, 5866, 5870, 5872, 5888, 5900, 5902, 5908, 5920, 5940, 5952, 5971, 5984, 5996, 5998, 6000, 6002, 6003, 6016, 6099, 6103, 6103, 6108, 6109, 6112, 6121, 6155, 6157, 6160, 6169, 6176, 6263, 6272, 6314, 6320, 6389, 6400, 6428, 6432, 6443, 6448, 6459, 6470, 6509, 6512, 6516, 6528, 6571, 6576, 6601, 6608, 6617, 6656, 6683, 6688, 6750, 6752, 6780, 6783, 6793, 6800, 6809, 6823, 6823, 6912, 6987, 6992, 7001, 7019, 7027, 7040, 7155, 7168, 7223, 7232, 7241, 7245, 7293, 7376, 7378, 7380, 7414, 7424, 7654, 7676, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8204, 8205, 8255, 8256, 8276, 8276, 8305, 8305, 8319, 8319, 8336, 8348, 8400, 8412, 8417, 8417, 8421, 8432, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8473, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8495, 8505, 8508, 8511, 8517, 8521, 8526, 8526, 8544, 8584, 11264, 11310, 11312, 11358, 11360, 11492, 11499, 11507, 11520, 11557, 11559, 11559, 11565, 11565, 11568, 11623, 11631, 11631, 11647, 11670, 11680, 11686, 11688, 11694, 11696, 11702, 11704, 11710, 11712, 11718, 11720, 11726, 11728, 11734, 11736, 11742, 11744, 11775, 11823, 11823, 12293, 12295, 12321, 12335, 12337, 12341, 12344, 12348, 12353, 12438, 12441, 12442, 12445, 12447, 12449, 12538, 12540, 12543, 12549, 12589, 12593, 12686, 12704, 12730, 12784, 12799, 13312, 19893, 19968, 40908, 40960, 42124, 42192, 42237, 42240, 42508, 42512, 42539, 42560, 42607, 42612, 42621, 42623, 42647, 42655, 42737, 42775, 42783, 42786, 42888, 42891, 42894, 42896, 42899, 42912, 42922, 43000, 43047, 43072, 43123, 43136, 43204, 43216, 43225, 43232, 43255, 43259, 43259, 43264, 43309, 43312, 43347, 43360, 43388, 43392, 43456, 43471, 43481, 43520, 43574, 43584, 43597, 43600, 43609, 43616, 43638, 43642, 43643, 43648, 43714, 43739, 43741, 43744, 43759, 43762, 43766, 43777, 43782, 43785, 43790, 43793, 43798, 43808, 43814, 43816, 43822, 43968, 44010, 44012, 44013, 44016, 44025, 44032, 55203, 55216, 55238, 55243, 55291, 63744, 64109, 64112, 64217, 64256, 64262, 64275, 64279, 64285, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019, 65024, 65039, 65056, 65062, 65075, 65076, 65101, 65103, 65136, 65140, 65142, 65276, 65296, 65305, 65313, 65338, 65343, 65343, 65345, 65370, 65382, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500, ];
        return Unicode;
    })();
    TypeScript.Unicode = Unicode;
})(TypeScript || (TypeScript = {}));
///<reference path='..\text\references.ts' />
///<reference path="references.ts" />
var TypeScript;
(function (TypeScript) {
    var IncrementalParser;
    (function (IncrementalParser) {
        // Parser source used in incremental scenarios. This parser source wraps an old tree, text 
        // change and new text, and uses all three to provide nodes and tokens to the parser.  In
        // general, nodes from the old tree are returned as long as they do not intersect with the text 
        // change.  Then, once the text change is reached, tokens from the old tree are returned as 
        // long as they do not intersect with the text change.  Then, the text that is actually changed
        // will be scanned using a normal scanner.  Then, once the new text is scanned, the source will
        // attempt to sync back up with nodes or tokens that started where the new tokens end. Once it
        // can do that, then all subsequent data will come from the original tree.
        //
        // This allows for an enormous amount of tree reuse in common scenarios.  Situations that 
        // prevent this level of reuse include substantially destructive operations like introducing
        // "/*" without a "*/" nearby to terminate the comment.
        function createParserSource(oldSyntaxTree, textChangeRange, text) {
            var fileName = oldSyntaxTree.fileName();
            var languageVersion = oldSyntaxTree.languageVersion();
            // The underlying source that we will use to scan tokens from any new text, or any tokens 
            // from the old tree that we decide we can't use for any reason.  We will also continue 
            // scanning tokens from this source until we've decided that we're resynchronized and can
            // read in subsequent data from the old tree.
            //
            // This parser source also keeps track of the absolute position in the text that we're in,
            // and any token diagnostics produced.  That way we dont' have to track that ourselves.
            var _scannerParserSource;
            // The range of text in the *original* text that was changed, and the new length of it after
            // the change.
            var _changeRange;
            // Cached value of _changeRange.newSpan().  Cached for performance.
            var _changeRangeNewSpan;
            // This number represents how our position in the old tree relates to the position we're 
            // pointing at in the new text.  If it is 0 then our positions are in sync and we can read
            // nodes or tokens from the old tree.  If it is non-zero, then our positions are not in 
            // sync and we cannot use nodes or tokens from the old tree.
            //
            // Now, changeDelta could be negative or positive.  Negative means 'the position we're at
            // in the original tree is behind the position we're at in the text'.  In this case we 
            // keep throwing out old nodes or tokens (and thus move forward in the original tree) until
            // changeDelta becomes 0 again or positive.  If it becomes 0 then we are resynched and can
            // read nodes or tokesn from the tree.
            //
            // If changeDelta is positive, that means the current node or token we're pointing at in 
            // the old tree is at a further ahead position than the position we're pointing at in the
            // new text.  In this case we have no choice but to scan tokens from teh new text.  We will
            // continue to do so until, again, changeDelta becomes 0 and we've resynced, or change delta
            // becomes negative and we need to skip nodes or tokes in the original tree.
            var _changeDelta = 0;
            // The cursor we use to navigate through and retrieve nodes and tokens from the old tree.
            var _oldSourceUnitCursor = getSyntaxCursor();
            var oldSourceUnit = oldSyntaxTree.sourceUnit();
            var _outstandingRewindPointCount = 0;
            // Start the cursor pointing at the first element in the source unit (if it exists).
            if (oldSourceUnit.moduleElements.length > 0) {
                _oldSourceUnitCursor.pushElement(TypeScript.childAt(oldSourceUnit.moduleElements, 0), 0);
            }
            // In general supporting multiple individual edits is just not that important.  So we 
            // just collapse this all down to a single range to make the code here easier.  The only
            // time this could be problematic would be if the user made a ton of discontinuous edits.
            // For example, doing a column select on a *large* section of a code.  If this is a 
            // problem, we can always update this code to handle multiple changes.
            _changeRange = extendToAffectedRange(textChangeRange, oldSourceUnit);
            _changeRangeNewSpan = _changeRange.newSpan();
            // The old tree's length, plus whatever length change was caused by the edit
            // Had better equal the new text's length!
            if (TypeScript.Debug.shouldAssert(2 /* Aggressive */)) {
                TypeScript.Debug.assert((TypeScript.fullWidth(oldSourceUnit) - _changeRange.span().length() + _changeRange.newLength()) === text.length());
            }
            // Set up a scanner so that we can scan tokens out of the new text.
            _scannerParserSource = TypeScript.Scanner.createParserSource(oldSyntaxTree.fileName(), text, oldSyntaxTree.languageVersion());
            function release() {
                _scannerParserSource.release();
                _scannerParserSource = null;
                _oldSourceUnitCursor = null;
                _outstandingRewindPointCount = 0;
            }
            function extendToAffectedRange(changeRange, sourceUnit) {
                // Consider the following code:
                //      void foo() { /; }
                //
                // If the text changes with an insertion of / just before the semicolon then we end up with:
                //      void foo() { //; }
                //
                // If we were to just use the changeRange a is, then we would not rescan the { token 
                // (as it does not intersect the actual original change range).  Because an edit may
                // change the token touching it, we actually need to look back *at least* one token so
                // that the prior token sees that change.  
                //
                // Note: i believe (outside of regex tokens) max lookahead is just one token for 
                // TypeScript.  However, if this turns out to be wrong, we may have to increase how much
                // futher we look back. 
                //
                // Note: lookahead handling for regex characters is handled specially in during 
                // incremental parsing, and does not need to be handled here.
                var maxLookahead = 1;
                var start = changeRange.span().start();
                for (var i = 0; start > 0 && i <= maxLookahead; i++) {
                    var token = TypeScript.findToken(sourceUnit, start);
                    // Debug.assert(token.kind !== SyntaxKind.None);
                    // Debug.assert(token.kind() === SyntaxKind.EndOfFileToken || token.fullWidth() > 0);
                    var position = token.fullStart();
                    start = Math.max(0, position - 1);
                }
                var finalSpan = TypeScript.TextSpan.fromBounds(start, changeRange.span().end());
                var finalLength = changeRange.newLength() + (changeRange.span().start() - start);
                return new TypeScript.TextChangeRange(finalSpan, finalLength);
            }
            function absolutePosition() {
                return _scannerParserSource.absolutePosition();
            }
            function tokenDiagnostics() {
                return _scannerParserSource.tokenDiagnostics();
            }
            function getRewindPoint() {
                // Get a rewind point for our new text reader and for our old source unit cursor.
                var rewindPoint = _scannerParserSource.getRewindPoint();
                // Clone our cursor.  That way we can restore to that point if hte parser needs to rewind.
                var oldSourceUnitCursorClone = cloneSyntaxCursor(_oldSourceUnitCursor);
                // Store where we were when the rewind point was created.
                rewindPoint.changeDelta = _changeDelta;
                rewindPoint.changeRange = _changeRange;
                rewindPoint.oldSourceUnitCursor = _oldSourceUnitCursor;
                _oldSourceUnitCursor = oldSourceUnitCursorClone;
                // Debug.assert(rewindPoint.pinCount === _oldSourceUnitCursor.pinCount());
                _outstandingRewindPointCount++;
                return rewindPoint;
            }
            function rewind(rewindPoint) {
                // Restore our state to the values when the rewind point was created.
                _changeRange = rewindPoint.changeRange;
                _changeDelta = rewindPoint.changeDelta;
                // Reset the cursor to what it was when we got the rewind point.  Make sure to return 
                // our existing cursor to the pool so it can be reused.
                returnSyntaxCursor(_oldSourceUnitCursor);
                _oldSourceUnitCursor = rewindPoint.oldSourceUnitCursor;
                // Null out the cursor that the rewind point points to.  This way we don't try
                // to return it in 'releaseRewindPoint'.
                rewindPoint.oldSourceUnitCursor = null;
                _scannerParserSource.rewind(rewindPoint);
            }
            function releaseRewindPoint(rewindPoint) {
                if (rewindPoint.oldSourceUnitCursor !== null) {
                    returnSyntaxCursor(rewindPoint.oldSourceUnitCursor);
                }
                _scannerParserSource.releaseRewindPoint(rewindPoint);
                _outstandingRewindPointCount--;
                TypeScript.Debug.assert(_outstandingRewindPointCount >= 0);
            }
            function isPinned() {
                return _outstandingRewindPointCount > 0;
            }
            function canReadFromOldSourceUnit() {
                // If we're currently pinned, then do not want to touch the cursor.  Here's why.  First,
                // recall that we're 'pinned' when we're speculatively parsing.  So say we were to allow
                // returning old nodes/tokens while speculatively parsing. Then, the parser might start
                // mutating the nodes and tokens we returned (i.e. by setting their parents).   Then, 
                // when we rewound, those nodes and tokens would still have those updated parents.  
                // Parents which we just decided we did *not* want to parse (hence why we rewound).  For
                // Example, say we have something like:
                //
                //          var v = f<a,b,c>e;  // note: this is not generic.
                //
                // When incrementally parsing, we will need to speculatively parse to determine if the
                // above is generic.  This will cause us to reuse the "a, b, c" tokens, and set their 
                // parent to a new type argument list.  A type argument list we will then throw away once
                // we decide that it isn't actually generic.  We will have now 'broken' the original tree.
                //
                // As such, the rule is simple.  We only return nodes/tokens from teh original tree if
                // we know the parser will accept and consume them and never rewind back before them.
                if (isPinned()) {
                    return false;
                }
                // If our current absolute position is in the middle of the changed range in the new text
                // then we definitely can't read from the old source unit right now.
                if (_changeRange !== null && _changeRangeNewSpan.intersectsWithPosition(absolutePosition())) {
                    return false;
                }
                // First, try to sync up with the new text if we're behind.
                syncCursorToNewTextIfBehind();
                // Now, if we're synced up *and* we're not currently pinned in the new text scanner,
                // then we can read a node from the cursor.  If we're pinned in the scanner then we
                // can't read a node from the cursor because we will mess up the pinned scanner when
                // we try to move it forward past this node.
                return _changeDelta === 0 && !_oldSourceUnitCursor.isFinished();
            }
            function updateTokens(nodeOrToken) {
                // If we got a node or token, and we're past the range of edited text, then walk its
                // constituent tokens, making sure all their positions are correct.  We don't need to
                // do this for the tokens before the edited range (since their positions couldn't have 
                // been affected by the edit), and we don't need to do this for the tokens in the 
                // edited range, as their positions will be correct when the underlying parser source 
                // creates them.
                var position = absolutePosition();
                var tokenWasMoved = isPastChangeRange() && TypeScript.fullStart(nodeOrToken) !== position;
                if (tokenWasMoved) {
                    setTokenFullStartWalker.position = position;
                    TypeScript.visitNodeOrToken(setTokenFullStartWalker, nodeOrToken);
                }
            }
            function currentNode() {
                if (canReadFromOldSourceUnit()) {
                    // Try to read a node.  If we can't then our caller will call back in and just try
                    // to get a token.
                    var node = tryGetNodeFromOldSourceUnit();
                    if (node !== null) {
                        // Make sure the positions for the tokens in this node are correct.
                        updateTokens(node);
                        return node;
                    }
                }
                // Either we were ahead of the old text, or we were pinned.  No node can be read here.
                return null;
            }
            function currentToken() {
                if (canReadFromOldSourceUnit()) {
                    var token = tryGetTokenFromOldSourceUnit();
                    if (token !== null) {
                        // Make sure the token's position/text is correct.
                        updateTokens(token);
                        return token;
                    }
                }
                // Either we couldn't read from the old source unit, or we weren't able to successfully
                // get a token from it.  In this case we need to read a token from the underlying text.
                return _scannerParserSource.currentToken();
            }
            function currentContextualToken() {
                // Just delegate to the underlying source to handle 
                return _scannerParserSource.currentContextualToken();
            }
            function syncCursorToNewTextIfBehind() {
                while (true) {
                    if (_oldSourceUnitCursor.isFinished()) {
                        break;
                    }
                    if (_changeDelta >= 0) {
                        break;
                    }
                    // We're behind in the original tree.  Throw out a node or token in an attempt to 
                    // catch up to the position we're at in the new text.
                    var currentNodeOrToken = _oldSourceUnitCursor.currentNodeOrToken();
                    // If we're pointing at a node, and that node's width is less than our delta,
                    // then we can just skip that node.  Otherwise, if we're pointing at a node
                    // whose width is greater than the delta, then crumble it and try again.
                    // Otherwise, we must be pointing at a token.  Just skip it and try again.
                    if (TypeScript.isNode(currentNodeOrToken) && (TypeScript.fullWidth(currentNodeOrToken) > Math.abs(_changeDelta))) {
                        // We were pointing at a node whose width was more than changeDelta.  Crumble the 
                        // node and try again.  Note: we haven't changed changeDelta.  So the callers loop
                        // will just repeat this until we get to a node or token that we can skip over.
                        _oldSourceUnitCursor.moveToFirstChild();
                    }
                    else {
                        _oldSourceUnitCursor.moveToNextSibling();
                        // Get our change delta closer to 0 as we skip past this item.
                        _changeDelta += TypeScript.fullWidth(currentNodeOrToken);
                    }
                }
                // At this point, we must be either:
                //   a) done with the cursor
                //   b) (ideally) caught up to the new text position.
                //   c) ahead of the new text position.
                // In case 'b' we can try to reuse a node from teh old tree.
                // Debug.assert(_oldSourceUnitCursor.isFinished() || _changeDelta >= 0);
            }
            function intersectsWithChangeRangeSpanInOriginalText(start, length) {
                return !isPastChangeRange() && _changeRange.span().intersectsWith(start, length);
            }
            function tryGetNodeFromOldSourceUnit() {
                // Debug.assert(canReadFromOldSourceUnit());
                while (true) {
                    var node = _oldSourceUnitCursor.currentNode();
                    if (node === null) {
                        // Couldn't even read a node, nothing to return.
                        return null;
                    }
                    if (!intersectsWithChangeRangeSpanInOriginalText(absolutePosition(), TypeScript.fullWidth(node))) {
                        // Didn't intersect with the change range.
                        var isIncrementallyUnusuable = TypeScript.isIncrementallyUnusable(node);
                        if (!isIncrementallyUnusuable) {
                            // Didn't contain anything that would make it unusable.  Awesome.  This is
                            // a node we can reuse.
                            return node;
                        }
                    }
                    // We couldn't use currentNode. Try to move to its first child (in case that's a 
                    // node).  If it is we can try using that.  Otherwise we'll just bail out in the
                    // next iteration of the loop.
                    _oldSourceUnitCursor.moveToFirstChild();
                }
            }
            function canReuseTokenFromOldSourceUnit(position, token) {
                // A token is safe to return if:
                //  a) it does not intersect the changed text.
                //  b) it does not contain skipped text.
                //  c) it is not zero width.
                //  d) it is not a contextual parser token.
                //
                // NOTE: It is safe to get a token regardless of what our strict context was/is.  That's 
                // because the strict context doesn't change what tokens are scanned, only how the 
                // parser reacts to them.
                //
                // NOTE: we don't mark a keyword that was converted to an identifier as 'incrementally 
                // unusable.  This is because we don't want to mark it's containing parent node as 
                // unusable.  i.e. if i have this:  "public Foo(string: Type) { }", then that *entire* node 
                // is reusuable even though "string" was converted to an identifier.  However, we still
                // need to make sure that if that the parser asks for a *token* we don't return it.  
                // Converted identifiers can't ever be created by the scanner, and as such, should not 
                // be returned by this source.
                if (token !== null) {
                    if (!intersectsWithChangeRangeSpanInOriginalText(position, token.fullWidth())) {
                        // Didn't intersect with the change range.
                        if (!token.isIncrementallyUnusable() && !TypeScript.Scanner.isContextualToken(token)) {
                            // Didn't contain anything that would make it unusable.  Awesome.  This is
                            // a token we can reuse.
                            return true;
                        }
                    }
                }
                return false;
            }
            function tryGetTokenFromOldSourceUnit() {
                // Debug.assert(canReadFromOldSourceUnit());
                // get the current token that the cursor is pointing at.
                var token = _oldSourceUnitCursor.currentToken();
                return canReuseTokenFromOldSourceUnit(absolutePosition(), token) ? token : null;
            }
            function peekToken(n) {
                if (canReadFromOldSourceUnit()) {
                    var token = tryPeekTokenFromOldSourceUnit(n);
                    if (token !== null) {
                        return token;
                    }
                }
                // Couldn't peek this far in the old tree.  Get the token from the new text.
                return _scannerParserSource.peekToken(n);
            }
            function tryPeekTokenFromOldSourceUnit(n) {
                // Debug.assert(canReadFromOldSourceUnit());
                // clone the existing cursor so we can move it forward and then restore ourselves back
                // to where we started from.
                var cursorClone = cloneSyntaxCursor(_oldSourceUnitCursor);
                var token = tryPeekTokenFromOldSourceUnitWorker(n);
                returnSyntaxCursor(_oldSourceUnitCursor);
                _oldSourceUnitCursor = cursorClone;
                return token;
            }
            function tryPeekTokenFromOldSourceUnitWorker(n) {
                // In order to peek the 'nth' token we need all the tokens up to that point.  That way
                // we know we know position that the nth token is at.  The position is necessary so 
                // that we can test if this token (or any that precede it cross the change range).
                var currentPosition = absolutePosition();
                // First, make sure the cursor is pointing at a token.
                _oldSourceUnitCursor.moveToFirstToken();
                for (var i = 0; i < n; i++) {
                    var interimToken = _oldSourceUnitCursor.currentToken();
                    if (!canReuseTokenFromOldSourceUnit(currentPosition, interimToken)) {
                        return null;
                    }
                    currentPosition += interimToken.fullWidth();
                    _oldSourceUnitCursor.moveToNextSibling();
                }
                var token = _oldSourceUnitCursor.currentToken();
                return canReuseTokenFromOldSourceUnit(currentPosition, token) ? token : null;
            }
            function consumeNode(node) {
                // A node could have only come from the old source unit cursor.  Update it and our 
                // current state.
                // Debug.assert(_changeDelta === 0);
                // Debug.assert(currentNode() === node);
                _oldSourceUnitCursor.moveToNextSibling();
                // Update the underlying source with where it should now be currently pointin.
                var _absolutePosition = absolutePosition() + TypeScript.fullWidth(node);
                _scannerParserSource.resetToPosition(_absolutePosition);
                // Debug.assert(previousToken !== null);
                // Debug.assert(previousToken.width() > 0);
                //if (!isPastChangeRange()) {
                //    // If we still have a change range, then this node must have ended before the 
                //    // change range starts.  Thus, we don't need to call 'skipPastChanges'.
                //    Debug.assert(absolutePosition() < _changeRange.span().start());
                //}
            }
            function consumeToken(currentToken) {
                // This token may have come from the old source unit, or from the new text.  Handle
                // both accordingly.
                if (_oldSourceUnitCursor.currentToken() === currentToken) {
                    // The token came from the old source unit.  So our tree and text must be in sync.
                    // Debug.assert(_changeDelta === 0);
                    // Move the cursor past this token.
                    _oldSourceUnitCursor.moveToNextSibling();
                    // Debug.assert(!_normalParserSource.isPinned());
                    // Update the underlying source with where it should now be currently pointing. We 
                    // don't need to do this when the token came from the new text as the source will
                    // automatically be placed in the right position.
                    var _absolutePosition = absolutePosition() + currentToken.fullWidth();
                    _scannerParserSource.resetToPosition(_absolutePosition);
                }
                else {
                    // the token came from the new text.  That means the normal source moved forward,
                    // while the syntax cursor stayed in the same place.  Thus our delta moves even 
                    // further back.
                    _changeDelta -= currentToken.fullWidth();
                    // Move our underlying source forward.
                    _scannerParserSource.consumeToken(currentToken);
                    // Because we read a token from the new text, we may have moved ourselves past the
                    // change range.  If we did, then we may also have to update our change delta to
                    // compensate for the length change between the old and new text.
                    if (!isPastChangeRange()) {
                        // var changeEndInNewText = _changeRange.span().start() + _changeRange.newLength();
                        if (absolutePosition() >= _changeRangeNewSpan.end()) {
                            _changeDelta += _changeRange.newLength() - _changeRange.span().length();
                            // Once we're past the change range, we no longer need it.  Null it out.
                            // From now on we can check if we're past the change range just by seeing
                            // if this is null.
                            _changeRange = null;
                        }
                    }
                }
            }
            function isPastChangeRange() {
                return _changeRange === null;
            }
            return {
                text: text,
                fileName: fileName,
                languageVersion: languageVersion,
                currentNode: currentNode,
                currentToken: currentToken,
                currentContextualToken: currentContextualToken,
                peekToken: peekToken,
                consumeNode: consumeNode,
                consumeToken: consumeToken,
                getRewindPoint: getRewindPoint,
                rewind: rewind,
                releaseRewindPoint: releaseRewindPoint,
                tokenDiagnostics: tokenDiagnostics,
                release: release
            };
        }
        function createSyntaxCursorPiece(element, indexInParent) {
            return { element: element, indexInParent: indexInParent };
        }
        // Pool syntax cursors so we don't churn too much memory when we need temporary cursors.  
        // i.e. when we're speculatively parsing, we can cheaply get a pooled cursor and then
        // return it when we no longer need it.
        var syntaxCursorPool = [];
        var syntaxCursorPoolCount = 0;
        function returnSyntaxCursor(cursor) {
            // Make sure the cursor isn't holding onto any syntax elements.  We don't want to leak 
            // them when we return the cursor to the pool.
            cursor.clean();
            syntaxCursorPool[syntaxCursorPoolCount] = cursor;
            syntaxCursorPoolCount++;
        }
        function getSyntaxCursor() {
            // Get an existing cursor from the pool if we have one.  Or create a new one if we don't.
            var cursor = syntaxCursorPoolCount > 0 ? syntaxCursorPool[syntaxCursorPoolCount - 1] : createSyntaxCursor();
            if (syntaxCursorPoolCount > 0) {
                // If we reused an existing cursor, take it out of the pool so no one else uses it.
                syntaxCursorPoolCount--;
                syntaxCursorPool[syntaxCursorPoolCount] = null;
            }
            return cursor;
        }
        function cloneSyntaxCursor(cursor) {
            var newCursor = getSyntaxCursor();
            // Make the new cursor a *deep* copy of the cursor passed in.  This ensures each cursor can
            // be moved without affecting the other.
            newCursor.deepCopyFrom(cursor);
            return newCursor;
        }
        function createSyntaxCursor() {
            // Our list of path pieces.  The piece pointed to by 'currentPieceIndex' must be a node or
            // token.  However, pieces earlier than that may point to list nodes.
            //
            // For perf we reuse pieces as much as possible.  i.e. instead of popping items off the 
            // list, we just will change currentPieceIndex so we can reuse that piece later.
            var pieces = [];
            var currentPieceIndex = -1;
            // Cleans up this cursor so that it doesn't have any references to actual syntax nodes.
            // This sould be done before returning the cursor to the pool so that the Parser module
            // doesn't unnecessarily keep old syntax trees alive.
            function clean() {
                for (var i = 0, n = pieces.length; i < n; i++) {
                    var piece = pieces[i];
                    if (piece.element === null) {
                        break;
                    }
                    piece.element = null;
                    piece.indexInParent = -1;
                }
                currentPieceIndex = -1;
            }
            // Makes this cursor into a deep copy of the cursor passed in.
            function deepCopyFrom(other) {
                for (var i = 0, n = other.pieces.length; i < n; i++) {
                    var piece = other.pieces[i];
                    if (piece.element === null) {
                        break;
                    }
                    pushElement(piece.element, piece.indexInParent);
                }
                // Debug.assert(currentPieceIndex === other.currentPieceIndex);
            }
            function isFinished() {
                return currentPieceIndex < 0;
            }
            function currentNodeOrToken() {
                if (isFinished()) {
                    return null;
                }
                var result = pieces[currentPieceIndex].element;
                // The current element must always be a node or a token.
                // Debug.assert(result !== null);
                // Debug.assert(result.isNode() || result.isToken());
                return result;
            }
            function currentNode() {
                var element = currentNodeOrToken();
                return TypeScript.isNode(element) ? element : null;
            }
            function moveToFirstChild() {
                var nodeOrToken = currentNodeOrToken();
                if (nodeOrToken === null) {
                    return;
                }
                if (TypeScript.isToken(nodeOrToken)) {
                    // If we're already on a token, there's nothing to do.
                    return;
                }
                for (var i = 0, n = TypeScript.childCount(nodeOrToken); i < n; i++) {
                    var child = TypeScript.childAt(nodeOrToken, i);
                    if (child !== null && !TypeScript.isShared(child)) {
                        // Great, we found a real child.  Push that.
                        pushElement(child, i);
                        // If it was a list, make sure we're pointing at its first element.  We know we
                        // must have one because this is a non-shared list.
                        moveToFirstChildIfList();
                        return;
                    }
                }
                // This element must have been an empty node.  Moving to its 'first child' is equivalent to just
                // moving to the next sibling.
                // Debug.assert(fullWidth(nodeOrToken) === 0);
                moveToNextSibling();
            }
            function moveToNextSibling() {
                while (!isFinished()) {
                    // first look to our parent and see if it has a sibling of us that we can move to.
                    var currentPiece = pieces[currentPieceIndex];
                    var parent = currentPiece.element.parent;
                    for (var i = currentPiece.indexInParent + 1, n = TypeScript.childCount(parent); i < n; i++) {
                        var sibling = TypeScript.childAt(parent, i);
                        if (sibling !== null && !TypeScript.isShared(sibling)) {
                            // We found a good sibling that we can move to.  Just reuse our existing piece
                            // so we don't have to push/pop.
                            currentPiece.element = sibling;
                            currentPiece.indexInParent = i;
                            // The sibling might have been a list.  Move to it's first child.  it must have
                            // one since this was a non-shared element.
                            moveToFirstChildIfList();
                            return;
                        }
                    }
                    // Didn't have a sibling for this element.  Go up to our parent and get its sibling.
                    // Clear the data from the old piece.  We don't want to keep any elements around
                    // unintentionally.
                    currentPiece.element = null;
                    currentPiece.indexInParent = -1;
                    // Point at the parent.  if we move past the top of the path, then we're finished.
                    currentPieceIndex--;
                }
            }
            function moveToFirstChildIfList() {
                var element = pieces[currentPieceIndex].element;
                if (TypeScript.isList(element) || TypeScript.isSeparatedList(element)) {
                    // We cannot ever get an empty list in our piece path.  Empty lists are 'shared' and
                    // we make sure to filter that out before pushing any children.
                    // Debug.assert(childCount(element) > 0);
                    pushElement(TypeScript.childAt(element, 0), 0);
                }
            }
            function pushElement(element, indexInParent) {
                // Debug.assert(element !== null);
                // Debug.assert(indexInParent >= 0);
                currentPieceIndex++;
                // Reuse an existing piece if we have one.  Otherwise, push a new piece to our list.
                if (currentPieceIndex === pieces.length) {
                    pieces.push(createSyntaxCursorPiece(element, indexInParent));
                }
                else {
                    var piece = pieces[currentPieceIndex];
                    piece.element = element;
                    piece.indexInParent = indexInParent;
                }
            }
            function moveToFirstToken() {
                while (!isFinished()) {
                    var element = pieces[currentPieceIndex].element;
                    if (TypeScript.isNode(element)) {
                        moveToFirstChild();
                        continue;
                    }
                    // Debug.assert(isToken(element));
                    return;
                }
            }
            function currentToken() {
                moveToFirstToken();
                var element = currentNodeOrToken();
                // Debug.assert(element === null || element.isToken());
                return element === null ? null : element;
            }
            return {
                pieces: pieces,
                clean: clean,
                isFinished: isFinished,
                moveToFirstChild: moveToFirstChild,
                moveToFirstToken: moveToFirstToken,
                moveToNextSibling: moveToNextSibling,
                currentNodeOrToken: currentNodeOrToken,
                currentNode: currentNode,
                currentToken: currentToken,
                pushElement: pushElement,
                deepCopyFrom: deepCopyFrom
            };
        }
        // A simple walker we use to hit all the tokens of a node and update their positions when they
        // are reused in a different location because of an incremental parse.
        var SetTokenFullStartWalker = (function (_super) {
            __extends(SetTokenFullStartWalker, _super);
            function SetTokenFullStartWalker() {
                _super.apply(this, arguments);
            }
            SetTokenFullStartWalker.prototype.visitToken = function (token) {
                var position = this.position;
                token.setFullStart(position);
                this.position = position + token.fullWidth();
            };
            return SetTokenFullStartWalker;
        })(TypeScript.SyntaxWalker);
        var setTokenFullStartWalker = new SetTokenFullStartWalker();
        function parse(oldSyntaxTree, textChangeRange, newText) {
            TypeScript.Debug.assert(oldSyntaxTree.isConcrete(), "Can only incrementally parse a concrete syntax tree.");
            if (textChangeRange.isUnchanged()) {
                return oldSyntaxTree;
            }
            return TypeScript.Parser.parseSource(createParserSource(oldSyntaxTree, textChangeRange, newText), oldSyntaxTree.isDeclaration());
        }
        IncrementalParser.parse = parse;
    })(IncrementalParser = TypeScript.IncrementalParser || (TypeScript.IncrementalParser = {}));
})(TypeScript || (TypeScript = {}));
/////<reference path='es5compat.ts' />
/////<reference path='..\compiler\typescript.ts' />
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
///<reference path='references.ts' />
var ts;
(function (ts) {
    var OutliningElementsCollector;
    (function (OutliningElementsCollector) {
        function collectElements(sourceFile) {
            var elements = [];
            function addOutlineRange(hintSpanNode, startElement, endElement) {
                if (hintSpanNode && startElement && endElement) {
                    var span = {
                        textSpan: TypeScript.TextSpan.fromBounds(startElement.pos, endElement.end),
                        hintSpan: TypeScript.TextSpan.fromBounds(hintSpanNode.getStart(), hintSpanNode.end),
                        bannerText: "...",
                        autoCollapse: false
                    };
                    elements.push(span);
                }
            }
            var depth = 0;
            var maxDepth = 20;
            function walk(n) {
                if (depth > maxDepth) {
                    return;
                }
                switch (n.kind) {
                    case 148 /* Block */:
                    case 173 /* FunctionBlock */:
                    case 178 /* ModuleBlock */:
                    case 167 /* TryBlock */:
                    case 167 /* TryBlock */:
                    case 168 /* CatchBlock */:
                    case 169 /* FinallyBlock */:
                        var openBrace = ts.forEach(n.getChildren(), function (c) { return c.kind === 9 /* OpenBraceToken */ && c; });
                        var closeBrace = ts.forEach(n.getChildren(), function (c) { return c.kind === 10 /* CloseBraceToken */ && c; });
                        addOutlineRange(n.parent, openBrace, closeBrace);
                        break;
                    case 174 /* ClassDeclaration */:
                    case 175 /* InterfaceDeclaration */:
                    case 176 /* EnumDeclaration */:
                    case 133 /* ObjectLiteral */:
                        var openBrace = ts.forEach(n.getChildren(), function (c) { return c.kind === 9 /* OpenBraceToken */ && c; });
                        var closeBrace = ts.forEach(n.getChildren(), function (c) { return c.kind === 10 /* CloseBraceToken */ && c; });
                        addOutlineRange(n, openBrace, closeBrace);
                        break;
                }
                depth++;
                ts.forEachChild(n, walk);
                depth--;
            }
            walk(sourceFile);
            return elements;
        }
        OutliningElementsCollector.collectElements = collectElements;
    })(OutliningElementsCollector = ts.OutliningElementsCollector || (ts.OutliningElementsCollector = {}));
})(ts || (ts = {}));
///<reference path='references.ts' />
var TypeScript;
(function (TypeScript) {
    var Services;
    (function (Services) {
        var NavigationBarItemGetter = (function () {
            function NavigationBarItemGetter() {
                this.hasGlobalNode = false;
            }
            NavigationBarItemGetter.prototype.getIndent = function (node) {
                var indent = this.hasGlobalNode ? 1 : 0;
                var current = node.parent;
                while (current != null) {
                    if (current.kind() == 131 /* ModuleDeclaration */ || current.kind() === 130 /* FunctionDeclaration */) {
                        indent++;
                    }
                    current = current.parent;
                }
                return indent;
            };
            NavigationBarItemGetter.prototype.getKindModifiers = function (modifiers) {
                var result = [];
                for (var i = 0, n = modifiers.length; i < n; i++) {
                    result.push(modifiers[i].text());
                }
                return result.length > 0 ? result.join(',') : ts.ScriptElementKindModifier.none;
            };
            NavigationBarItemGetter.prototype.getItems = function (node) {
                var _this = this;
                return this.getItemsWorker(function () { return _this.getTopLevelNodes(node); }, function (n) { return _this.createTopLevelItem(n); });
            };
            NavigationBarItemGetter.prototype.getChildNodes = function (nodes) {
                var childNodes = [];
                for (var i = 0, n = nodes.length; i < n; i++) {
                    var node = nodes[i];
                    if (node.kind() === 130 /* FunctionDeclaration */) {
                        childNodes.push(node);
                    }
                    else if (node.kind() === 149 /* VariableStatement */) {
                        var variableDeclaration = node.variableDeclaration;
                        childNodes.push.apply(childNodes, variableDeclaration.variableDeclarators);
                    }
                }
                return childNodes;
            };
            NavigationBarItemGetter.prototype.getTopLevelNodes = function (node) {
                var topLevelNodes = [];
                topLevelNodes.push(node);
                this.addTopLevelNodes(node.moduleElements, topLevelNodes);
                return topLevelNodes;
            };
            NavigationBarItemGetter.prototype.addTopLevelNodes = function (nodes, topLevelNodes) {
                for (var i = 0, n = nodes.length; i < n; i++) {
                    var node = nodes[i];
                    switch (node.kind()) {
                        case 132 /* ClassDeclaration */:
                        case 133 /* EnumDeclaration */:
                        case 129 /* InterfaceDeclaration */:
                            topLevelNodes.push(node);
                            break;
                        case 131 /* ModuleDeclaration */:
                            var moduleDeclaration = node;
                            topLevelNodes.push(node);
                            this.addTopLevelNodes(moduleDeclaration.moduleElements, topLevelNodes);
                            break;
                        case 130 /* FunctionDeclaration */:
                            var functionDeclaration = node;
                            if (this.isTopLevelFunctionDeclaration(functionDeclaration)) {
                                topLevelNodes.push(node);
                                this.addTopLevelNodes(functionDeclaration.block.statements, topLevelNodes);
                            }
                            break;
                    }
                }
            };
            NavigationBarItemGetter.prototype.isTopLevelFunctionDeclaration = function (functionDeclaration) {
                // A function declaration is 'top level' if it contains any function declarations 
                // within it.
                return functionDeclaration.block && TypeScript.ArrayUtilities.any(functionDeclaration.block.statements, function (s) { return s.kind() === 130 /* FunctionDeclaration */; });
            };
            NavigationBarItemGetter.prototype.getItemsWorker = function (getNodes, createItem) {
                var items = [];
                var keyToItem = TypeScript.createIntrinsicsObject();
                var nodes = getNodes();
                for (var i = 0, n = nodes.length; i < n; i++) {
                    var child = nodes[i];
                    var item = createItem(child);
                    if (item != null) {
                        if (item.text.length > 0) {
                            var key = item.text + "-" + item.kind;
                            var itemWithSameName = keyToItem[key];
                            if (itemWithSameName) {
                                // We had an item with the same name.  Merge these items together.
                                this.merge(itemWithSameName, item);
                            }
                            else {
                                keyToItem[key] = item;
                                items.push(item);
                            }
                        }
                    }
                }
                return items;
            };
            NavigationBarItemGetter.prototype.merge = function (target, source) {
                // First, add any spans in the source to the target.
                target.spans.push.apply(target.spans, source.spans);
                if (source.childItems) {
                    if (!target.childItems) {
                        target.childItems = [];
                    }
                    outer: for (var i = 0, n = source.childItems.length; i < n; i++) {
                        var sourceChild = source.childItems[i];
                        for (var j = 0, m = target.childItems.length; j < m; j++) {
                            var targetChild = target.childItems[j];
                            if (targetChild.text === sourceChild.text && targetChild.kind === sourceChild.kind) {
                                // Found a match.  merge them.
                                this.merge(targetChild, sourceChild);
                                continue outer;
                            }
                        }
                        // Didn't find a match, just add this child to the list.
                        target.childItems.push(sourceChild);
                    }
                }
            };
            NavigationBarItemGetter.prototype.createChildItem = function (node) {
                switch (node.kind()) {
                    case 243 /* Parameter */:
                        var parameter = node;
                        if (parameter.modifiers.length === 0) {
                            return null;
                        }
                        return new ts.NavigationBarItem(parameter.identifier.text(), ts.ScriptElementKind.memberVariableElement, this.getKindModifiers(parameter.modifiers), [TypeScript.TextSpan.fromBounds(TypeScript.start(node), TypeScript.end(node))]);
                    case 136 /* MemberFunctionDeclaration */:
                        var memberFunction = node;
                        return new ts.NavigationBarItem(memberFunction.propertyName.text(), ts.ScriptElementKind.memberFunctionElement, this.getKindModifiers(memberFunction.modifiers), [TypeScript.TextSpan.fromBounds(TypeScript.start(node), TypeScript.end(node))]);
                    case 140 /* GetAccessor */:
                        var getAccessor = node;
                        return new ts.NavigationBarItem(getAccessor.propertyName.text(), ts.ScriptElementKind.memberGetAccessorElement, this.getKindModifiers(getAccessor.modifiers), [TypeScript.TextSpan.fromBounds(TypeScript.start(node), TypeScript.end(node))]);
                    case 141 /* SetAccessor */:
                        var setAccessor = node;
                        return new ts.NavigationBarItem(setAccessor.propertyName.text(), ts.ScriptElementKind.memberSetAccessorElement, this.getKindModifiers(setAccessor.modifiers), [TypeScript.TextSpan.fromBounds(TypeScript.start(node), TypeScript.end(node))]);
                    case 145 /* IndexSignature */:
                        var indexSignature = node;
                        return new ts.NavigationBarItem("[]", ts.ScriptElementKind.indexSignatureElement, ts.ScriptElementKindModifier.none, [TypeScript.TextSpan.fromBounds(TypeScript.start(node), TypeScript.end(node))]);
                    case 244 /* EnumElement */:
                        var enumElement = node;
                        return new ts.NavigationBarItem(enumElement.propertyName.text(), ts.ScriptElementKind.memberVariableElement, ts.ScriptElementKindModifier.none, [TypeScript.TextSpan.fromBounds(TypeScript.start(node), TypeScript.end(node))]);
                    case 143 /* CallSignature */:
                        var callSignature = node;
                        return new ts.NavigationBarItem("()", ts.ScriptElementKind.callSignatureElement, ts.ScriptElementKindModifier.none, [TypeScript.TextSpan.fromBounds(TypeScript.start(node), TypeScript.end(node))]);
                    case 144 /* ConstructSignature */:
                        var constructSignature = node;
                        return new ts.NavigationBarItem("new()", ts.ScriptElementKind.constructSignatureElement, ts.ScriptElementKindModifier.none, [TypeScript.TextSpan.fromBounds(TypeScript.start(node), TypeScript.end(node))]);
                    case 146 /* MethodSignature */:
                        var methodSignature = node;
                        return new ts.NavigationBarItem(methodSignature.propertyName.text(), ts.ScriptElementKind.memberFunctionElement, ts.ScriptElementKindModifier.none, [TypeScript.TextSpan.fromBounds(TypeScript.start(node), TypeScript.end(node))]);
                    case 142 /* PropertySignature */:
                        var propertySignature = node;
                        return new ts.NavigationBarItem(propertySignature.propertyName.text(), ts.ScriptElementKind.memberVariableElement, ts.ScriptElementKindModifier.none, [TypeScript.TextSpan.fromBounds(TypeScript.start(node), TypeScript.end(node))]);
                    case 130 /* FunctionDeclaration */:
                        var functionDeclaration = node;
                        if (!this.isTopLevelFunctionDeclaration(functionDeclaration)) {
                            return new ts.NavigationBarItem(functionDeclaration.identifier.text(), ts.ScriptElementKind.functionElement, this.getKindModifiers(functionDeclaration.modifiers), [TypeScript.TextSpan.fromBounds(TypeScript.start(node), TypeScript.end(node))]);
                        }
                        break;
                    case 137 /* MemberVariableDeclaration */:
                        var memberVariableDeclaration = node;
                        return new ts.NavigationBarItem(memberVariableDeclaration.variableDeclarator.propertyName.text(), ts.ScriptElementKind.memberVariableElement, this.getKindModifiers(memberVariableDeclaration.modifiers), [TypeScript.TextSpan.fromBounds(TypeScript.start(memberVariableDeclaration.variableDeclarator), TypeScript.end(memberVariableDeclaration.variableDeclarator))]);
                    case 226 /* VariableDeclarator */:
                        var variableDeclarator = node;
                        return new ts.NavigationBarItem(variableDeclarator.propertyName.text(), ts.ScriptElementKind.variableElement, ts.ScriptElementKindModifier.none, [TypeScript.TextSpan.fromBounds(TypeScript.start(variableDeclarator), TypeScript.end(variableDeclarator))]);
                    case 138 /* ConstructorDeclaration */:
                        var constructorDeclaration = node;
                        return new ts.NavigationBarItem("constructor", ts.ScriptElementKind.constructorImplementationElement, ts.ScriptElementKindModifier.none, [TypeScript.TextSpan.fromBounds(TypeScript.start(node), TypeScript.end(node))]);
                }
                return null;
            };
            NavigationBarItemGetter.prototype.createTopLevelItem = function (node) {
                switch (node.kind()) {
                    case 120 /* SourceUnit */:
                        return this.createSourceUnitItem(node);
                    case 132 /* ClassDeclaration */:
                        return this.createClassItem(node);
                    case 133 /* EnumDeclaration */:
                        return this.createEnumItem(node);
                    case 129 /* InterfaceDeclaration */:
                        return this.createIterfaceItem(node);
                    case 131 /* ModuleDeclaration */:
                        return this.createModuleItem(node);
                    case 130 /* FunctionDeclaration */:
                        return this.createFunctionItem(node);
                }
                return null;
            };
            NavigationBarItemGetter.prototype.getModuleNames = function (node) {
                var result = [];
                if (node.stringLiteral) {
                    result.push(node.stringLiteral.text());
                }
                else {
                    this.getModuleNamesHelper(node.name, result);
                }
                return result;
            };
            NavigationBarItemGetter.prototype.getModuleNamesHelper = function (name, result) {
                if (name.kind() === 121 /* QualifiedName */) {
                    var qualifiedName = name;
                    this.getModuleNamesHelper(qualifiedName.left, result);
                    result.push(qualifiedName.right.text());
                }
                else {
                    result.push(name.text());
                }
            };
            NavigationBarItemGetter.prototype.createModuleItem = function (node) {
                var _this = this;
                var moduleNames = this.getModuleNames(node);
                var childItems = this.getItemsWorker(function () { return _this.getChildNodes(node.moduleElements); }, function (n) { return _this.createChildItem(n); });
                return new ts.NavigationBarItem(moduleNames.join("."), ts.ScriptElementKind.moduleElement, this.getKindModifiers(node.modifiers), [TypeScript.TextSpan.fromBounds(TypeScript.start(node), TypeScript.end(node))], childItems, this.getIndent(node));
            };
            NavigationBarItemGetter.prototype.createFunctionItem = function (node) {
                var _this = this;
                var childItems = this.getItemsWorker(function () { return node.block.statements; }, function (n) { return _this.createChildItem(n); });
                return new ts.NavigationBarItem(node.identifier.text(), ts.ScriptElementKind.functionElement, this.getKindModifiers(node.modifiers), [TypeScript.TextSpan.fromBounds(TypeScript.start(node), TypeScript.end(node))], childItems, this.getIndent(node));
            };
            NavigationBarItemGetter.prototype.createSourceUnitItem = function (node) {
                var _this = this;
                var childItems = this.getItemsWorker(function () { return _this.getChildNodes(node.moduleElements); }, function (n) { return _this.createChildItem(n); });
                if (childItems === null || childItems.length === 0) {
                    return null;
                }
                this.hasGlobalNode = true;
                return new ts.NavigationBarItem("<global>", ts.ScriptElementKind.moduleElement, ts.ScriptElementKindModifier.none, [TypeScript.TextSpan.fromBounds(TypeScript.start(node), TypeScript.end(node))], childItems);
            };
            NavigationBarItemGetter.prototype.createClassItem = function (node) {
                var _this = this;
                var constructor = TypeScript.ArrayUtilities.firstOrDefault(node.classElements, function (n) { return n.kind() === 138 /* ConstructorDeclaration */; });
                // Add the constructor parameters in as children of hte class (for property parameters).
                var nodes = constructor ? constructor.callSignature.parameterList.parameters.concat(node.classElements) : node.classElements;
                var childItems = this.getItemsWorker(function () { return nodes; }, function (n) { return _this.createChildItem(n); });
                return new ts.NavigationBarItem(node.identifier.text(), ts.ScriptElementKind.classElement, this.getKindModifiers(node.modifiers), [TypeScript.TextSpan.fromBounds(TypeScript.start(node), TypeScript.end(node))], childItems, this.getIndent(node));
            };
            NavigationBarItemGetter.prototype.createEnumItem = function (node) {
                var _this = this;
                var childItems = this.getItemsWorker(function () { return node.enumElements; }, function (n) { return _this.createChildItem(n); });
                return new ts.NavigationBarItem(node.identifier.text(), ts.ScriptElementKind.enumElement, this.getKindModifiers(node.modifiers), [TypeScript.TextSpan.fromBounds(TypeScript.start(node), TypeScript.end(node))], childItems, this.getIndent(node));
            };
            NavigationBarItemGetter.prototype.createIterfaceItem = function (node) {
                var _this = this;
                var childItems = this.getItemsWorker(function () { return node.body.typeMembers; }, function (n) { return _this.createChildItem(n); });
                return new ts.NavigationBarItem(node.identifier.text(), ts.ScriptElementKind.interfaceElement, this.getKindModifiers(node.modifiers), [TypeScript.TextSpan.fromBounds(TypeScript.start(node), TypeScript.end(node))], childItems, this.getIndent(node));
            };
            return NavigationBarItemGetter;
        })();
        Services.NavigationBarItemGetter = NavigationBarItemGetter;
    })(Services = TypeScript.Services || (TypeScript.Services = {}));
})(TypeScript || (TypeScript = {}));
// Copyright (c) Microsoft. All rights reserved. Licensed under the Apache License, Version 2.0. 
// See LICENSE.txt in the project root for complete license information.
///<reference path='references.ts' />
var TypeScript;
(function (TypeScript) {
    var Services;
    (function (Services) {
        var Breakpoints;
        (function (Breakpoints) {
            function createBreakpointSpanInfo(parentElement) {
                var childElements = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    childElements[_i - 1] = arguments[_i];
                }
                if (!parentElement) {
                    return null;
                }
                if (childElements.length == 0) {
                    return TypeScript.TextSpan.fromBounds(TypeScript.start(parentElement), TypeScript.end(parentElement));
                }
                var start;
                var end;
                for (var i = 0; i < childElements.length; i++) {
                    var element = childElements[i];
                    if (element && !TypeScript.isShared(element)) {
                        if (start == undefined) {
                            start = TypeScript.start(element);
                        }
                        end = TypeScript.end(element);
                    }
                }
                return TypeScript.TextSpan.fromBounds(start, end);
            }
            function createBreakpointSpanInfoWithLimChar(startElement, limChar) {
                return TypeScript.TextSpan.fromBounds(TypeScript.start(startElement), limChar);
            }
            var BreakpointResolver = (function () {
                function BreakpointResolver(posLine, lineMap) {
                    this.posLine = posLine;
                    this.lineMap = lineMap;
                }
                BreakpointResolver.prototype.breakpointSpanOfToken = function (positionedToken) {
                    switch (positionedToken.kind()) {
                        case 70 /* OpenBraceToken */:
                            return this.breakpointSpanOfOpenBrace(positionedToken);
                        case 71 /* CloseBraceToken */:
                            return this.breakpointSpanOfCloseBrace(positionedToken);
                        case 79 /* CommaToken */:
                            return this.breakpointSpanOfComma(positionedToken);
                        case 78 /* SemicolonToken */:
                        case 10 /* EndOfFileToken */:
                            return this.breakpointSpanIfStartsOnSameLine(TypeScript.previousToken(positionedToken));
                        case 73 /* CloseParenToken */:
                            return this.breakpointSpanOfCloseParen(positionedToken);
                        case 22 /* DoKeyword */:
                            var parentElement = positionedToken.parent;
                            if (parentElement && parentElement.kind() == 162 /* DoStatement */) {
                                return this.breakpointSpanIfStartsOnSameLine(TypeScript.nextToken(positionedToken));
                            }
                            break;
                    }
                    return this.breakpointSpanOfContainingNode(positionedToken);
                };
                BreakpointResolver.prototype.breakpointSpanOfOpenBrace = function (openBraceToken) {
                    var container = TypeScript.Syntax.containingNode(openBraceToken);
                    if (container) {
                        var originalContainer = container;
                        if (container && container.kind() == 147 /* Block */) {
                            // We have to check the parent and decide what to do with the breakpoint
                            container = TypeScript.Syntax.containingNode(container);
                            if (!container) {
                                container = originalContainer;
                            }
                        }
                        switch (container.kind()) {
                            case 147 /* Block */:
                                if (!this.canHaveBreakpointInBlock(container)) {
                                    return null;
                                }
                                return this.breakpointSpanOfFirstStatementInBlock(container);
                                break;
                            case 131 /* ModuleDeclaration */:
                            case 132 /* ClassDeclaration */:
                            case 130 /* FunctionDeclaration */:
                            case 138 /* ConstructorDeclaration */:
                            case 136 /* MemberFunctionDeclaration */:
                            case 140 /* GetAccessor */:
                            case 141 /* SetAccessor */:
                            case 223 /* FunctionExpression */:
                            case 219 /* ParenthesizedArrowFunctionExpression */:
                            case 220 /* SimpleArrowFunctionExpression */:
                                if (!this.canHaveBreakpointInDeclaration(container)) {
                                    return null;
                                }
                                if (this.posLine != this.lineMap.getLineNumberFromPosition(TypeScript.start(container))) {
                                    return this.breakpointSpanOfFirstChildOfSyntaxList(this.getSyntaxListOfDeclarationWithElements(container));
                                }
                                else {
                                    return this.breakpointSpanOf(container);
                                }
                            case 133 /* EnumDeclaration */:
                                if (!this.canHaveBreakpointInDeclaration(container)) {
                                    return null;
                                }
                                if (this.posLine != this.lineMap.getLineNumberFromPosition(TypeScript.start(container))) {
                                    return this.breakpointSpanOfFirstEnumElement(container);
                                }
                                else {
                                    return this.breakpointSpanOf(container);
                                }
                            case 148 /* IfStatement */:
                            case 156 /* ForInStatement */:
                            case 159 /* WhileStatement */:
                            case 237 /* CatchClause */:
                                if (this.posLine != this.lineMap.getLineNumberFromPosition(TypeScript.start(container))) {
                                    return this.breakpointSpanOfFirstStatementInBlock(originalContainer);
                                }
                                else {
                                    return this.breakpointSpanOf(container);
                                }
                            case 162 /* DoStatement */:
                                return this.breakpointSpanOfFirstStatementInBlock(originalContainer);
                            case 155 /* ForStatement */:
                                if (this.posLine != this.lineMap.getLineNumberFromPosition(TypeScript.start(container))) {
                                    return this.breakpointSpanOfFirstStatementInBlock(originalContainer);
                                }
                                else {
                                    return this.breakpointSpanOf(TypeScript.previousToken(openBraceToken));
                                }
                            case 236 /* ElseClause */:
                            case 234 /* CaseSwitchClause */:
                            case 235 /* DefaultSwitchClause */:
                            case 164 /* WithStatement */:
                            case 160 /* TryStatement */:
                            case 238 /* FinallyClause */:
                                return this.breakpointSpanOfFirstStatementInBlock(originalContainer);
                            case 152 /* SwitchStatement */:
                                if (this.posLine != this.lineMap.getLineNumberFromPosition(TypeScript.start(container))) {
                                    return this.breakpointSpanOfFirstStatementOfFirstCaseClause(container);
                                }
                                else {
                                    return this.breakpointSpanOf(container);
                                }
                        }
                    }
                    return null;
                };
                BreakpointResolver.prototype.breakpointSpanOfCloseBrace = function (closeBraceToken) {
                    var container = TypeScript.Syntax.containingNode(closeBraceToken);
                    if (container) {
                        var originalContainer = container;
                        if (container.kind() == 147 /* Block */) {
                            // We have to check the parent and decide what to do with the breakpoint
                            container = TypeScript.Syntax.containingNode(container);
                            if (!container) {
                                container = originalContainer;
                            }
                        }
                        switch (container.kind()) {
                            case 147 /* Block */:
                                if (!this.canHaveBreakpointInBlock(container)) {
                                    return null;
                                }
                                return this.breakpointSpanOfLastStatementInBlock(container);
                                break;
                            case 131 /* ModuleDeclaration */:
                                if (!this.canHaveBreakpointInDeclaration(container)) {
                                    return null;
                                }
                                var moduleSyntax = container;
                                if (moduleSyntax.moduleElements && moduleSyntax.moduleElements.length > 0) {
                                    return createBreakpointSpanInfo(closeBraceToken);
                                }
                                else {
                                    return null;
                                }
                            case 132 /* ClassDeclaration */:
                            case 130 /* FunctionDeclaration */:
                            case 138 /* ConstructorDeclaration */:
                            case 136 /* MemberFunctionDeclaration */:
                            case 140 /* GetAccessor */:
                            case 141 /* SetAccessor */:
                            case 223 /* FunctionExpression */:
                                if (!this.canHaveBreakpointInDeclaration(container)) {
                                    return null;
                                }
                                return createBreakpointSpanInfo(closeBraceToken);
                            case 133 /* EnumDeclaration */:
                                if (!this.canHaveBreakpointInDeclaration(container)) {
                                    return null;
                                }
                                return createBreakpointSpanInfo(closeBraceToken);
                            case 148 /* IfStatement */:
                            case 236 /* ElseClause */:
                            case 156 /* ForInStatement */:
                            case 155 /* ForStatement */:
                            case 159 /* WhileStatement */:
                            case 162 /* DoStatement */:
                            case 234 /* CaseSwitchClause */:
                            case 235 /* DefaultSwitchClause */:
                            case 164 /* WithStatement */:
                            case 160 /* TryStatement */:
                            case 237 /* CatchClause */:
                            case 238 /* FinallyClause */:
                            case 219 /* ParenthesizedArrowFunctionExpression */:
                            case 220 /* SimpleArrowFunctionExpression */:
                                return this.breakpointSpanOfLastStatementInBlock(originalContainer);
                            case 152 /* SwitchStatement */:
                                return this.breakpointSpanOfLastStatementOfLastCaseClause(container);
                        }
                    }
                    return null;
                };
                BreakpointResolver.prototype.breakpointSpanOfComma = function (commaToken) {
                    var commaParent = commaToken.parent;
                    if (TypeScript.isSeparatedList(commaParent)) {
                        var grandParent = commaParent.parent;
                        if (grandParent) {
                            switch (grandParent.kind()) {
                                case 225 /* VariableDeclaration */:
                                case 133 /* EnumDeclaration */:
                                case 228 /* ParameterList */:
                                    var index = TypeScript.Syntax.childIndex(commaParent, commaToken);
                                    // Use the previous child
                                    if (index > 0) {
                                        var child = TypeScript.childAt(commaParent, index - 1);
                                        return this.breakpointSpanOf(child);
                                    }
                                    // If we cant set breakpoint on enum element, just dont set breakpoint
                                    if (grandParent.kind() == 133 /* EnumDeclaration */) {
                                        return null;
                                    }
                                    break;
                            }
                        }
                    }
                    return this.breakpointSpanOfContainingNode(commaToken);
                };
                BreakpointResolver.prototype.breakpointSpanOfCloseParen = function (closeParenToken) {
                    var closeParenParent = closeParenToken.parent;
                    if (closeParenParent) {
                        switch (closeParenParent.kind()) {
                            case 155 /* ForStatement */:
                            case 228 /* ParameterList */:
                                return this.breakpointSpanOf(TypeScript.previousToken(closeParenToken));
                        }
                    }
                    return this.breakpointSpanOfContainingNode(closeParenToken);
                };
                BreakpointResolver.prototype.canHaveBreakpointInBlock = function (blockNode) {
                    if (!blockNode || TypeScript.SyntaxUtilities.isAmbientDeclarationSyntax(blockNode)) {
                        return false;
                    }
                    var blockSyntax = blockNode;
                    return blockSyntax.statements && blockSyntax.statements.length != 0;
                };
                BreakpointResolver.prototype.breakpointSpanOfFirstStatementInBlock = function (blockNode) {
                    if (!blockNode) {
                        return null;
                    }
                    var blockSyntax = blockNode;
                    var statementsNode = blockSyntax.statements;
                    if (!statementsNode || statementsNode.length == 0) {
                        return null;
                    }
                    var firstStatement = TypeScript.childAt(statementsNode, 0);
                    if (firstStatement && firstStatement.kind() == 147 /* Block */) {
                        if (this.canHaveBreakpointInBlock(firstStatement)) {
                            return this.breakpointSpanOfFirstStatementInBlock(firstStatement);
                        }
                        return null;
                    }
                    else {
                        return this.breakpointSpanOf(firstStatement);
                    }
                };
                BreakpointResolver.prototype.breakpointSpanOfLastStatementInBlock = function (blockNode) {
                    if (!blockNode) {
                        return null;
                    }
                    var blockSyntax = blockNode;
                    var statementsNode = blockSyntax.statements;
                    if (!statementsNode || statementsNode.length == 0) {
                        return null;
                    }
                    var lastStatement = TypeScript.childAt(statementsNode, statementsNode.length - 1);
                    if (lastStatement && lastStatement.kind() == 147 /* Block */) {
                        if (this.canHaveBreakpointInBlock(lastStatement)) {
                            return this.breakpointSpanOfLastStatementInBlock(lastStatement);
                        }
                        return null;
                    }
                    else {
                        return this.breakpointSpanOf(lastStatement);
                    }
                };
                BreakpointResolver.prototype.breakpointSpanOfFirstChildOfSyntaxList = function (positionedList) {
                    if (!positionedList) {
                        return null;
                    }
                    // Find the first syntax element
                    var listSyntax = positionedList;
                    if (listSyntax.length == 0) {
                        return null;
                    }
                    var firstStatement = TypeScript.childAt(positionedList, 0);
                    if (firstStatement && firstStatement.kind() == 147 /* Block */) {
                        if (this.canHaveBreakpointInBlock(firstStatement)) {
                            return this.breakpointSpanOfFirstStatementInBlock(firstStatement);
                        }
                        return null;
                    }
                    else {
                        return this.breakpointSpanOf(firstStatement);
                    }
                };
                BreakpointResolver.prototype.breakpointSpanOfLastChildOfSyntaxList = function (positionedList) {
                    if (!positionedList) {
                        return null;
                    }
                    // Find the first syntax element
                    var listSyntax = positionedList;
                    if (listSyntax.length == 0) {
                        return null;
                    }
                    var lastStatement = TypeScript.childAt(positionedList, 0);
                    if (lastStatement && lastStatement.kind() == 147 /* Block */) {
                        if (this.canHaveBreakpointInBlock(lastStatement)) {
                            return this.breakpointSpanOfLastStatementInBlock(lastStatement);
                        }
                        return null;
                    }
                    else {
                        return this.breakpointSpanOf(lastStatement);
                    }
                };
                BreakpointResolver.prototype.breakpointSpanOfNode = function (positionedNode) {
                    var node = positionedNode;
                    switch (node.kind()) {
                        case 131 /* ModuleDeclaration */:
                        case 132 /* ClassDeclaration */:
                        case 130 /* FunctionDeclaration */:
                        case 138 /* ConstructorDeclaration */:
                        case 136 /* MemberFunctionDeclaration */:
                        case 140 /* GetAccessor */:
                        case 141 /* SetAccessor */:
                        case 223 /* FunctionExpression */:
                            return this.breakpointSpanOfDeclarationWithElements(positionedNode);
                        case 226 /* VariableDeclarator */:
                            return this.breakpointSpanOfVariableDeclarator(positionedNode);
                        case 225 /* VariableDeclaration */:
                            return this.breakpointSpanOfVariableDeclaration(positionedNode);
                        case 149 /* VariableStatement */:
                            return this.breakpointSpanOfVariableStatement(positionedNode);
                        case 243 /* Parameter */:
                            return this.breakpointSpanOfParameter(positionedNode);
                        case 137 /* MemberVariableDeclaration */:
                            return this.breakpointSpanOfMemberVariableDeclaration(positionedNode);
                        case 134 /* ImportDeclaration */:
                            return this.breakpointSpanOfImportDeclaration(positionedNode);
                        case 133 /* EnumDeclaration */:
                            return this.breakpointSpanOfEnumDeclaration(positionedNode);
                        case 244 /* EnumElement */:
                            return this.breakpointSpanOfEnumElement(positionedNode);
                        case 148 /* IfStatement */:
                            return this.breakpointSpanOfIfStatement(positionedNode);
                        case 236 /* ElseClause */:
                            return this.breakpointSpanOfElseClause(positionedNode);
                        case 156 /* ForInStatement */:
                            return this.breakpointSpanOfForInStatement(positionedNode);
                        case 155 /* ForStatement */:
                            return this.breakpointSpanOfForStatement(positionedNode);
                        case 159 /* WhileStatement */:
                            return this.breakpointSpanOfWhileStatement(positionedNode);
                        case 162 /* DoStatement */:
                            return this.breakpointSpanOfDoStatement(positionedNode);
                        case 152 /* SwitchStatement */:
                            return this.breakpointSpanOfSwitchStatement(positionedNode);
                        case 234 /* CaseSwitchClause */:
                            return this.breakpointSpanOfCaseSwitchClause(positionedNode);
                        case 235 /* DefaultSwitchClause */:
                            return this.breakpointSpanOfDefaultSwitchClause(positionedNode);
                        case 164 /* WithStatement */:
                            return this.breakpointSpanOfWithStatement(positionedNode);
                        case 160 /* TryStatement */:
                            return this.breakpointSpanOfTryStatement(positionedNode);
                        case 237 /* CatchClause */:
                            return this.breakpointSpanOfCatchClause(positionedNode);
                        case 238 /* FinallyClause */:
                            return this.breakpointSpanOfFinallyClause(positionedNode);
                        case 219 /* ParenthesizedArrowFunctionExpression */:
                            return this.breakpointSpanOfParenthesizedArrowFunctionExpression(positionedNode);
                        case 220 /* SimpleArrowFunctionExpression */:
                            return this.breakpointSpanOfSimpleArrowFunctionExpression(positionedNode);
                        default:
                            if (TypeScript.SyntaxUtilities.isStatement(node)) {
                                return this.breakpointSpanOfStatement(positionedNode);
                            }
                            else {
                                return this.breakpointOfExpression(positionedNode);
                            }
                    }
                };
                BreakpointResolver.prototype.isExpressionOfArrowExpressions = function (expression) {
                    if (!expression) {
                        return false;
                    }
                    var expressionParent = expression.parent;
                    if (expressionParent) {
                        if (expressionParent.kind() == 219 /* ParenthesizedArrowFunctionExpression */) {
                            var parenthesizedArrowExpression = expressionParent;
                            var expressionOfParenthesizedArrowExpression = parenthesizedArrowExpression.expression;
                            return expressionOfParenthesizedArrowExpression == expression;
                        }
                        else if (expressionParent.kind() == 220 /* SimpleArrowFunctionExpression */) {
                            var simpleArrowExpression = expressionParent;
                            var expressionOfSimpleArrowExpression = simpleArrowExpression.expression;
                            return expressionOfSimpleArrowExpression == expression;
                        }
                        else if (expressionParent.kind() == 174 /* CommaExpression */) {
                            return this.isExpressionOfArrowExpressions(expressionParent);
                        }
                    }
                    return false;
                };
                BreakpointResolver.prototype.isInitializerOfForStatement = function (expressionNode) {
                    if (!expressionNode) {
                        return false;
                    }
                    var expressionParent = expressionNode.parent;
                    if (expressionParent && expressionParent.kind() == 155 /* ForStatement */) {
                        var expression = expressionNode;
                        var forStatement = expressionParent;
                        var initializer = forStatement.initializer;
                        return initializer === expression;
                    }
                    else if (expressionParent && expressionParent.kind() == 174 /* CommaExpression */) {
                        return this.isInitializerOfForStatement(expressionParent);
                    }
                    return false;
                };
                BreakpointResolver.prototype.isConditionOfForStatement = function (expressionNode) {
                    if (!expressionNode) {
                        return false;
                    }
                    var expressionParent = expressionNode.parent;
                    if (expressionParent && expressionParent.kind() == 155 /* ForStatement */) {
                        var expression = expressionNode;
                        var forStatement = expressionParent;
                        var condition = forStatement.condition;
                        return condition === expression;
                    }
                    else if (expressionParent && expressionParent.kind() == 174 /* CommaExpression */) {
                        return this.isConditionOfForStatement(expressionParent);
                    }
                    return false;
                };
                BreakpointResolver.prototype.isIncrememtorOfForStatement = function (expressionNode) {
                    if (!expressionNode) {
                        return false;
                    }
                    var expressionParent = expressionNode.parent;
                    if (expressionParent && expressionParent.kind() == 155 /* ForStatement */) {
                        var expression = expressionNode;
                        var forStatement = expressionParent;
                        var incrementor = forStatement.incrementor;
                        return incrementor === expression;
                    }
                    else if (expressionParent && expressionParent.kind() == 174 /* CommaExpression */) {
                        return this.isIncrememtorOfForStatement(expressionParent);
                    }
                    return false;
                };
                BreakpointResolver.prototype.breakpointOfLeftOfCommaExpression = function (commaExpressionNode) {
                    var commaExpression = commaExpressionNode;
                    return this.breakpointSpanOf(commaExpression.left);
                };
                BreakpointResolver.prototype.breakpointOfExpression = function (expressionNode) {
                    if (this.isInitializerOfForStatement(expressionNode) || this.isConditionOfForStatement(expressionNode) || this.isIncrememtorOfForStatement(expressionNode)) {
                        if (expressionNode.kind() == 174 /* CommaExpression */) {
                            return this.breakpointOfLeftOfCommaExpression(expressionNode);
                        }
                        return createBreakpointSpanInfo(expressionNode);
                    }
                    if (this.isExpressionOfArrowExpressions(expressionNode)) {
                        if (expressionNode.kind() == 174 /* CommaExpression */) {
                            return this.breakpointOfLeftOfCommaExpression(expressionNode);
                        }
                        return createBreakpointSpanInfo(expressionNode);
                    }
                    if (expressionNode.kind() == 135 /* ExportAssignment */) {
                        var exportAssignmentSyntax = expressionNode;
                        return createBreakpointSpanInfo(expressionNode, exportAssignmentSyntax.exportKeyword, exportAssignmentSyntax.equalsToken, exportAssignmentSyntax.identifier);
                    }
                    return this.breakpointSpanOfContainingNode(expressionNode);
                };
                BreakpointResolver.prototype.breakpointSpanOfStatement = function (statementNode) {
                    var statement = statementNode;
                    if (statement.kind() == 157 /* EmptyStatement */) {
                        return null;
                    }
                    var containingNode = TypeScript.Syntax.containingNode(statementNode);
                    if (TypeScript.SyntaxUtilities.isStatement(containingNode)) {
                        // Check if not the declarations and the compound statements
                        var useNodeForBreakpoint = false;
                        switch (containingNode.kind()) {
                            case 131 /* ModuleDeclaration */:
                            case 132 /* ClassDeclaration */:
                            case 130 /* FunctionDeclaration */:
                            case 138 /* ConstructorDeclaration */:
                            case 136 /* MemberFunctionDeclaration */:
                            case 140 /* GetAccessor */:
                            case 141 /* SetAccessor */:
                            case 147 /* Block */:
                            case 148 /* IfStatement */:
                            case 236 /* ElseClause */:
                            case 156 /* ForInStatement */:
                            case 155 /* ForStatement */:
                            case 159 /* WhileStatement */:
                            case 162 /* DoStatement */:
                            case 152 /* SwitchStatement */:
                            case 234 /* CaseSwitchClause */:
                            case 235 /* DefaultSwitchClause */:
                            case 164 /* WithStatement */:
                            case 160 /* TryStatement */:
                            case 237 /* CatchClause */:
                            case 238 /* FinallyClause */:
                            case 147 /* Block */:
                                useNodeForBreakpoint = true;
                        }
                        if (!useNodeForBreakpoint) {
                            return this.breakpointSpanOfContainingNode(statementNode);
                        }
                    }
                    switch (statement.kind()) {
                        case 150 /* ExpressionStatement */:
                            var expressionSyntax = statement;
                            return createBreakpointSpanInfo(expressionSyntax.expression);
                        case 151 /* ReturnStatement */:
                            var returnStatementSyntax = statement;
                            return createBreakpointSpanInfo(statementNode, returnStatementSyntax.returnKeyword, returnStatementSyntax.expression);
                        case 158 /* ThrowStatement */:
                            var throwStatementSyntax = statement;
                            return createBreakpointSpanInfo(statementNode, throwStatementSyntax.throwKeyword, throwStatementSyntax.expression);
                        case 153 /* BreakStatement */:
                            var breakStatementSyntax = statement;
                            return createBreakpointSpanInfo(statementNode, breakStatementSyntax.breakKeyword, breakStatementSyntax.identifier);
                        case 154 /* ContinueStatement */:
                            var continueStatementSyntax = statement;
                            return createBreakpointSpanInfo(statementNode, continueStatementSyntax.continueKeyword, continueStatementSyntax.identifier);
                        case 163 /* DebuggerStatement */:
                            var debuggerStatementSyntax = statement;
                            return createBreakpointSpanInfo(debuggerStatementSyntax.debuggerKeyword);
                        case 161 /* LabeledStatement */:
                            var labeledStatementSyntax = statement;
                            return this.breakpointSpanOf(labeledStatementSyntax.statement);
                    }
                    return null;
                };
                BreakpointResolver.prototype.getSyntaxListOfDeclarationWithElements = function (positionedNode) {
                    var node = positionedNode;
                    var elementsList;
                    var block;
                    switch (node.kind()) {
                        case 131 /* ModuleDeclaration */:
                            elementsList = node.moduleElements;
                            break;
                        case 132 /* ClassDeclaration */:
                            elementsList = node.classElements;
                            break;
                        case 130 /* FunctionDeclaration */:
                            block = node.block;
                            break;
                        case 138 /* ConstructorDeclaration */:
                            block = node.block;
                            break;
                        case 136 /* MemberFunctionDeclaration */:
                            block = node.block;
                            break;
                        case 140 /* GetAccessor */:
                            block = node.block;
                            break;
                        case 141 /* SetAccessor */:
                            block = node.block;
                            break;
                        case 223 /* FunctionExpression */:
                            block = node.block;
                            break;
                        case 219 /* ParenthesizedArrowFunctionExpression */:
                            block = node.block;
                            break;
                        case 220 /* SimpleArrowFunctionExpression */:
                            block = node.block;
                            break;
                        default:
                            throw TypeScript.Errors.argument('positionNode', 'unknown node kind in getSyntaxListOfDeclarationWithElements');
                    }
                    var parentElement = positionedNode;
                    if (block) {
                        parentElement = block;
                        elementsList = block.statements;
                    }
                    return elementsList;
                };
                BreakpointResolver.prototype.canHaveBreakpointInDeclaration = function (positionedNode) {
                    return positionedNode && !TypeScript.SyntaxUtilities.isAmbientDeclarationSyntax(positionedNode);
                };
                BreakpointResolver.prototype.breakpointSpanOfDeclarationWithElements = function (positionedNode) {
                    if (!this.canHaveBreakpointInDeclaration(positionedNode)) {
                        return null;
                    }
                    // If inside another module the whole declaration is debuggable
                    var node = positionedNode;
                    var moduleSyntax = positionedNode;
                    if ((TypeScript.SyntaxUtilities.isModuleElement(node) && TypeScript.Syntax.containingNode(positionedNode).kind() != 120 /* SourceUnit */) || TypeScript.SyntaxUtilities.isClassElement(node) || (moduleSyntax.kind() == 131 /* ModuleDeclaration */ && moduleSyntax.name && moduleSyntax.name.kind() == 121 /* QualifiedName */)) {
                        return createBreakpointSpanInfo(positionedNode);
                    }
                    else {
                        // Try to get the breakpoint in first element declaration
                        return this.breakpointSpanOfFirstChildOfSyntaxList(this.getSyntaxListOfDeclarationWithElements(positionedNode));
                    }
                };
                BreakpointResolver.prototype.canHaveBreakpointInVariableDeclarator = function (varDeclaratorNode) {
                    if (!varDeclaratorNode || TypeScript.SyntaxUtilities.isAmbientDeclarationSyntax(varDeclaratorNode)) {
                        return false;
                    }
                    var varDeclaratorSyntax = varDeclaratorNode;
                    return !!varDeclaratorSyntax.equalsValueClause;
                };
                BreakpointResolver.prototype.breakpointSpanOfVariableDeclarator = function (varDeclaratorNode) {
                    if (!this.canHaveBreakpointInVariableDeclarator(varDeclaratorNode)) {
                        return null;
                    }
                    var container = TypeScript.Syntax.containingNode(varDeclaratorNode);
                    if (container && container.kind() == 225 /* VariableDeclaration */) {
                        var parentDeclaratorsList = varDeclaratorNode.parent;
                        // If this is the first declarator in the list use the declaration instead
                        if (parentDeclaratorsList && TypeScript.childAt(parentDeclaratorsList, 0) == varDeclaratorNode) {
                            return this.breakpointSpanOfVariableDeclaration(container);
                        }
                        // Create breakpoint on this var declarator
                        if (this.canHaveBreakpointInVariableDeclarator(varDeclaratorNode)) {
                            return createBreakpointSpanInfo(varDeclaratorNode);
                        }
                        else {
                            return null;
                        }
                    }
                    else if (container) {
                        // Member Variable syntax
                        return this.breakpointSpanOfMemberVariableDeclaration(container);
                    }
                    return null;
                };
                BreakpointResolver.prototype.canHaveBreakpointInVariableDeclaration = function (varDeclarationNode) {
                    if (!varDeclarationNode || TypeScript.SyntaxUtilities.isAmbientDeclarationSyntax(varDeclarationNode)) {
                        return false;
                    }
                    var varDeclarationSyntax = varDeclarationNode;
                    var containerChildren = varDeclarationSyntax.variableDeclarators;
                    if (!containerChildren || TypeScript.childCount(containerChildren) == 0) {
                        return false;
                    }
                    var child = TypeScript.childAt(containerChildren, 0);
                    if (TypeScript.isNode(child)) {
                        return this.canHaveBreakpointInVariableDeclarator(child);
                    }
                    return false;
                };
                BreakpointResolver.prototype.breakpointSpanOfVariableDeclaration = function (varDeclarationNode) {
                    if (!this.canHaveBreakpointInDeclaration(varDeclarationNode)) {
                        return null;
                    }
                    var container = TypeScript.Syntax.containingNode(varDeclarationNode);
                    var varDeclarationSyntax = varDeclarationNode;
                    var varDeclarators = varDeclarationSyntax.variableDeclarators;
                    if (container && container.kind() == 149 /* VariableStatement */) {
                        return this.breakpointSpanOfVariableStatement(container);
                    }
                    if (this.canHaveBreakpointInVariableDeclaration(varDeclarationNode)) {
                        return createBreakpointSpanInfoWithLimChar(varDeclarationNode, TypeScript.end(TypeScript.childAt(varDeclarators, 0)));
                    }
                    else {
                        return null;
                    }
                };
                BreakpointResolver.prototype.canHaveBreakpointInVariableStatement = function (varStatementNode) {
                    if (!varStatementNode || TypeScript.SyntaxUtilities.isAmbientDeclarationSyntax(varStatementNode)) {
                        return false;
                    }
                    var variableStatement = varStatementNode;
                    return this.canHaveBreakpointInVariableDeclaration(variableStatement.variableDeclaration);
                };
                BreakpointResolver.prototype.breakpointSpanOfVariableStatement = function (varStatementNode) {
                    if (!this.canHaveBreakpointInVariableStatement(varStatementNode)) {
                        return null;
                    }
                    var variableStatement = varStatementNode;
                    var variableDeclaration = variableStatement.variableDeclaration;
                    var varDeclarationSyntax = variableDeclaration;
                    var varDeclarators = varDeclarationSyntax.variableDeclarators;
                    return createBreakpointSpanInfoWithLimChar(varStatementNode, TypeScript.end(TypeScript.childAt(varDeclarators, 0)));
                };
                BreakpointResolver.prototype.breakpointSpanOfParameter = function (parameterNode) {
                    if (parameterNode.parent.kind() === 220 /* SimpleArrowFunctionExpression */) {
                        return this.breakpointSpanOfNode(parameterNode.parent);
                    }
                    if (TypeScript.SyntaxUtilities.isAmbientDeclarationSyntax(parameterNode)) {
                        return null;
                    }
                    var parameterSyntax = parameterNode;
                    if (parameterSyntax.dotDotDotToken || parameterSyntax.equalsValueClause || parameterSyntax.modifiers.length > 0) {
                        return createBreakpointSpanInfo(parameterNode);
                    }
                    else {
                        return null;
                    }
                };
                BreakpointResolver.prototype.breakpointSpanOfMemberVariableDeclaration = function (memberVarDeclarationNode) {
                    if (TypeScript.SyntaxUtilities.isAmbientDeclarationSyntax(memberVarDeclarationNode)) {
                        return null;
                    }
                    var memberVariableDeclaration = memberVarDeclarationNode;
                    if (this.canHaveBreakpointInVariableDeclarator(memberVariableDeclaration.variableDeclarator)) {
                        return createBreakpointSpanInfo(memberVarDeclarationNode, memberVariableDeclaration.modifiers, memberVariableDeclaration.variableDeclarator);
                    }
                    else {
                        return null;
                    }
                };
                BreakpointResolver.prototype.breakpointSpanOfImportDeclaration = function (importDeclarationNode) {
                    if (TypeScript.SyntaxUtilities.isAmbientDeclarationSyntax(importDeclarationNode)) {
                        return null;
                    }
                    var importSyntax = importDeclarationNode;
                    return createBreakpointSpanInfo(importDeclarationNode, importSyntax.modifiers, importSyntax.importKeyword, importSyntax.identifier, importSyntax.equalsToken, importSyntax.moduleReference);
                };
                BreakpointResolver.prototype.breakpointSpanOfEnumDeclaration = function (enumDeclarationNode) {
                    if (!this.canHaveBreakpointInDeclaration(enumDeclarationNode)) {
                        return null;
                    }
                    return createBreakpointSpanInfo(enumDeclarationNode);
                };
                BreakpointResolver.prototype.breakpointSpanOfFirstEnumElement = function (enumDeclarationNode) {
                    var enumDeclarationSyntax = enumDeclarationNode;
                    var enumElements = enumDeclarationSyntax.enumElements;
                    if (enumElements && TypeScript.childCount(enumElements)) {
                        return this.breakpointSpanOf(TypeScript.childAt(enumElements, 0));
                    }
                    return null;
                };
                BreakpointResolver.prototype.breakpointSpanOfEnumElement = function (enumElementNode) {
                    if (TypeScript.SyntaxUtilities.isAmbientDeclarationSyntax(enumElementNode)) {
                        return null;
                    }
                    return createBreakpointSpanInfo(enumElementNode);
                };
                BreakpointResolver.prototype.breakpointSpanOfIfStatement = function (ifStatementNode) {
                    var ifStatement = ifStatementNode;
                    return createBreakpointSpanInfo(ifStatementNode, ifStatement.ifKeyword, ifStatement.openParenToken, ifStatement.condition, ifStatement.closeParenToken);
                };
                BreakpointResolver.prototype.breakpointSpanOfElseClause = function (elseClauseNode) {
                    var elseClause = elseClauseNode;
                    return this.breakpointSpanOf(elseClause.statement);
                };
                BreakpointResolver.prototype.breakpointSpanOfForInStatement = function (forInStatementNode) {
                    var forInStatement = forInStatementNode;
                    return createBreakpointSpanInfo(forInStatementNode, forInStatement.forKeyword, forInStatement.openParenToken, forInStatement.variableDeclaration, forInStatement.left, forInStatement.inKeyword, forInStatement.expression, forInStatement.closeParenToken);
                };
                BreakpointResolver.prototype.breakpointSpanOfForStatement = function (forStatementNode) {
                    var forStatement = forStatementNode;
                    return this.breakpointSpanOf(forStatement.variableDeclaration ? forStatement.variableDeclaration : forStatement.initializer);
                };
                BreakpointResolver.prototype.breakpointSpanOfWhileStatement = function (whileStatementNode) {
                    var whileStatement = whileStatementNode;
                    return createBreakpointSpanInfo(whileStatementNode, whileStatement.whileKeyword, whileStatement.openParenToken, whileStatement.condition, whileStatement.closeParenToken);
                };
                BreakpointResolver.prototype.breakpointSpanOfDoStatement = function (doStatementNode) {
                    var doStatement = doStatementNode;
                    return createBreakpointSpanInfo(doStatementNode, doStatement.whileKeyword, doStatement.openParenToken, doStatement.condition, doStatement.closeParenToken);
                };
                BreakpointResolver.prototype.breakpointSpanOfSwitchStatement = function (switchStatementNode) {
                    var switchStatement = switchStatementNode;
                    return createBreakpointSpanInfo(switchStatementNode, switchStatement.switchKeyword, switchStatement.openParenToken, switchStatement.expression, switchStatement.closeParenToken);
                };
                BreakpointResolver.prototype.breakpointSpanOfFirstStatementOfFirstCaseClause = function (switchStatementNode) {
                    var switchStatement = switchStatementNode;
                    if (switchStatement.switchClauses && switchStatement.switchClauses.length == 0) {
                        return null;
                    }
                    var switchClauses = switchStatement.switchClauses;
                    if (switchClauses.length == 0) {
                        return null;
                    }
                    var firstCaseClause = switchClauses[0];
                    var statements = firstCaseClause.statements;
                    return this.breakpointSpanOfFirstChildOfSyntaxList(statements);
                };
                BreakpointResolver.prototype.breakpointSpanOfLastStatementOfLastCaseClause = function (switchStatementNode) {
                    var switchStatement = switchStatementNode;
                    if (switchStatement.switchClauses && switchStatement.switchClauses.length == 0) {
                        return null;
                    }
                    var switchClauses = switchStatement.switchClauses;
                    if (switchClauses.length == 0) {
                        return null;
                    }
                    var lastClauseNode = switchClauses[switchClauses.length - 1];
                    var statements = lastClauseNode.statements;
                    return this.breakpointSpanOfLastChildOfSyntaxList(statements);
                };
                BreakpointResolver.prototype.breakpointSpanOfCaseSwitchClause = function (caseClauseNode) {
                    var caseSwitchClause = caseClauseNode;
                    return this.breakpointSpanOfFirstChildOfSyntaxList(caseSwitchClause.statements);
                };
                BreakpointResolver.prototype.breakpointSpanOfDefaultSwitchClause = function (defaultSwithClauseNode) {
                    var defaultSwitchClause = defaultSwithClauseNode;
                    return this.breakpointSpanOfFirstChildOfSyntaxList(defaultSwitchClause.statements);
                };
                BreakpointResolver.prototype.breakpointSpanOfWithStatement = function (withStatementNode) {
                    var withStatement = withStatementNode;
                    return this.breakpointSpanOf(withStatement.statement);
                };
                BreakpointResolver.prototype.breakpointSpanOfTryStatement = function (tryStatementNode) {
                    var tryStatement = tryStatementNode;
                    return this.breakpointSpanOfFirstStatementInBlock(tryStatement.block);
                };
                BreakpointResolver.prototype.breakpointSpanOfCatchClause = function (catchClauseNode) {
                    var catchClause = catchClauseNode;
                    return createBreakpointSpanInfo(catchClauseNode, catchClause.catchKeyword, catchClause.openParenToken, catchClause.identifier, catchClause.typeAnnotation, catchClause.closeParenToken);
                };
                BreakpointResolver.prototype.breakpointSpanOfFinallyClause = function (finallyClauseNode) {
                    var finallyClause = finallyClauseNode;
                    return this.breakpointSpanOfFirstStatementInBlock(finallyClause.block);
                };
                BreakpointResolver.prototype.breakpointSpanOfParenthesizedArrowFunctionExpression = function (arrowFunctionExpression) {
                    if (arrowFunctionExpression.block) {
                        return this.breakpointSpanOfFirstStatementInBlock(arrowFunctionExpression.block);
                    }
                    else {
                        return this.breakpointSpanOf(arrowFunctionExpression.expression);
                    }
                };
                BreakpointResolver.prototype.breakpointSpanOfSimpleArrowFunctionExpression = function (arrowFunctionExpression) {
                    if (arrowFunctionExpression.block) {
                        return this.breakpointSpanOfFirstStatementInBlock(arrowFunctionExpression.block);
                    }
                    else {
                        return this.breakpointSpanOf(arrowFunctionExpression.expression);
                    }
                };
                BreakpointResolver.prototype.breakpointSpanOfContainingNode = function (positionedElement) {
                    var current = positionedElement.parent;
                    while (!TypeScript.isNode(current)) {
                        current = current.parent;
                    }
                    return this.breakpointSpanOf(current);
                };
                BreakpointResolver.prototype.breakpointSpanIfStartsOnSameLine = function (positionedElement) {
                    if (positionedElement && this.posLine == this.lineMap.getLineNumberFromPosition(TypeScript.start(positionedElement))) {
                        return this.breakpointSpanOf(positionedElement);
                    }
                    return null;
                };
                BreakpointResolver.prototype.breakpointSpanOf = function (positionedElement) {
                    if (!positionedElement) {
                        return null;
                    }
                    for (var containingNode = TypeScript.Syntax.containingNode(positionedElement); containingNode != null; containingNode = TypeScript.Syntax.containingNode(containingNode)) {
                        if (containingNode.kind() == 245 /* TypeAnnotation */) {
                            return this.breakpointSpanIfStartsOnSameLine(containingNode);
                        }
                    }
                    var element = positionedElement;
                    // Syntax node
                    if (TypeScript.isNode(element)) {
                        return this.breakpointSpanOfNode(positionedElement);
                    }
                    // Token
                    if (TypeScript.isToken(element)) {
                        return this.breakpointSpanOfToken(positionedElement);
                    }
                    // List
                    // Separated List 
                    return this.breakpointSpanOfContainingNode(positionedElement);
                };
                return BreakpointResolver;
            })();
            function getBreakpointLocation(syntaxTree, askedPos) {
                // Cannot set breakpoint in dts file
                if (TypeScript.isDTSFile(syntaxTree.fileName())) {
                    return null;
                }
                var sourceUnit = syntaxTree.sourceUnit();
                var positionedToken = TypeScript.findToken(sourceUnit, askedPos);
                var lineMap = syntaxTree.lineMap();
                var posLine = lineMap.getLineNumberFromPosition(askedPos);
                var tokenStartLine = lineMap.getLineNumberFromPosition(TypeScript.start(positionedToken));
                if (posLine < tokenStartLine) {
                    return null;
                }
                var breakpointResolver = new BreakpointResolver(posLine, lineMap);
                return breakpointResolver.breakpointSpanOf(positionedToken);
            }
            Breakpoints.getBreakpointLocation = getBreakpointLocation;
        })(Breakpoints = Services.Breakpoints || (Services.Breakpoints = {}));
    })(Services = TypeScript.Services || (TypeScript.Services = {}));
})(TypeScript || (TypeScript = {}));
///<reference path='references.ts' />
var TypeScript;
(function (TypeScript) {
    var Indentation;
    (function (Indentation) {
        function columnForEndOfTokenAtPosition(syntaxTree, position, options) {
            var token = TypeScript.findToken(syntaxTree.sourceUnit(), position);
            return columnForStartOfTokenAtPosition(syntaxTree, position, options) + TypeScript.width(token);
        }
        Indentation.columnForEndOfTokenAtPosition = columnForEndOfTokenAtPosition;
        function columnForStartOfTokenAtPosition(syntaxTree, position, options) {
            var token = TypeScript.findToken(syntaxTree.sourceUnit(), position);
            // Walk backward from this token until we find the first token in the line.  For each token 
            // we see (that is not the first tokem in line), push the entirety of the text into the text 
            // array.  Then, for the first token, add its text (without its leading trivia) to the text
            // array.  i.e. if we have:
            //
            //      var foo = a => bar();
            //
            // And we want the column for the start of 'bar', then we'll add the underlinded portions to
            // the text array:
            //
            //      var foo = a => bar();
            //                  _
            //                __
            //              __
            //          ____
            //      ____
            var firstTokenInLine = TypeScript.Syntax.firstTokenInLineContainingPosition(syntaxTree, token.fullStart());
            var leadingTextInReverse = [];
            var current = token;
            while (current !== firstTokenInLine) {
                current = TypeScript.previousToken(current);
                if (current === firstTokenInLine) {
                    // We're at the first token in teh line.
                    // We don't want the leading trivia for this token.  That will be taken care of in
                    // columnForFirstNonWhitespaceCharacterInLine.  So just push the trailing trivia
                    // and then the token text.
                    leadingTextInReverse.push(current.trailingTrivia().fullText());
                    leadingTextInReverse.push(current.text());
                }
                else {
                    // We're at an intermediate token on the line.  Just push all its text into the array.
                    leadingTextInReverse.push(current.fullText());
                }
            }
            // Now, add all trivia to the start of the line on the first token in the list.
            collectLeadingTriviaTextToStartOfLine(firstTokenInLine, leadingTextInReverse);
            return columnForLeadingTextInReverse(leadingTextInReverse, options);
        }
        Indentation.columnForStartOfTokenAtPosition = columnForStartOfTokenAtPosition;
        function columnForStartOfFirstTokenInLineContainingPosition(syntaxTree, position, options) {
            // Walk backward through the tokens until we find the first one on the line.
            var firstTokenInLine = TypeScript.Syntax.firstTokenInLineContainingPosition(syntaxTree, position);
            var leadingTextInReverse = [];
            // Now, add all trivia to the start of the line on the first token in the list.
            collectLeadingTriviaTextToStartOfLine(firstTokenInLine, leadingTextInReverse);
            return columnForLeadingTextInReverse(leadingTextInReverse, options);
        }
        Indentation.columnForStartOfFirstTokenInLineContainingPosition = columnForStartOfFirstTokenInLineContainingPosition;
        // Collect all the trivia that precedes this token.  Stopping when we hit a newline trivia
        // or a multiline comment that spans multiple lines.  This is meant to be called on the first
        // token in a line.
        function collectLeadingTriviaTextToStartOfLine(firstTokenInLine, leadingTextInReverse) {
            var leadingTrivia = firstTokenInLine.leadingTrivia();
            for (var i = leadingTrivia.count() - 1; i >= 0; i--) {
                var trivia = leadingTrivia.syntaxTriviaAt(i);
                if (trivia.kind() === 5 /* NewLineTrivia */) {
                    break;
                }
                if (trivia.kind() === 6 /* MultiLineCommentTrivia */) {
                    var lineSegments = TypeScript.Syntax.splitMultiLineCommentTriviaIntoMultipleLines(trivia);
                    leadingTextInReverse.push(TypeScript.ArrayUtilities.last(lineSegments));
                    if (lineSegments.length > 0) {
                        break;
                    }
                }
                leadingTextInReverse.push(trivia.fullText());
            }
        }
        function columnForLeadingTextInReverse(leadingTextInReverse, options) {
            var column = 0;
            for (var i = leadingTextInReverse.length - 1; i >= 0; i--) {
                var text = leadingTextInReverse[i];
                column = columnForPositionInStringWorker(text, text.length, column, options);
            }
            return column;
        }
        // Returns the column that this input string ends at (assuming it starts at column 0).
        function columnForPositionInString(input, position, options) {
            return columnForPositionInStringWorker(input, position, 0, options);
        }
        Indentation.columnForPositionInString = columnForPositionInString;
        function columnForPositionInStringWorker(input, position, startColumn, options) {
            var column = startColumn;
            var spacesPerTab = options.spacesPerTab;
            for (var j = 0; j < position; j++) {
                var ch = input.charCodeAt(j);
                if (ch === 9 /* tab */) {
                    column += spacesPerTab - column % spacesPerTab;
                }
                else {
                    column++;
                }
            }
            return column;
        }
        function indentationString(column, options) {
            var numberOfTabs = 0;
            var numberOfSpaces = Math.max(0, column);
            if (options.useTabs) {
                numberOfTabs = Math.floor(column / options.spacesPerTab);
                numberOfSpaces -= numberOfTabs * options.spacesPerTab;
            }
            return TypeScript.StringUtilities.repeat('\t', numberOfTabs) + TypeScript.StringUtilities.repeat(' ', numberOfSpaces);
        }
        Indentation.indentationString = indentationString;
        function firstNonWhitespacePosition(value) {
            for (var i = 0; i < value.length; i++) {
                var ch = value.charCodeAt(i);
                if (!TypeScript.CharacterInfo.isWhitespace(ch)) {
                    return i;
                }
            }
            return value.length;
        }
        Indentation.firstNonWhitespacePosition = firstNonWhitespacePosition;
    })(Indentation = TypeScript.Indentation || (TypeScript.Indentation = {}));
})(TypeScript || (TypeScript = {}));
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
///<reference path='formatting.ts' />
var TypeScript;
(function (TypeScript) {
    var Services;
    (function (Services) {
        var Formatting;
        (function (Formatting) {
            var TextSnapshot = (function () {
                function TextSnapshot(snapshot) {
                    this.snapshot = snapshot;
                    this.lines = [];
                }
                TextSnapshot.prototype.getLength = function () {
                    return this.snapshot.length();
                };
                TextSnapshot.prototype.getText = function (span) {
                    return this.snapshot.substr(span.start(), span.length());
                };
                TextSnapshot.prototype.getLineNumberFromPosition = function (position) {
                    return this.snapshot.lineMap().getLineNumberFromPosition(position);
                };
                TextSnapshot.prototype.getLineFromPosition = function (position) {
                    var lineNumber = this.getLineNumberFromPosition(position);
                    return this.getLineFromLineNumber(lineNumber);
                };
                TextSnapshot.prototype.getLineFromLineNumber = function (lineNumber) {
                    var line = this.lines[lineNumber];
                    if (line === undefined) {
                        line = this.getLineFromLineNumberWorker(lineNumber);
                        this.lines[lineNumber] = line;
                    }
                    return line;
                };
                TextSnapshot.prototype.getLineFromLineNumberWorker = function (lineNumber) {
                    var lineMap = this.snapshot.lineMap().lineStarts();
                    var lineMapIndex = lineNumber; //Note: lineMap is 0-based
                    if (lineMapIndex < 0 || lineMapIndex >= lineMap.length)
                        throw new Error(TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Invalid_line_number_0, [lineMapIndex]));
                    var start = lineMap[lineMapIndex];
                    var end;
                    var endIncludingLineBreak;
                    var lineBreak = "";
                    if (lineMapIndex == lineMap.length) {
                        end = endIncludingLineBreak = this.snapshot.length();
                    }
                    else {
                        endIncludingLineBreak = (lineMapIndex >= lineMap.length - 1 ? this.snapshot.length() : lineMap[lineMapIndex + 1]);
                        for (var p = endIncludingLineBreak - 1; p >= start; p--) {
                            var c = this.snapshot.substr(p, 1);
                            //TODO: Other ones?
                            if (c != "\r" && c != "\n") {
                                break;
                            }
                        }
                        end = p + 1;
                        lineBreak = this.snapshot.substr(end, endIncludingLineBreak - end);
                    }
                    var result = new Formatting.TextSnapshotLine(this, lineNumber, start, end, lineBreak);
                    return result;
                };
                return TextSnapshot;
            })();
            Formatting.TextSnapshot = TextSnapshot;
        })(Formatting = Services.Formatting || (Services.Formatting = {}));
    })(Services = TypeScript.Services || (TypeScript.Services = {}));
})(TypeScript || (TypeScript = {}));
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
///<reference path='formatting.ts' />
var TypeScript;
(function (TypeScript) {
    var Services;
    (function (Services) {
        var Formatting;
        (function (Formatting) {
            var TextSnapshotLine = (function () {
                function TextSnapshotLine(_snapshot, _lineNumber, _start, _end, _lineBreak) {
                    this._snapshot = _snapshot;
                    this._lineNumber = _lineNumber;
                    this._start = _start;
                    this._end = _end;
                    this._lineBreak = _lineBreak;
                }
                TextSnapshotLine.prototype.snapshot = function () {
                    return this._snapshot;
                };
                TextSnapshotLine.prototype.start = function () {
                    return new Formatting.SnapshotPoint(this._snapshot, this._start);
                };
                TextSnapshotLine.prototype.startPosition = function () {
                    return this._start;
                };
                TextSnapshotLine.prototype.end = function () {
                    return new Formatting.SnapshotPoint(this._snapshot, this._end);
                };
                TextSnapshotLine.prototype.endPosition = function () {
                    return this._end;
                };
                TextSnapshotLine.prototype.endIncludingLineBreak = function () {
                    return new Formatting.SnapshotPoint(this._snapshot, this._end + this._lineBreak.length);
                };
                TextSnapshotLine.prototype.endIncludingLineBreakPosition = function () {
                    return this._end + this._lineBreak.length;
                };
                TextSnapshotLine.prototype.length = function () {
                    return this._end - this._start;
                };
                TextSnapshotLine.prototype.lineNumber = function () {
                    return this._lineNumber;
                };
                TextSnapshotLine.prototype.getText = function () {
                    return this._snapshot.getText(TypeScript.TextSpan.fromBounds(this._start, this._end));
                };
                return TextSnapshotLine;
            })();
            Formatting.TextSnapshotLine = TextSnapshotLine;
        })(Formatting = Services.Formatting || (Services.Formatting = {}));
    })(Services = TypeScript.Services || (TypeScript.Services = {}));
})(TypeScript || (TypeScript = {}));
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
///<reference path='formatting.ts' />
var TypeScript;
(function (TypeScript) {
    var Services;
    (function (Services) {
        var Formatting;
        (function (Formatting) {
            var SnapshotPoint = (function () {
                function SnapshotPoint(snapshot, position) {
                    this.snapshot = snapshot;
                    this.position = position;
                }
                SnapshotPoint.prototype.getContainingLine = function () {
                    return this.snapshot.getLineFromPosition(this.position);
                };
                SnapshotPoint.prototype.add = function (offset) {
                    return new SnapshotPoint(this.snapshot, this.position + offset);
                };
                return SnapshotPoint;
            })();
            Formatting.SnapshotPoint = SnapshotPoint;
        })(Formatting = Services.Formatting || (Services.Formatting = {}));
    })(Services = TypeScript.Services || (TypeScript.Services = {}));
})(TypeScript || (TypeScript = {}));
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
/// <reference path="formatting.ts"/>
var TypeScript;
(function (TypeScript) {
    var Services;
    (function (Services) {
        var Formatting;
        (function (Formatting) {
            var FormattingContext = (function () {
                function FormattingContext(snapshot, formattingRequestKind) {
                    this.snapshot = snapshot;
                    this.formattingRequestKind = formattingRequestKind;
                    this.currentTokenSpan = null;
                    this.nextTokenSpan = null;
                    this.contextNode = null;
                    this.currentTokenParent = null;
                    this.nextTokenParent = null;
                    this.contextNodeAllOnSameLine = null;
                    this.nextNodeAllOnSameLine = null;
                    this.tokensAreOnSameLine = null;
                    this.contextNodeBlockIsOnOneLine = null;
                    this.nextNodeBlockIsOnOneLine = null;
                    TypeScript.Debug.assert(this.snapshot != null, "snapshot is null");
                }
                FormattingContext.prototype.updateContext = function (currentTokenSpan, currentTokenParent, nextTokenSpan, nextTokenParent, commonParent) {
                    TypeScript.Debug.assert(currentTokenSpan != null, "currentTokenSpan is null");
                    TypeScript.Debug.assert(currentTokenParent != null, "currentTokenParent is null");
                    TypeScript.Debug.assert(nextTokenSpan != null, "nextTokenSpan is null");
                    TypeScript.Debug.assert(nextTokenParent != null, "nextTokenParent is null");
                    TypeScript.Debug.assert(commonParent != null, "commonParent is null");
                    this.currentTokenSpan = currentTokenSpan;
                    this.currentTokenParent = currentTokenParent;
                    this.nextTokenSpan = nextTokenSpan;
                    this.nextTokenParent = nextTokenParent;
                    this.contextNode = commonParent;
                    this.contextNodeAllOnSameLine = null;
                    this.nextNodeAllOnSameLine = null;
                    this.tokensAreOnSameLine = null;
                    this.contextNodeBlockIsOnOneLine = null;
                    this.nextNodeBlockIsOnOneLine = null;
                };
                FormattingContext.prototype.ContextNodeAllOnSameLine = function () {
                    if (this.contextNodeAllOnSameLine === null) {
                        this.contextNodeAllOnSameLine = this.NodeIsOnOneLine(this.contextNode);
                    }
                    return this.contextNodeAllOnSameLine;
                };
                FormattingContext.prototype.NextNodeAllOnSameLine = function () {
                    if (this.nextNodeAllOnSameLine === null) {
                        this.nextNodeAllOnSameLine = this.NodeIsOnOneLine(this.nextTokenParent);
                    }
                    return this.nextNodeAllOnSameLine;
                };
                FormattingContext.prototype.TokensAreOnSameLine = function () {
                    if (this.tokensAreOnSameLine === null) {
                        var startLine = this.snapshot.getLineNumberFromPosition(this.currentTokenSpan.start());
                        var endLine = this.snapshot.getLineNumberFromPosition(this.nextTokenSpan.start());
                        this.tokensAreOnSameLine = (startLine == endLine);
                    }
                    return this.tokensAreOnSameLine;
                };
                FormattingContext.prototype.ContextNodeBlockIsOnOneLine = function () {
                    if (this.contextNodeBlockIsOnOneLine === null) {
                        this.contextNodeBlockIsOnOneLine = this.BlockIsOnOneLine(this.contextNode);
                    }
                    return this.contextNodeBlockIsOnOneLine;
                };
                FormattingContext.prototype.NextNodeBlockIsOnOneLine = function () {
                    if (this.nextNodeBlockIsOnOneLine === null) {
                        this.nextNodeBlockIsOnOneLine = this.BlockIsOnOneLine(this.nextTokenParent);
                    }
                    return this.nextNodeBlockIsOnOneLine;
                };
                FormattingContext.prototype.NodeIsOnOneLine = function (node) {
                    var startLine = this.snapshot.getLineNumberFromPosition(node.start());
                    var endLine = this.snapshot.getLineNumberFromPosition(node.end());
                    return startLine == endLine;
                };
                // Now we know we have a block (or a fake block represented by some other kind of node with an open and close brace as children).
                // IMPORTANT!!! This relies on the invariant that IsBlockContext must return true ONLY for nodes with open and close braces as immediate children
                FormattingContext.prototype.BlockIsOnOneLine = function (node) {
                    var block = node.node();
                    // Now check if they are on the same line
                    return this.snapshot.getLineNumberFromPosition(TypeScript.end(block.openBraceToken)) === this.snapshot.getLineNumberFromPosition(TypeScript.start(block.closeBraceToken));
                };
                return FormattingContext;
            })();
            Formatting.FormattingContext = FormattingContext;
        })(Formatting = Services.Formatting || (Services.Formatting = {}));
    })(Services = TypeScript.Services || (TypeScript.Services = {}));
})(TypeScript || (TypeScript = {}));
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
/// <reference path="formatting.ts"/>
var TypeScript;
(function (TypeScript) {
    var Services;
    (function (Services) {
        var Formatting;
        (function (Formatting) {
            var FormattingManager = (function () {
                function FormattingManager(syntaxTree, snapshot, rulesProvider, editorOptions) {
                    this.syntaxTree = syntaxTree;
                    this.snapshot = snapshot;
                    this.rulesProvider = rulesProvider;
                    //
                    // TODO: convert to use FormattingOptions instead of EditorOptions
                    this.options = new TypeScript.FormattingOptions(!editorOptions.ConvertTabsToSpaces, editorOptions.TabSize, editorOptions.IndentSize, editorOptions.NewLineCharacter);
                }
                FormattingManager.prototype.formatSelection = function (minChar, limChar) {
                    var span = TypeScript.TextSpan.fromBounds(minChar, limChar);
                    return this.formatSpan(span, 1 /* FormatSelection */);
                };
                FormattingManager.prototype.formatDocument = function () {
                    var span = TypeScript.TextSpan.fromBounds(0, this.snapshot.getLength());
                    return this.formatSpan(span, 0 /* FormatDocument */);
                };
                FormattingManager.prototype.formatOnSemicolon = function (caretPosition) {
                    var sourceUnit = this.syntaxTree.sourceUnit();
                    var semicolonPositionedToken = TypeScript.findToken(sourceUnit, caretPosition - 1);
                    if (semicolonPositionedToken.kind() === 78 /* SemicolonToken */) {
                        // Find the outer most parent that this semicolon terminates
                        var current = semicolonPositionedToken;
                        while (current.parent !== null && TypeScript.end(current.parent) === TypeScript.end(semicolonPositionedToken) && current.parent.kind() !== 1 /* List */) {
                            current = current.parent;
                        }
                        // Compute the span
                        var span = new TypeScript.TextSpan(TypeScript.fullStart(current), TypeScript.fullWidth(current));
                        // Format the span
                        return this.formatSpan(span, 3 /* FormatOnSemicolon */);
                    }
                    return [];
                };
                FormattingManager.prototype.formatOnClosingCurlyBrace = function (caretPosition) {
                    var sourceUnit = this.syntaxTree.sourceUnit();
                    var closeBracePositionedToken = TypeScript.findToken(sourceUnit, caretPosition - 1);
                    if (closeBracePositionedToken.kind() === 71 /* CloseBraceToken */) {
                        // Find the outer most parent that this closing brace terminates
                        var current = closeBracePositionedToken;
                        while (current.parent !== null && TypeScript.end(current.parent) === TypeScript.end(closeBracePositionedToken) && current.parent.kind() !== 1 /* List */) {
                            current = current.parent;
                        }
                        // Compute the span
                        var span = new TypeScript.TextSpan(TypeScript.fullStart(current), TypeScript.fullWidth(current));
                        // Format the span
                        return this.formatSpan(span, 4 /* FormatOnClosingCurlyBrace */);
                    }
                    return [];
                };
                FormattingManager.prototype.formatOnEnter = function (caretPosition) {
                    var lineNumber = this.snapshot.getLineNumberFromPosition(caretPosition);
                    if (lineNumber > 0) {
                        // Format both lines
                        var prevLine = this.snapshot.getLineFromLineNumber(lineNumber - 1);
                        var currentLine = this.snapshot.getLineFromLineNumber(lineNumber);
                        var span = TypeScript.TextSpan.fromBounds(prevLine.startPosition(), currentLine.endPosition());
                        // Format the span
                        return this.formatSpan(span, 2 /* FormatOnEnter */);
                    }
                    return [];
                };
                FormattingManager.prototype.formatSpan = function (span, formattingRequestKind) {
                    // Always format from the beginning of the line
                    var startLine = this.snapshot.getLineFromPosition(span.start());
                    span = TypeScript.TextSpan.fromBounds(startLine.startPosition(), span.end());
                    var result = [];
                    var formattingEdits = Formatting.Formatter.getEdits(span, this.syntaxTree.sourceUnit(), this.options, true, this.snapshot, this.rulesProvider, formattingRequestKind);
                    //
                    // TODO: Change the ILanguageService interface to return TextEditInfo (with start, and length) instead of TextEdit (with minChar and limChar)
                    formattingEdits.forEach(function (item) {
                        var edit = new ts.TextChange(new TypeScript.TextSpan(item.position, item.length), item.replaceWith);
                        result.push(edit);
                    });
                    return result;
                };
                return FormattingManager;
            })();
            Formatting.FormattingManager = FormattingManager;
        })(Formatting = Services.Formatting || (Services.Formatting = {}));
    })(Services = TypeScript.Services || (TypeScript.Services = {}));
})(TypeScript || (TypeScript = {}));
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
/// <reference path="formatting.ts"/>
var TypeScript;
(function (TypeScript) {
    var Services;
    (function (Services) {
        var Formatting;
        (function (Formatting) {
            (function (FormattingRequestKind) {
                FormattingRequestKind[FormattingRequestKind["FormatDocument"] = 0] = "FormatDocument";
                FormattingRequestKind[FormattingRequestKind["FormatSelection"] = 1] = "FormatSelection";
                FormattingRequestKind[FormattingRequestKind["FormatOnEnter"] = 2] = "FormatOnEnter";
                FormattingRequestKind[FormattingRequestKind["FormatOnSemicolon"] = 3] = "FormatOnSemicolon";
                FormattingRequestKind[FormattingRequestKind["FormatOnClosingCurlyBrace"] = 4] = "FormatOnClosingCurlyBrace";
                FormattingRequestKind[FormattingRequestKind["FormatOnPaste"] = 5] = "FormatOnPaste";
            })(Formatting.FormattingRequestKind || (Formatting.FormattingRequestKind = {}));
            var FormattingRequestKind = Formatting.FormattingRequestKind;
        })(Formatting = Services.Formatting || (Services.Formatting = {}));
    })(Services = TypeScript.Services || (TypeScript.Services = {}));
})(TypeScript || (TypeScript = {}));
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
///<reference path='formatting.ts' />
var TypeScript;
(function (TypeScript) {
    var Services;
    (function (Services) {
        var Formatting;
        (function (Formatting) {
            var Rule = (function () {
                function Rule(Descriptor, Operation, Flag) {
                    if (Flag === void 0) { Flag = 0 /* None */; }
                    this.Descriptor = Descriptor;
                    this.Operation = Operation;
                    this.Flag = Flag;
                }
                Rule.prototype.toString = function () {
                    return "[desc=" + this.Descriptor + "," + "operation=" + this.Operation + "," + "flag=" + this.Flag + "]";
                };
                return Rule;
            })();
            Formatting.Rule = Rule;
        })(Formatting = Services.Formatting || (Services.Formatting = {}));
    })(Services = TypeScript.Services || (TypeScript.Services = {}));
})(TypeScript || (TypeScript = {}));
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
///<reference path='formatting.ts' />
var TypeScript;
(function (TypeScript) {
    var Services;
    (function (Services) {
        var Formatting;
        (function (Formatting) {
            (function (RuleAction) {
                RuleAction[RuleAction["Ignore"] = 0] = "Ignore";
                RuleAction[RuleAction["Space"] = 1] = "Space";
                RuleAction[RuleAction["NewLine"] = 2] = "NewLine";
                RuleAction[RuleAction["Delete"] = 3] = "Delete";
            })(Formatting.RuleAction || (Formatting.RuleAction = {}));
            var RuleAction = Formatting.RuleAction;
        })(Formatting = Services.Formatting || (Services.Formatting = {}));
    })(Services = TypeScript.Services || (TypeScript.Services = {}));
})(TypeScript || (TypeScript = {}));
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
///<reference path='formatting.ts' />
var TypeScript;
(function (TypeScript) {
    var Services;
    (function (Services) {
        var Formatting;
        (function (Formatting) {
            var RuleDescriptor = (function () {
                function RuleDescriptor(LeftTokenRange, RightTokenRange) {
                    this.LeftTokenRange = LeftTokenRange;
                    this.RightTokenRange = RightTokenRange;
                }
                RuleDescriptor.prototype.toString = function () {
                    return "[leftRange=" + this.LeftTokenRange + "," + "rightRange=" + this.RightTokenRange + "]";
                };
                RuleDescriptor.create1 = function (left, right) {
                    return RuleDescriptor.create4(Formatting.Shared.TokenRange.FromToken(left), Formatting.Shared.TokenRange.FromToken(right));
                };
                RuleDescriptor.create2 = function (left, right) {
                    return RuleDescriptor.create4(left, Formatting.Shared.TokenRange.FromToken(right));
                };
                RuleDescriptor.create3 = function (left, right) {
                    return RuleDescriptor.create4(Formatting.Shared.TokenRange.FromToken(left), right);
                };
                RuleDescriptor.create4 = function (left, right) {
                    return new RuleDescriptor(left, right);
                };
                return RuleDescriptor;
            })();
            Formatting.RuleDescriptor = RuleDescriptor;
        })(Formatting = Services.Formatting || (Services.Formatting = {}));
    })(Services = TypeScript.Services || (TypeScript.Services = {}));
})(TypeScript || (TypeScript = {}));
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
///<reference path='formatting.ts' />
var TypeScript;
(function (TypeScript) {
    var Services;
    (function (Services) {
        var Formatting;
        (function (Formatting) {
            (function (RuleFlags) {
                RuleFlags[RuleFlags["None"] = 0] = "None";
                RuleFlags[RuleFlags["CanDeleteNewLines"] = 1] = "CanDeleteNewLines";
            })(Formatting.RuleFlags || (Formatting.RuleFlags = {}));
            var RuleFlags = Formatting.RuleFlags;
        })(Formatting = Services.Formatting || (Services.Formatting = {}));
    })(Services = TypeScript.Services || (TypeScript.Services = {}));
})(TypeScript || (TypeScript = {}));
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
///<reference path='formatting.ts' />
var TypeScript;
(function (TypeScript) {
    var Services;
    (function (Services) {
        var Formatting;
        (function (Formatting) {
            var RuleOperation = (function () {
                function RuleOperation() {
                    this.Context = null;
                    this.Action = null;
                }
                RuleOperation.prototype.toString = function () {
                    return "[context=" + this.Context + "," + "action=" + this.Action + "]";
                };
                RuleOperation.create1 = function (action) {
                    return RuleOperation.create2(Formatting.RuleOperationContext.Any, action);
                };
                RuleOperation.create2 = function (context, action) {
                    var result = new RuleOperation();
                    result.Context = context;
                    result.Action = action;
                    return result;
                };
                return RuleOperation;
            })();
            Formatting.RuleOperation = RuleOperation;
        })(Formatting = Services.Formatting || (Services.Formatting = {}));
    })(Services = TypeScript.Services || (TypeScript.Services = {}));
})(TypeScript || (TypeScript = {}));
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
///<reference path='formatting.ts' />
var TypeScript;
(function (TypeScript) {
    var Services;
    (function (Services) {
        var Formatting;
        (function (Formatting) {
            var RuleOperationContext = (function () {
                function RuleOperationContext() {
                    var funcs = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        funcs[_i - 0] = arguments[_i];
                    }
                    this.customContextChecks = funcs;
                }
                RuleOperationContext.prototype.IsAny = function () {
                    return this == RuleOperationContext.Any;
                };
                RuleOperationContext.prototype.InContext = function (context) {
                    if (this.IsAny()) {
                        return true;
                    }
                    for (var i = 0, len = this.customContextChecks.length; i < len; i++) {
                        if (!this.customContextChecks[i](context)) {
                            return false;
                        }
                    }
                    return true;
                };
                RuleOperationContext.Any = new RuleOperationContext();
                return RuleOperationContext;
            })();
            Formatting.RuleOperationContext = RuleOperationContext;
        })(Formatting = Services.Formatting || (Services.Formatting = {}));
    })(Services = TypeScript.Services || (TypeScript.Services = {}));
})(TypeScript || (TypeScript = {}));
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
///<reference path='formatting.ts' />
var TypeScript;
(function (TypeScript) {
    var Services;
    (function (Services) {
        var Formatting;
        (function (Formatting) {
            var Rules = (function () {
                function Rules() {
                    ///
                    /// Common Rules
                    ///
                    // Leave comments alone
                    this.IgnoreBeforeComment = new Formatting.Rule(Formatting.RuleDescriptor.create4(Formatting.Shared.TokenRange.Any, Formatting.Shared.TokenRange.Comments), Formatting.RuleOperation.create1(0 /* Ignore */));
                    this.IgnoreAfterLineComment = new Formatting.Rule(Formatting.RuleDescriptor.create3(7 /* SingleLineCommentTrivia */, Formatting.Shared.TokenRange.Any), Formatting.RuleOperation.create1(0 /* Ignore */));
                    // Space after keyword but not before ; or : or ?
                    this.NoSpaceBeforeSemicolon = new Formatting.Rule(Formatting.RuleDescriptor.create2(Formatting.Shared.TokenRange.Any, 78 /* SemicolonToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), 3 /* Delete */));
                    this.NoSpaceBeforeColon = new Formatting.Rule(Formatting.RuleDescriptor.create2(Formatting.Shared.TokenRange.Any, 106 /* ColonToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsNotBinaryOpContext), 3 /* Delete */));
                    this.NoSpaceBeforeQMark = new Formatting.Rule(Formatting.RuleDescriptor.create2(Formatting.Shared.TokenRange.Any, 105 /* QuestionToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsNotBinaryOpContext), 3 /* Delete */));
                    this.SpaceAfterColon = new Formatting.Rule(Formatting.RuleDescriptor.create3(106 /* ColonToken */, Formatting.Shared.TokenRange.Any), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsNotBinaryOpContext), 1 /* Space */));
                    this.SpaceAfterQMark = new Formatting.Rule(Formatting.RuleDescriptor.create3(105 /* QuestionToken */, Formatting.Shared.TokenRange.Any), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsNotBinaryOpContext), 1 /* Space */));
                    this.SpaceAfterSemicolon = new Formatting.Rule(Formatting.RuleDescriptor.create3(78 /* SemicolonToken */, Formatting.Shared.TokenRange.Any), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), 1 /* Space */));
                    // Space after }.
                    this.SpaceAfterCloseBrace = new Formatting.Rule(Formatting.RuleDescriptor.create3(71 /* CloseBraceToken */, Formatting.Shared.TokenRange.Any), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsAfterCodeBlockContext), 1 /* Space */));
                    // Special case for (}, else) and (}, while) since else & while tokens are not part of the tree which makes SpaceAfterCloseBrace rule not applied
                    this.SpaceBetweenCloseBraceAndElse = new Formatting.Rule(Formatting.RuleDescriptor.create1(71 /* CloseBraceToken */, 23 /* ElseKeyword */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), 1 /* Space */));
                    this.SpaceBetweenCloseBraceAndWhile = new Formatting.Rule(Formatting.RuleDescriptor.create1(71 /* CloseBraceToken */, 42 /* WhileKeyword */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), 1 /* Space */));
                    this.NoSpaceAfterCloseBrace = new Formatting.Rule(Formatting.RuleDescriptor.create3(71 /* CloseBraceToken */, Formatting.Shared.TokenRange.FromTokens([73 /* CloseParenToken */, 75 /* CloseBracketToken */, 79 /* CommaToken */, 78 /* SemicolonToken */])), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), 3 /* Delete */));
                    // No space for indexer and dot
                    this.NoSpaceBeforeDot = new Formatting.Rule(Formatting.RuleDescriptor.create2(Formatting.Shared.TokenRange.Any, 76 /* DotToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), 3 /* Delete */));
                    this.NoSpaceAfterDot = new Formatting.Rule(Formatting.RuleDescriptor.create3(76 /* DotToken */, Formatting.Shared.TokenRange.Any), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), 3 /* Delete */));
                    this.NoSpaceBeforeOpenBracket = new Formatting.Rule(Formatting.RuleDescriptor.create2(Formatting.Shared.TokenRange.Any, 74 /* OpenBracketToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), 3 /* Delete */));
                    this.NoSpaceAfterOpenBracket = new Formatting.Rule(Formatting.RuleDescriptor.create3(74 /* OpenBracketToken */, Formatting.Shared.TokenRange.Any), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), 3 /* Delete */));
                    this.NoSpaceBeforeCloseBracket = new Formatting.Rule(Formatting.RuleDescriptor.create2(Formatting.Shared.TokenRange.Any, 75 /* CloseBracketToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), 3 /* Delete */));
                    this.NoSpaceAfterCloseBracket = new Formatting.Rule(Formatting.RuleDescriptor.create3(75 /* CloseBracketToken */, Formatting.Shared.TokenRange.Any), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), 3 /* Delete */));
                    // Place a space before open brace in a function declaration
                    this.FunctionOpenBraceLeftTokenRange = Formatting.Shared.TokenRange.AnyIncludingMultilineComments;
                    this.SpaceBeforeOpenBraceInFunction = new Formatting.Rule(Formatting.RuleDescriptor.create2(this.FunctionOpenBraceLeftTokenRange, 70 /* OpenBraceToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsFunctionDeclContext, Rules.IsNotFormatOnEnter, Rules.IsSameLineTokenOrBeforeMultilineBlockContext), 1 /* Space */), 1 /* CanDeleteNewLines */);
                    // Place a space before open brace in a TypeScript declaration that has braces as children (class, module, enum, etc)
                    this.TypeScriptOpenBraceLeftTokenRange = Formatting.Shared.TokenRange.FromTokens([11 /* IdentifierName */, 6 /* MultiLineCommentTrivia */]);
                    this.SpaceBeforeOpenBraceInTypeScriptDeclWithBlock = new Formatting.Rule(Formatting.RuleDescriptor.create2(this.TypeScriptOpenBraceLeftTokenRange, 70 /* OpenBraceToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsTypeScriptDeclWithBlockContext, Rules.IsNotFormatOnEnter, Rules.IsSameLineTokenOrBeforeMultilineBlockContext), 1 /* Space */), 1 /* CanDeleteNewLines */);
                    // Place a space before open brace in a control flow construct
                    this.ControlOpenBraceLeftTokenRange = Formatting.Shared.TokenRange.FromTokens([73 /* CloseParenToken */, 6 /* MultiLineCommentTrivia */, 22 /* DoKeyword */, 38 /* TryKeyword */, 25 /* FinallyKeyword */, 23 /* ElseKeyword */]);
                    this.SpaceBeforeOpenBraceInControl = new Formatting.Rule(Formatting.RuleDescriptor.create2(this.ControlOpenBraceLeftTokenRange, 70 /* OpenBraceToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsControlDeclContext, Rules.IsNotFormatOnEnter, Rules.IsSameLineTokenOrBeforeMultilineBlockContext), 1 /* Space */), 1 /* CanDeleteNewLines */);
                    // Insert a space after { and before } in single-line contexts, but remove space from empty object literals {}.
                    this.SpaceAfterOpenBrace = new Formatting.Rule(Formatting.RuleDescriptor.create3(70 /* OpenBraceToken */, Formatting.Shared.TokenRange.Any), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSingleLineBlockContext), 1 /* Space */));
                    this.SpaceBeforeCloseBrace = new Formatting.Rule(Formatting.RuleDescriptor.create2(Formatting.Shared.TokenRange.Any, 71 /* CloseBraceToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSingleLineBlockContext), 1 /* Space */));
                    this.NoSpaceBetweenEmptyBraceBrackets = new Formatting.Rule(Formatting.RuleDescriptor.create1(70 /* OpenBraceToken */, 71 /* CloseBraceToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsObjectContext), 3 /* Delete */));
                    // Insert new line after { and before } in multi-line contexts.
                    this.NewLineAfterOpenBraceInBlockContext = new Formatting.Rule(Formatting.RuleDescriptor.create3(70 /* OpenBraceToken */, Formatting.Shared.TokenRange.Any), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsMultilineBlockContext), 2 /* NewLine */));
                    // For functions and control block place } on a new line    [multi-line rule]
                    this.NewLineBeforeCloseBraceInBlockContext = new Formatting.Rule(Formatting.RuleDescriptor.create2(Formatting.Shared.TokenRange.AnyIncludingMultilineComments, 71 /* CloseBraceToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsMultilineBlockContext), 2 /* NewLine */));
                    // Special handling of unary operators.
                    // Prefix operators generally shouldn't have a space between
                    // them and their target unary expression.
                    this.NoSpaceAfterUnaryPrefixOperator = new Formatting.Rule(Formatting.RuleDescriptor.create4(Formatting.Shared.TokenRange.UnaryPrefixOperators, Formatting.Shared.TokenRange.UnaryPrefixExpressions), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsNotBinaryOpContext), 3 /* Delete */));
                    this.NoSpaceAfterUnaryPreincrementOperator = new Formatting.Rule(Formatting.RuleDescriptor.create3(93 /* PlusPlusToken */, Formatting.Shared.TokenRange.UnaryPreincrementExpressions), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), 3 /* Delete */));
                    this.NoSpaceAfterUnaryPredecrementOperator = new Formatting.Rule(Formatting.RuleDescriptor.create3(94 /* MinusMinusToken */, Formatting.Shared.TokenRange.UnaryPredecrementExpressions), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), 3 /* Delete */));
                    this.NoSpaceBeforeUnaryPostincrementOperator = new Formatting.Rule(Formatting.RuleDescriptor.create2(Formatting.Shared.TokenRange.UnaryPostincrementExpressions, 93 /* PlusPlusToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), 3 /* Delete */));
                    this.NoSpaceBeforeUnaryPostdecrementOperator = new Formatting.Rule(Formatting.RuleDescriptor.create2(Formatting.Shared.TokenRange.UnaryPostdecrementExpressions, 94 /* MinusMinusToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), 3 /* Delete */));
                    // More unary operator special-casing.
                    // DevDiv 181814:  Be careful when removing leading whitespace
                    // around unary operators.  Examples:
                    //      1 - -2  --X-->  1--2
                    //      a + ++b --X-->  a+++b
                    this.SpaceAfterPostincrementWhenFollowedByAdd = new Formatting.Rule(Formatting.RuleDescriptor.create1(93 /* PlusPlusToken */, 89 /* PlusToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsBinaryOpContext), 1 /* Space */));
                    this.SpaceAfterAddWhenFollowedByUnaryPlus = new Formatting.Rule(Formatting.RuleDescriptor.create1(89 /* PlusToken */, 89 /* PlusToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsBinaryOpContext), 1 /* Space */));
                    this.SpaceAfterAddWhenFollowedByPreincrement = new Formatting.Rule(Formatting.RuleDescriptor.create1(89 /* PlusToken */, 93 /* PlusPlusToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsBinaryOpContext), 1 /* Space */));
                    this.SpaceAfterPostdecrementWhenFollowedBySubtract = new Formatting.Rule(Formatting.RuleDescriptor.create1(94 /* MinusMinusToken */, 90 /* MinusToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsBinaryOpContext), 1 /* Space */));
                    this.SpaceAfterSubtractWhenFollowedByUnaryMinus = new Formatting.Rule(Formatting.RuleDescriptor.create1(90 /* MinusToken */, 90 /* MinusToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsBinaryOpContext), 1 /* Space */));
                    this.SpaceAfterSubtractWhenFollowedByPredecrement = new Formatting.Rule(Formatting.RuleDescriptor.create1(90 /* MinusToken */, 94 /* MinusMinusToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsBinaryOpContext), 1 /* Space */));
                    this.NoSpaceBeforeComma = new Formatting.Rule(Formatting.RuleDescriptor.create2(Formatting.Shared.TokenRange.Any, 79 /* CommaToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), 3 /* Delete */));
                    this.SpaceAfterCertainKeywords = new Formatting.Rule(Formatting.RuleDescriptor.create4(Formatting.Shared.TokenRange.FromTokens([40 /* VarKeyword */, 36 /* ThrowKeyword */, 31 /* NewKeyword */, 21 /* DeleteKeyword */, 33 /* ReturnKeyword */, 39 /* TypeOfKeyword */]), Formatting.Shared.TokenRange.Any), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), 1 /* Space */));
                    this.NoSpaceBeforeOpenParenInFuncCall = new Formatting.Rule(Formatting.RuleDescriptor.create2(Formatting.Shared.TokenRange.Any, 72 /* OpenParenToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsFunctionCallOrNewContext), 3 /* Delete */));
                    this.SpaceAfterFunctionInFuncDecl = new Formatting.Rule(Formatting.RuleDescriptor.create3(27 /* FunctionKeyword */, Formatting.Shared.TokenRange.Any), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsFunctionDeclContext), 1 /* Space */));
                    this.NoSpaceBeforeOpenParenInFuncDecl = new Formatting.Rule(Formatting.RuleDescriptor.create2(Formatting.Shared.TokenRange.Any, 72 /* OpenParenToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsFunctionDeclContext), 3 /* Delete */));
                    this.SpaceAfterVoidOperator = new Formatting.Rule(Formatting.RuleDescriptor.create3(41 /* VoidKeyword */, Formatting.Shared.TokenRange.Any), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsVoidOpContext), 1 /* Space */));
                    this.NoSpaceBetweenReturnAndSemicolon = new Formatting.Rule(Formatting.RuleDescriptor.create1(33 /* ReturnKeyword */, 78 /* SemicolonToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), 3 /* Delete */));
                    // Add a space between statements. All keywords except (do,else,case) has open/close parens after them.
                    // So, we have a rule to add a space for [),Any], [do,Any], [else,Any], and [case,Any]
                    this.SpaceBetweenStatements = new Formatting.Rule(Formatting.RuleDescriptor.create4(Formatting.Shared.TokenRange.FromTokens([73 /* CloseParenToken */, 22 /* DoKeyword */, 23 /* ElseKeyword */, 16 /* CaseKeyword */]), Formatting.Shared.TokenRange.Any), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsNotForContext), 1 /* Space */));
                    // This low-pri rule takes care of "try {" and "finally {" in case the rule SpaceBeforeOpenBraceInControl didn't execute on FormatOnEnter.
                    this.SpaceAfterTryFinally = new Formatting.Rule(Formatting.RuleDescriptor.create2(Formatting.Shared.TokenRange.FromTokens([38 /* TryKeyword */, 25 /* FinallyKeyword */]), 70 /* OpenBraceToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), 1 /* Space */));
                    //      get x() {}
                    //      set x(val) {}
                    this.SpaceAfterGetSetInMember = new Formatting.Rule(Formatting.RuleDescriptor.create2(Formatting.Shared.TokenRange.FromTokens([64 /* GetKeyword */, 68 /* SetKeyword */]), 11 /* IdentifierName */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsFunctionDeclContext), 1 /* Space */));
                    // Special case for binary operators (that are keywords). For these we have to add a space and shouldn't follow any user options.
                    this.SpaceBeforeBinaryKeywordOperator = new Formatting.Rule(Formatting.RuleDescriptor.create4(Formatting.Shared.TokenRange.Any, Formatting.Shared.TokenRange.BinaryKeywordOperators), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsBinaryOpContext), 1 /* Space */));
                    this.SpaceAfterBinaryKeywordOperator = new Formatting.Rule(Formatting.RuleDescriptor.create4(Formatting.Shared.TokenRange.BinaryKeywordOperators, Formatting.Shared.TokenRange.Any), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsBinaryOpContext), 1 /* Space */));
                    // TypeScript-specific higher priority rules
                    // Treat constructor as an identifier in a function declaration, and remove spaces between constructor and following left parentheses
                    this.NoSpaceAfterConstructor = new Formatting.Rule(Formatting.RuleDescriptor.create1(62 /* ConstructorKeyword */, 72 /* OpenParenToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), 3 /* Delete */));
                    // Use of module as a function call. e.g.: import m2 = module("m2");
                    this.NoSpaceAfterModuleImport = new Formatting.Rule(Formatting.RuleDescriptor.create2(Formatting.Shared.TokenRange.FromTokens([65 /* ModuleKeyword */, 66 /* RequireKeyword */]), 72 /* OpenParenToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), 3 /* Delete */));
                    // Add a space around certain TypeScript keywords
                    this.SpaceAfterCertainTypeScriptKeywords = new Formatting.Rule(Formatting.RuleDescriptor.create4(Formatting.Shared.TokenRange.FromTokens([44 /* ClassKeyword */, 63 /* DeclareKeyword */, 46 /* EnumKeyword */, 47 /* ExportKeyword */, 48 /* ExtendsKeyword */, 64 /* GetKeyword */, 51 /* ImplementsKeyword */, 49 /* ImportKeyword */, 52 /* InterfaceKeyword */, 65 /* ModuleKeyword */, 55 /* PrivateKeyword */, 57 /* PublicKeyword */, 68 /* SetKeyword */, 58 /* StaticKeyword */]), Formatting.Shared.TokenRange.Any), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), 1 /* Space */));
                    this.SpaceBeforeCertainTypeScriptKeywords = new Formatting.Rule(Formatting.RuleDescriptor.create4(Formatting.Shared.TokenRange.Any, Formatting.Shared.TokenRange.FromTokens([48 /* ExtendsKeyword */, 51 /* ImplementsKeyword */])), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), 1 /* Space */));
                    // Treat string literals in module names as identifiers, and add a space between the literal and the opening Brace braces, e.g.: module "m2" {
                    this.SpaceAfterModuleName = new Formatting.Rule(Formatting.RuleDescriptor.create1(14 /* StringLiteral */, 70 /* OpenBraceToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsModuleDeclContext), 1 /* Space */));
                    // Lambda expressions
                    this.SpaceAfterArrow = new Formatting.Rule(Formatting.RuleDescriptor.create3(85 /* EqualsGreaterThanToken */, Formatting.Shared.TokenRange.Any), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), 1 /* Space */));
                    // Optional parameters and var args
                    this.NoSpaceAfterEllipsis = new Formatting.Rule(Formatting.RuleDescriptor.create1(77 /* DotDotDotToken */, 11 /* IdentifierName */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), 3 /* Delete */));
                    this.NoSpaceAfterOptionalParameters = new Formatting.Rule(Formatting.RuleDescriptor.create3(105 /* QuestionToken */, Formatting.Shared.TokenRange.FromTokens([73 /* CloseParenToken */, 79 /* CommaToken */])), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsNotBinaryOpContext), 3 /* Delete */));
                    // generics
                    this.NoSpaceBeforeOpenAngularBracket = new Formatting.Rule(Formatting.RuleDescriptor.create2(Formatting.Shared.TokenRange.TypeNames, 80 /* LessThanToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsTypeArgumentOrParameterContext), 3 /* Delete */));
                    this.NoSpaceBetweenCloseParenAndAngularBracket = new Formatting.Rule(Formatting.RuleDescriptor.create1(73 /* CloseParenToken */, 80 /* LessThanToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsTypeArgumentOrParameterContext), 3 /* Delete */));
                    this.NoSpaceAfterOpenAngularBracket = new Formatting.Rule(Formatting.RuleDescriptor.create3(80 /* LessThanToken */, Formatting.Shared.TokenRange.TypeNames), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsTypeArgumentOrParameterContext), 3 /* Delete */));
                    this.NoSpaceBeforeCloseAngularBracket = new Formatting.Rule(Formatting.RuleDescriptor.create2(Formatting.Shared.TokenRange.Any, 81 /* GreaterThanToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsTypeArgumentOrParameterContext), 3 /* Delete */));
                    this.NoSpaceAfterCloseAngularBracket = new Formatting.Rule(Formatting.RuleDescriptor.create3(81 /* GreaterThanToken */, Formatting.Shared.TokenRange.FromTokens([72 /* OpenParenToken */, 74 /* OpenBracketToken */, 81 /* GreaterThanToken */, 79 /* CommaToken */])), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsTypeArgumentOrParameterContext), 3 /* Delete */));
                    // Remove spaces in empty interface literals. e.g.: x: {}
                    this.NoSpaceBetweenEmptyInterfaceBraceBrackets = new Formatting.Rule(Formatting.RuleDescriptor.create1(70 /* OpenBraceToken */, 71 /* CloseBraceToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsObjectTypeContext), 3 /* Delete */));
                    // These rules are higher in priority than user-configurable rules.
                    this.HighPriorityCommonRules = [
                        this.IgnoreBeforeComment,
                        this.IgnoreAfterLineComment,
                        this.NoSpaceBeforeColon,
                        this.SpaceAfterColon,
                        this.NoSpaceBeforeQMark,
                        this.SpaceAfterQMark,
                        this.NoSpaceBeforeDot,
                        this.NoSpaceAfterDot,
                        this.NoSpaceAfterUnaryPrefixOperator,
                        this.NoSpaceAfterUnaryPreincrementOperator,
                        this.NoSpaceAfterUnaryPredecrementOperator,
                        this.NoSpaceBeforeUnaryPostincrementOperator,
                        this.NoSpaceBeforeUnaryPostdecrementOperator,
                        this.SpaceAfterPostincrementWhenFollowedByAdd,
                        this.SpaceAfterAddWhenFollowedByUnaryPlus,
                        this.SpaceAfterAddWhenFollowedByPreincrement,
                        this.SpaceAfterPostdecrementWhenFollowedBySubtract,
                        this.SpaceAfterSubtractWhenFollowedByUnaryMinus,
                        this.SpaceAfterSubtractWhenFollowedByPredecrement,
                        this.NoSpaceAfterCloseBrace,
                        this.SpaceAfterOpenBrace,
                        this.SpaceBeforeCloseBrace,
                        this.NewLineBeforeCloseBraceInBlockContext,
                        this.SpaceAfterCloseBrace,
                        this.SpaceBetweenCloseBraceAndElse,
                        this.SpaceBetweenCloseBraceAndWhile,
                        this.NoSpaceBetweenEmptyBraceBrackets,
                        this.SpaceAfterFunctionInFuncDecl,
                        this.NewLineAfterOpenBraceInBlockContext,
                        this.SpaceAfterGetSetInMember,
                        this.NoSpaceBetweenReturnAndSemicolon,
                        this.SpaceAfterCertainKeywords,
                        this.NoSpaceBeforeOpenParenInFuncCall,
                        this.SpaceBeforeBinaryKeywordOperator,
                        this.SpaceAfterBinaryKeywordOperator,
                        this.SpaceAfterVoidOperator,
                        this.NoSpaceAfterConstructor,
                        this.NoSpaceAfterModuleImport,
                        this.SpaceAfterCertainTypeScriptKeywords,
                        this.SpaceBeforeCertainTypeScriptKeywords,
                        this.SpaceAfterModuleName,
                        this.SpaceAfterArrow,
                        this.NoSpaceAfterEllipsis,
                        this.NoSpaceAfterOptionalParameters,
                        this.NoSpaceBetweenEmptyInterfaceBraceBrackets,
                        this.NoSpaceBeforeOpenAngularBracket,
                        this.NoSpaceBetweenCloseParenAndAngularBracket,
                        this.NoSpaceAfterOpenAngularBracket,
                        this.NoSpaceBeforeCloseAngularBracket,
                        this.NoSpaceAfterCloseAngularBracket
                    ];
                    // These rules are lower in priority than user-configurable rules.
                    this.LowPriorityCommonRules = [
                        this.NoSpaceBeforeSemicolon,
                        this.SpaceBeforeOpenBraceInControl,
                        this.SpaceBeforeOpenBraceInFunction,
                        this.SpaceBeforeOpenBraceInTypeScriptDeclWithBlock,
                        this.NoSpaceBeforeComma,
                        this.NoSpaceBeforeOpenBracket,
                        this.NoSpaceAfterOpenBracket,
                        this.NoSpaceBeforeCloseBracket,
                        this.NoSpaceAfterCloseBracket,
                        this.SpaceAfterSemicolon,
                        this.NoSpaceBeforeOpenParenInFuncDecl,
                        this.SpaceBetweenStatements,
                        this.SpaceAfterTryFinally
                    ];
                    ///
                    /// Rules controlled by user options
                    ///
                    // Insert space after comma delimiter
                    this.SpaceAfterComma = new Formatting.Rule(Formatting.RuleDescriptor.create3(79 /* CommaToken */, Formatting.Shared.TokenRange.Any), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), 1 /* Space */));
                    this.NoSpaceAfterComma = new Formatting.Rule(Formatting.RuleDescriptor.create3(79 /* CommaToken */, Formatting.Shared.TokenRange.Any), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), 3 /* Delete */));
                    // Insert space before and after binary operators
                    this.SpaceBeforeBinaryOperator = new Formatting.Rule(Formatting.RuleDescriptor.create4(Formatting.Shared.TokenRange.Any, Formatting.Shared.TokenRange.BinaryOperators), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsBinaryOpContext), 1 /* Space */));
                    this.SpaceAfterBinaryOperator = new Formatting.Rule(Formatting.RuleDescriptor.create4(Formatting.Shared.TokenRange.BinaryOperators, Formatting.Shared.TokenRange.Any), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsBinaryOpContext), 1 /* Space */));
                    this.NoSpaceBeforeBinaryOperator = new Formatting.Rule(Formatting.RuleDescriptor.create4(Formatting.Shared.TokenRange.Any, Formatting.Shared.TokenRange.BinaryOperators), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsBinaryOpContext), 3 /* Delete */));
                    this.NoSpaceAfterBinaryOperator = new Formatting.Rule(Formatting.RuleDescriptor.create4(Formatting.Shared.TokenRange.BinaryOperators, Formatting.Shared.TokenRange.Any), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsBinaryOpContext), 3 /* Delete */));
                    // Insert space after keywords in control flow statements
                    this.SpaceAfterKeywordInControl = new Formatting.Rule(Formatting.RuleDescriptor.create2(Formatting.Shared.TokenRange.Keywords, 72 /* OpenParenToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsControlDeclContext), 1 /* Space */));
                    this.NoSpaceAfterKeywordInControl = new Formatting.Rule(Formatting.RuleDescriptor.create2(Formatting.Shared.TokenRange.Keywords, 72 /* OpenParenToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsControlDeclContext), 3 /* Delete */));
                    // Open Brace braces after function
                    //TypeScript: Function can have return types, which can be made of tons of different token kinds
                    this.NewLineBeforeOpenBraceInFunction = new Formatting.Rule(Formatting.RuleDescriptor.create2(this.FunctionOpenBraceLeftTokenRange, 70 /* OpenBraceToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsFunctionDeclContext, Rules.IsBeforeMultilineBlockContext), 2 /* NewLine */), 1 /* CanDeleteNewLines */);
                    // Open Brace braces after TypeScript module/class/interface
                    this.NewLineBeforeOpenBraceInTypeScriptDeclWithBlock = new Formatting.Rule(Formatting.RuleDescriptor.create2(this.TypeScriptOpenBraceLeftTokenRange, 70 /* OpenBraceToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsTypeScriptDeclWithBlockContext, Rules.IsBeforeMultilineBlockContext), 2 /* NewLine */), 1 /* CanDeleteNewLines */);
                    // Open Brace braces after control block
                    this.NewLineBeforeOpenBraceInControl = new Formatting.Rule(Formatting.RuleDescriptor.create2(this.ControlOpenBraceLeftTokenRange, 70 /* OpenBraceToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsControlDeclContext, Rules.IsBeforeMultilineBlockContext), 2 /* NewLine */), 1 /* CanDeleteNewLines */);
                    // Insert space after semicolon in for statement
                    this.SpaceAfterSemicolonInFor = new Formatting.Rule(Formatting.RuleDescriptor.create3(78 /* SemicolonToken */, Formatting.Shared.TokenRange.Any), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsForContext), 1 /* Space */));
                    this.NoSpaceAfterSemicolonInFor = new Formatting.Rule(Formatting.RuleDescriptor.create3(78 /* SemicolonToken */, Formatting.Shared.TokenRange.Any), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsForContext), 3 /* Delete */));
                    // Insert space after opening and before closing nonempty parenthesis
                    this.SpaceAfterOpenParen = new Formatting.Rule(Formatting.RuleDescriptor.create3(72 /* OpenParenToken */, Formatting.Shared.TokenRange.Any), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), 1 /* Space */));
                    this.SpaceBeforeCloseParen = new Formatting.Rule(Formatting.RuleDescriptor.create2(Formatting.Shared.TokenRange.Any, 73 /* CloseParenToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), 1 /* Space */));
                    this.NoSpaceBetweenParens = new Formatting.Rule(Formatting.RuleDescriptor.create1(72 /* OpenParenToken */, 73 /* CloseParenToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), 3 /* Delete */));
                    this.NoSpaceAfterOpenParen = new Formatting.Rule(Formatting.RuleDescriptor.create3(72 /* OpenParenToken */, Formatting.Shared.TokenRange.Any), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), 3 /* Delete */));
                    this.NoSpaceBeforeCloseParen = new Formatting.Rule(Formatting.RuleDescriptor.create2(Formatting.Shared.TokenRange.Any, 73 /* CloseParenToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), 3 /* Delete */));
                    // Insert space after function keyword for anonymous functions
                    this.SpaceAfterAnonymousFunctionKeyword = new Formatting.Rule(Formatting.RuleDescriptor.create1(27 /* FunctionKeyword */, 72 /* OpenParenToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsFunctionDeclContext), 1 /* Space */));
                    this.NoSpaceAfterAnonymousFunctionKeyword = new Formatting.Rule(Formatting.RuleDescriptor.create1(27 /* FunctionKeyword */, 72 /* OpenParenToken */), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsFunctionDeclContext), 3 /* Delete */));
                }
                Rules.prototype.getRuleName = function (rule) {
                    var o = this;
                    for (var name in o) {
                        if (o[name] === rule) {
                            return name;
                        }
                    }
                    throw new Error(TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Unknown_rule, null));
                };
                ///
                /// Contexts
                ///
                Rules.IsForContext = function (context) {
                    return context.contextNode.kind() === 155 /* ForStatement */;
                };
                Rules.IsNotForContext = function (context) {
                    return !Rules.IsForContext(context);
                };
                Rules.IsBinaryOpContext = function (context) {
                    switch (context.contextNode.kind()) {
                        case 175 /* AssignmentExpression */:
                        case 176 /* AddAssignmentExpression */:
                        case 177 /* SubtractAssignmentExpression */:
                        case 178 /* MultiplyAssignmentExpression */:
                        case 179 /* DivideAssignmentExpression */:
                        case 180 /* ModuloAssignmentExpression */:
                        case 181 /* AndAssignmentExpression */:
                        case 182 /* ExclusiveOrAssignmentExpression */:
                        case 183 /* OrAssignmentExpression */:
                        case 184 /* LeftShiftAssignmentExpression */:
                        case 185 /* SignedRightShiftAssignmentExpression */:
                        case 186 /* UnsignedRightShiftAssignmentExpression */:
                        case 187 /* ConditionalExpression */:
                        case 188 /* LogicalOrExpression */:
                        case 189 /* LogicalAndExpression */:
                        case 190 /* BitwiseOrExpression */:
                        case 191 /* BitwiseExclusiveOrExpression */:
                        case 192 /* BitwiseAndExpression */:
                        case 193 /* EqualsWithTypeConversionExpression */:
                        case 194 /* NotEqualsWithTypeConversionExpression */:
                        case 195 /* EqualsExpression */:
                        case 196 /* NotEqualsExpression */:
                        case 197 /* LessThanExpression */:
                        case 198 /* GreaterThanExpression */:
                        case 199 /* LessThanOrEqualExpression */:
                        case 200 /* GreaterThanOrEqualExpression */:
                        case 201 /* InstanceOfExpression */:
                        case 202 /* InExpression */:
                        case 203 /* LeftShiftExpression */:
                        case 204 /* SignedRightShiftExpression */:
                        case 205 /* UnsignedRightShiftExpression */:
                        case 206 /* MultiplyExpression */:
                        case 207 /* DivideExpression */:
                        case 208 /* ModuloExpression */:
                        case 209 /* AddExpression */:
                        case 210 /* SubtractExpression */:
                            return true;
                        case 134 /* ImportDeclaration */:
                        case 226 /* VariableDeclarator */:
                        case 233 /* EqualsValueClause */:
                            return context.currentTokenSpan.kind === 107 /* EqualsToken */ || context.nextTokenSpan.kind === 107 /* EqualsToken */;
                        case 156 /* ForInStatement */:
                            return context.currentTokenSpan.kind === 29 /* InKeyword */ || context.nextTokenSpan.kind === 29 /* InKeyword */;
                    }
                    return false;
                };
                Rules.IsNotBinaryOpContext = function (context) {
                    return !Rules.IsBinaryOpContext(context);
                };
                Rules.IsSameLineTokenOrBeforeMultilineBlockContext = function (context) {
                    //// This check is mainly used inside SpaceBeforeOpenBraceInControl and SpaceBeforeOpenBraceInFunction.
                    ////
                    //// Ex: 
                    //// if (1)     { ....
                    ////      * ) and { are on the same line so apply the rule. Here we don't care whether it's same or multi block context
                    ////
                    //// Ex: 
                    //// if (1)
                    //// { ... }
                    ////      * ) and { are on differnet lines. We only need to format if the block is multiline context. So in this case we don't format.
                    ////
                    //// Ex:
                    //// if (1) 
                    //// { ...
                    //// }
                    ////      * ) and { are on differnet lines. We only need to format if the block is multiline context. So in this case we format.
                    return context.TokensAreOnSameLine() || Rules.IsBeforeMultilineBlockContext(context);
                };
                // This check is done before an open brace in a control construct, a function, or a typescript block declaration
                Rules.IsBeforeMultilineBlockContext = function (context) {
                    return Rules.IsBeforeBlockContext(context) && !(context.NextNodeAllOnSameLine() || context.NextNodeBlockIsOnOneLine());
                };
                Rules.IsMultilineBlockContext = function (context) {
                    return Rules.IsBlockContext(context) && !(context.ContextNodeAllOnSameLine() || context.ContextNodeBlockIsOnOneLine());
                };
                Rules.IsSingleLineBlockContext = function (context) {
                    return Rules.IsBlockContext(context) && (context.ContextNodeAllOnSameLine() || context.ContextNodeBlockIsOnOneLine());
                };
                Rules.IsBlockContext = function (context) {
                    return Rules.NodeIsBlockContext(context.contextNode);
                };
                Rules.IsBeforeBlockContext = function (context) {
                    return Rules.NodeIsBlockContext(context.nextTokenParent);
                };
                // IMPORTANT!!! This method must return true ONLY for nodes with open and close braces as immediate children
                Rules.NodeIsBlockContext = function (node) {
                    if (Rules.NodeIsTypeScriptDeclWithBlockContext(node)) {
                        // This means we are in a context that looks like a block to the user, but in the grammar is actually not a node (it's a class, module, enum, object type literal, etc).
                        return true;
                    }
                    switch (node.kind()) {
                        case 147 /* Block */:
                        case 152 /* SwitchStatement */:
                        case 216 /* ObjectLiteralExpression */:
                            return true;
                    }
                    return false;
                };
                Rules.IsFunctionDeclContext = function (context) {
                    switch (context.contextNode.kind()) {
                        case 130 /* FunctionDeclaration */:
                        case 136 /* MemberFunctionDeclaration */:
                        case 140 /* GetAccessor */:
                        case 141 /* SetAccessor */:
                        case 146 /* MethodSignature */:
                        case 143 /* CallSignature */:
                        case 223 /* FunctionExpression */:
                        case 138 /* ConstructorDeclaration */:
                        case 220 /* SimpleArrowFunctionExpression */:
                        case 219 /* ParenthesizedArrowFunctionExpression */:
                        case 129 /* InterfaceDeclaration */:
                            return true;
                    }
                    return false;
                };
                Rules.IsTypeScriptDeclWithBlockContext = function (context) {
                    return Rules.NodeIsTypeScriptDeclWithBlockContext(context.contextNode);
                };
                Rules.NodeIsTypeScriptDeclWithBlockContext = function (node) {
                    switch (node.kind()) {
                        case 132 /* ClassDeclaration */:
                        case 133 /* EnumDeclaration */:
                        case 122 /* ObjectType */:
                        case 131 /* ModuleDeclaration */:
                            return true;
                    }
                    return false;
                };
                Rules.IsAfterCodeBlockContext = function (context) {
                    switch (context.currentTokenParent.kind()) {
                        case 132 /* ClassDeclaration */:
                        case 131 /* ModuleDeclaration */:
                        case 133 /* EnumDeclaration */:
                        case 147 /* Block */:
                        case 152 /* SwitchStatement */:
                            return true;
                    }
                    return false;
                };
                Rules.IsControlDeclContext = function (context) {
                    switch (context.contextNode.kind()) {
                        case 148 /* IfStatement */:
                        case 152 /* SwitchStatement */:
                        case 155 /* ForStatement */:
                        case 156 /* ForInStatement */:
                        case 159 /* WhileStatement */:
                        case 160 /* TryStatement */:
                        case 162 /* DoStatement */:
                        case 164 /* WithStatement */:
                        case 236 /* ElseClause */:
                        case 237 /* CatchClause */:
                        case 238 /* FinallyClause */:
                            return true;
                        default:
                            return false;
                    }
                };
                Rules.IsObjectContext = function (context) {
                    return context.contextNode.kind() === 216 /* ObjectLiteralExpression */;
                };
                Rules.IsFunctionCallContext = function (context) {
                    return context.contextNode.kind() === 214 /* InvocationExpression */;
                };
                Rules.IsNewContext = function (context) {
                    return context.contextNode.kind() === 217 /* ObjectCreationExpression */;
                };
                Rules.IsFunctionCallOrNewContext = function (context) {
                    return Rules.IsFunctionCallContext(context) || Rules.IsNewContext(context);
                };
                Rules.IsSameLineTokenContext = function (context) {
                    return context.TokensAreOnSameLine();
                };
                Rules.IsNotFormatOnEnter = function (context) {
                    return context.formattingRequestKind != 2 /* FormatOnEnter */;
                };
                Rules.IsModuleDeclContext = function (context) {
                    return context.contextNode.kind() === 131 /* ModuleDeclaration */;
                };
                Rules.IsObjectTypeContext = function (context) {
                    return context.contextNode.kind() === 122 /* ObjectType */ && context.contextNode.parent().kind() !== 129 /* InterfaceDeclaration */;
                };
                Rules.IsTypeArgumentOrParameter = function (tokenKind, parentKind) {
                    return ((tokenKind === 80 /* LessThanToken */ || tokenKind === 81 /* GreaterThanToken */) && (parentKind === 230 /* TypeParameterList */ || parentKind === 229 /* TypeArgumentList */));
                };
                Rules.IsTypeArgumentOrParameterContext = function (context) {
                    return Rules.IsTypeArgumentOrParameter(context.currentTokenSpan.kind, context.currentTokenParent.kind()) || Rules.IsTypeArgumentOrParameter(context.nextTokenSpan.kind, context.nextTokenParent.kind());
                };
                Rules.IsVoidOpContext = function (context) {
                    return context.currentTokenSpan.kind === 41 /* VoidKeyword */ && context.currentTokenParent.kind() === 173 /* VoidExpression */;
                };
                return Rules;
            })();
            Formatting.Rules = Rules;
        })(Formatting = Services.Formatting || (Services.Formatting = {}));
    })(Services = TypeScript.Services || (TypeScript.Services = {}));
})(TypeScript || (TypeScript = {}));
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
///<reference path='formatting.ts' />
var TypeScript;
(function (TypeScript) {
    var Services;
    (function (Services) {
        var Formatting;
        (function (Formatting) {
            var RulesMap = (function () {
                function RulesMap() {
                    this.map = [];
                    this.mapRowLength = 0;
                }
                RulesMap.create = function (rules) {
                    var result = new RulesMap();
                    result.Initialize(rules);
                    return result;
                };
                RulesMap.prototype.Initialize = function (rules) {
                    this.mapRowLength = TypeScript.SyntaxKind.LastToken + 1;
                    this.map = new Array(this.mapRowLength * this.mapRowLength); //new Array<RulesBucket>(this.mapRowLength * this.mapRowLength);
                    // This array is used only during construction of the rulesbucket in the map
                    var rulesBucketConstructionStateList = new Array(this.map.length); //new Array<RulesBucketConstructionState>(this.map.length);
                    this.FillRules(rules, rulesBucketConstructionStateList);
                    return this.map;
                };
                RulesMap.prototype.FillRules = function (rules, rulesBucketConstructionStateList) {
                    var _this = this;
                    rules.forEach(function (rule) {
                        _this.FillRule(rule, rulesBucketConstructionStateList);
                    });
                };
                RulesMap.prototype.GetRuleBucketIndex = function (row, column) {
                    var rulesBucketIndex = (row * this.mapRowLength) + column;
                    //Debug.Assert(rulesBucketIndex < this.map.Length, "Trying to access an index outside the array.");
                    return rulesBucketIndex;
                };
                RulesMap.prototype.FillRule = function (rule, rulesBucketConstructionStateList) {
                    var _this = this;
                    var specificRule = rule.Descriptor.LeftTokenRange != Formatting.Shared.TokenRange.Any && rule.Descriptor.RightTokenRange != Formatting.Shared.TokenRange.Any;
                    rule.Descriptor.LeftTokenRange.GetTokens().forEach(function (left) {
                        rule.Descriptor.RightTokenRange.GetTokens().forEach(function (right) {
                            var rulesBucketIndex = _this.GetRuleBucketIndex(left, right);
                            var rulesBucket = _this.map[rulesBucketIndex];
                            if (rulesBucket == undefined) {
                                rulesBucket = _this.map[rulesBucketIndex] = new RulesBucket();
                            }
                            rulesBucket.AddRule(rule, specificRule, rulesBucketConstructionStateList, rulesBucketIndex);
                        });
                    });
                };
                RulesMap.prototype.GetRule = function (context) {
                    var bucketIndex = this.GetRuleBucketIndex(context.currentTokenSpan.kind, context.nextTokenSpan.kind);
                    var bucket = this.map[bucketIndex];
                    if (bucket != null) {
                        for (var i = 0, len = bucket.Rules().length; i < len; i++) {
                            var rule = bucket.Rules()[i];
                            if (rule.Operation.Context.InContext(context))
                                return rule;
                        }
                    }
                    return null;
                };
                return RulesMap;
            })();
            Formatting.RulesMap = RulesMap;
            var MaskBitSize = 5;
            var Mask = 0x1f;
            (function (RulesPosition) {
                RulesPosition[RulesPosition["IgnoreRulesSpecific"] = 0] = "IgnoreRulesSpecific";
                RulesPosition[RulesPosition["IgnoreRulesAny"] = MaskBitSize * 1] = "IgnoreRulesAny";
                RulesPosition[RulesPosition["ContextRulesSpecific"] = MaskBitSize * 2] = "ContextRulesSpecific";
                RulesPosition[RulesPosition["ContextRulesAny"] = MaskBitSize * 3] = "ContextRulesAny";
                RulesPosition[RulesPosition["NoContextRulesSpecific"] = MaskBitSize * 4] = "NoContextRulesSpecific";
                RulesPosition[RulesPosition["NoContextRulesAny"] = MaskBitSize * 5] = "NoContextRulesAny";
            })(Formatting.RulesPosition || (Formatting.RulesPosition = {}));
            var RulesPosition = Formatting.RulesPosition;
            var RulesBucketConstructionState = (function () {
                function RulesBucketConstructionState() {
                    //// The Rules list contains all the inserted rules into a rulebucket in the following order:
                    ////    1- Ignore rules with specific token combination
                    ////    2- Ignore rules with any token combination
                    ////    3- Context rules with specific token combination
                    ////    4- Context rules with any token combination
                    ////    5- Non-context rules with specific token combination
                    ////    6- Non-context rules with any token combination
                    //// 
                    //// The member rulesInsertionIndexBitmap is used to describe the number of rules
                    //// in each sub-bucket (above) hence can be used to know the index of where to insert 
                    //// the next rule. It's a bitmap which contains 6 different sections each is given 5 bits.
                    ////
                    //// Example:
                    //// In order to insert a rule to the end of sub-bucket (3), we get the index by adding
                    //// the values in the bitmap segments 3rd, 2nd, and 1st.
                    this.rulesInsertionIndexBitmap = 0;
                }
                RulesBucketConstructionState.prototype.GetInsertionIndex = function (maskPosition) {
                    var index = 0;
                    var pos = 0;
                    var indexBitmap = this.rulesInsertionIndexBitmap;
                    while (pos <= maskPosition) {
                        index += (indexBitmap & Mask);
                        indexBitmap >>= MaskBitSize;
                        pos += MaskBitSize;
                    }
                    return index;
                };
                RulesBucketConstructionState.prototype.IncreaseInsertionIndex = function (maskPosition) {
                    var value = (this.rulesInsertionIndexBitmap >> maskPosition) & Mask;
                    value++;
                    TypeScript.Debug.assert((value & Mask) == value, "Adding more rules into the sub-bucket than allowed. Maximum allowed is 32 rules.");
                    var temp = this.rulesInsertionIndexBitmap & ~(Mask << maskPosition);
                    temp |= value << maskPosition;
                    this.rulesInsertionIndexBitmap = temp;
                };
                return RulesBucketConstructionState;
            })();
            Formatting.RulesBucketConstructionState = RulesBucketConstructionState;
            var RulesBucket = (function () {
                function RulesBucket() {
                    this.rules = [];
                }
                RulesBucket.prototype.Rules = function () {
                    return this.rules;
                };
                RulesBucket.prototype.AddRule = function (rule, specificTokens, constructionState, rulesBucketIndex) {
                    var position;
                    if (rule.Operation.Action == 0 /* Ignore */) {
                        position = specificTokens ? 0 /* IgnoreRulesSpecific */ : RulesPosition.IgnoreRulesAny;
                    }
                    else if (!rule.Operation.Context.IsAny()) {
                        position = specificTokens ? RulesPosition.ContextRulesSpecific : RulesPosition.ContextRulesAny;
                    }
                    else {
                        position = specificTokens ? RulesPosition.NoContextRulesSpecific : RulesPosition.NoContextRulesAny;
                    }
                    var state = constructionState[rulesBucketIndex];
                    if (state === undefined) {
                        state = constructionState[rulesBucketIndex] = new RulesBucketConstructionState();
                    }
                    var index = state.GetInsertionIndex(position);
                    this.rules.splice(index, 0, rule);
                    state.IncreaseInsertionIndex(position);
                };
                return RulesBucket;
            })();
            Formatting.RulesBucket = RulesBucket;
        })(Formatting = Services.Formatting || (Services.Formatting = {}));
    })(Services = TypeScript.Services || (TypeScript.Services = {}));
})(TypeScript || (TypeScript = {}));
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
/// <reference path="formatting.ts"/>
var TypeScript;
(function (TypeScript) {
    var Services;
    (function (Services) {
        var Formatting;
        (function (Formatting) {
            var RulesProvider = (function () {
                function RulesProvider(logger) {
                    this.logger = logger;
                    this.globalRules = new Formatting.Rules();
                }
                RulesProvider.prototype.getRuleName = function (rule) {
                    return this.globalRules.getRuleName(rule);
                };
                RulesProvider.prototype.getRuleByName = function (name) {
                    return this.globalRules[name];
                };
                RulesProvider.prototype.getRulesMap = function () {
                    return this.rulesMap;
                };
                RulesProvider.prototype.ensureUpToDate = function (options) {
                    if (this.options == null || !ts.compareDataObjects(this.options, options)) {
                        var activeRules = this.createActiveRules(options);
                        var rulesMap = Formatting.RulesMap.create(activeRules);
                        this.activeRules = activeRules;
                        this.rulesMap = rulesMap;
                        this.options = ts.clone(options);
                    }
                };
                RulesProvider.prototype.createActiveRules = function (options) {
                    var rules = this.globalRules.HighPriorityCommonRules.slice(0);
                    if (options.InsertSpaceAfterCommaDelimiter) {
                        rules.push(this.globalRules.SpaceAfterComma);
                    }
                    else {
                        rules.push(this.globalRules.NoSpaceAfterComma);
                    }
                    if (options.InsertSpaceAfterFunctionKeywordForAnonymousFunctions) {
                        rules.push(this.globalRules.SpaceAfterAnonymousFunctionKeyword);
                    }
                    else {
                        rules.push(this.globalRules.NoSpaceAfterAnonymousFunctionKeyword);
                    }
                    if (options.InsertSpaceAfterKeywordsInControlFlowStatements) {
                        rules.push(this.globalRules.SpaceAfterKeywordInControl);
                    }
                    else {
                        rules.push(this.globalRules.NoSpaceAfterKeywordInControl);
                    }
                    if (options.InsertSpaceAfterOpeningAndBeforeClosingNonemptyParenthesis) {
                        rules.push(this.globalRules.SpaceAfterOpenParen);
                        rules.push(this.globalRules.SpaceBeforeCloseParen);
                        rules.push(this.globalRules.NoSpaceBetweenParens);
                    }
                    else {
                        rules.push(this.globalRules.NoSpaceAfterOpenParen);
                        rules.push(this.globalRules.NoSpaceBeforeCloseParen);
                        rules.push(this.globalRules.NoSpaceBetweenParens);
                    }
                    if (options.InsertSpaceAfterSemicolonInForStatements) {
                        rules.push(this.globalRules.SpaceAfterSemicolonInFor);
                    }
                    else {
                        rules.push(this.globalRules.NoSpaceAfterSemicolonInFor);
                    }
                    if (options.InsertSpaceBeforeAndAfterBinaryOperators) {
                        rules.push(this.globalRules.SpaceBeforeBinaryOperator);
                        rules.push(this.globalRules.SpaceAfterBinaryOperator);
                    }
                    else {
                        rules.push(this.globalRules.NoSpaceBeforeBinaryOperator);
                        rules.push(this.globalRules.NoSpaceAfterBinaryOperator);
                    }
                    if (options.PlaceOpenBraceOnNewLineForControlBlocks) {
                        rules.push(this.globalRules.NewLineBeforeOpenBraceInControl);
                    }
                    if (options.PlaceOpenBraceOnNewLineForFunctions) {
                        rules.push(this.globalRules.NewLineBeforeOpenBraceInFunction);
                        rules.push(this.globalRules.NewLineBeforeOpenBraceInTypeScriptDeclWithBlock);
                    }
                    rules = rules.concat(this.globalRules.LowPriorityCommonRules);
                    return rules;
                };
                return RulesProvider;
            })();
            Formatting.RulesProvider = RulesProvider;
        })(Formatting = Services.Formatting || (Services.Formatting = {}));
    })(Services = TypeScript.Services || (TypeScript.Services = {}));
})(TypeScript || (TypeScript = {}));
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
///<reference path='formatting.ts' />
var TypeScript;
(function (TypeScript) {
    var Services;
    (function (Services) {
        var Formatting;
        (function (Formatting) {
            var TextEditInfo = (function () {
                function TextEditInfo(position, length, replaceWith) {
                    this.position = position;
                    this.length = length;
                    this.replaceWith = replaceWith;
                }
                TextEditInfo.prototype.toString = function () {
                    return "[ position: " + this.position + ", length: " + this.length + ", replaceWith: '" + this.replaceWith + "' ]";
                };
                return TextEditInfo;
            })();
            Formatting.TextEditInfo = TextEditInfo;
        })(Formatting = Services.Formatting || (Services.Formatting = {}));
    })(Services = TypeScript.Services || (TypeScript.Services = {}));
})(TypeScript || (TypeScript = {}));
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
///<reference path='formatting.ts' />
var TypeScript;
(function (TypeScript) {
    var Services;
    (function (Services) {
        var Formatting;
        (function (Formatting) {
            var Shared;
            (function (Shared) {
                var TokenRangeAccess = (function () {
                    function TokenRangeAccess(from, to, except) {
                        this.tokens = [];
                        for (var token = from; token <= to; token++) {
                            if (except.indexOf(token) < 0) {
                                this.tokens.push(token);
                            }
                        }
                    }
                    TokenRangeAccess.prototype.GetTokens = function () {
                        return this.tokens;
                    };
                    TokenRangeAccess.prototype.Contains = function (token) {
                        return this.tokens.indexOf(token) >= 0;
                    };
                    TokenRangeAccess.prototype.toString = function () {
                        return "[tokenRangeStart=" + TypeScript.SyntaxKind[this.tokens[0]] + "," + "tokenRangeEnd=" + TypeScript.SyntaxKind[this.tokens[this.tokens.length - 1]] + "]";
                    };
                    return TokenRangeAccess;
                })();
                Shared.TokenRangeAccess = TokenRangeAccess;
                var TokenValuesAccess = (function () {
                    function TokenValuesAccess(tks) {
                        this.tokens = tks && tks.length ? tks : [];
                    }
                    TokenValuesAccess.prototype.GetTokens = function () {
                        return this.tokens;
                    };
                    TokenValuesAccess.prototype.Contains = function (token) {
                        return this.tokens.indexOf(token) >= 0;
                    };
                    return TokenValuesAccess;
                })();
                Shared.TokenValuesAccess = TokenValuesAccess;
                var TokenSingleValueAccess = (function () {
                    function TokenSingleValueAccess(token) {
                        this.token = token;
                    }
                    TokenSingleValueAccess.prototype.GetTokens = function () {
                        return [this.token];
                    };
                    TokenSingleValueAccess.prototype.Contains = function (tokenValue) {
                        return tokenValue == this.token;
                    };
                    TokenSingleValueAccess.prototype.toString = function () {
                        return "[singleTokenKind=" + TypeScript.SyntaxKind[this.token] + "]";
                    };
                    return TokenSingleValueAccess;
                })();
                Shared.TokenSingleValueAccess = TokenSingleValueAccess;
                var TokenAllAccess = (function () {
                    function TokenAllAccess() {
                    }
                    TokenAllAccess.prototype.GetTokens = function () {
                        var result = [];
                        for (var token = TypeScript.SyntaxKind.FirstToken; token <= TypeScript.SyntaxKind.LastToken; token++) {
                            result.push(token);
                        }
                        return result;
                    };
                    TokenAllAccess.prototype.Contains = function (tokenValue) {
                        return true;
                    };
                    TokenAllAccess.prototype.toString = function () {
                        return "[allTokens]";
                    };
                    return TokenAllAccess;
                })();
                Shared.TokenAllAccess = TokenAllAccess;
                var TokenRange = (function () {
                    function TokenRange(tokenAccess) {
                        this.tokenAccess = tokenAccess;
                    }
                    TokenRange.FromToken = function (token) {
                        return new TokenRange(new TokenSingleValueAccess(token));
                    };
                    TokenRange.FromTokens = function (tokens) {
                        return new TokenRange(new TokenValuesAccess(tokens));
                    };
                    TokenRange.FromRange = function (f, to, except) {
                        if (except === void 0) { except = []; }
                        return new TokenRange(new TokenRangeAccess(f, to, except));
                    };
                    TokenRange.AllTokens = function () {
                        return new TokenRange(new TokenAllAccess());
                    };
                    TokenRange.prototype.GetTokens = function () {
                        return this.tokenAccess.GetTokens();
                    };
                    TokenRange.prototype.Contains = function (token) {
                        return this.tokenAccess.Contains(token);
                    };
                    TokenRange.prototype.toString = function () {
                        return this.tokenAccess.toString();
                    };
                    TokenRange.Any = TokenRange.AllTokens();
                    TokenRange.AnyIncludingMultilineComments = TokenRange.FromTokens(TokenRange.Any.GetTokens().concat([6 /* MultiLineCommentTrivia */]));
                    TokenRange.Keywords = TokenRange.FromRange(TypeScript.SyntaxKind.FirstKeyword, TypeScript.SyntaxKind.LastKeyword);
                    TokenRange.Operators = TokenRange.FromRange(78 /* SemicolonToken */, 119 /* SlashEqualsToken */);
                    TokenRange.BinaryOperators = TokenRange.FromRange(80 /* LessThanToken */, 119 /* SlashEqualsToken */);
                    TokenRange.BinaryKeywordOperators = TokenRange.FromTokens([29 /* InKeyword */, 30 /* InstanceOfKeyword */]);
                    TokenRange.ReservedKeywords = TokenRange.FromRange(TypeScript.SyntaxKind.FirstFutureReservedStrictKeyword, TypeScript.SyntaxKind.LastFutureReservedStrictKeyword);
                    TokenRange.UnaryPrefixOperators = TokenRange.FromTokens([93 /* PlusPlusToken */, 94 /* MinusMinusToken */, 102 /* TildeToken */, 101 /* ExclamationToken */]);
                    TokenRange.UnaryPrefixExpressions = TokenRange.FromTokens([13 /* NumericLiteral */, 11 /* IdentifierName */, 72 /* OpenParenToken */, 74 /* OpenBracketToken */, 70 /* OpenBraceToken */, 35 /* ThisKeyword */, 31 /* NewKeyword */]);
                    TokenRange.UnaryPreincrementExpressions = TokenRange.FromTokens([11 /* IdentifierName */, 72 /* OpenParenToken */, 35 /* ThisKeyword */, 31 /* NewKeyword */]);
                    TokenRange.UnaryPostincrementExpressions = TokenRange.FromTokens([11 /* IdentifierName */, 73 /* CloseParenToken */, 75 /* CloseBracketToken */, 31 /* NewKeyword */]);
                    TokenRange.UnaryPredecrementExpressions = TokenRange.FromTokens([11 /* IdentifierName */, 72 /* OpenParenToken */, 35 /* ThisKeyword */, 31 /* NewKeyword */]);
                    TokenRange.UnaryPostdecrementExpressions = TokenRange.FromTokens([11 /* IdentifierName */, 73 /* CloseParenToken */, 75 /* CloseBracketToken */, 31 /* NewKeyword */]);
                    TokenRange.Comments = TokenRange.FromTokens([7 /* SingleLineCommentTrivia */, 6 /* MultiLineCommentTrivia */]);
                    TokenRange.TypeNames = TokenRange.FromTokens([11 /* IdentifierName */, 67 /* NumberKeyword */, 69 /* StringKeyword */, 61 /* BooleanKeyword */, 41 /* VoidKeyword */, 60 /* AnyKeyword */]);
                    return TokenRange;
                })();
                Shared.TokenRange = TokenRange;
            })(Shared = Formatting.Shared || (Formatting.Shared = {}));
        })(Formatting = Services.Formatting || (Services.Formatting = {}));
    })(Services = TypeScript.Services || (TypeScript.Services = {}));
})(TypeScript || (TypeScript = {}));
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
///<reference path='formatting.ts' />
var TypeScript;
(function (TypeScript) {
    var Services;
    (function (Services) {
        var Formatting;
        (function (Formatting) {
            var TokenSpan = (function (_super) {
                __extends(TokenSpan, _super);
                function TokenSpan(kind, start, length) {
                    _super.call(this, start, length);
                    this.kind = kind;
                }
                return TokenSpan;
            })(TypeScript.TextSpan);
            Formatting.TokenSpan = TokenSpan;
        })(Formatting = Services.Formatting || (Services.Formatting = {}));
    })(Services = TypeScript.Services || (TypeScript.Services = {}));
})(TypeScript || (TypeScript = {}));
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
///<reference path='formatting.ts' />
var TypeScript;
(function (TypeScript) {
    var Services;
    (function (Services) {
        var Formatting;
        (function (Formatting) {
            var IndentationNodeContext = (function () {
                function IndentationNodeContext(parent, node, fullStart, indentationAmount, childIndentationAmountDelta) {
                    this.update(parent, node, fullStart, indentationAmount, childIndentationAmountDelta);
                }
                IndentationNodeContext.prototype.parent = function () {
                    return this._parent;
                };
                IndentationNodeContext.prototype.node = function () {
                    return this._node;
                };
                IndentationNodeContext.prototype.fullStart = function () {
                    return this._fullStart;
                };
                IndentationNodeContext.prototype.fullWidth = function () {
                    return TypeScript.fullWidth(this._node);
                };
                IndentationNodeContext.prototype.start = function () {
                    return this._fullStart + TypeScript.leadingTriviaWidth(this._node);
                };
                IndentationNodeContext.prototype.end = function () {
                    return this._fullStart + TypeScript.leadingTriviaWidth(this._node) + TypeScript.width(this._node);
                };
                IndentationNodeContext.prototype.indentationAmount = function () {
                    return this._indentationAmount;
                };
                IndentationNodeContext.prototype.childIndentationAmountDelta = function () {
                    return this._childIndentationAmountDelta;
                };
                IndentationNodeContext.prototype.depth = function () {
                    return this._depth;
                };
                IndentationNodeContext.prototype.kind = function () {
                    return this._node.kind();
                };
                IndentationNodeContext.prototype.hasSkippedOrMissingTokenChild = function () {
                    if (this._hasSkippedOrMissingTokenChild === null) {
                        this._hasSkippedOrMissingTokenChild = TypeScript.Syntax.nodeHasSkippedOrMissingTokens(this._node);
                    }
                    return this._hasSkippedOrMissingTokenChild;
                };
                IndentationNodeContext.prototype.clone = function (pool) {
                    var parent = null;
                    if (this._parent) {
                        parent = this._parent.clone(pool);
                    }
                    return pool.getNode(parent, this._node, this._fullStart, this._indentationAmount, this._childIndentationAmountDelta);
                };
                IndentationNodeContext.prototype.update = function (parent, node, fullStart, indentationAmount, childIndentationAmountDelta) {
                    this._parent = parent;
                    this._node = node;
                    this._fullStart = fullStart;
                    this._indentationAmount = indentationAmount;
                    this._childIndentationAmountDelta = childIndentationAmountDelta;
                    this._hasSkippedOrMissingTokenChild = null;
                    if (parent) {
                        this._depth = parent.depth() + 1;
                    }
                    else {
                        this._depth = 0;
                    }
                };
                return IndentationNodeContext;
            })();
            Formatting.IndentationNodeContext = IndentationNodeContext;
        })(Formatting = Services.Formatting || (Services.Formatting = {}));
    })(Services = TypeScript.Services || (TypeScript.Services = {}));
})(TypeScript || (TypeScript = {}));
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
///<reference path='formatting.ts' />
var TypeScript;
(function (TypeScript) {
    var Services;
    (function (Services) {
        var Formatting;
        (function (Formatting) {
            var IndentationNodeContextPool = (function () {
                function IndentationNodeContextPool() {
                    this.nodes = [];
                }
                IndentationNodeContextPool.prototype.getNode = function (parent, node, fullStart, indentationLevel, childIndentationLevelDelta) {
                    if (this.nodes.length > 0) {
                        var cachedNode = this.nodes.pop();
                        cachedNode.update(parent, node, fullStart, indentationLevel, childIndentationLevelDelta);
                        return cachedNode;
                    }
                    return new Formatting.IndentationNodeContext(parent, node, fullStart, indentationLevel, childIndentationLevelDelta);
                };
                IndentationNodeContextPool.prototype.releaseNode = function (node, recursive) {
                    if (recursive === void 0) { recursive = false; }
                    this.nodes.push(node);
                    if (recursive) {
                        var parent = node.parent();
                        if (parent) {
                            this.releaseNode(parent, recursive);
                        }
                    }
                };
                return IndentationNodeContextPool;
            })();
            Formatting.IndentationNodeContextPool = IndentationNodeContextPool;
        })(Formatting = Services.Formatting || (Services.Formatting = {}));
    })(Services = TypeScript.Services || (TypeScript.Services = {}));
})(TypeScript || (TypeScript = {}));
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
///<reference path='formatting.ts' />
var TypeScript;
(function (TypeScript) {
    var Services;
    (function (Services) {
        var Formatting;
        (function (Formatting) {
            var IndentationTrackingWalker = (function (_super) {
                __extends(IndentationTrackingWalker, _super);
                function IndentationTrackingWalker(textSpan, sourceUnit, snapshot, indentFirstToken, options) {
                    _super.call(this);
                    this.options = options;
                    this._position = 0;
                    this._parent = null;
                    // Create a pool object to manage context nodes while walking the tree
                    this._indentationNodeContextPool = new Formatting.IndentationNodeContextPool();
                    this._textSpan = textSpan;
                    this._text = sourceUnit.syntaxTree.text;
                    this._snapshot = snapshot;
                    this._parent = this._indentationNodeContextPool.getNode(null, sourceUnit, 0, 0, 0);
                    // Is the first token in the span at the start of a new line.
                    this._lastTriviaWasNewLine = indentFirstToken;
                }
                IndentationTrackingWalker.prototype.position = function () {
                    return this._position;
                };
                IndentationTrackingWalker.prototype.parent = function () {
                    return this._parent;
                };
                IndentationTrackingWalker.prototype.textSpan = function () {
                    return this._textSpan;
                };
                IndentationTrackingWalker.prototype.snapshot = function () {
                    return this._snapshot;
                };
                IndentationTrackingWalker.prototype.indentationNodeContextPool = function () {
                    return this._indentationNodeContextPool;
                };
                IndentationTrackingWalker.prototype.forceIndentNextToken = function (tokenStart) {
                    this._lastTriviaWasNewLine = true;
                    this.forceRecomputeIndentationOfParent(tokenStart, true);
                };
                IndentationTrackingWalker.prototype.forceSkipIndentingNextToken = function (tokenStart) {
                    this._lastTriviaWasNewLine = false;
                    this.forceRecomputeIndentationOfParent(tokenStart, false);
                };
                IndentationTrackingWalker.prototype.indentToken = function (token, indentationAmount, commentIndentationAmount) {
                    throw TypeScript.Errors.abstract();
                };
                IndentationTrackingWalker.prototype.visitTokenInSpan = function (token) {
                    if (this._lastTriviaWasNewLine) {
                        // Compute the indentation level at the current token
                        var indentationAmount = this.getTokenIndentationAmount(token);
                        var commentIndentationAmount = this.getCommentIndentationAmount(token);
                        // Process the token
                        this.indentToken(token, indentationAmount, commentIndentationAmount);
                    }
                };
                IndentationTrackingWalker.prototype.visitToken = function (token) {
                    var tokenSpan = new TypeScript.TextSpan(this._position, token.fullWidth());
                    if (tokenSpan.intersectsWithTextSpan(this._textSpan)) {
                        this.visitTokenInSpan(token);
                        // Only track new lines on tokens within the range. Make sure to check that the last trivia is a newline, and not just one of the trivia
                        var trivia = token.trailingTrivia();
                        this._lastTriviaWasNewLine = trivia.hasNewLine() && trivia.syntaxTriviaAt(trivia.count() - 1).kind() == 5 /* NewLineTrivia */;
                    }
                    // Update the position
                    this._position += token.fullWidth();
                };
                IndentationTrackingWalker.prototype.visitNode = function (node) {
                    var nodeSpan = new TypeScript.TextSpan(this._position, TypeScript.fullWidth(node));
                    if (nodeSpan.intersectsWithTextSpan(this._textSpan)) {
                        // Update indentation level
                        var indentation = this.getNodeIndentation(node);
                        // Update the parent
                        var currentParent = this._parent;
                        this._parent = this._indentationNodeContextPool.getNode(currentParent, node, this._position, indentation.indentationAmount, indentation.indentationAmountDelta);
                        // Visit node
                        TypeScript.visitNodeOrToken(this, node);
                        // Reset state
                        this._indentationNodeContextPool.releaseNode(this._parent);
                        this._parent = currentParent;
                    }
                    else {
                        // We're skipping the node, so update our position accordingly.
                        this._position += TypeScript.fullWidth(node);
                    }
                };
                IndentationTrackingWalker.prototype.getTokenIndentationAmount = function (token) {
                    // If this is the first token of a node, it should follow the node indentation and not the child indentation; 
                    // (e.g.class in a class declaration or module in module declariotion).
                    // Open and close braces should follow the indentation of thier parent as well(e.g.
                    // class {
                    // }
                    // Also in a do-while statement, the while should be indented like the parent.
                    if (TypeScript.firstToken(this._parent.node()) === token || token.kind() === 70 /* OpenBraceToken */ || token.kind() === 71 /* CloseBraceToken */ || token.kind() === 74 /* OpenBracketToken */ || token.kind() === 75 /* CloseBracketToken */ || (token.kind() === 42 /* WhileKeyword */ && this._parent.node().kind() == 162 /* DoStatement */)) {
                        return this._parent.indentationAmount();
                    }
                    return (this._parent.indentationAmount() + this._parent.childIndentationAmountDelta());
                };
                IndentationTrackingWalker.prototype.getCommentIndentationAmount = function (token) {
                    // If this is token terminating an indentation scope, leading comments should be indented to follow the children 
                    // indentation level and not the node
                    if (token.kind() === 71 /* CloseBraceToken */ || token.kind() === 75 /* CloseBracketToken */) {
                        return (this._parent.indentationAmount() + this._parent.childIndentationAmountDelta());
                    }
                    return this._parent.indentationAmount();
                };
                IndentationTrackingWalker.prototype.getNodeIndentation = function (node, newLineInsertedByFormatting) {
                    var parent = this._parent;
                    // We need to get the parent's indentation, which could be one of 2 things. If first token of the parent is in the span, use the parent's computed indentation.
                    // If the parent was outside the span, use the actual indentation of the parent.
                    var parentIndentationAmount;
                    if (this._textSpan.containsPosition(parent.start())) {
                        parentIndentationAmount = parent.indentationAmount();
                    }
                    else {
                        if (parent.kind() === 147 /* Block */ && !this.shouldIndentBlockInParent(this._parent.parent())) {
                            // Blocks preserve the indentation of their containing node (unless they're a 
                            // standalone block in a list).  i.e. if you have:
                            //
                            //  function foo(
                            //      a: number) {
                            //
                            // Then we expect the indentation of the block to be tied to the function, not to
                            // the line that the block is defined on.  If we were to do the latter, then the 
                            // indentation would be here:
                            //
                            //  function foo(
                            //      a: number) {
                            //          |
                            //
                            // Instead of:
                            //
                            //  function foo(
                            //      a: number) {
                            //      |
                            parent = this._parent.parent();
                        }
                        var line = this._snapshot.getLineFromPosition(parent.start()).getText();
                        var firstNonWhiteSpacePosition = TypeScript.Indentation.firstNonWhitespacePosition(line);
                        parentIndentationAmount = TypeScript.Indentation.columnForPositionInString(line, firstNonWhiteSpacePosition, this.options);
                    }
                    var parentIndentationAmountDelta = parent.childIndentationAmountDelta();
                    // The indentation level of the node
                    var indentationAmount;
                    // The delta it adds to its children. 
                    var indentationAmountDelta;
                    var parentNode = parent.node();
                    switch (node.kind()) {
                        default:
                            // General case
                            // This node should follow the child indentation set by its parent
                            // This node does not introduce any new indentation scope, indent any decendants of this node (tokens or child nodes)
                            // using the same indentation level
                            indentationAmount = (parentIndentationAmount + parentIndentationAmountDelta);
                            indentationAmountDelta = 0;
                            break;
                        case 132 /* ClassDeclaration */:
                        case 131 /* ModuleDeclaration */:
                        case 122 /* ObjectType */:
                        case 133 /* EnumDeclaration */:
                        case 152 /* SwitchStatement */:
                        case 216 /* ObjectLiteralExpression */:
                        case 138 /* ConstructorDeclaration */:
                        case 130 /* FunctionDeclaration */:
                        case 223 /* FunctionExpression */:
                        case 136 /* MemberFunctionDeclaration */:
                        case 140 /* GetAccessor */:
                        case 141 /* SetAccessor */:
                        case 139 /* IndexMemberDeclaration */:
                        case 237 /* CatchClause */:
                        case 215 /* ArrayLiteralExpression */:
                        case 124 /* ArrayType */:
                        case 222 /* ElementAccessExpression */:
                        case 145 /* IndexSignature */:
                        case 155 /* ForStatement */:
                        case 156 /* ForInStatement */:
                        case 159 /* WhileStatement */:
                        case 162 /* DoStatement */:
                        case 164 /* WithStatement */:
                        case 234 /* CaseSwitchClause */:
                        case 235 /* DefaultSwitchClause */:
                        case 151 /* ReturnStatement */:
                        case 158 /* ThrowStatement */:
                        case 220 /* SimpleArrowFunctionExpression */:
                        case 219 /* ParenthesizedArrowFunctionExpression */:
                        case 225 /* VariableDeclaration */:
                        case 135 /* ExportAssignment */:
                        case 214 /* InvocationExpression */:
                        case 217 /* ObjectCreationExpression */:
                        case 143 /* CallSignature */:
                        case 144 /* ConstructSignature */:
                            // These nodes should follow the child indentation set by its parent;
                            // they introduce a new indenation scope; children should be indented at one level deeper
                            indentationAmount = (parentIndentationAmount + parentIndentationAmountDelta);
                            indentationAmountDelta = this.options.indentSpaces;
                            break;
                        case 148 /* IfStatement */:
                            if (parent.kind() === 236 /* ElseClause */ && !TypeScript.SyntaxUtilities.isLastTokenOnLine(parentNode.elseKeyword, this._text)) {
                                // This is an else if statement with the if on the same line as the else, do not indent the if statmement.
                                // Note: Children indentation has already been set by the parent if statement, so no need to increment
                                indentationAmount = parentIndentationAmount;
                            }
                            else {
                                // Otherwise introduce a new indenation scope; children should be indented at one level deeper
                                indentationAmount = (parentIndentationAmount + parentIndentationAmountDelta);
                            }
                            indentationAmountDelta = this.options.indentSpaces;
                            break;
                        case 236 /* ElseClause */:
                            // Else should always follow its parent if statement indentation.
                            // Note: Children indentation has already been set by the parent if statement, so no need to increment
                            indentationAmount = parentIndentationAmount;
                            indentationAmountDelta = this.options.indentSpaces;
                            break;
                        case 147 /* Block */:
                            // Check if the block is a member in a list of statements (if the parent is a source unit, module, or block, or switch clause)
                            if (this.shouldIndentBlockInParent(parent)) {
                                indentationAmount = parentIndentationAmount + parentIndentationAmountDelta;
                            }
                            else {
                                indentationAmount = parentIndentationAmount;
                            }
                            indentationAmountDelta = this.options.indentSpaces;
                            break;
                    }
                    // If the parent happens to start on the same line as this node, then override the current node indenation with that 
                    // of the parent. This avoid having to add an extra level of indentation for the children. e.g.:
                    //	return {
                    //	    a:1
                    //	};
                    // instead of:
                    //	return {
                    //	        a:1
                    //	    };
                    // We also need to pass the delta (if it is nonzero) to the children, so that subsequent lines get indented. Essentially, if any node starting on the given line
                    // has a nonzero delta , the resulting delta should be inherited from this node. This is to indent cases like the following:
                    //  return a
                    //      || b;
                    // Lastly, it is possible the node indentation needs to be recomputed because the formatter inserted a newline before its first token.
                    // If this is the case, we know the node no longer starts on the same line as its parent (or at least we shouldn't treat it as such).
                    if (parentNode) {
                        if (!newLineInsertedByFormatting) {
                            var parentStartLine = this._snapshot.getLineNumberFromPosition(parent.start());
                            var currentNodeStartLine = this._snapshot.getLineNumberFromPosition(this._position + TypeScript.leadingTriviaWidth(node));
                            if (parentStartLine === currentNodeStartLine || newLineInsertedByFormatting === false) {
                                indentationAmount = parentIndentationAmount;
                                indentationAmountDelta = Math.min(this.options.indentSpaces, parentIndentationAmountDelta + indentationAmountDelta);
                            }
                        }
                    }
                    return {
                        indentationAmount: indentationAmount,
                        indentationAmountDelta: indentationAmountDelta
                    };
                };
                IndentationTrackingWalker.prototype.shouldIndentBlockInParent = function (parent) {
                    switch (parent.kind()) {
                        case 120 /* SourceUnit */:
                        case 131 /* ModuleDeclaration */:
                        case 147 /* Block */:
                        case 234 /* CaseSwitchClause */:
                        case 235 /* DefaultSwitchClause */:
                            return true;
                        default:
                            return false;
                    }
                };
                IndentationTrackingWalker.prototype.forceRecomputeIndentationOfParent = function (tokenStart, newLineAdded /*as opposed to removed*/) {
                    var parent = this._parent;
                    if (parent.fullStart() === tokenStart) {
                        // Temporarily pop the parent before recomputing
                        this._parent = parent.parent();
                        var indentation = this.getNodeIndentation(parent.node(), newLineAdded);
                        parent.update(parent.parent(), parent.node(), parent.fullStart(), indentation.indentationAmount, indentation.indentationAmountDelta);
                        this._parent = parent;
                    }
                };
                return IndentationTrackingWalker;
            })(TypeScript.SyntaxWalker);
            Formatting.IndentationTrackingWalker = IndentationTrackingWalker;
        })(Formatting = Services.Formatting || (Services.Formatting = {}));
    })(Services = TypeScript.Services || (TypeScript.Services = {}));
})(TypeScript || (TypeScript = {}));
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
///<reference path='formatting.ts' />
var TypeScript;
(function (TypeScript) {
    var Services;
    (function (Services) {
        var Formatting;
        (function (Formatting) {
            var MultipleTokenIndenter = (function (_super) {
                __extends(MultipleTokenIndenter, _super);
                function MultipleTokenIndenter(textSpan, sourceUnit, snapshot, indentFirstToken, options) {
                    _super.call(this, textSpan, sourceUnit, snapshot, indentFirstToken, options);
                    this._edits = [];
                }
                MultipleTokenIndenter.prototype.indentToken = function (token, indentationAmount, commentIndentationAmount) {
                    // Ignore generated tokens
                    if (token.fullWidth() === 0) {
                        return;
                    }
                    // If we have any skipped tokens as children, do not process this node for indentation or formatting
                    if (this.parent().hasSkippedOrMissingTokenChild()) {
                        return;
                    }
                    // Be strict, and only consider nodes that fall inside the span. This avoids indenting a multiline string
                    // on enter at the end of, as the whole token was not included in the span
                    var tokenSpan = new TypeScript.TextSpan(this.position() + token.leadingTriviaWidth(), TypeScript.width(token));
                    if (!this.textSpan().containsTextSpan(tokenSpan)) {
                        return;
                    }
                    // Compute an indentation string for this token
                    var indentationString = TypeScript.Indentation.indentationString(indentationAmount, this.options);
                    var commentIndentationString = TypeScript.Indentation.indentationString(commentIndentationAmount, this.options);
                    // Record any needed indentation edits
                    this.recordIndentationEditsForToken(token, indentationString, commentIndentationString);
                };
                MultipleTokenIndenter.prototype.edits = function () {
                    return this._edits;
                };
                MultipleTokenIndenter.prototype.recordEdit = function (position, length, replaceWith) {
                    this._edits.push(new Formatting.TextEditInfo(position, length, replaceWith));
                };
                MultipleTokenIndenter.prototype.recordIndentationEditsForToken = function (token, indentationString, commentIndentationString) {
                    var position = this.position();
                    var indentNextTokenOrTrivia = true;
                    var leadingWhiteSpace = ""; // We need to track the whitespace before a multiline comment
                    // Process any leading trivia if any
                    var triviaList = token.leadingTrivia();
                    if (triviaList) {
                        for (var i = 0, length = triviaList.count(); i < length; i++, position += trivia.fullWidth()) {
                            var trivia = triviaList.syntaxTriviaAt(i);
                            // Skip this trivia if it is not in the span
                            if (!this.textSpan().containsTextSpan(new TypeScript.TextSpan(position, trivia.fullWidth()))) {
                                continue;
                            }
                            switch (trivia.kind()) {
                                case 6 /* MultiLineCommentTrivia */:
                                    // We will only indent the first line of the multiline comment if we were planning to indent the next trivia. However,
                                    // subsequent lines will always be indented
                                    this.recordIndentationEditsForMultiLineComment(trivia, position, commentIndentationString, leadingWhiteSpace, !indentNextTokenOrTrivia);
                                    indentNextTokenOrTrivia = false;
                                    leadingWhiteSpace = "";
                                    break;
                                case 7 /* SingleLineCommentTrivia */:
                                case 8 /* SkippedTokenTrivia */:
                                    if (indentNextTokenOrTrivia) {
                                        this.recordIndentationEditsForSingleLineOrSkippedText(trivia, position, commentIndentationString);
                                        indentNextTokenOrTrivia = false;
                                    }
                                    break;
                                case 4 /* WhitespaceTrivia */:
                                    // If the next trivia is a comment, use the comment indentation level instead of the regular indentation level
                                    // If the next trivia is a newline, this whole line is just whitespace, so don't do anything (trimming will take care of it)
                                    var nextTrivia = length > i + 1 && triviaList.syntaxTriviaAt(i + 1);
                                    var whiteSpaceIndentationString = nextTrivia && nextTrivia.isComment() ? commentIndentationString : indentationString;
                                    if (indentNextTokenOrTrivia) {
                                        if (!(nextTrivia && nextTrivia.isNewLine())) {
                                            this.recordIndentationEditsForWhitespace(trivia, position, whiteSpaceIndentationString);
                                        }
                                        indentNextTokenOrTrivia = false;
                                    }
                                    leadingWhiteSpace += trivia.fullText();
                                    break;
                                case 5 /* NewLineTrivia */:
                                    // We hit a newline processing the trivia.  We need to add the indentation to the 
                                    // next line as well.  Note: don't bother indenting the newline itself.  This will 
                                    // just insert ugly whitespace that most users probably will not want.
                                    indentNextTokenOrTrivia = true;
                                    leadingWhiteSpace = "";
                                    break;
                                default:
                                    throw TypeScript.Errors.invalidOperation();
                            }
                        }
                    }
                    if (token.kind() !== 10 /* EndOfFileToken */ && indentNextTokenOrTrivia) {
                        // If the last trivia item was a new line, or no trivia items were encounterd record the 
                        // indentation edit at the token position
                        if (indentationString.length > 0) {
                            this.recordEdit(position, 0, indentationString);
                        }
                    }
                };
                MultipleTokenIndenter.prototype.recordIndentationEditsForSingleLineOrSkippedText = function (trivia, fullStart, indentationString) {
                    // Record the edit
                    if (indentationString.length > 0) {
                        this.recordEdit(fullStart, 0, indentationString);
                    }
                };
                MultipleTokenIndenter.prototype.recordIndentationEditsForWhitespace = function (trivia, fullStart, indentationString) {
                    var text = trivia.fullText();
                    // Check if the current indentation matches the desired indentation or not
                    if (indentationString === text) {
                        return;
                    }
                    // Record the edit 
                    this.recordEdit(fullStart, text.length, indentationString);
                };
                MultipleTokenIndenter.prototype.recordIndentationEditsForMultiLineComment = function (trivia, fullStart, indentationString, leadingWhiteSpace, firstLineAlreadyIndented) {
                    // If the multiline comment spans multiple lines, we need to add the right indent amount to
                    // each successive line segment as well.
                    var position = fullStart;
                    var segments = TypeScript.Syntax.splitMultiLineCommentTriviaIntoMultipleLines(trivia);
                    if (segments.length <= 1) {
                        if (!firstLineAlreadyIndented) {
                            // Process the one-line multiline comment just like a single line comment
                            this.recordIndentationEditsForSingleLineOrSkippedText(trivia, fullStart, indentationString);
                        }
                        return;
                    }
                    // Find number of columns in first segment
                    var whiteSpaceColumnsInFirstSegment = TypeScript.Indentation.columnForPositionInString(leadingWhiteSpace, leadingWhiteSpace.length, this.options);
                    var indentationColumns = TypeScript.Indentation.columnForPositionInString(indentationString, indentationString.length, this.options);
                    var startIndex = 0;
                    if (firstLineAlreadyIndented) {
                        startIndex = 1;
                        position += segments[0].length;
                    }
                    for (var i = startIndex; i < segments.length; i++) {
                        var segment = segments[i];
                        this.recordIndentationEditsForSegment(segment, position, indentationColumns, whiteSpaceColumnsInFirstSegment);
                        position += segment.length;
                    }
                };
                MultipleTokenIndenter.prototype.recordIndentationEditsForSegment = function (segment, fullStart, indentationColumns, whiteSpaceColumnsInFirstSegment) {
                    // Indent subsequent lines using a column delta of the actual indentation relative to the first line
                    var firstNonWhitespacePosition = TypeScript.Indentation.firstNonWhitespacePosition(segment);
                    var leadingWhiteSpaceColumns = TypeScript.Indentation.columnForPositionInString(segment, firstNonWhitespacePosition, this.options);
                    var deltaFromFirstSegment = leadingWhiteSpaceColumns - whiteSpaceColumnsInFirstSegment;
                    var finalColumns = indentationColumns + deltaFromFirstSegment;
                    if (finalColumns < 0) {
                        finalColumns = 0;
                    }
                    var indentationString = TypeScript.Indentation.indentationString(finalColumns, this.options);
                    if (firstNonWhitespacePosition < segment.length && TypeScript.CharacterInfo.isLineTerminator(segment.charCodeAt(firstNonWhitespacePosition))) {
                        // If this segment was just a newline, then don't bother indenting it.  That will just
                        // leave the user with an ugly indent in their output that they probably do not want.
                        return;
                    }
                    if (indentationString === segment.substring(0, firstNonWhitespacePosition)) {
                        return;
                    }
                    // Record the edit 
                    this.recordEdit(fullStart, firstNonWhitespacePosition, indentationString);
                };
                return MultipleTokenIndenter;
            })(Formatting.IndentationTrackingWalker);
            Formatting.MultipleTokenIndenter = MultipleTokenIndenter;
        })(Formatting = Services.Formatting || (Services.Formatting = {}));
    })(Services = TypeScript.Services || (TypeScript.Services = {}));
})(TypeScript || (TypeScript = {}));
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
///<reference path='formatting.ts' />
var TypeScript;
(function (TypeScript) {
    var Services;
    (function (Services) {
        var Formatting;
        (function (Formatting) {
            var Formatter = (function (_super) {
                __extends(Formatter, _super);
                function Formatter(textSpan, sourceUnit, indentFirstToken, options, snapshot, rulesProvider, formattingRequestKind) {
                    _super.call(this, textSpan, sourceUnit, snapshot, indentFirstToken, options);
                    this.previousTokenSpan = null;
                    this.previousTokenParent = null;
                    // TODO: implement it with skipped tokens in Fidelity
                    this.scriptHasErrors = false;
                    this.previousTokenParent = this.parent().clone(this.indentationNodeContextPool());
                    this.rulesProvider = rulesProvider;
                    this.formattingRequestKind = formattingRequestKind;
                    this.formattingContext = new Formatting.FormattingContext(this.snapshot(), this.formattingRequestKind);
                }
                Formatter.getEdits = function (textSpan, sourceUnit, options, indentFirstToken, snapshot, rulesProvider, formattingRequestKind) {
                    var walker = new Formatter(textSpan, sourceUnit, indentFirstToken, options, snapshot, rulesProvider, formattingRequestKind);
                    TypeScript.visitNodeOrToken(walker, sourceUnit);
                    return walker.edits();
                };
                Formatter.prototype.visitTokenInSpan = function (token) {
                    if (token.fullWidth() !== 0) {
                        var tokenSpan = new TypeScript.TextSpan(this.position() + token.leadingTriviaWidth(), TypeScript.width(token));
                        if (this.textSpan().containsTextSpan(tokenSpan)) {
                            this.processToken(token);
                        }
                    }
                    // Call the base class to process the token and indent it if needed
                    _super.prototype.visitTokenInSpan.call(this, token);
                };
                Formatter.prototype.processToken = function (token) {
                    var position = this.position();
                    // Extract any leading comments
                    if (token.leadingTriviaWidth() !== 0) {
                        this.processTrivia(token.leadingTrivia(), position);
                        position += token.leadingTriviaWidth();
                    }
                    // Push the token
                    var currentTokenSpan = new Formatting.TokenSpan(token.kind(), position, TypeScript.width(token));
                    if (!this.parent().hasSkippedOrMissingTokenChild()) {
                        if (this.previousTokenSpan) {
                            // Note that formatPair calls TrimWhitespaceInLineRange in between the 2 tokens
                            this.formatPair(this.previousTokenSpan, this.previousTokenParent, currentTokenSpan, this.parent());
                        }
                        else {
                            // We still want to trim whitespace even if it is the first trivia of the first token. Trim from the beginning of the span to the trivia
                            this.trimWhitespaceInLineRange(this.getLineNumber(this.textSpan()), this.getLineNumber(currentTokenSpan));
                        }
                    }
                    this.previousTokenSpan = currentTokenSpan;
                    if (this.previousTokenParent) {
                        // Make sure to clear the previous parent before assigning a new value to it
                        this.indentationNodeContextPool().releaseNode(this.previousTokenParent, true);
                    }
                    this.previousTokenParent = this.parent().clone(this.indentationNodeContextPool());
                    position += TypeScript.width(token);
                    // Extract any trailing comments
                    if (token.trailingTriviaWidth() !== 0) {
                        this.processTrivia(token.trailingTrivia(), position);
                    }
                };
                Formatter.prototype.processTrivia = function (triviaList, fullStart) {
                    var position = fullStart;
                    for (var i = 0, n = triviaList.count(); i < n; i++) {
                        var trivia = triviaList.syntaxTriviaAt(i);
                        // For a comment, format it like it is a token. For skipped text, eat it up as a token, but skip the formatting
                        if (trivia.isComment() || trivia.isSkippedToken()) {
                            var currentTokenSpan = new Formatting.TokenSpan(trivia.kind(), position, trivia.fullWidth());
                            if (this.textSpan().containsTextSpan(currentTokenSpan)) {
                                if (trivia.isComment() && this.previousTokenSpan) {
                                    // Note that formatPair calls TrimWhitespaceInLineRange in between the 2 tokens
                                    this.formatPair(this.previousTokenSpan, this.previousTokenParent, currentTokenSpan, this.parent());
                                }
                                else {
                                    // We still want to trim whitespace even if it is the first trivia of the first token. Trim from the beginning of the span to the trivia
                                    var startLine = this.getLineNumber(this.previousTokenSpan || this.textSpan());
                                    this.trimWhitespaceInLineRange(startLine, this.getLineNumber(currentTokenSpan));
                                }
                                this.previousTokenSpan = currentTokenSpan;
                                if (this.previousTokenParent) {
                                    // Make sure to clear the previous parent before assigning a new value to it
                                    this.indentationNodeContextPool().releaseNode(this.previousTokenParent, true);
                                }
                                this.previousTokenParent = this.parent().clone(this.indentationNodeContextPool());
                            }
                        }
                        position += trivia.fullWidth();
                    }
                };
                Formatter.prototype.findCommonParents = function (parent1, parent2) {
                    // TODO: disable debug assert message
                    var shallowParent;
                    var shallowParentDepth;
                    var deepParent;
                    var deepParentDepth;
                    if (parent1.depth() < parent2.depth()) {
                        shallowParent = parent1;
                        shallowParentDepth = parent1.depth();
                        deepParent = parent2;
                        deepParentDepth = parent2.depth();
                    }
                    else {
                        shallowParent = parent2;
                        shallowParentDepth = parent2.depth();
                        deepParent = parent1;
                        deepParentDepth = parent1.depth();
                    }
                    TypeScript.Debug.assert(shallowParentDepth >= 0, "Expected shallowParentDepth >= 0");
                    TypeScript.Debug.assert(deepParentDepth >= 0, "Expected deepParentDepth >= 0");
                    TypeScript.Debug.assert(deepParentDepth >= shallowParentDepth, "Expected deepParentDepth >= shallowParentDepth");
                    while (deepParentDepth > shallowParentDepth) {
                        deepParent = deepParent.parent();
                        deepParentDepth--;
                    }
                    TypeScript.Debug.assert(deepParentDepth === shallowParentDepth, "Expected deepParentDepth === shallowParentDepth");
                    while (deepParent.node() && shallowParent.node()) {
                        if (deepParent.node() === shallowParent.node()) {
                            return deepParent;
                        }
                        deepParent = deepParent.parent();
                        shallowParent = shallowParent.parent();
                    }
                    throw TypeScript.Errors.invalidOperation();
                };
                Formatter.prototype.formatPair = function (t1, t1Parent, t2, t2Parent) {
                    var token1Line = this.getLineNumber(t1);
                    var token2Line = this.getLineNumber(t2);
                    // Find common parent
                    var commonParent = this.findCommonParents(t1Parent, t2Parent);
                    // Update the context
                    this.formattingContext.updateContext(t1, t1Parent, t2, t2Parent, commonParent);
                    // Find rules matching the current context
                    var rule = this.rulesProvider.getRulesMap().GetRule(this.formattingContext);
                    if (rule != null) {
                        // Record edits from the rule
                        this.RecordRuleEdits(rule, t1, t2);
                        // Handle the case where the next line is moved to be the end of this line. 
                        // In this case we don't indent the next line in the next pass.
                        if ((rule.Operation.Action == 1 /* Space */ || rule.Operation.Action == 3 /* Delete */) && token1Line != token2Line) {
                            this.forceSkipIndentingNextToken(t2.start());
                        }
                        // Handle the case where token2 is moved to the new line. 
                        // In this case we indent token2 in the next pass but we set
                        // sameLineIndent flag to notify the indenter that the indentation is within the line.
                        if (rule.Operation.Action == 2 /* NewLine */ && token1Line == token2Line) {
                            this.forceIndentNextToken(t2.start());
                        }
                    }
                    // We need to trim trailing whitespace between the tokens if they were on different lines, and no rule was applied to put them on the same line
                    if (token1Line != token2Line && (!rule || (rule.Operation.Action != 3 /* Delete */ && rule.Flag != 1 /* CanDeleteNewLines */))) {
                        this.trimWhitespaceInLineRange(token1Line, token2Line, t1);
                    }
                };
                Formatter.prototype.getLineNumber = function (span) {
                    return this.snapshot().getLineNumberFromPosition(span.start());
                };
                Formatter.prototype.trimWhitespaceInLineRange = function (startLine, endLine, token) {
                    for (var lineNumber = startLine; lineNumber < endLine; ++lineNumber) {
                        var line = this.snapshot().getLineFromLineNumber(lineNumber);
                        this.trimWhitespace(line, token);
                    }
                };
                Formatter.prototype.trimWhitespace = function (line, token) {
                    // Don't remove the trailing spaces inside comments (this includes line comments and block comments)
                    if (token && (token.kind == 6 /* MultiLineCommentTrivia */ || token.kind == 7 /* SingleLineCommentTrivia */) && token.start() <= line.endPosition() && token.end() >= line.endPosition())
                        return;
                    var text = line.getText();
                    var index = 0;
                    for (index = text.length - 1; index >= 0; --index) {
                        if (!TypeScript.CharacterInfo.isWhitespace(text.charCodeAt(index))) {
                            break;
                        }
                    }
                    ++index;
                    if (index < text.length) {
                        this.recordEdit(line.startPosition() + index, line.length() - index, "");
                    }
                };
                Formatter.prototype.RecordRuleEdits = function (rule, t1, t2) {
                    if (rule.Operation.Action == 0 /* Ignore */) {
                        return;
                    }
                    var betweenSpan;
                    switch (rule.Operation.Action) {
                        case 3 /* Delete */:
                            {
                                betweenSpan = new TypeScript.TextSpan(t1.end(), t2.start() - t1.end());
                                if (betweenSpan.length() > 0) {
                                    this.recordEdit(betweenSpan.start(), betweenSpan.length(), "");
                                    return;
                                }
                            }
                            break;
                        case 2 /* NewLine */:
                            {
                                if (!(rule.Flag == 1 /* CanDeleteNewLines */ || this.getLineNumber(t1) == this.getLineNumber(t2))) {
                                    return;
                                }
                                betweenSpan = new TypeScript.TextSpan(t1.end(), t2.start() - t1.end());
                                var doEdit = false;
                                var betweenText = this.snapshot().getText(betweenSpan);
                                var lineFeedLoc = betweenText.indexOf(this.options.newLineCharacter);
                                if (lineFeedLoc < 0) {
                                    // no linefeeds, do the edit
                                    doEdit = true;
                                }
                                else {
                                    // We only require one line feed. If there is another one, do the edit
                                    lineFeedLoc = betweenText.indexOf(this.options.newLineCharacter, lineFeedLoc + 1);
                                    if (lineFeedLoc >= 0) {
                                        doEdit = true;
                                    }
                                }
                                if (doEdit) {
                                    this.recordEdit(betweenSpan.start(), betweenSpan.length(), this.options.newLineCharacter);
                                    return;
                                }
                            }
                            break;
                        case 1 /* Space */:
                            {
                                if (!(rule.Flag == 1 /* CanDeleteNewLines */ || this.getLineNumber(t1) == this.getLineNumber(t2))) {
                                    return;
                                }
                                betweenSpan = new TypeScript.TextSpan(t1.end(), t2.start() - t1.end());
                                if (betweenSpan.length() > 1 || this.snapshot().getText(betweenSpan) != " ") {
                                    this.recordEdit(betweenSpan.start(), betweenSpan.length(), " ");
                                    return;
                                }
                            }
                            break;
                    }
                };
                return Formatter;
            })(Formatting.MultipleTokenIndenter);
            Formatting.Formatter = Formatter;
        })(Formatting = Services.Formatting || (Services.Formatting = {}));
    })(Services = TypeScript.Services || (TypeScript.Services = {}));
})(TypeScript || (TypeScript = {}));
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
///<reference path='..\services.ts' />
var ts;
(function (ts) {
    var formatting;
    (function (formatting) {
        var SmartIndenter;
        (function (SmartIndenter) {
            function getIndentation(position, sourceFile, options) {
                if (position > sourceFile.text.length) {
                    return 0; // past EOF
                }
                var precedingToken = findPrecedingToken(position, sourceFile);
                if (!precedingToken) {
                    return 0;
                }
                // no indentation in string \regex literals
                if ((precedingToken.kind === 7 /* StringLiteral */ || precedingToken.kind === 8 /* RegularExpressionLiteral */) && precedingToken.getStart(sourceFile) <= position && precedingToken.end > position) {
                    return 0;
                }
                var lineAtPosition = sourceFile.getLineAndCharacterFromPosition(position).line;
                if (precedingToken.kind === 18 /* CommaToken */ && precedingToken.parent.kind !== 145 /* BinaryExpression */) {
                    // previous token is comma that separates items in list - find the previous item and try to derive indentation from it
                    var actualIndentation = getActualIndentationForListItemBeforeComma(precedingToken, sourceFile, options);
                    if (actualIndentation !== -1) {
                        return actualIndentation;
                    }
                }
                // try to find node that can contribute to indentation and includes 'position' starting from 'precedingToken'
                // if such node is found - compute initial indentation for 'position' inside this node
                var previous;
                var current = precedingToken;
                var currentStart;
                var indentationDelta;
                while (current) {
                    if (positionBelongsToNode(current, position, sourceFile) && nodeContentIsIndented(current, previous)) {
                        currentStart = getStartLineAndCharacterForNode(current, sourceFile);
                        if (nextTokenIsCurlyBraceOnSameLineAsCursor(precedingToken, current, lineAtPosition, sourceFile)) {
                            indentationDelta = 0;
                        }
                        else {
                            indentationDelta = lineAtPosition !== currentStart.line ? options.indentSpaces : 0;
                        }
                        break;
                    }
                    // check if current node is a list item - if yes, take indentation from it
                    var actualIndentation = getActualIndentationForListItem(current, sourceFile, options);
                    if (actualIndentation !== -1) {
                        return actualIndentation;
                    }
                    previous = current;
                    current = current.parent;
                }
                if (!current) {
                    // no parent was found - return 0 to be indented on the level of SourceFile
                    return 0;
                }
                var parent = current.parent;
                var parentStart;
                while (parent) {
                    // check if current node is a list item - if yes, take indentation from it
                    var actualIndentation = getActualIndentationForListItem(current, sourceFile, options);
                    if (actualIndentation !== -1) {
                        return actualIndentation + indentationDelta;
                    }
                    parentStart = sourceFile.getLineAndCharacterFromPosition(parent.getStart(sourceFile));
                    var parentAndChildShareLine = parentStart.line === currentStart.line || childStartsOnTheSameLineWithElseInIfStatement(parent, current, currentStart.line, sourceFile);
                    // try to fetch actual indentation for current node from source text
                    var actualIndentation = getActualIndentationForNode(current, parent, currentStart, parentAndChildShareLine, sourceFile, options);
                    if (actualIndentation !== -1) {
                        return actualIndentation + indentationDelta;
                    }
                    // increase indentation if parent node wants its content to be indented and parent and child nodes don't start on the same line
                    if (nodeContentIsIndented(parent, current) && !parentAndChildShareLine) {
                        indentationDelta += options.indentSpaces;
                    }
                    current = parent;
                    currentStart = parentStart;
                    parent = current.parent;
                }
                return indentationDelta;
            }
            SmartIndenter.getIndentation = getIndentation;
            /*
             * Function returns -1 if indentation cannot be determined
             */
            function getActualIndentationForListItemBeforeComma(commaToken, sourceFile, options) {
                // previous token is comma that separates items in list - find the previous item and try to derive indentation from it
                var itemInfo = findPrecedingListItem(commaToken);
                return deriveActualIndentationFromList(itemInfo.list.getChildren(), itemInfo.listItemIndex, sourceFile, options);
            }
            /*
             * Function returns -1 if actual indentation for node should not be used (i.e because node is nested expression)
             */
            function getActualIndentationForNode(current, parent, currentLineAndChar, parentAndChildShareLine, sourceFile, options) {
                // actual indentation is used for statements\declarations if one of cases below is true:
                // - parent is SourceFile - by default immediate children of SourceFile are not indented except when user indents them manually
                // - parent and child are not on the same line
                var useActualIndentation = (ts.isDeclaration(current) || ts.isStatement(current)) && (parent.kind === 182 /* SourceFile */ || !parentAndChildShareLine);
                if (!useActualIndentation) {
                    return -1;
                }
                return findColumnForFirstNonWhitespaceCharacterInLine(currentLineAndChar, sourceFile, options);
            }
            function nextTokenIsCurlyBraceOnSameLineAsCursor(precedingToken, current, lineAtPosition, sourceFile) {
                var nextToken = findNextToken(precedingToken, current);
                if (!nextToken) {
                    return false;
                }
                if (nextToken.kind === 9 /* OpenBraceToken */) {
                    // open braces are always indented at the parent level
                    return true;
                }
                else if (nextToken.kind === 10 /* CloseBraceToken */) {
                    // close braces are indented at the parent level if they are located on the same line with cursor
                    // this means that if new line will be added at $ position, this case will be indented
                    // class A {
                    //    $
                    // }
                    /// and this one - not
                    // class A {
                    // $}
                    var nextTokenStartLine = getStartLineAndCharacterForNode(nextToken, sourceFile).line;
                    return lineAtPosition === nextTokenStartLine;
                }
                return false;
            }
            function getStartLineAndCharacterForNode(n, sourceFile) {
                return sourceFile.getLineAndCharacterFromPosition(n.getStart(sourceFile));
            }
            function findPrecedingListItem(commaToken) {
                // CommaToken node is synthetic and thus will be stored in SyntaxList, however parent of the CommaToken points to the container of the SyntaxList skipping the list.
                // In order to find the preceding list item we first need to locate SyntaxList itself and then search for the position of CommaToken
                var syntaxList = ts.forEach(commaToken.parent.getChildren(), function (c) {
                    // find syntax list that covers the span of CommaToken
                    if (c.kind == 184 /* SyntaxList */ && c.pos <= commaToken.end && c.end >= commaToken.end) {
                        return c;
                    }
                });
                ts.Debug.assert(syntaxList);
                var children = syntaxList.getChildren();
                var commaIndex = ts.indexOf(children, commaToken);
                ts.Debug.assert(commaIndex !== -1 && commaIndex !== 0);
                return {
                    listItemIndex: commaIndex - 1,
                    list: syntaxList
                };
            }
            function positionBelongsToNode(candidate, position, sourceFile) {
                return candidate.end > position || !isCompletedNode(candidate, sourceFile);
            }
            function childStartsOnTheSameLineWithElseInIfStatement(parent, child, childStartLine, sourceFile) {
                if (parent.kind === 152 /* IfStatement */ && parent.elseStatement === child) {
                    var elseKeyword = ts.forEach(parent.getChildren(), function (c) { return c.kind === 70 /* ElseKeyword */ && c; });
                    ts.Debug.assert(elseKeyword);
                    var elseKeywordStartLine = getStartLineAndCharacterForNode(elseKeyword, sourceFile).line;
                    return elseKeywordStartLine === childStartLine;
                }
            }
            function getActualIndentationForListItem(node, sourceFile, options) {
                if (node.parent) {
                    switch (node.parent.kind) {
                        case 127 /* TypeReference */:
                            if (node.parent.typeArguments) {
                                return getActualIndentationFromList(node.parent.typeArguments);
                            }
                            break;
                        case 133 /* ObjectLiteral */:
                            return getActualIndentationFromList(node.parent.properties);
                        case 129 /* TypeLiteral */:
                            return getActualIndentationFromList(node.parent.members);
                        case 132 /* ArrayLiteral */:
                            return getActualIndentationFromList(node.parent.elements);
                        case 172 /* FunctionDeclaration */:
                        case 141 /* FunctionExpression */:
                        case 142 /* ArrowFunction */:
                        case 120 /* Method */:
                        case 124 /* CallSignature */:
                        case 125 /* ConstructSignature */:
                            if (node.parent.typeParameters && node.end < node.parent.typeParameters.end) {
                                return getActualIndentationFromList(node.parent.typeParameters);
                            }
                            return getActualIndentationFromList(node.parent.parameters);
                        case 138 /* NewExpression */:
                        case 137 /* CallExpression */:
                            if (node.parent.typeArguments && node.end < node.parent.typeArguments.end) {
                                return getActualIndentationFromList(node.parent.typeArguments);
                            }
                            return getActualIndentationFromList(node.parent.arguments);
                    }
                }
                return -1;
                function getActualIndentationFromList(list) {
                    var index = ts.indexOf(list, node);
                    return index !== -1 ? deriveActualIndentationFromList(list, index, sourceFile, options) : -1;
                }
            }
            function deriveActualIndentationFromList(list, index, sourceFile, options) {
                ts.Debug.assert(index >= 0 && index < list.length);
                var node = list[index];
                // walk toward the start of the list starting from current node and check if the line is the same for all items.
                // if end line for item [i - 1] differs from the start line for item [i] - find column of the first non-whitespace character on the line of item [i]
                var lineAndCharacter = getStartLineAndCharacterForNode(node, sourceFile);
                for (var i = index - 1; i >= 0; --i) {
                    if (list[i].kind === 18 /* CommaToken */) {
                        continue;
                    }
                    // skip list items that ends on the same line with the current list element
                    var prevEndLine = sourceFile.getLineAndCharacterFromPosition(list[i].end).line;
                    if (prevEndLine !== lineAndCharacter.line) {
                        return findColumnForFirstNonWhitespaceCharacterInLine(lineAndCharacter, sourceFile, options);
                    }
                    lineAndCharacter = getStartLineAndCharacterForNode(list[i], sourceFile);
                }
                return -1;
            }
            function findColumnForFirstNonWhitespaceCharacterInLine(lineAndCharacter, sourceFile, options) {
                var lineStart = sourceFile.getPositionFromLineAndCharacter(lineAndCharacter.line, 1);
                var column = 0;
                for (var i = 0; i < lineAndCharacter.character; ++i) {
                    var charCode = sourceFile.text.charCodeAt(lineStart + i);
                    if (!ts.isWhiteSpace(charCode)) {
                        return column;
                    }
                    if (charCode === 9 /* tab */) {
                        column += options.spacesPerTab;
                    }
                    else {
                        column++;
                    }
                }
                return column;
            }
            function findNextToken(previousToken, parent) {
                return find(parent);
                function find(n) {
                    if (isToken(n) && n.pos === previousToken.end) {
                        // this is token that starts at the end of previous token - return it
                        return n;
                    }
                    var children = n.getChildren();
                    for (var i = 0, len = children.length; i < len; ++i) {
                        var child = children[i];
                        var shouldDiveInChildNode = (child.pos <= previousToken.pos && child.end > previousToken.end) || (child.pos === previousToken.end);
                        if (shouldDiveInChildNode && nodeHasTokens(child)) {
                            return find(child);
                        }
                    }
                    return undefined;
                }
            }
            function findPrecedingToken(position, sourceFile) {
                return find(sourceFile);
                function findRightmostToken(n) {
                    if (isToken(n)) {
                        return n;
                    }
                    var children = n.getChildren();
                    var candidate = findRightmostChildNodeWithTokens(children, children.length);
                    return candidate && findRightmostToken(candidate);
                }
                function find(n) {
                    if (isToken(n)) {
                        return n;
                    }
                    var children = n.getChildren();
                    for (var i = 0, len = children.length; i < len; ++i) {
                        var child = children[i];
                        if (nodeHasTokens(child)) {
                            if (position < child.end) {
                                if (child.getStart(sourceFile) >= position) {
                                    // actual start of the node is past the position - previous token should be at the end of previous child
                                    var candidate = findRightmostChildNodeWithTokens(children, i);
                                    return candidate && findRightmostToken(candidate);
                                }
                                else {
                                    // candidate should be in this node
                                    return find(child);
                                }
                            }
                        }
                    }
                    ts.Debug.assert(n.kind === 182 /* SourceFile */);
                    // Here we know that none of child token nodes embrace the position, 
                    // the only known case is when position is at the end of the file.
                    // Try to find the rightmost token in the file without filtering.
                    // Namely we are skipping the check: 'position < node.end'
                    if (children.length) {
                        var candidate = findRightmostChildNodeWithTokens(children, children.length);
                        return candidate && findRightmostToken(candidate);
                    }
                }
                /// finds last node that is considered as candidate for search (isCandidate(node) === true) starting from 'exclusiveStartPosition'
                function findRightmostChildNodeWithTokens(children, exclusiveStartPosition) {
                    for (var i = exclusiveStartPosition - 1; i >= 0; --i) {
                        if (nodeHasTokens(children[i])) {
                            return children[i];
                        }
                    }
                }
            }
            /*
             * Checks if node is something that can contain tokens (except EOF) - filters out EOF tokens, Missing\Omitted expressions, empty SyntaxLists and expression statements that wrap any of listed nodes.
             */
            function nodeHasTokens(n) {
                if (n.kind === 151 /* ExpressionStatement */) {
                    return nodeHasTokens(n.expression);
                }
                if (n.kind === 1 /* EndOfFileToken */ || n.kind === 147 /* OmittedExpression */ || n.kind === 115 /* Missing */) {
                    return false;
                }
                // SyntaxList is already realized so getChildCount should be fast and non-expensive
                return n.kind !== 184 /* SyntaxList */ || n.getChildCount() !== 0;
            }
            function isToken(n) {
                return n.kind >= ts.SyntaxKind.FirstToken && n.kind <= ts.SyntaxKind.LastToken;
            }
            function nodeContentIsIndented(parent, child) {
                switch (parent.kind) {
                    case 174 /* ClassDeclaration */:
                    case 175 /* InterfaceDeclaration */:
                    case 176 /* EnumDeclaration */:
                        return true;
                    case 177 /* ModuleDeclaration */:
                        // ModuleBlock should take care of indentation
                        return false;
                    case 172 /* FunctionDeclaration */:
                    case 120 /* Method */:
                    case 141 /* FunctionExpression */:
                    case 122 /* GetAccessor */:
                    case 123 /* SetAccessor */:
                    case 121 /* Constructor */:
                        // FunctionBlock should take care of indentation
                        return false;
                    case 153 /* DoStatement */:
                    case 154 /* WhileStatement */:
                    case 156 /* ForInStatement */:
                    case 155 /* ForStatement */:
                        return child && child.kind !== 148 /* Block */;
                    case 152 /* IfStatement */:
                        return child && child.kind !== 148 /* Block */;
                    case 166 /* TryStatement */:
                        // TryBlock\CatchBlock\FinallyBlock should take care of indentation
                        return false;
                    case 132 /* ArrayLiteral */:
                    case 148 /* Block */:
                    case 173 /* FunctionBlock */:
                    case 167 /* TryBlock */:
                    case 168 /* CatchBlock */:
                    case 169 /* FinallyBlock */:
                    case 178 /* ModuleBlock */:
                    case 133 /* ObjectLiteral */:
                    case 129 /* TypeLiteral */:
                    case 161 /* SwitchStatement */:
                    case 163 /* DefaultClause */:
                    case 162 /* CaseClause */:
                    case 140 /* ParenExpression */:
                    case 137 /* CallExpression */:
                    case 138 /* NewExpression */:
                    case 149 /* VariableStatement */:
                    case 171 /* VariableDeclaration */:
                        return true;
                    default:
                        return false;
                }
            }
            /*
             * Checks if node ends with 'expectedLastToken'.
             * If child at position 'length - 1' is 'SemicolonToken' it is skipped and 'expectedLastToken' is compared with child at position 'length - 2'.
             */
            function nodeEndsWith(n, expectedLastToken, sourceFile) {
                var children = n.getChildren(sourceFile);
                if (children.length) {
                    var last = children[children.length - 1];
                    if (last.kind === expectedLastToken) {
                        return true;
                    }
                    else if (last.kind === 17 /* SemicolonToken */ && children.length !== 1) {
                        return children[children.length - 2].kind === expectedLastToken;
                    }
                }
                return false;
            }
            /*
             * This function is always called when position of the cursor is located after the node
             */
            function isCompletedNode(n, sourceFile) {
                switch (n.kind) {
                    case 174 /* ClassDeclaration */:
                    case 175 /* InterfaceDeclaration */:
                    case 176 /* EnumDeclaration */:
                    case 133 /* ObjectLiteral */:
                    case 148 /* Block */:
                    case 168 /* CatchBlock */:
                    case 169 /* FinallyBlock */:
                    case 173 /* FunctionBlock */:
                    case 178 /* ModuleBlock */:
                    case 161 /* SwitchStatement */:
                        return nodeEndsWith(n, 10 /* CloseBraceToken */, sourceFile);
                    case 140 /* ParenExpression */:
                    case 124 /* CallSignature */:
                    case 137 /* CallExpression */:
                    case 125 /* ConstructSignature */:
                        return nodeEndsWith(n, 12 /* CloseParenToken */, sourceFile);
                    case 172 /* FunctionDeclaration */:
                    case 141 /* FunctionExpression */:
                    case 120 /* Method */:
                    case 142 /* ArrowFunction */:
                        return !n.body || isCompletedNode(n.body, sourceFile);
                    case 177 /* ModuleDeclaration */:
                        return n.body && isCompletedNode(n.body, sourceFile);
                    case 152 /* IfStatement */:
                        if (n.elseStatement) {
                            return isCompletedNode(n.elseStatement, sourceFile);
                        }
                        return isCompletedNode(n.thenStatement, sourceFile);
                    case 151 /* ExpressionStatement */:
                        return isCompletedNode(n.expression, sourceFile);
                    case 132 /* ArrayLiteral */:
                        return nodeEndsWith(n, 14 /* CloseBracketToken */, sourceFile);
                    case 115 /* Missing */:
                        return false;
                    case 162 /* CaseClause */:
                    case 163 /* DefaultClause */:
                        // there is no such thing as terminator token for CaseClause\DefaultClause so for simplicitly always consider them non-completed
                        return false;
                    case 154 /* WhileStatement */:
                        return isCompletedNode(n.statement, sourceFile);
                    case 153 /* DoStatement */:
                        // rough approximation: if DoStatement has While keyword - then if node is completed is checking the presence of ')';
                        var hasWhileKeyword = ts.forEach(n.getChildren(), function (c) { return c.kind === 94 /* WhileKeyword */ && c; });
                        if (hasWhileKeyword) {
                            return nodeEndsWith(n, 12 /* CloseParenToken */, sourceFile);
                        }
                        return isCompletedNode(n.statement, sourceFile);
                    default:
                        return true;
                }
            }
        })(SmartIndenter = formatting.SmartIndenter || (formatting.SmartIndenter = {}));
    })(formatting = ts.formatting || (ts.formatting = {}));
})(ts || (ts = {}));
/////<reference path='resources\references.ts' />
/////<reference path='core\references.ts' />
/////<reference path='text\references.ts' />
/////<reference path='syntax\references.ts' />
/////<reference path='diagnostics.ts' />
/////<reference path='document.ts' />
/////<reference path='flags.ts' />
/////<reference path='hashTable.ts' />
/////<reference path='ast.ts' />
/////<reference path='astHelpers.ts' />
/////<reference path='astWalker.ts' />
/////<reference path='base64.ts' />
/////<reference path='sourceMapping.ts' />
/////<reference path='emitter.ts' />
/////<reference path='types.ts' />
/////<reference path='pathUtils.ts' />
/////<reference path='referenceResolution.ts' />
/////<reference path='precompile.ts' />
/////<reference path='referenceResolver.ts' />
/////<reference path='declarationEmitter.ts' />
/////<reference path='identifierWalker.ts' />
/////<reference path='settings.ts' />
/////<reference path='typecheck\pullFlags.ts' />
/////<reference path='typecheck\pullDecls.ts' />
/////<reference path='typecheck\pullSymbols.ts' />
/////<reference path='typecheck\pullTypeEnclosingTypeWalker.ts' />
/////<reference path='typecheck\pullTypeResolutionContext.ts' />
/////<reference path='typecheck\pullTypeResolution.ts' />
/////<reference path='typecheck\pullSemanticInfo.ts' />
/////<reference path='typecheck\pullDeclCollection.ts' />
/////<reference path='typecheck\pullSymbolBinder.ts' />
/////<reference path='typecheck\pullHelpers.ts' />
/////<reference path='typecheck\pullInstantiationHelpers.ts' />
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
///<reference path='references.ts' />
var TypeScript;
(function (TypeScript) {
    var NullLogger = (function () {
        function NullLogger() {
        }
        NullLogger.prototype.log = function (s) {
        };
        return NullLogger;
    })();
    TypeScript.NullLogger = NullLogger;
})(TypeScript || (TypeScript = {}));
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
///<reference path='references.ts' />
var TypeScript;
(function (TypeScript) {
    var proto = "__proto__";
    var BlockIntrinsics = (function () {
        function BlockIntrinsics() {
            this.prototype = undefined;
            this.toString = undefined;
            this.toLocaleString = undefined;
            this.valueOf = undefined;
            this.hasOwnProperty = undefined;
            this.propertyIsEnumerable = undefined;
            this.isPrototypeOf = undefined;
            // initialize the 'constructor' field
            this["constructor"] = undefined;
            // First we set it to null, because that's the only way to erase the value in node. Then we set it to undefined in case we are not in node, since
            // in StringHashTable below, we check for undefined explicitly.
            this[proto] = null;
            this[proto] = undefined;
        }
        return BlockIntrinsics;
    })();
    function createIntrinsicsObject() {
        return new BlockIntrinsics();
    }
    TypeScript.createIntrinsicsObject = createIntrinsicsObject;
})(TypeScript || (TypeScript = {}));
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
///<reference path='references.ts' />
var TypeScript;
(function (TypeScript) {
    var Comment = (function () {
        function Comment(_trivia, endsLine, _start, _end) {
            this._trivia = _trivia;
            this.endsLine = endsLine;
            this._start = _start;
            this._end = _end;
        }
        Comment.prototype.start = function () {
            return this._start;
        };
        Comment.prototype.end = function () {
            return this._end;
        };
        Comment.prototype.fullText = function () {
            return this._trivia.fullText();
        };
        Comment.prototype.kind = function () {
            return this._trivia.kind();
        };
        Comment.prototype.structuralEquals = function (ast, includingPosition) {
            if (includingPosition) {
                if (this.start() !== ast.start() || this.end() !== ast.end()) {
                    return false;
                }
            }
            return this._trivia.fullText() === ast._trivia.fullText() && this.endsLine === ast.endsLine;
        };
        return Comment;
    })();
    TypeScript.Comment = Comment;
})(TypeScript || (TypeScript = {}));
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
///<reference path='references.ts' />
var TypeScript;
(function (TypeScript) {
    function walkListChildren(preAst, walker) {
        for (var i = 0, n = preAst.length; i < n; i++) {
            walker.walk(preAst[i]);
        }
    }
    function walkThrowStatementChildren(preAst, walker) {
        walker.walk(preAst.expression);
    }
    function walkPrefixUnaryExpressionChildren(preAst, walker) {
        walker.walk(preAst.operand);
    }
    function walkPostfixUnaryExpressionChildren(preAst, walker) {
        walker.walk(preAst.operand);
    }
    function walkDeleteExpressionChildren(preAst, walker) {
        walker.walk(preAst.expression);
    }
    function walkTypeArgumentListChildren(preAst, walker) {
        walker.walk(preAst.typeArguments);
    }
    function walkTupleTypeChildren(preAst, walker) {
        walker.walk(preAst.types);
    }
    function walkTypeOfExpressionChildren(preAst, walker) {
        walker.walk(preAst.expression);
    }
    function walkVoidExpressionChildren(preAst, walker) {
        walker.walk(preAst.expression);
    }
    function walkArgumentListChildren(preAst, walker) {
        walker.walk(preAst.typeArgumentList);
        walker.walk(preAst.arguments);
    }
    function walkArrayLiteralExpressionChildren(preAst, walker) {
        walker.walk(preAst.expressions);
    }
    function walkSimplePropertyAssignmentChildren(preAst, walker) {
        walker.walk(preAst.propertyName);
        walker.walk(preAst.expression);
    }
    function walkFunctionPropertyAssignmentChildren(preAst, walker) {
        walker.walk(preAst.propertyName);
        walker.walk(preAst.callSignature);
        walker.walk(preAst.block);
    }
    function walkGetAccessorChildren(preAst, walker) {
        walker.walk(preAst.propertyName);
        walker.walk(preAst.callSignature);
        walker.walk(preAst.block);
    }
    function walkSeparatedListChildren(preAst, walker) {
        for (var i = 0, n = preAst.length; i < n; i++) {
            walker.walk(preAst[i]);
        }
    }
    function walkSetAccessorChildren(preAst, walker) {
        walker.walk(preAst.propertyName);
        walker.walk(preAst.callSignature);
        walker.walk(preAst.block);
    }
    function walkObjectLiteralExpressionChildren(preAst, walker) {
        walker.walk(preAst.propertyAssignments);
    }
    function walkCastExpressionChildren(preAst, walker) {
        walker.walk(preAst.type);
        walker.walk(preAst.expression);
    }
    function walkParenthesizedExpressionChildren(preAst, walker) {
        walker.walk(preAst.expression);
    }
    function walkElementAccessExpressionChildren(preAst, walker) {
        walker.walk(preAst.expression);
        walker.walk(preAst.argumentExpression);
    }
    function walkMemberAccessExpressionChildren(preAst, walker) {
        walker.walk(preAst.expression);
        walker.walk(preAst.name);
    }
    function walkQualifiedNameChildren(preAst, walker) {
        walker.walk(preAst.left);
        walker.walk(preAst.right);
    }
    function walkBinaryExpressionChildren(preAst, walker) {
        walker.walk(preAst.left);
        walker.walk(preAst.right);
    }
    function walkEqualsValueClauseChildren(preAst, walker) {
        walker.walk(preAst.value);
    }
    function walkTypeParameterChildren(preAst, walker) {
        walker.walk(preAst.identifier);
        walker.walk(preAst.constraint);
    }
    function walkTypeParameterListChildren(preAst, walker) {
        walker.walk(preAst.typeParameters);
    }
    function walkGenericTypeChildren(preAst, walker) {
        walker.walk(preAst.name);
        walker.walk(preAst.typeArgumentList);
    }
    function walkTypeAnnotationChildren(preAst, walker) {
        walker.walk(preAst.type);
    }
    function walkTypeQueryChildren(preAst, walker) {
        walker.walk(preAst.name);
    }
    function walkInvocationExpressionChildren(preAst, walker) {
        walker.walk(preAst.expression);
        walker.walk(preAst.argumentList);
    }
    function walkObjectCreationExpressionChildren(preAst, walker) {
        walker.walk(preAst.expression);
        walker.walk(preAst.argumentList);
    }
    function walkTrinaryExpressionChildren(preAst, walker) {
        walker.walk(preAst.condition);
        walker.walk(preAst.whenTrue);
        walker.walk(preAst.whenFalse);
    }
    function walkFunctionExpressionChildren(preAst, walker) {
        walker.walk(preAst.identifier);
        walker.walk(preAst.callSignature);
        walker.walk(preAst.block);
    }
    function walkFunctionTypeChildren(preAst, walker) {
        walker.walk(preAst.typeParameterList);
        walker.walk(preAst.parameterList);
        walker.walk(preAst.type);
    }
    function walkParenthesizedArrowFunctionExpressionChildren(preAst, walker) {
        walker.walk(preAst.callSignature);
        walker.walk(preAst.block);
        walker.walk(preAst.expression);
    }
    function walkSimpleArrowFunctionExpressionChildren(preAst, walker) {
        walker.walk(preAst.parameter);
        walker.walk(preAst.block);
        walker.walk(preAst.expression);
    }
    function walkMemberFunctionDeclarationChildren(preAst, walker) {
        walker.walk(preAst.propertyName);
        walker.walk(preAst.callSignature);
        walker.walk(preAst.block);
    }
    function walkFuncDeclChildren(preAst, walker) {
        walker.walk(preAst.identifier);
        walker.walk(preAst.callSignature);
        walker.walk(preAst.block);
    }
    function walkIndexMemberDeclarationChildren(preAst, walker) {
        walker.walk(preAst.indexSignature);
    }
    function walkIndexSignatureChildren(preAst, walker) {
        walker.walk(preAst.parameters);
        walker.walk(preAst.typeAnnotation);
    }
    function walkCallSignatureChildren(preAst, walker) {
        walker.walk(preAst.typeParameterList);
        walker.walk(preAst.parameterList);
        walker.walk(preAst.typeAnnotation);
    }
    function walkConstraintChildren(preAst, walker) {
        walker.walk(preAst.typeOrExpression);
    }
    function walkConstructorDeclarationChildren(preAst, walker) {
        walker.walk(preAst.callSignature);
        walker.walk(preAst.block);
    }
    function walkConstructorTypeChildren(preAst, walker) {
        walker.walk(preAst.typeParameterList);
        walker.walk(preAst.parameterList);
        walker.walk(preAst.type);
    }
    function walkConstructSignatureChildren(preAst, walker) {
        walker.walk(preAst.callSignature);
    }
    function walkParameterChildren(preAst, walker) {
        walker.walk(preAst.identifier);
        walker.walk(preAst.typeAnnotation);
        walker.walk(preAst.equalsValueClause);
    }
    function walkParameterListChildren(preAst, walker) {
        walker.walk(preAst.parameters);
    }
    function walkPropertySignatureChildren(preAst, walker) {
        walker.walk(preAst.propertyName);
        walker.walk(preAst.typeAnnotation);
    }
    function walkVariableDeclaratorChildren(preAst, walker) {
        walker.walk(preAst.propertyName);
        walker.walk(preAst.typeAnnotation);
        walker.walk(preAst.equalsValueClause);
    }
    function walkMemberVariableDeclarationChildren(preAst, walker) {
        walker.walk(preAst.variableDeclarator);
    }
    function walkMethodSignatureChildren(preAst, walker) {
        walker.walk(preAst.propertyName);
        walker.walk(preAst.callSignature);
    }
    function walkReturnStatementChildren(preAst, walker) {
        walker.walk(preAst.expression);
    }
    function walkForStatementChildren(preAst, walker) {
        walker.walk(preAst.variableDeclaration);
        walker.walk(preAst.initializer);
        walker.walk(preAst.condition);
        walker.walk(preAst.incrementor);
        walker.walk(preAst.statement);
    }
    function walkForInStatementChildren(preAst, walker) {
        walker.walk(preAst.variableDeclaration);
        walker.walk(preAst.left);
        walker.walk(preAst.expression);
        walker.walk(preAst.statement);
    }
    function walkIfStatementChildren(preAst, walker) {
        walker.walk(preAst.condition);
        walker.walk(preAst.statement);
        walker.walk(preAst.elseClause);
    }
    function walkElseClauseChildren(preAst, walker) {
        walker.walk(preAst.statement);
    }
    function walkWhileStatementChildren(preAst, walker) {
        walker.walk(preAst.condition);
        walker.walk(preAst.statement);
    }
    function walkDoStatementChildren(preAst, walker) {
        walker.walk(preAst.condition);
        walker.walk(preAst.statement);
    }
    function walkBlockChildren(preAst, walker) {
        walker.walk(preAst.statements);
    }
    function walkVariableDeclarationChildren(preAst, walker) {
        walker.walk(preAst.variableDeclarators);
    }
    function walkCaseSwitchClauseChildren(preAst, walker) {
        walker.walk(preAst.expression);
        walker.walk(preAst.statements);
    }
    function walkDefaultSwitchClauseChildren(preAst, walker) {
        walker.walk(preAst.statements);
    }
    function walkSwitchStatementChildren(preAst, walker) {
        walker.walk(preAst.expression);
        walker.walk(preAst.switchClauses);
    }
    function walkTryStatementChildren(preAst, walker) {
        walker.walk(preAst.block);
        walker.walk(preAst.catchClause);
        walker.walk(preAst.finallyClause);
    }
    function walkCatchClauseChildren(preAst, walker) {
        walker.walk(preAst.identifier);
        walker.walk(preAst.typeAnnotation);
        walker.walk(preAst.block);
    }
    function walkExternalModuleReferenceChildren(preAst, walker) {
        walker.walk(preAst.stringLiteral);
    }
    function walkFinallyClauseChildren(preAst, walker) {
        walker.walk(preAst.block);
    }
    function walkClassDeclChildren(preAst, walker) {
        walker.walk(preAst.identifier);
        walker.walk(preAst.typeParameterList);
        walker.walk(preAst.heritageClauses);
        walker.walk(preAst.classElements);
    }
    function walkScriptChildren(preAst, walker) {
        walker.walk(preAst.moduleElements);
    }
    function walkHeritageClauseChildren(preAst, walker) {
        walker.walk(preAst.typeNames);
    }
    function walkInterfaceDeclerationChildren(preAst, walker) {
        walker.walk(preAst.identifier);
        walker.walk(preAst.typeParameterList);
        walker.walk(preAst.heritageClauses);
        walker.walk(preAst.body);
    }
    function walkObjectTypeChildren(preAst, walker) {
        walker.walk(preAst.typeMembers);
    }
    function walkArrayTypeChildren(preAst, walker) {
        walker.walk(preAst.type);
    }
    function walkModuleDeclarationChildren(preAst, walker) {
        walker.walk(preAst.name);
        walker.walk(preAst.stringLiteral);
        walker.walk(preAst.moduleElements);
    }
    function walkModuleNameModuleReferenceChildren(preAst, walker) {
        walker.walk(preAst.moduleName);
    }
    function walkEnumDeclarationChildren(preAst, walker) {
        walker.walk(preAst.identifier);
        walker.walk(preAst.enumElements);
    }
    function walkEnumElementChildren(preAst, walker) {
        walker.walk(preAst.propertyName);
        walker.walk(preAst.equalsValueClause);
    }
    function walkImportDeclarationChildren(preAst, walker) {
        walker.walk(preAst.identifier);
        walker.walk(preAst.moduleReference);
    }
    function walkExportAssignmentChildren(preAst, walker) {
        walker.walk(preAst.identifier);
    }
    function walkWithStatementChildren(preAst, walker) {
        walker.walk(preAst.condition);
        walker.walk(preAst.statement);
    }
    function walkExpressionStatementChildren(preAst, walker) {
        walker.walk(preAst.expression);
    }
    function walkLabeledStatementChildren(preAst, walker) {
        walker.walk(preAst.identifier);
        walker.walk(preAst.statement);
    }
    function walkVariableStatementChildren(preAst, walker) {
        walker.walk(preAst.variableDeclaration);
    }
    var childrenWalkers = new Array(TypeScript.SyntaxKind.LastNode + 1);
    for (var i = TypeScript.SyntaxKind.FirstToken, n = TypeScript.SyntaxKind.LastToken; i <= n; i++) {
        childrenWalkers[i] = null;
    }
    for (var i = TypeScript.SyntaxKind.FirstTrivia, n = TypeScript.SyntaxKind.LastTrivia; i <= n; i++) {
        childrenWalkers[i] = null;
    }
    childrenWalkers[176 /* AddAssignmentExpression */] = walkBinaryExpressionChildren;
    childrenWalkers[209 /* AddExpression */] = walkBinaryExpressionChildren;
    childrenWalkers[181 /* AndAssignmentExpression */] = walkBinaryExpressionChildren;
    childrenWalkers[60 /* AnyKeyword */] = null;
    childrenWalkers[227 /* ArgumentList */] = walkArgumentListChildren;
    childrenWalkers[215 /* ArrayLiteralExpression */] = walkArrayLiteralExpressionChildren;
    childrenWalkers[124 /* ArrayType */] = walkArrayTypeChildren;
    childrenWalkers[220 /* SimpleArrowFunctionExpression */] = walkSimpleArrowFunctionExpressionChildren;
    childrenWalkers[219 /* ParenthesizedArrowFunctionExpression */] = walkParenthesizedArrowFunctionExpressionChildren;
    childrenWalkers[175 /* AssignmentExpression */] = walkBinaryExpressionChildren;
    childrenWalkers[192 /* BitwiseAndExpression */] = walkBinaryExpressionChildren;
    childrenWalkers[191 /* BitwiseExclusiveOrExpression */] = walkBinaryExpressionChildren;
    childrenWalkers[167 /* BitwiseNotExpression */] = walkPrefixUnaryExpressionChildren;
    childrenWalkers[190 /* BitwiseOrExpression */] = walkBinaryExpressionChildren;
    childrenWalkers[147 /* Block */] = walkBlockChildren;
    childrenWalkers[61 /* BooleanKeyword */] = null;
    childrenWalkers[153 /* BreakStatement */] = null;
    childrenWalkers[143 /* CallSignature */] = walkCallSignatureChildren;
    childrenWalkers[234 /* CaseSwitchClause */] = walkCaseSwitchClauseChildren;
    childrenWalkers[221 /* CastExpression */] = walkCastExpressionChildren;
    childrenWalkers[237 /* CatchClause */] = walkCatchClauseChildren;
    childrenWalkers[132 /* ClassDeclaration */] = walkClassDeclChildren;
    childrenWalkers[174 /* CommaExpression */] = walkBinaryExpressionChildren;
    childrenWalkers[187 /* ConditionalExpression */] = walkTrinaryExpressionChildren;
    childrenWalkers[240 /* Constraint */] = walkConstraintChildren;
    childrenWalkers[138 /* ConstructorDeclaration */] = walkConstructorDeclarationChildren;
    childrenWalkers[144 /* ConstructSignature */] = walkConstructSignatureChildren;
    childrenWalkers[154 /* ContinueStatement */] = null;
    childrenWalkers[125 /* ConstructorType */] = walkConstructorTypeChildren;
    childrenWalkers[163 /* DebuggerStatement */] = null;
    childrenWalkers[235 /* DefaultSwitchClause */] = walkDefaultSwitchClauseChildren;
    childrenWalkers[171 /* DeleteExpression */] = walkDeleteExpressionChildren;
    childrenWalkers[179 /* DivideAssignmentExpression */] = walkBinaryExpressionChildren;
    childrenWalkers[207 /* DivideExpression */] = walkBinaryExpressionChildren;
    childrenWalkers[162 /* DoStatement */] = walkDoStatementChildren;
    childrenWalkers[222 /* ElementAccessExpression */] = walkElementAccessExpressionChildren;
    childrenWalkers[236 /* ElseClause */] = walkElseClauseChildren;
    childrenWalkers[157 /* EmptyStatement */] = null;
    childrenWalkers[133 /* EnumDeclaration */] = walkEnumDeclarationChildren;
    childrenWalkers[244 /* EnumElement */] = walkEnumElementChildren;
    childrenWalkers[195 /* EqualsExpression */] = walkBinaryExpressionChildren;
    childrenWalkers[233 /* EqualsValueClause */] = walkEqualsValueClauseChildren;
    childrenWalkers[193 /* EqualsWithTypeConversionExpression */] = walkBinaryExpressionChildren;
    childrenWalkers[182 /* ExclusiveOrAssignmentExpression */] = walkBinaryExpressionChildren;
    childrenWalkers[135 /* ExportAssignment */] = walkExportAssignmentChildren;
    childrenWalkers[150 /* ExpressionStatement */] = walkExpressionStatementChildren;
    childrenWalkers[231 /* ExtendsHeritageClause */] = walkHeritageClauseChildren;
    childrenWalkers[246 /* ExternalModuleReference */] = walkExternalModuleReferenceChildren;
    childrenWalkers[24 /* FalseKeyword */] = null;
    childrenWalkers[238 /* FinallyClause */] = walkFinallyClauseChildren;
    childrenWalkers[156 /* ForInStatement */] = walkForInStatementChildren;
    childrenWalkers[155 /* ForStatement */] = walkForStatementChildren;
    childrenWalkers[130 /* FunctionDeclaration */] = walkFuncDeclChildren;
    childrenWalkers[223 /* FunctionExpression */] = walkFunctionExpressionChildren;
    childrenWalkers[242 /* FunctionPropertyAssignment */] = walkFunctionPropertyAssignmentChildren;
    childrenWalkers[123 /* FunctionType */] = walkFunctionTypeChildren;
    childrenWalkers[126 /* GenericType */] = walkGenericTypeChildren;
    childrenWalkers[140 /* GetAccessor */] = walkGetAccessorChildren;
    childrenWalkers[198 /* GreaterThanExpression */] = walkBinaryExpressionChildren;
    childrenWalkers[200 /* GreaterThanOrEqualExpression */] = walkBinaryExpressionChildren;
    childrenWalkers[148 /* IfStatement */] = walkIfStatementChildren;
    childrenWalkers[232 /* ImplementsHeritageClause */] = walkHeritageClauseChildren;
    childrenWalkers[134 /* ImportDeclaration */] = walkImportDeclarationChildren;
    childrenWalkers[139 /* IndexMemberDeclaration */] = walkIndexMemberDeclarationChildren;
    childrenWalkers[145 /* IndexSignature */] = walkIndexSignatureChildren;
    childrenWalkers[202 /* InExpression */] = walkBinaryExpressionChildren;
    childrenWalkers[201 /* InstanceOfExpression */] = walkBinaryExpressionChildren;
    childrenWalkers[129 /* InterfaceDeclaration */] = walkInterfaceDeclerationChildren;
    childrenWalkers[214 /* InvocationExpression */] = walkInvocationExpressionChildren;
    childrenWalkers[161 /* LabeledStatement */] = walkLabeledStatementChildren;
    childrenWalkers[184 /* LeftShiftAssignmentExpression */] = walkBinaryExpressionChildren;
    childrenWalkers[203 /* LeftShiftExpression */] = walkBinaryExpressionChildren;
    childrenWalkers[197 /* LessThanExpression */] = walkBinaryExpressionChildren;
    childrenWalkers[199 /* LessThanOrEqualExpression */] = walkBinaryExpressionChildren;
    childrenWalkers[1 /* List */] = walkListChildren;
    childrenWalkers[189 /* LogicalAndExpression */] = walkBinaryExpressionChildren;
    childrenWalkers[168 /* LogicalNotExpression */] = walkPrefixUnaryExpressionChildren;
    childrenWalkers[188 /* LogicalOrExpression */] = walkBinaryExpressionChildren;
    childrenWalkers[213 /* MemberAccessExpression */] = walkMemberAccessExpressionChildren;
    childrenWalkers[136 /* MemberFunctionDeclaration */] = walkMemberFunctionDeclarationChildren;
    childrenWalkers[137 /* MemberVariableDeclaration */] = walkMemberVariableDeclarationChildren;
    childrenWalkers[146 /* MethodSignature */] = walkMethodSignatureChildren;
    childrenWalkers[131 /* ModuleDeclaration */] = walkModuleDeclarationChildren;
    childrenWalkers[247 /* ModuleNameModuleReference */] = walkModuleNameModuleReferenceChildren;
    childrenWalkers[180 /* ModuloAssignmentExpression */] = walkBinaryExpressionChildren;
    childrenWalkers[208 /* ModuloExpression */] = walkBinaryExpressionChildren;
    childrenWalkers[178 /* MultiplyAssignmentExpression */] = walkBinaryExpressionChildren;
    childrenWalkers[206 /* MultiplyExpression */] = walkBinaryExpressionChildren;
    childrenWalkers[11 /* IdentifierName */] = null;
    childrenWalkers[166 /* NegateExpression */] = walkPrefixUnaryExpressionChildren;
    childrenWalkers[0 /* None */] = null;
    childrenWalkers[196 /* NotEqualsExpression */] = walkBinaryExpressionChildren;
    childrenWalkers[194 /* NotEqualsWithTypeConversionExpression */] = walkBinaryExpressionChildren;
    childrenWalkers[32 /* NullKeyword */] = null;
    childrenWalkers[67 /* NumberKeyword */] = null;
    childrenWalkers[13 /* NumericLiteral */] = null;
    childrenWalkers[217 /* ObjectCreationExpression */] = walkObjectCreationExpressionChildren;
    childrenWalkers[216 /* ObjectLiteralExpression */] = walkObjectLiteralExpressionChildren;
    childrenWalkers[122 /* ObjectType */] = walkObjectTypeChildren;
    childrenWalkers[224 /* OmittedExpression */] = null;
    childrenWalkers[183 /* OrAssignmentExpression */] = walkBinaryExpressionChildren;
    childrenWalkers[243 /* Parameter */] = walkParameterChildren;
    childrenWalkers[228 /* ParameterList */] = walkParameterListChildren;
    childrenWalkers[218 /* ParenthesizedExpression */] = walkParenthesizedExpressionChildren;
    childrenWalkers[165 /* PlusExpression */] = walkPrefixUnaryExpressionChildren;
    childrenWalkers[212 /* PostDecrementExpression */] = walkPostfixUnaryExpressionChildren;
    childrenWalkers[211 /* PostIncrementExpression */] = walkPostfixUnaryExpressionChildren;
    childrenWalkers[170 /* PreDecrementExpression */] = walkPrefixUnaryExpressionChildren;
    childrenWalkers[169 /* PreIncrementExpression */] = walkPrefixUnaryExpressionChildren;
    childrenWalkers[142 /* PropertySignature */] = walkPropertySignatureChildren;
    childrenWalkers[121 /* QualifiedName */] = walkQualifiedNameChildren;
    childrenWalkers[12 /* RegularExpressionLiteral */] = null;
    childrenWalkers[151 /* ReturnStatement */] = walkReturnStatementChildren;
    childrenWalkers[120 /* SourceUnit */] = walkScriptChildren;
    childrenWalkers[2 /* SeparatedList */] = walkSeparatedListChildren;
    childrenWalkers[141 /* SetAccessor */] = walkSetAccessorChildren;
    childrenWalkers[185 /* SignedRightShiftAssignmentExpression */] = walkBinaryExpressionChildren;
    childrenWalkers[204 /* SignedRightShiftExpression */] = walkBinaryExpressionChildren;
    childrenWalkers[241 /* SimplePropertyAssignment */] = walkSimplePropertyAssignmentChildren;
    childrenWalkers[14 /* StringLiteral */] = null;
    childrenWalkers[69 /* StringKeyword */] = null;
    childrenWalkers[177 /* SubtractAssignmentExpression */] = walkBinaryExpressionChildren;
    childrenWalkers[210 /* SubtractExpression */] = walkBinaryExpressionChildren;
    childrenWalkers[50 /* SuperKeyword */] = null;
    childrenWalkers[152 /* SwitchStatement */] = walkSwitchStatementChildren;
    childrenWalkers[35 /* ThisKeyword */] = null;
    childrenWalkers[158 /* ThrowStatement */] = walkThrowStatementChildren;
    childrenWalkers[3 /* TriviaList */] = null;
    childrenWalkers[37 /* TrueKeyword */] = null;
    childrenWalkers[160 /* TryStatement */] = walkTryStatementChildren;
    childrenWalkers[128 /* TupleType */] = walkTupleTypeChildren;
    childrenWalkers[245 /* TypeAnnotation */] = walkTypeAnnotationChildren;
    childrenWalkers[229 /* TypeArgumentList */] = walkTypeArgumentListChildren;
    childrenWalkers[172 /* TypeOfExpression */] = walkTypeOfExpressionChildren;
    childrenWalkers[239 /* TypeParameter */] = walkTypeParameterChildren;
    childrenWalkers[230 /* TypeParameterList */] = walkTypeParameterListChildren;
    childrenWalkers[127 /* TypeQuery */] = walkTypeQueryChildren;
    childrenWalkers[186 /* UnsignedRightShiftAssignmentExpression */] = walkBinaryExpressionChildren;
    childrenWalkers[205 /* UnsignedRightShiftExpression */] = walkBinaryExpressionChildren;
    childrenWalkers[225 /* VariableDeclaration */] = walkVariableDeclarationChildren;
    childrenWalkers[226 /* VariableDeclarator */] = walkVariableDeclaratorChildren;
    childrenWalkers[149 /* VariableStatement */] = walkVariableStatementChildren;
    childrenWalkers[173 /* VoidExpression */] = walkVoidExpressionChildren;
    childrenWalkers[41 /* VoidKeyword */] = null;
    childrenWalkers[159 /* WhileStatement */] = walkWhileStatementChildren;
    childrenWalkers[164 /* WithStatement */] = walkWithStatementChildren;
    for (var e in TypeScript.SyntaxKind) {
        if (TypeScript.SyntaxKind.hasOwnProperty(e) && TypeScript.StringUtilities.isString(TypeScript.SyntaxKind[e])) {
            TypeScript.Debug.assert(childrenWalkers[e] !== undefined, "Fix initWalkers: " + TypeScript.SyntaxKind[e]);
        }
    }
    var AstWalkOptions = (function () {
        function AstWalkOptions() {
            this.goChildren = true;
            this.stopWalking = false;
        }
        return AstWalkOptions;
    })();
    TypeScript.AstWalkOptions = AstWalkOptions;
    var SimplePreAstWalker = (function () {
        function SimplePreAstWalker(pre, state) {
            this.pre = pre;
            this.state = state;
            this.options = new AstWalkOptions();
        }
        SimplePreAstWalker.prototype.walk = function (ast) {
            if (!ast) {
                return;
            }
            this.pre(ast, this.state);
            var walker = childrenWalkers[ast.kind()];
            if (walker) {
                walker(ast, this);
            }
        };
        return SimplePreAstWalker;
    })();
    var SimplePrePostAstWalker = (function () {
        function SimplePrePostAstWalker(pre, post, state) {
            this.pre = pre;
            this.post = post;
            this.state = state;
            this.options = new AstWalkOptions();
        }
        SimplePrePostAstWalker.prototype.walk = function (ast) {
            if (!ast) {
                return;
            }
            this.pre(ast, this.state);
            var walker = childrenWalkers[ast.kind()];
            if (walker) {
                walker(ast, this);
            }
            this.post(ast, this.state);
        };
        return SimplePrePostAstWalker;
    })();
    var NormalAstWalker = (function () {
        function NormalAstWalker(pre, post, state) {
            this.pre = pre;
            this.post = post;
            this.state = state;
            this.options = new AstWalkOptions();
        }
        NormalAstWalker.prototype.walk = function (ast) {
            if (!ast) {
                return;
            }
            // If we're stopping, then bail out immediately.
            if (this.options.stopWalking) {
                return;
            }
            this.pre(ast, this);
            // If we were asked to stop, then stop.
            if (this.options.stopWalking) {
                return;
            }
            if (this.options.goChildren) {
                // Call the "walkChildren" function corresponding to "nodeType".
                var walker = childrenWalkers[ast.kind()];
                if (walker) {
                    walker(ast, this);
                }
            }
            else {
                // no go only applies to children of node issuing it
                this.options.goChildren = true;
            }
            if (this.post) {
                this.post(ast, this);
            }
        };
        return NormalAstWalker;
    })();
    var AstWalkerFactory = (function () {
        function AstWalkerFactory() {
        }
        AstWalkerFactory.prototype.walk = function (ast, pre, post, state) {
            new NormalAstWalker(pre, post, state).walk(ast);
        };
        AstWalkerFactory.prototype.simpleWalk = function (ast, pre, post, state) {
            if (post) {
                new SimplePrePostAstWalker(pre, post, state).walk(ast);
            }
            else {
                new SimplePreAstWalker(pre, state).walk(ast);
            }
        };
        return AstWalkerFactory;
    })();
    TypeScript.AstWalkerFactory = AstWalkerFactory;
    var globalAstWalkerFactory = new AstWalkerFactory();
    function getAstWalkerFactory() {
        return globalAstWalkerFactory;
    }
    TypeScript.getAstWalkerFactory = getAstWalkerFactory;
})(TypeScript || (TypeScript = {}));
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
///<reference path='references.ts' />
var TypeScript;
(function (TypeScript) {
    var ASTHelpers;
    (function (ASTHelpers) {
        var sentinelEmptyArray = [];
        //export function scriptIsElided(sourceUnit: SourceUnitSyntax): boolean {
        //    return isDTSFile(sourceUnit.syntaxTree.fileName()) || moduleMembersAreElided(sourceUnit.moduleElements);
        //}
        //export function moduleIsElided(declaration: ModuleDeclarationSyntax): boolean {
        //    return hasModifier(declaration.modifiers, PullElementFlags.Ambient) || moduleMembersAreElided(declaration.moduleElements);
        //}
        //function moduleMembersAreElided(members: IModuleElementSyntax[]): boolean {
        //    for (var i = 0, n = members.length; i < n; i++) {
        //        var member = members[i];
        //        // We should emit *this* module if it contains any non-interface types. 
        //        // Caveat: if we have contain a module, then we should be emitted *if we want to
        //        // emit that inner module as well.
        //        if (member.kind() === SyntaxKind.ModuleDeclaration) {
        //            if (!moduleIsElided(<ModuleDeclarationSyntax>member)) {
        //                return false;
        //            }
        //        }
        //        else if (member.kind() !== SyntaxKind.InterfaceDeclaration) {
        //            return false;
        //        }
        //    }
        //    return true;
        //}
        //export function enumIsElided(declaration: EnumDeclarationSyntax): boolean {
        //    if (hasModifier(declaration.modifiers, PullElementFlags.Ambient)) {
        //        return true;
        //    }
        //    return false;
        //}
        function isValidAstNode(ast) {
            return ast && !TypeScript.isShared(ast) && TypeScript.start(ast) !== -1 && TypeScript.end(ast) !== -1;
        }
        ASTHelpers.isValidAstNode = isValidAstNode;
        function isValidSpan(ast) {
            if (!ast)
                return false;
            if (ast.start() === -1 || ast.end() === -1)
                return false;
            return true;
        }
        ASTHelpers.isValidSpan = isValidSpan;
        ///
        /// Return the ISyntaxElement containing "position"
        ///
        function getAstAtPosition(script, pos, useTrailingTriviaAsLimChar, forceInclusive) {
            if (useTrailingTriviaAsLimChar === void 0) { useTrailingTriviaAsLimChar = true; }
            if (forceInclusive === void 0) { forceInclusive = false; }
            var top = null;
            var pre = function (cur, walker) {
                if (!TypeScript.isShared(cur) && isValidAstNode(cur)) {
                    var isInvalid1 = cur.kind() === 150 /* ExpressionStatement */ && TypeScript.width(cur) === 0;
                    if (isInvalid1) {
                        walker.options.goChildren = false;
                    }
                    else {
                        // Add "cur" to the stack if it contains our position
                        // For "identifier" nodes, we need a special case: A position equal to "limChar" is
                        // valid, since the position corresponds to a caret position (in between characters)
                        // For example:
                        //  bar
                        //  0123
                        // If "position === 3", the caret is at the "right" of the "r" character, which should be considered valid
                        var inclusive = forceInclusive || cur.kind() === 11 /* IdentifierName */ || cur.kind() === 213 /* MemberAccessExpression */ || cur.kind() === 121 /* QualifiedName */ || cur.kind() === 225 /* VariableDeclaration */ || cur.kind() === 226 /* VariableDeclarator */ || cur.kind() === 214 /* InvocationExpression */ || pos === TypeScript.end(script) + TypeScript.lastToken(script).trailingTriviaWidth(); // Special "EOF" case
                        var minChar = TypeScript.start(cur);
                        var limChar = TypeScript.end(cur) + (useTrailingTriviaAsLimChar ? TypeScript.trailingTriviaWidth(cur) : 0) + (inclusive ? 1 : 0);
                        if (pos >= minChar && pos < limChar) {
                            // Ignore empty lists
                            if ((cur.kind() !== 1 /* List */ && cur.kind() !== 2 /* SeparatedList */) || TypeScript.end(cur) > TypeScript.start(cur)) {
                                // TODO: Since ISyntaxElement is sometimes not correct wrt to position, only add "cur" if it's better
                                //       than top of the stack.
                                if (top === null) {
                                    top = cur;
                                }
                                else if (TypeScript.start(cur) >= TypeScript.start(top) && (TypeScript.end(cur) + (useTrailingTriviaAsLimChar ? TypeScript.trailingTriviaWidth(cur) : 0)) <= (TypeScript.end(top) + (useTrailingTriviaAsLimChar ? TypeScript.trailingTriviaWidth(top) : 0))) {
                                    // this new node appears to be better than the one we're 
                                    // storing.  Make this the new node.
                                    // However, If the current top is a missing identifier, we 
                                    // don't want to replace it with another missing identifier.
                                    // We want to return the first missing identifier found in a
                                    // depth first walk of  the tree.
                                    if (TypeScript.width(top) !== 0 || TypeScript.width(cur) !== 0) {
                                        top = cur;
                                    }
                                }
                            }
                        }
                        // Don't go further down the tree if pos is outside of [minChar, limChar]
                        walker.options.goChildren = (minChar <= pos && pos <= limChar);
                    }
                }
            };
            TypeScript.getAstWalkerFactory().walk(script, pre);
            return top;
        }
        ASTHelpers.getAstAtPosition = getAstAtPosition;
        function getExtendsHeritageClause(clauses) {
            return getHeritageClause(clauses, 231 /* ExtendsHeritageClause */);
        }
        ASTHelpers.getExtendsHeritageClause = getExtendsHeritageClause;
        function getImplementsHeritageClause(clauses) {
            return getHeritageClause(clauses, 232 /* ImplementsHeritageClause */);
        }
        ASTHelpers.getImplementsHeritageClause = getImplementsHeritageClause;
        function getHeritageClause(clauses, kind) {
            if (clauses) {
                for (var i = 0, n = clauses.length; i < n; i++) {
                    var child = clauses[i];
                    if (child.typeNames.length > 0 && child.kind() === kind) {
                        return child;
                    }
                }
            }
            return null;
        }
        function isCallExpression(ast) {
            return (ast && ast.kind() === 214 /* InvocationExpression */) || (ast && ast.kind() === 217 /* ObjectCreationExpression */);
        }
        ASTHelpers.isCallExpression = isCallExpression;
        function isCallExpressionTarget(ast) {
            return !!getCallExpressionTarget(ast);
        }
        ASTHelpers.isCallExpressionTarget = isCallExpressionTarget;
        function getCallExpressionTarget(ast) {
            if (!ast) {
                return null;
            }
            var current = ast;
            while (current && current.parent) {
                if (current.parent.kind() === 213 /* MemberAccessExpression */ && current.parent.name === current) {
                    current = current.parent;
                    continue;
                }
                break;
            }
            if (current && current.parent) {
                if (current.parent.kind() === 214 /* InvocationExpression */ || current.parent.kind() === 217 /* ObjectCreationExpression */) {
                    return current === current.parent.expression ? current : null;
                }
            }
            return null;
        }
        ASTHelpers.getCallExpressionTarget = getCallExpressionTarget;
        function isNameOfSomeDeclaration(ast) {
            if (ast === null || ast.parent === null) {
                return false;
            }
            if (ast.kind() !== 11 /* IdentifierName */) {
                return false;
            }
            switch (ast.parent.kind()) {
                case 132 /* ClassDeclaration */:
                    return ast.parent.identifier === ast;
                case 129 /* InterfaceDeclaration */:
                    return ast.parent.identifier === ast;
                case 133 /* EnumDeclaration */:
                    return ast.parent.identifier === ast;
                case 131 /* ModuleDeclaration */:
                    return ast.parent.name === ast || ast.parent.stringLiteral === ast;
                case 226 /* VariableDeclarator */:
                    return ast.parent.propertyName === ast;
                case 130 /* FunctionDeclaration */:
                    return ast.parent.identifier === ast;
                case 136 /* MemberFunctionDeclaration */:
                    return ast.parent.propertyName === ast;
                case 243 /* Parameter */:
                    return ast.parent.identifier === ast;
                case 239 /* TypeParameter */:
                    return ast.parent.identifier === ast;
                case 241 /* SimplePropertyAssignment */:
                    return ast.parent.propertyName === ast;
                case 242 /* FunctionPropertyAssignment */:
                    return ast.parent.propertyName === ast;
                case 244 /* EnumElement */:
                    return ast.parent.propertyName === ast;
                case 134 /* ImportDeclaration */:
                    return ast.parent.identifier === ast;
                case 146 /* MethodSignature */:
                    return ast.parent.propertyName === ast;
                case 142 /* PropertySignature */:
                    return ast.parent.propertyName === ast;
            }
            return false;
        }
        function isDeclarationASTOrDeclarationNameAST(ast) {
            return isNameOfSomeDeclaration(ast) || ASTHelpers.isDeclarationAST(ast);
        }
        ASTHelpers.isDeclarationASTOrDeclarationNameAST = isDeclarationASTOrDeclarationNameAST;
        function getEnclosingParameterForInitializer(ast) {
            var current = ast;
            while (current) {
                switch (current.kind()) {
                    case 233 /* EqualsValueClause */:
                        if (current.parent && current.parent.kind() === 243 /* Parameter */) {
                            return current.parent;
                        }
                        break;
                    case 132 /* ClassDeclaration */:
                    case 129 /* InterfaceDeclaration */:
                    case 131 /* ModuleDeclaration */:
                        // exit early
                        return null;
                }
                current = current.parent;
            }
            return null;
        }
        ASTHelpers.getEnclosingParameterForInitializer = getEnclosingParameterForInitializer;
        function getEnclosingMemberDeclaration(ast) {
            var current = ast;
            while (current) {
                switch (current.kind()) {
                    case 137 /* MemberVariableDeclaration */:
                    case 146 /* MethodSignature */:
                    case 136 /* MemberFunctionDeclaration */:
                    case 140 /* GetAccessor */:
                    case 141 /* SetAccessor */:
                        return current;
                    case 132 /* ClassDeclaration */:
                    case 129 /* InterfaceDeclaration */:
                    case 131 /* ModuleDeclaration */:
                        // exit early
                        return null;
                }
                current = current.parent;
            }
            return null;
        }
        ASTHelpers.getEnclosingMemberDeclaration = getEnclosingMemberDeclaration;
        function isNameOfFunction(ast) {
            return ast && ast.parent && ast.kind() === 11 /* IdentifierName */ && ast.parent.kind() === 130 /* FunctionDeclaration */ && ast.parent.identifier === ast;
        }
        ASTHelpers.isNameOfFunction = isNameOfFunction;
        function isNameOfMemberFunction(ast) {
            return ast && ast.parent && ast.kind() === 11 /* IdentifierName */ && ast.parent.kind() === 136 /* MemberFunctionDeclaration */ && ast.parent.propertyName === ast;
        }
        ASTHelpers.isNameOfMemberFunction = isNameOfMemberFunction;
        function isNameOfMemberAccessExpression(ast) {
            if (ast && ast.parent && ast.parent.kind() === 213 /* MemberAccessExpression */ && ast.parent.name === ast) {
                return true;
            }
            return false;
        }
        ASTHelpers.isNameOfMemberAccessExpression = isNameOfMemberAccessExpression;
        function isRightSideOfQualifiedName(ast) {
            if (ast && ast.parent && ast.parent.kind() === 121 /* QualifiedName */ && ast.parent.right === ast) {
                return true;
            }
            return false;
        }
        ASTHelpers.isRightSideOfQualifiedName = isRightSideOfQualifiedName;
        function parentIsModuleDeclaration(ast) {
            return ast.parent && ast.parent.kind() === 131 /* ModuleDeclaration */;
        }
        ASTHelpers.parentIsModuleDeclaration = parentIsModuleDeclaration;
        function isDeclarationAST(ast) {
            switch (ast.kind()) {
                case 226 /* VariableDeclarator */:
                    return getVariableStatement(ast) !== null;
                case 134 /* ImportDeclaration */:
                case 132 /* ClassDeclaration */:
                case 129 /* InterfaceDeclaration */:
                case 243 /* Parameter */:
                case 220 /* SimpleArrowFunctionExpression */:
                case 219 /* ParenthesizedArrowFunctionExpression */:
                case 145 /* IndexSignature */:
                case 130 /* FunctionDeclaration */:
                case 131 /* ModuleDeclaration */:
                case 124 /* ArrayType */:
                case 122 /* ObjectType */:
                case 239 /* TypeParameter */:
                case 138 /* ConstructorDeclaration */:
                case 136 /* MemberFunctionDeclaration */:
                case 140 /* GetAccessor */:
                case 141 /* SetAccessor */:
                case 137 /* MemberVariableDeclaration */:
                case 139 /* IndexMemberDeclaration */:
                case 133 /* EnumDeclaration */:
                case 244 /* EnumElement */:
                case 241 /* SimplePropertyAssignment */:
                case 242 /* FunctionPropertyAssignment */:
                case 223 /* FunctionExpression */:
                case 143 /* CallSignature */:
                case 144 /* ConstructSignature */:
                case 146 /* MethodSignature */:
                case 142 /* PropertySignature */:
                    return true;
                default:
                    return false;
            }
        }
        ASTHelpers.isDeclarationAST = isDeclarationAST;
        function preComments(element, text) {
            if (element) {
                switch (element.kind()) {
                    case 149 /* VariableStatement */:
                    case 150 /* ExpressionStatement */:
                    case 132 /* ClassDeclaration */:
                    case 134 /* ImportDeclaration */:
                    case 130 /* FunctionDeclaration */:
                    case 131 /* ModuleDeclaration */:
                    case 133 /* EnumDeclaration */:
                    case 148 /* IfStatement */:
                    case 241 /* SimplePropertyAssignment */:
                    case 136 /* MemberFunctionDeclaration */:
                    case 129 /* InterfaceDeclaration */:
                    case 140 /* GetAccessor */:
                    case 141 /* SetAccessor */:
                    case 151 /* ReturnStatement */:
                    case 138 /* ConstructorDeclaration */:
                    case 137 /* MemberVariableDeclaration */:
                    case 244 /* EnumElement */:
                    case 143 /* CallSignature */:
                    case 144 /* ConstructSignature */:
                    case 145 /* IndexSignature */:
                    case 142 /* PropertySignature */:
                    case 146 /* MethodSignature */:
                    case 242 /* FunctionPropertyAssignment */:
                    case 243 /* Parameter */:
                        return convertNodeLeadingComments(element, text);
                }
            }
            return null;
        }
        ASTHelpers.preComments = preComments;
        function postComments(element, text) {
            if (element) {
                switch (element.kind()) {
                    case 150 /* ExpressionStatement */:
                        return convertNodeTrailingComments(element, text, true);
                    case 149 /* VariableStatement */:
                    case 132 /* ClassDeclaration */:
                    case 134 /* ImportDeclaration */:
                    case 130 /* FunctionDeclaration */:
                    case 131 /* ModuleDeclaration */:
                    case 133 /* EnumDeclaration */:
                    case 148 /* IfStatement */:
                    case 241 /* SimplePropertyAssignment */:
                    case 136 /* MemberFunctionDeclaration */:
                    case 129 /* InterfaceDeclaration */:
                    case 140 /* GetAccessor */:
                    case 141 /* SetAccessor */:
                    case 151 /* ReturnStatement */:
                    case 138 /* ConstructorDeclaration */:
                    case 137 /* MemberVariableDeclaration */:
                    case 244 /* EnumElement */:
                    case 143 /* CallSignature */:
                    case 144 /* ConstructSignature */:
                    case 145 /* IndexSignature */:
                    case 142 /* PropertySignature */:
                    case 146 /* MethodSignature */:
                    case 242 /* FunctionPropertyAssignment */:
                    case 243 /* Parameter */:
                        return convertNodeTrailingComments(element, text);
                }
            }
            return null;
        }
        ASTHelpers.postComments = postComments;
        function convertNodeTrailingComments(node, text, allowWithNewLine) {
            if (allowWithNewLine === void 0) { allowWithNewLine = false; }
            // Bail out quickly before doing any expensive math computation.
            var _lastToken = TypeScript.lastToken(node);
            if (_lastToken === null || !_lastToken.hasTrailingTrivia()) {
                return null;
            }
            if (!allowWithNewLine && TypeScript.SyntaxUtilities.isLastTokenOnLine(_lastToken, text)) {
                return null;
            }
            return convertComments(_lastToken.trailingTrivia(text), TypeScript.fullStart(node) + TypeScript.fullWidth(node) - _lastToken.trailingTriviaWidth(text));
        }
        function convertNodeLeadingComments(element, text) {
            if (element) {
                return convertTokenLeadingComments(TypeScript.firstToken(element), text);
            }
            return null;
        }
        function convertTokenLeadingComments(token, text) {
            if (token === null) {
                return null;
            }
            return token.hasLeadingTrivia() ? convertComments(token.leadingTrivia(text), token.fullStart()) : null;
        }
        ASTHelpers.convertTokenLeadingComments = convertTokenLeadingComments;
        function convertTokenTrailingComments(token, text) {
            if (token === null) {
                return null;
            }
            return token.hasTrailingTrivia() ? convertComments(token.trailingTrivia(text), TypeScript.fullEnd(token) - token.trailingTriviaWidth(text)) : null;
        }
        ASTHelpers.convertTokenTrailingComments = convertTokenTrailingComments;
        function convertComments(triviaList, commentStartPosition) {
            var result = null;
            for (var i = 0, n = triviaList.count(); i < n; i++) {
                var trivia = triviaList.syntaxTriviaAt(i);
                if (trivia.isComment()) {
                    var hasTrailingNewLine = ((i + 1) < n) && triviaList.syntaxTriviaAt(i + 1).isNewLine();
                    result = result || [];
                    result.push(convertComment(trivia, commentStartPosition, hasTrailingNewLine));
                }
                commentStartPosition += trivia.fullWidth();
            }
            return result;
        }
        function convertComment(trivia, commentStartPosition, hasTrailingNewLine) {
            var comment = new TypeScript.Comment(trivia, hasTrailingNewLine, commentStartPosition, commentStartPosition + trivia.fullWidth());
            return comment;
        }
        function docComments(ast, text) {
            if (isDeclarationAST(ast)) {
                var comments = null;
                if (ast.kind() === 226 /* VariableDeclarator */) {
                    // Get the doc comments for a variable off of the variable statement.  That's what
                    // they'll be attached to in the tree.
                    comments = TypeScript.ASTHelpers.preComments(getVariableStatement(ast), text);
                }
                else if (ast.kind() === 243 /* Parameter */) {
                    // First check if the parameter was written like so:
                    //      (
                    //          /** blah */ a,
                    //          /** blah */ b);
                    comments = TypeScript.ASTHelpers.preComments(ast, text);
                    if (!comments) {
                        // Now check if it was written like so:
                        //      (/** blah */ a, /** blah */ b);
                        // In this case, the comment will belong to the preceding token.
                        var previousToken = TypeScript.findToken(TypeScript.syntaxTree(ast).sourceUnit(), TypeScript.firstToken(ast).fullStart() - 1);
                        if (previousToken && (previousToken.kind() === 72 /* OpenParenToken */ || previousToken.kind() === 79 /* CommaToken */)) {
                            comments = convertTokenTrailingComments(previousToken, text);
                        }
                    }
                }
                else {
                    comments = TypeScript.ASTHelpers.preComments(ast, text);
                }
                if (comments && comments.length > 0) {
                    return comments.filter(function (c) { return isDocComment(c); });
                }
            }
            return sentinelEmptyArray;
        }
        ASTHelpers.docComments = docComments;
        function isDocComment(comment) {
            if (comment.kind() === 6 /* MultiLineCommentTrivia */) {
                var fullText = comment.fullText();
                return fullText.charAt(2) === "*" && fullText.charAt(3) !== "/";
            }
            return false;
        }
        ASTHelpers.isDocComment = isDocComment;
        function getParameterList(ast) {
            if (ast) {
                switch (ast.kind()) {
                    case 138 /* ConstructorDeclaration */:
                        return getParameterList(ast.callSignature);
                    case 130 /* FunctionDeclaration */:
                        return getParameterList(ast.callSignature);
                    case 219 /* ParenthesizedArrowFunctionExpression */:
                        return getParameterList(ast.callSignature);
                    case 144 /* ConstructSignature */:
                        return getParameterList(ast.callSignature);
                    case 136 /* MemberFunctionDeclaration */:
                        return getParameterList(ast.callSignature);
                    case 242 /* FunctionPropertyAssignment */:
                        return getParameterList(ast.callSignature);
                    case 223 /* FunctionExpression */:
                        return getParameterList(ast.callSignature);
                    case 146 /* MethodSignature */:
                        return getParameterList(ast.callSignature);
                    case 125 /* ConstructorType */:
                        return ast.parameterList;
                    case 123 /* FunctionType */:
                        return ast.parameterList;
                    case 143 /* CallSignature */:
                        return ast.parameterList;
                    case 140 /* GetAccessor */:
                        return getParameterList(ast.callSignature);
                    case 141 /* SetAccessor */:
                        return getParameterList(ast.callSignature);
                }
            }
            return null;
        }
        ASTHelpers.getParameterList = getParameterList;
        function getType(ast) {
            if (ast) {
                switch (ast.kind()) {
                    case 130 /* FunctionDeclaration */:
                        return getType(ast.callSignature);
                    case 219 /* ParenthesizedArrowFunctionExpression */:
                        return getType(ast.callSignature);
                    case 144 /* ConstructSignature */:
                        return getType(ast.callSignature);
                    case 136 /* MemberFunctionDeclaration */:
                        return getType(ast.callSignature);
                    case 242 /* FunctionPropertyAssignment */:
                        return getType(ast.callSignature);
                    case 223 /* FunctionExpression */:
                        return getType(ast.callSignature);
                    case 146 /* MethodSignature */:
                        return getType(ast.callSignature);
                    case 143 /* CallSignature */:
                        return getType(ast.typeAnnotation);
                    case 145 /* IndexSignature */:
                        return getType(ast.typeAnnotation);
                    case 142 /* PropertySignature */:
                        return getType(ast.typeAnnotation);
                    case 140 /* GetAccessor */:
                        return getType(ast.callSignature);
                    case 243 /* Parameter */:
                        return getType(ast.typeAnnotation);
                    case 137 /* MemberVariableDeclaration */:
                        return getType(ast.variableDeclarator);
                    case 226 /* VariableDeclarator */:
                        return getType(ast.typeAnnotation);
                    case 237 /* CatchClause */:
                        return getType(ast.typeAnnotation);
                    case 125 /* ConstructorType */:
                        return ast.type;
                    case 123 /* FunctionType */:
                        return ast.type;
                    case 245 /* TypeAnnotation */:
                        return ast.type;
                }
            }
            return null;
        }
        ASTHelpers.getType = getType;
        function getVariableStatement(variableDeclarator) {
            if (variableDeclarator && variableDeclarator.parent && variableDeclarator.parent.parent && variableDeclarator.parent.parent.parent && variableDeclarator.parent.kind() === 2 /* SeparatedList */ && variableDeclarator.parent.parent.kind() === 225 /* VariableDeclaration */ && variableDeclarator.parent.parent.parent.kind() === 149 /* VariableStatement */) {
                return variableDeclarator.parent.parent.parent;
            }
            return null;
        }
        function getVariableDeclaratorModifiers(variableDeclarator) {
            var variableStatement = getVariableStatement(variableDeclarator);
            return variableStatement ? variableStatement.modifiers : TypeScript.Syntax.emptyList();
        }
        ASTHelpers.getVariableDeclaratorModifiers = getVariableDeclaratorModifiers;
        function isIntegerLiteralAST(expression) {
            if (expression) {
                switch (expression.kind()) {
                    case 165 /* PlusExpression */:
                    case 166 /* NegateExpression */:
                        // Note: if there is a + or - sign, we can only allow a normal integer following
                        // (and not a hex integer).  i.e. -0xA is a legal expression, but it is not a 
                        // *literal*.
                        expression = expression.operand;
                        return expression.kind() === 13 /* NumericLiteral */ && TypeScript.IntegerUtilities.isInteger(expression.text());
                    case 13 /* NumericLiteral */:
                        // If it doesn't have a + or -, then either an integer literal or a hex literal
                        // is acceptable.
                        var text = expression.text();
                        return TypeScript.IntegerUtilities.isInteger(text) || TypeScript.IntegerUtilities.isHexInteger(text);
                }
            }
            return false;
        }
        ASTHelpers.isIntegerLiteralAST = isIntegerLiteralAST;
        function getEnclosingModuleDeclaration(ast) {
            while (ast) {
                if (ast.kind() === 131 /* ModuleDeclaration */) {
                    return ast;
                }
                ast = ast.parent;
            }
            return null;
        }
        ASTHelpers.getEnclosingModuleDeclaration = getEnclosingModuleDeclaration;
        function isEntireNameOfModuleDeclaration(nameAST) {
            return parentIsModuleDeclaration(nameAST) && nameAST.parent.name === nameAST;
        }
        function getModuleDeclarationFromNameAST(ast) {
            if (ast) {
                switch (ast.kind()) {
                    case 14 /* StringLiteral */:
                        if (parentIsModuleDeclaration(ast) && ast.parent.stringLiteral === ast) {
                            return ast.parent;
                        }
                        return null;
                    case 11 /* IdentifierName */:
                    case 121 /* QualifiedName */:
                        if (isEntireNameOfModuleDeclaration(ast)) {
                            return ast.parent;
                        }
                        break;
                    default:
                        return null;
                }
                for (ast = ast.parent; ast && ast.kind() === 121 /* QualifiedName */; ast = ast.parent) {
                    if (isEntireNameOfModuleDeclaration(ast)) {
                        return ast.parent;
                    }
                }
            }
            return null;
        }
        ASTHelpers.getModuleDeclarationFromNameAST = getModuleDeclarationFromNameAST;
        function isLastNameOfModule(ast, astName) {
            if (ast) {
                if (ast.stringLiteral) {
                    return astName === ast.stringLiteral;
                }
                else if (ast.name.kind() === 121 /* QualifiedName */) {
                    return astName === ast.name.right;
                }
                else {
                    return astName === ast.name;
                }
            }
            return false;
        }
        ASTHelpers.isLastNameOfModule = isLastNameOfModule;
        function getNameOfIdentifierOrQualifiedName(name) {
            if (name.kind() === 11 /* IdentifierName */) {
                return name.text();
            }
            else {
                TypeScript.Debug.assert(name.kind() == 121 /* QualifiedName */);
                var dotExpr = name;
                return getNameOfIdentifierOrQualifiedName(dotExpr.left) + "." + getNameOfIdentifierOrQualifiedName(dotExpr.right);
            }
        }
        ASTHelpers.getNameOfIdentifierOrQualifiedName = getNameOfIdentifierOrQualifiedName;
        function getModuleNames(name, result) {
            result = result || [];
            if (name.kind() === 121 /* QualifiedName */) {
                getModuleNames(name.left, result);
                result.push(name.right);
            }
            else {
                result.push(name);
            }
            return result;
        }
        ASTHelpers.getModuleNames = getModuleNames;
    })(ASTHelpers = TypeScript.ASTHelpers || (TypeScript.ASTHelpers = {}));
})(TypeScript || (TypeScript = {}));
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
///<reference path='references.ts' />
var TypeScript;
(function (TypeScript) {
    var MemberName = (function () {
        function MemberName() {
            this.prefix = "";
            this.suffix = "";
        }
        MemberName.prototype.isString = function () {
            return false;
        };
        MemberName.prototype.isArray = function () {
            return false;
        };
        MemberName.prototype.isMarker = function () {
            return !this.isString() && !this.isArray();
        };
        MemberName.prototype.toString = function () {
            return MemberName.memberNameToString(this);
        };
        MemberName.memberNameToString = function (memberName, markerInfo, markerBaseLength) {
            if (markerBaseLength === void 0) { markerBaseLength = 0; }
            var result = memberName.prefix;
            if (memberName.isString()) {
                result += memberName.text;
            }
            else if (memberName.isArray()) {
                var ar = memberName;
                for (var index = 0; index < ar.entries.length; index++) {
                    if (ar.entries[index].isMarker()) {
                        if (markerInfo) {
                            markerInfo.push(markerBaseLength + result.length);
                        }
                        continue;
                    }
                    result += MemberName.memberNameToString(ar.entries[index], markerInfo, markerBaseLength + result.length);
                    result += ar.delim;
                }
            }
            result += memberName.suffix;
            return result;
        };
        MemberName.create = function (arg1, arg2, arg3) {
            if (typeof arg1 === "string") {
                return new MemberNameString(arg1);
            }
            else {
                var result = new MemberNameArray();
                if (arg2)
                    result.prefix = arg2;
                if (arg3)
                    result.suffix = arg3;
                result.entries.push(arg1);
                return result;
            }
        };
        return MemberName;
    })();
    TypeScript.MemberName = MemberName;
    var MemberNameString = (function (_super) {
        __extends(MemberNameString, _super);
        function MemberNameString(text) {
            _super.call(this);
            this.text = text;
        }
        MemberNameString.prototype.isString = function () {
            return true;
        };
        return MemberNameString;
    })(MemberName);
    TypeScript.MemberNameString = MemberNameString;
    var MemberNameArray = (function (_super) {
        __extends(MemberNameArray, _super);
        function MemberNameArray() {
            _super.call(this);
            this.delim = "";
            this.entries = [];
        }
        MemberNameArray.prototype.isArray = function () {
            return true;
        };
        MemberNameArray.prototype.add = function (entry) {
            this.entries.push(entry);
        };
        MemberNameArray.prototype.addAll = function (entries) {
            for (var i = 0; i < entries.length; i++) {
                this.entries.push(entries[i]);
            }
        };
        return MemberNameArray;
    })(MemberName);
    TypeScript.MemberNameArray = MemberNameArray;
})(TypeScript || (TypeScript = {}));
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
///<reference path='references.ts' />
var TypeScript;
(function (TypeScript) {
    function stripStartAndEndQuotes(str) {
        var firstCharCode = str && str.charCodeAt(0);
        if (str && str.length >= 2 && firstCharCode === str.charCodeAt(str.length - 1) && (firstCharCode === 39 /* singleQuote */ || firstCharCode === 34 /* doubleQuote */)) {
            return str.substring(1, str.length - 1);
        }
        return str;
    }
    TypeScript.stripStartAndEndQuotes = stripStartAndEndQuotes;
    function isSingleQuoted(str) {
        return str && str.length >= 2 && str.charCodeAt(0) === str.charCodeAt(str.length - 1) && str.charCodeAt(0) === 39 /* singleQuote */;
    }
    TypeScript.isSingleQuoted = isSingleQuoted;
    function isDoubleQuoted(str) {
        return str && str.length >= 2 && str.charCodeAt(0) === str.charCodeAt(str.length - 1) && str.charCodeAt(0) === 34 /* doubleQuote */;
    }
    TypeScript.isDoubleQuoted = isDoubleQuoted;
    function isQuoted(str) {
        return isDoubleQuoted(str) || isSingleQuoted(str);
    }
    TypeScript.isQuoted = isQuoted;
    function quoteStr(str) {
        return "\"" + str + "\"";
    }
    TypeScript.quoteStr = quoteStr;
    var switchToForwardSlashesRegEx = /\\/g;
    function switchToForwardSlashes(path) {
        return path.replace(switchToForwardSlashesRegEx, "/");
    }
    TypeScript.switchToForwardSlashes = switchToForwardSlashes;
    function trimModName(modName) {
        // in case's it's a declare file...
        if (modName.length > 5 && modName.substring(modName.length - 5, modName.length) === ".d.ts") {
            return modName.substring(0, modName.length - 5);
        }
        if (modName.length > 3 && modName.substring(modName.length - 3, modName.length) === ".ts") {
            return modName.substring(0, modName.length - 3);
        }
        // in case's it's a .js file
        if (modName.length > 3 && modName.substring(modName.length - 3, modName.length) === ".js") {
            return modName.substring(0, modName.length - 3);
        }
        return modName;
    }
    TypeScript.trimModName = trimModName;
    function getDeclareFilePath(fname) {
        return isTSFile(fname) ? changePathToDTS(fname) : changePathToDTS(fname);
    }
    TypeScript.getDeclareFilePath = getDeclareFilePath;
    function isFileOfExtension(fname, ext) {
        var invariantFname = fname.toLocaleUpperCase();
        var invariantExt = ext.toLocaleUpperCase();
        var extLength = invariantExt.length;
        return invariantFname.length > extLength && invariantFname.substring(invariantFname.length - extLength, invariantFname.length) === invariantExt;
    }
    function isTSFile(fname) {
        return isFileOfExtension(fname, ".ts");
    }
    TypeScript.isTSFile = isTSFile;
    function isDTSFile(fname) {
        return isFileOfExtension(fname, ".d.ts");
    }
    TypeScript.isDTSFile = isDTSFile;
    function getPrettyName(modPath, quote, treatAsFileName) {
        if (quote === void 0) { quote = true; }
        if (treatAsFileName === void 0) { treatAsFileName = false; }
        var modName = treatAsFileName ? switchToForwardSlashes(modPath) : trimModName(stripStartAndEndQuotes(modPath));
        var components = this.getPathComponents(modName);
        return components.length ? (quote ? quoteStr(components[components.length - 1]) : components[components.length - 1]) : modPath;
    }
    TypeScript.getPrettyName = getPrettyName;
    function getPathComponents(path) {
        return path.split("/");
    }
    TypeScript.getPathComponents = getPathComponents;
    function getRelativePathToFixedPath(fixedModFilePath, absoluteModPath, isAbsoultePathURL) {
        if (isAbsoultePathURL === void 0) { isAbsoultePathURL = true; }
        absoluteModPath = switchToForwardSlashes(absoluteModPath);
        var modComponents = this.getPathComponents(absoluteModPath);
        var fixedModComponents = this.getPathComponents(fixedModFilePath);
        // Find the component that differs
        var joinStartIndex = 0;
        for (; joinStartIndex < modComponents.length && joinStartIndex < fixedModComponents.length; joinStartIndex++) {
            if (fixedModComponents[joinStartIndex] !== modComponents[joinStartIndex]) {
                break;
            }
        }
        // Get the relative path
        if (joinStartIndex !== 0) {
            var relativePath = "";
            var relativePathComponents = modComponents.slice(joinStartIndex, modComponents.length);
            for (; joinStartIndex < fixedModComponents.length; joinStartIndex++) {
                if (fixedModComponents[joinStartIndex] !== "") {
                    relativePath = relativePath + "../";
                }
            }
            return relativePath + relativePathComponents.join("/");
        }
        if (isAbsoultePathURL && absoluteModPath.indexOf("://") === -1) {
            absoluteModPath = "file:///" + absoluteModPath;
        }
        return absoluteModPath;
    }
    TypeScript.getRelativePathToFixedPath = getRelativePathToFixedPath;
    function changePathToDTS(modPath) {
        return trimModName(stripStartAndEndQuotes(modPath)) + ".d.ts";
    }
    TypeScript.changePathToDTS = changePathToDTS;
    function isRelative(path) {
        return path.length > 0 && path.charAt(0) === ".";
    }
    TypeScript.isRelative = isRelative;
    function isRooted(path) {
        return path.length > 0 && (path.charAt(0) === "\\" || path.charAt(0) === "/" || (path.indexOf(":\\") !== -1) || (path.indexOf(":/") !== -1));
    }
    TypeScript.isRooted = isRooted;
    function getRootFilePath(outFname) {
        if (outFname === "") {
            return outFname;
        }
        else {
            var isPath = outFname.indexOf("/") !== -1;
            return isPath ? filePath(outFname) : "";
        }
    }
    TypeScript.getRootFilePath = getRootFilePath;
    function filePathComponents(fullPath) {
        fullPath = switchToForwardSlashes(fullPath);
        var components = getPathComponents(fullPath);
        return components.slice(0, components.length - 1);
    }
    TypeScript.filePathComponents = filePathComponents;
    function filePath(fullPath) {
        var path = filePathComponents(fullPath);
        return path.join("/") + "/";
    }
    TypeScript.filePath = filePath;
    function convertToDirectoryPath(dirPath) {
        if (dirPath && dirPath.charAt(dirPath.length - 1) !== "/") {
            dirPath += "/";
        }
        return dirPath;
    }
    TypeScript.convertToDirectoryPath = convertToDirectoryPath;
    var normalizePathRegEx = /^\\\\[^\\]/;
    function normalizePath(path) {
        // If it's a UNC style path (i.e. \\server\share), convert to a URI style (i.e. file://server/share)
        if (normalizePathRegEx.test(path)) {
            path = "file:" + path;
        }
        var parts = this.getPathComponents(switchToForwardSlashes(path));
        var normalizedParts = [];
        for (var i = 0; i < parts.length; i++) {
            var part = parts[i];
            if (part === ".") {
                continue;
            }
            if (normalizedParts.length > 0 && TypeScript.ArrayUtilities.last(normalizedParts) !== ".." && part === "..") {
                normalizedParts.pop();
                continue;
            }
            normalizedParts.push(part);
        }
        return normalizedParts.join("/");
    }
    TypeScript.normalizePath = normalizePath;
})(TypeScript || (TypeScript = {}));
/// <reference path="..\compiler\types.ts"/>
/// <reference path="..\compiler\core.ts"/>
/// <reference path="..\compiler\scanner.ts"/>
/// <reference path="..\compiler\parser.ts"/>
/// <reference path="..\compiler\checker.ts"/>
/// <reference path='syntax\incrementalParser.ts' />
/// <reference path='outliningElementsCollector.ts' />
/// <reference path='getScriptLexicalStructureWalker.ts' />
/// <reference path='breakpoints.ts' />
/// <reference path='indentation.ts' />
/// <reference path='formatting\formatting.ts' />
/// <reference path='formatting\smartIndenter.ts' />
/// <reference path='core\references.ts' />
/// <reference path='resources\references.ts' />
/// <reference path='text\references.ts' />
/// <reference path='syntax\references.ts' />
/// <reference path='compiler\diagnostics.ts' />
/// <reference path='compiler\hashTable.ts' />
/// <reference path='compiler\ast.ts' />
/// <reference path='compiler\astWalker.ts' />
/// <reference path='compiler\astHelpers.ts' />
/// <reference path='compiler\types.ts' />
/// <reference path='compiler\pathUtils.ts' />
var ts;
(function (ts) {
    var scanner = ts.createScanner(1 /* ES5 */, true);
    var emptyArray = [];
    function createNode(kind, pos, end, flags, parent) {
        var node = new (ts.getNodeConstructor(kind))();
        node.pos = pos;
        node.end = end;
        node.flags = flags;
        node.parent = parent;
        return node;
    }
    var NodeObject = (function () {
        function NodeObject() {
        }
        NodeObject.prototype.getSourceFile = function () {
            return ts.getSourceFileOfNode(this);
        };
        NodeObject.prototype.getStart = function (sourceFile) {
            return ts.getTokenPosOfNode(this, sourceFile);
        };
        NodeObject.prototype.getFullStart = function () {
            return this.pos;
        };
        NodeObject.prototype.getEnd = function () {
            return this.end;
        };
        NodeObject.prototype.getWidth = function (sourceFile) {
            return this.getEnd() - this.getStart(sourceFile);
        };
        NodeObject.prototype.getFullWidth = function () {
            return this.end - this.getFullStart();
        };
        NodeObject.prototype.getLeadingTriviaWidth = function (sourceFile) {
            return this.getStart(sourceFile) - this.pos;
        };
        NodeObject.prototype.getFullText = function (sourceFile) {
            return (sourceFile || this.getSourceFile()).text.substring(this.pos, this.end);
        };
        NodeObject.prototype.addSyntheticNodes = function (nodes, pos, end) {
            scanner.setTextPos(pos);
            while (pos < end) {
                var token = scanner.scan();
                var textPos = scanner.getTextPos();
                var node = nodes.push(createNode(token, pos, textPos, 512 /* Synthetic */, this));
                pos = textPos;
            }
            return pos;
        };
        NodeObject.prototype.createSyntaxList = function (nodes) {
            var list = createNode(184 /* SyntaxList */, nodes.pos, nodes.end, 512 /* Synthetic */, this);
            list._children = [];
            var pos = nodes.pos;
            for (var i = 0, len = nodes.length; i < len; i++) {
                var node = nodes[i];
                if (pos < node.pos) {
                    pos = this.addSyntheticNodes(list._children, pos, node.pos);
                }
                list._children.push(node);
                pos = node.end;
            }
            if (pos < nodes.end) {
                this.addSyntheticNodes(list._children, pos, nodes.end);
            }
            return list;
        };
        NodeObject.prototype.createChildren = function (sourceFile) {
            var _this = this;
            if (this.kind > 115 /* Missing */) {
                scanner.setText((sourceFile || this.getSourceFile()).text);
                var children = [];
                var pos = this.pos;
                var processNode = function (node) {
                    if (pos < node.pos) {
                        pos = _this.addSyntheticNodes(children, pos, node.pos);
                    }
                    children.push(node);
                    pos = node.end;
                };
                var processNodes = function (nodes) {
                    if (pos < nodes.pos) {
                        pos = _this.addSyntheticNodes(children, pos, nodes.pos);
                    }
                    children.push(_this.createSyntaxList(nodes));
                    pos = nodes.end;
                };
                ts.forEachChild(this, processNode, processNodes);
                if (pos < this.end) {
                    this.addSyntheticNodes(children, pos, this.end);
                }
                scanner.setText(undefined);
            }
            this._children = children || emptyArray;
        };
        NodeObject.prototype.getChildCount = function (sourceFile) {
            if (!this._children)
                this.createChildren(sourceFile);
            return this._children.length;
        };
        NodeObject.prototype.getChildAt = function (index, sourceFile) {
            if (!this._children)
                this.createChildren(sourceFile);
            return this._children[index];
        };
        NodeObject.prototype.getChildren = function (sourceFile) {
            if (!this._children)
                this.createChildren(sourceFile);
            return this._children;
        };
        NodeObject.prototype.getFirstToken = function (sourceFile) {
            var children = this.getChildren(sourceFile);
            for (var i = 0; i < children.length; i++) {
                var child = children[i];
                if (child.kind < 115 /* Missing */)
                    return child;
                if (child.kind > 115 /* Missing */)
                    return child.getFirstToken(sourceFile);
            }
        };
        NodeObject.prototype.getLastToken = function (sourceFile) {
            var children = this.getChildren(sourceFile);
            for (var i = children.length - 1; i >= 0; i--) {
                var child = children[i];
                if (child.kind < 115 /* Missing */)
                    return child;
                if (child.kind > 115 /* Missing */)
                    return child.getLastToken(sourceFile);
            }
        };
        return NodeObject;
    })();
    var SymbolObject = (function () {
        function SymbolObject(flags, name) {
            this.flags = flags;
            this.name = name;
        }
        SymbolObject.prototype.getFlags = function () {
            return this.flags;
        };
        SymbolObject.prototype.getName = function () {
            return this.name;
        };
        SymbolObject.prototype.getDeclarations = function () {
            return this.declarations;
        };
        SymbolObject.prototype.getDocumentationComment = function () {
            if (this.documentationComment === undefined) {
                var lines = [];
                // Get the doc comments from all the declarations of this symbol, and merge them
                // into one single doc comment.
                var declarations = this.getDeclarations();
                if (declarations) {
                    for (var i = 0, n = declarations.length; i < n; i++) {
                        this.processDocumentationCommentDeclaration(lines, declarations[0]);
                    }
                }
                // TODO: get the newline info from the host.
                this.documentationComment = lines.join("\r\n");
            }
            return this.documentationComment;
        };
        SymbolObject.prototype.processDocumentationCommentDeclaration = function (lines, declaration) {
            var commentRanges = ts.getLeadingCommentRangesOfNode(declaration);
            if (commentRanges) {
                var sourceFile = declaration.getSourceFile();
                for (var i = 0, n = commentRanges.length; i < n; i++) {
                    this.processDocumentationCommentRange(lines, sourceFile, commentRanges[0]);
                }
            }
        };
        SymbolObject.prototype.processDocumentationCommentRange = function (lines, sourceFile, commentRange) {
            // We only care about well-formed /** */ comments
            if (commentRange.end - commentRange.pos > "/**/".length && sourceFile.text.substr(commentRange.pos, "/**".length) === "/**" && sourceFile.text.substr(commentRange.end - "*/".length, "*/".length) === "*/") {
                // Put a newline between each converted comment we join together.
                if (lines.length) {
                    lines.push("");
                }
                var startLineAndChar = sourceFile.getLineAndCharacterFromPosition(commentRange.pos);
                var endLineAndChar = sourceFile.getLineAndCharacterFromPosition(commentRange.end);
                if (startLineAndChar.line === endLineAndChar.line) {
                    // A single line doc comment.  Just extract the text between the
                    // comment markers and add that to the doc comment we're building
                    // up.
                    lines.push(sourceFile.text.substring(commentRange.pos + "/**".length, commentRange.end - "*/".length).trim());
                }
                else {
                    this.processMultiLineDocumentationCommentRange(sourceFile, commentRange, startLineAndChar, endLineAndChar, lines);
                }
            }
        };
        SymbolObject.prototype.processMultiLineDocumentationCommentRange = function (sourceFile, commentRange, startLineAndChar, endLineAndChar, lines) {
            // Comment spanned multiple lines.  Find the leftmost character 
            // position in each line, and use that to determine what we should
            // trim off, and what part of the line to keep.
            // i.e.   if the comment looks like:
            // 
            // /** Foo
            //   * Bar
            //   *    Baz
            //   */
            //
            // Then we'll want to add:
            // Foo
            // Bar
            //    Baz
            var trimLength = undefined;
            for (var iLine = startLineAndChar.line + 1; iLine <= endLineAndChar.line; iLine++) {
                var lineStart = sourceFile.getPositionFromLineAndCharacter(iLine, 1);
                var lineEnd = iLine === endLineAndChar.line ? commentRange.end - "*/".length : sourceFile.getPositionFromLineAndCharacter(iLine + 1, 1);
                var docCommentTriviaLength = this.skipDocumentationCommentTrivia(sourceFile.text, lineStart, lineEnd);
                if (trimLength === undefined || (docCommentTriviaLength && docCommentTriviaLength < trimLength)) {
                    trimLength = docCommentTriviaLength;
                }
            }
            // Add the first line in.
            var firstLine = sourceFile.text.substring(commentRange.pos + "/**".length, sourceFile.getPositionFromLineAndCharacter(startLineAndChar.line + 1, 1)).trim();
            if (firstLine !== "") {
                lines.push(firstLine);
            }
            for (var iLine = startLineAndChar.line + 1; iLine < endLineAndChar.line; iLine++) {
                var line = this.trimRight(sourceFile.text.substring(sourceFile.getPositionFromLineAndCharacter(iLine, 1), sourceFile.getPositionFromLineAndCharacter(iLine + 1, 1))).substr(trimLength);
                lines.push(line);
            }
            // Add the last line if there is any actual text before the */
            var lastLine = this.trimRight(sourceFile.text.substring(sourceFile.getPositionFromLineAndCharacter(endLineAndChar.line, 1), commentRange.end - "*/".length)).substr(trimLength);
            if (lastLine !== "") {
                lines.push(lastLine);
            }
        };
        SymbolObject.prototype.trimRight = function (val) {
            return val.replace(/(\n|\r|\s)+$/, '');
        };
        SymbolObject.prototype.skipDocumentationCommentTrivia = function (text, lineStart, lineEnd) {
            var seenAsterisk = false;
            var lineLength = lineEnd - lineStart;
            for (var i = 0; i < lineLength; i++) {
                var char = text.charCodeAt(i + lineStart);
                if (char === 42 /* asterisk */ && !seenAsterisk) {
                    // Ignore the first asterisk we see.  We want to trim out the line of *'s 
                    // commonly seen at the start of a doc comment.
                    seenAsterisk = true;
                    continue;
                }
                else if (ts.isLineBreak(char)) {
                    break;
                }
                else if (!ts.isWhiteSpace(char)) {
                    // Found a real doc comment character.  Keep track of it so we can determine how
                    // much of the doc comment leading trivia to trim off.
                    return i;
                }
            }
            return undefined;
        };
        return SymbolObject;
    })();
    var TypeObject = (function () {
        function TypeObject(checker, flags) {
            this.checker = checker;
            this.flags = flags;
        }
        TypeObject.prototype.getFlags = function () {
            return this.flags;
        };
        TypeObject.prototype.getSymbol = function () {
            return this.symbol;
        };
        TypeObject.prototype.getProperties = function () {
            return this.checker.getPropertiesOfType(this);
        };
        TypeObject.prototype.getProperty = function (propertyName) {
            return this.checker.getPropertyOfType(this, propertyName);
        };
        TypeObject.prototype.getApparentProperties = function () {
            return this.checker.getAugmentedPropertiesOfApparentType(this);
        };
        TypeObject.prototype.getCallSignatures = function () {
            return this.checker.getSignaturesOfType(this, 0 /* Call */);
        };
        TypeObject.prototype.getConstructSignatures = function () {
            return this.checker.getSignaturesOfType(this, 1 /* Construct */);
        };
        TypeObject.prototype.getStringIndexType = function () {
            return this.checker.getIndexTypeOfType(this, 0 /* String */);
        };
        TypeObject.prototype.getNumberIndexType = function () {
            return this.checker.getIndexTypeOfType(this, 1 /* Number */);
        };
        return TypeObject;
    })();
    var SignatureObject = (function () {
        function SignatureObject(checker) {
            this.checker = checker;
        }
        SignatureObject.prototype.getDeclaration = function () {
            return this.declaration;
        };
        SignatureObject.prototype.getTypeParameters = function () {
            return this.typeParameters;
        };
        SignatureObject.prototype.getParameters = function () {
            return this.parameters;
        };
        SignatureObject.prototype.getReturnType = function () {
            return this.checker.getReturnTypeOfSignature(this);
        };
        return SignatureObject;
    })();
    var incrementalParse = TypeScript.IncrementalParser.parse;
    var SourceFileObject = (function (_super) {
        __extends(SourceFileObject, _super);
        function SourceFileObject() {
            _super.apply(this, arguments);
        }
        SourceFileObject.prototype.getLineAndCharacterFromPosition = function (position) {
            return null;
        };
        SourceFileObject.prototype.getPositionFromLineAndCharacter = function (line, character) {
            return -1;
        };
        SourceFileObject.prototype.getSourceUnit = function () {
            // If we don't have a script, create one from our parse tree.
            return this.getSyntaxTree().sourceUnit();
        };
        SourceFileObject.prototype.getScriptSnapshot = function () {
            return this.scriptSnapshot;
        };
        SourceFileObject.prototype.getLineMap = function () {
            return this.getSyntaxTree().lineMap();
        };
        SourceFileObject.prototype.getNamedDeclarations = function () {
            if (!this.namedDeclarations) {
                var sourceFile = this;
                var namedDeclarations = [];
                var isExternalModule = ts.isExternalModule(sourceFile);
                ts.forEachChild(sourceFile, function visit(node) {
                    switch (node.kind) {
                        case 174 /* ClassDeclaration */:
                        case 175 /* InterfaceDeclaration */:
                        case 176 /* EnumDeclaration */:
                        case 177 /* ModuleDeclaration */:
                        case 179 /* ImportDeclaration */:
                        case 120 /* Method */:
                        case 172 /* FunctionDeclaration */:
                        case 121 /* Constructor */:
                        case 122 /* GetAccessor */:
                        case 123 /* SetAccessor */:
                        case 129 /* TypeLiteral */:
                            if (node.name) {
                                namedDeclarations.push(node);
                            }
                            ts.forEachChild(node, visit);
                            break;
                        case 149 /* VariableStatement */:
                        case 178 /* ModuleBlock */:
                        case 173 /* FunctionBlock */:
                            ts.forEachChild(node, visit);
                            break;
                        case 118 /* Parameter */:
                            if (!(node.flags & ts.NodeFlags.AccessibilityModifier)) {
                                break;
                            }
                        case 171 /* VariableDeclaration */:
                        case 181 /* EnumMember */:
                        case 119 /* Property */:
                            namedDeclarations.push(node);
                            break;
                    }
                    // do not go any deeper
                    return undefined;
                });
                this.namedDeclarations = namedDeclarations;
            }
            return this.namedDeclarations;
        };
        SourceFileObject.prototype.getSyntaxTree = function () {
            if (!this.syntaxTree) {
                var start = new Date().getTime();
                this.syntaxTree = TypeScript.Parser.parse(this.filename, TypeScript.SimpleText.fromScriptSnapshot(this.scriptSnapshot), this.languageVersion, this.isDeclareFile());
                var time = new Date().getTime() - start;
            }
            return this.syntaxTree;
        };
        SourceFileObject.prototype.isDeclareFile = function () {
            return TypeScript.isDTSFile(this.filename);
        };
        SourceFileObject.prototype.update = function (scriptSnapshot, version, isOpen, textChangeRange) {
            // See if we are currently holding onto a syntax tree.  We may not be because we're 
            // either a closed file, or we've just been lazy and haven't had to create the syntax
            // tree yet.  Access the field instead of the method so we don't accidentally realize
            // the old syntax tree.
            var oldSyntaxTree = this.syntaxTree;
            if (textChangeRange && ts.Debug.shouldAssert(1 /* Normal */)) {
                var oldText = this.scriptSnapshot;
                var newText = scriptSnapshot;
                TypeScript.Debug.assert((oldText.getLength() - textChangeRange.span().length() + textChangeRange.newLength()) === newText.getLength());
                if (ts.Debug.shouldAssert(3 /* VeryAggressive */)) {
                    var oldTextPrefix = oldText.getText(0, textChangeRange.span().start());
                    var newTextPrefix = newText.getText(0, textChangeRange.span().start());
                    TypeScript.Debug.assert(oldTextPrefix === newTextPrefix);
                    var oldTextSuffix = oldText.getText(textChangeRange.span().end(), oldText.getLength());
                    var newTextSuffix = newText.getText(textChangeRange.newSpan().end(), newText.getLength());
                    TypeScript.Debug.assert(oldTextSuffix === newTextSuffix);
                }
            }
            var text = TypeScript.SimpleText.fromScriptSnapshot(scriptSnapshot);
            // If we don't have a text change, or we don't have an old syntax tree, then do a full
            // parse.  Otherwise, do an incremental parse.
            var newSyntaxTree = !textChangeRange || !oldSyntaxTree ? TypeScript.Parser.parse(this.filename, text, this.languageVersion, TypeScript.isDTSFile(this.filename)) : TypeScript.IncrementalParser.parse(oldSyntaxTree, textChangeRange, text);
            return SourceFileObject.createSourceFileObject(this.filename, scriptSnapshot, this.languageVersion, version, isOpen, newSyntaxTree);
        };
        SourceFileObject.createSourceFileObject = function (filename, scriptSnapshot, languageVersion, version, isOpen, syntaxTree) {
            var newSourceFile = ts.createSourceFile(filename, scriptSnapshot.getText(0, scriptSnapshot.getLength()), languageVersion, version, isOpen);
            newSourceFile.scriptSnapshot = scriptSnapshot;
            newSourceFile.syntaxTree = syntaxTree;
            return newSourceFile;
        };
        return SourceFileObject;
    })(NodeObject);
    var ClassificationTypeNames = (function () {
        function ClassificationTypeNames() {
        }
        ClassificationTypeNames.comment = "comment";
        ClassificationTypeNames.identifier = "identifier";
        ClassificationTypeNames.keyword = "keyword";
        ClassificationTypeNames.numericLiteral = "number";
        ClassificationTypeNames.operator = "operator";
        ClassificationTypeNames.stringLiteral = "string";
        ClassificationTypeNames.whiteSpace = "whitespace";
        ClassificationTypeNames.text = "text";
        ClassificationTypeNames.punctuation = "punctuation";
        ClassificationTypeNames.className = "class name";
        ClassificationTypeNames.enumName = "enum name";
        ClassificationTypeNames.interfaceName = "interface name";
        ClassificationTypeNames.moduleName = "module name";
        ClassificationTypeNames.typeParameterName = "type parameter name";
        return ClassificationTypeNames;
    })();
    ts.ClassificationTypeNames = ClassificationTypeNames;
    var ClassifiedSpan = (function () {
        function ClassifiedSpan(textSpan, classificationType) {
            this.textSpan = textSpan;
            this.classificationType = classificationType;
        }
        return ClassifiedSpan;
    })();
    ts.ClassifiedSpan = ClassifiedSpan;
    var NavigationBarItem = (function () {
        function NavigationBarItem(text, kind, kindModifiers, spans, childItems, indent, bolded, grayed) {
            if (childItems === void 0) { childItems = null; }
            if (indent === void 0) { indent = 0; }
            if (bolded === void 0) { bolded = false; }
            if (grayed === void 0) { grayed = false; }
            this.text = text;
            this.kind = kind;
            this.kindModifiers = kindModifiers;
            this.spans = spans;
            this.childItems = childItems;
            this.indent = indent;
            this.bolded = bolded;
            this.grayed = grayed;
        }
        return NavigationBarItem;
    })();
    ts.NavigationBarItem = NavigationBarItem;
    var TodoCommentDescriptor = (function () {
        function TodoCommentDescriptor(text, priority) {
            this.text = text;
            this.priority = priority;
        }
        return TodoCommentDescriptor;
    })();
    ts.TodoCommentDescriptor = TodoCommentDescriptor;
    var TodoComment = (function () {
        function TodoComment(descriptor, message, position) {
            this.descriptor = descriptor;
            this.message = message;
            this.position = position;
        }
        return TodoComment;
    })();
    ts.TodoComment = TodoComment;
    var TextChange = (function () {
        function TextChange(span, newText) {
            this.span = span;
            this.newText = newText;
        }
        TextChange.createInsert = function (pos, newText) {
            return new TextChange(new TypeScript.TextSpan(pos, 0), newText);
        };
        TextChange.createDelete = function (start, end) {
            return new TextChange(TypeScript.TextSpan.fromBounds(start, end), "");
        };
        TextChange.createReplace = function (start, end, newText) {
            return new TextChange(TypeScript.TextSpan.fromBounds(start, end), newText);
        };
        return TextChange;
    })();
    ts.TextChange = TextChange;
    var ReferenceEntry = (function () {
        function ReferenceEntry(fileName, textSpan, isWriteAccess) {
            this.fileName = "";
            this.isWriteAccess = false;
            this.fileName = fileName;
            this.textSpan = textSpan;
            this.isWriteAccess = isWriteAccess;
        }
        return ReferenceEntry;
    })();
    ts.ReferenceEntry = ReferenceEntry;
    var NavigateToItem = (function () {
        function NavigateToItem(name, kind, kindModifiers, matchKind, fileName, textSpan, containerName, containerKind) {
            this.name = name;
            this.kind = kind;
            this.kindModifiers = kindModifiers;
            this.matchKind = matchKind;
            this.fileName = fileName;
            this.textSpan = textSpan;
            this.containerName = containerName;
            this.containerKind = containerKind;
        }
        return NavigateToItem;
    })();
    ts.NavigateToItem = NavigateToItem;
    var DefinitionInfo = (function () {
        function DefinitionInfo(fileName, textSpan, kind, name, containerKind, containerName) {
            this.fileName = fileName;
            this.textSpan = textSpan;
            this.kind = kind;
            this.name = name;
            this.containerKind = containerKind;
            this.containerName = containerName;
        }
        return DefinitionInfo;
    })();
    ts.DefinitionInfo = DefinitionInfo;
    var QuickInfo = (function () {
        function QuickInfo(kind, kindModifiers, textSpan, displayParts, documentation) {
            this.kind = kind;
            this.kindModifiers = kindModifiers;
            this.textSpan = textSpan;
            this.displayParts = displayParts;
            this.documentation = documentation;
        }
        return QuickInfo;
    })();
    ts.QuickInfo = QuickInfo;
    var TypeInfo = (function () {
        function TypeInfo(memberName, docComment, fullSymbolName, kind, textSpan) {
            this.memberName = memberName;
            this.docComment = docComment;
            this.fullSymbolName = fullSymbolName;
            this.kind = kind;
            this.textSpan = textSpan;
        }
        return TypeInfo;
    })();
    ts.TypeInfo = TypeInfo;
    var RenameInfo = (function () {
        function RenameInfo(canRename, localizedErrorMessage, displayName, fullDisplayName, kind, kindModifiers, triggerSpan) {
            this.canRename = canRename;
            this.localizedErrorMessage = localizedErrorMessage;
            this.displayName = displayName;
            this.fullDisplayName = fullDisplayName;
            this.kind = kind;
            this.kindModifiers = kindModifiers;
            this.triggerSpan = triggerSpan;
        }
        RenameInfo.CreateError = function (localizedErrorMessage) {
            return new RenameInfo(false, localizedErrorMessage, null, null, null, null, null);
        };
        RenameInfo.Create = function (displayName, fullDisplayName, kind, kindModifiers, triggerSpan) {
            return new RenameInfo(true, null, displayName, fullDisplayName, kind, kindModifiers, triggerSpan);
        };
        return RenameInfo;
    })();
    ts.RenameInfo = RenameInfo;
    var SignatureHelpParameter = (function () {
        function SignatureHelpParameter(name, documentation, display, isOptional) {
            this.name = name;
            this.documentation = documentation;
            this.display = display;
            this.isOptional = isOptional;
        }
        return SignatureHelpParameter;
    })();
    ts.SignatureHelpParameter = SignatureHelpParameter;
    /**
     * Represents a single signature to show in signature help.
     * The id is used for subsequent calls into the language service to ask questions about the
     * signature help item in the context of any documents that have been updated.  i.e. after
     * an edit has happened, while signature help is still active, the host can ask important
     * questions like 'what parameter is the user currently contained within?'.
     */
    var SignatureHelpItem = (function () {
        function SignatureHelpItem(isVariadic, prefix, suffix, separator, parameters, documentation) {
            this.isVariadic = isVariadic;
            this.prefix = prefix;
            this.suffix = suffix;
            this.separator = separator;
            this.parameters = parameters;
            this.documentation = documentation;
        }
        return SignatureHelpItem;
    })();
    ts.SignatureHelpItem = SignatureHelpItem;
    /**
     * Represents a set of signature help items, and the preferred item that should be selected.
     */
    var SignatureHelpItems = (function () {
        function SignatureHelpItems(items, applicableSpan, selectedItemIndex) {
            this.items = items;
            this.applicableSpan = applicableSpan;
            this.selectedItemIndex = selectedItemIndex;
        }
        return SignatureHelpItems;
    })();
    ts.SignatureHelpItems = SignatureHelpItems;
    var SignatureHelpState = (function () {
        function SignatureHelpState(argumentIndex, argumentCount) {
            this.argumentIndex = argumentIndex;
            this.argumentCount = argumentCount;
        }
        return SignatureHelpState;
    })();
    ts.SignatureHelpState = SignatureHelpState;
    (function (OutputFileType) {
        OutputFileType[OutputFileType["JavaScript"] = 0] = "JavaScript";
        OutputFileType[OutputFileType["SourceMap"] = 1] = "SourceMap";
        OutputFileType[OutputFileType["Declaration"] = 2] = "Declaration";
    })(ts.OutputFileType || (ts.OutputFileType = {}));
    var OutputFileType = ts.OutputFileType;
    (function (EndOfLineState) {
        EndOfLineState[EndOfLineState["Start"] = 0] = "Start";
        EndOfLineState[EndOfLineState["InMultiLineCommentTrivia"] = 1] = "InMultiLineCommentTrivia";
        EndOfLineState[EndOfLineState["InSingleQuoteStringLiteral"] = 2] = "InSingleQuoteStringLiteral";
        EndOfLineState[EndOfLineState["InDoubleQuoteStringLiteral"] = 3] = "InDoubleQuoteStringLiteral";
    })(ts.EndOfLineState || (ts.EndOfLineState = {}));
    var EndOfLineState = ts.EndOfLineState;
    (function (TokenClass) {
        TokenClass[TokenClass["Punctuation"] = 0] = "Punctuation";
        TokenClass[TokenClass["Keyword"] = 1] = "Keyword";
        TokenClass[TokenClass["Operator"] = 2] = "Operator";
        TokenClass[TokenClass["Comment"] = 3] = "Comment";
        TokenClass[TokenClass["Whitespace"] = 4] = "Whitespace";
        TokenClass[TokenClass["Identifier"] = 5] = "Identifier";
        TokenClass[TokenClass["NumberLiteral"] = 6] = "NumberLiteral";
        TokenClass[TokenClass["StringLiteral"] = 7] = "StringLiteral";
        TokenClass[TokenClass["RegExpLiteral"] = 8] = "RegExpLiteral";
    })(ts.TokenClass || (ts.TokenClass = {}));
    var TokenClass = ts.TokenClass;
    // TODO: move these to enums
    var ScriptElementKind = (function () {
        function ScriptElementKind() {
        }
        ScriptElementKind.unknown = "";
        // predefined type (void) or keyword (class)
        ScriptElementKind.keyword = "keyword";
        // top level script node
        ScriptElementKind.scriptElement = "script";
        // module foo {}
        ScriptElementKind.moduleElement = "module";
        // class X {}
        ScriptElementKind.classElement = "class";
        // interface Y {}
        ScriptElementKind.interfaceElement = "interface";
        // enum E
        ScriptElementKind.enumElement = "enum";
        // Inside module and script only
        // var v = ..
        ScriptElementKind.variableElement = "var";
        // Inside function
        ScriptElementKind.localVariableElement = "local var";
        // Inside module and script only
        // function f() { }
        ScriptElementKind.functionElement = "function";
        // Inside function
        ScriptElementKind.localFunctionElement = "local function";
        // class X { [public|private]* foo() {} }
        ScriptElementKind.memberFunctionElement = "method";
        // class X { [public|private]* [get|set] foo:number; }
        ScriptElementKind.memberGetAccessorElement = "getter";
        ScriptElementKind.memberSetAccessorElement = "setter";
        // class X { [public|private]* foo:number; }
        // interface Y { foo:number; }
        ScriptElementKind.memberVariableElement = "property";
        // class X { constructor() { } }
        ScriptElementKind.constructorImplementationElement = "constructor";
        // interface Y { ():number; }
        ScriptElementKind.callSignatureElement = "call";
        // interface Y { []:number; }
        ScriptElementKind.indexSignatureElement = "index";
        // interface Y { new():Y; }
        ScriptElementKind.constructSignatureElement = "construct";
        // function foo(*Y*: string)
        ScriptElementKind.parameterElement = "parameter";
        ScriptElementKind.typeParameterElement = "type parameter";
        ScriptElementKind.primitiveType = "primitive type";
        ScriptElementKind.label = "label";
        return ScriptElementKind;
    })();
    ts.ScriptElementKind = ScriptElementKind;
    var ScriptElementKindModifier = (function () {
        function ScriptElementKindModifier() {
        }
        ScriptElementKindModifier.none = "";
        ScriptElementKindModifier.publicMemberModifier = "public";
        ScriptElementKindModifier.privateMemberModifier = "private";
        ScriptElementKindModifier.exportedModifier = "export";
        ScriptElementKindModifier.ambientModifier = "declare";
        ScriptElementKindModifier.staticModifier = "static";
        return ScriptElementKindModifier;
    })();
    ts.ScriptElementKindModifier = ScriptElementKindModifier;
    var MatchKind;
    (function (MatchKind) {
        MatchKind[MatchKind["none"] = 0] = "none";
        MatchKind[MatchKind["exact"] = 1] = "exact";
        MatchKind[MatchKind["substring"] = 2] = "substring";
        MatchKind[MatchKind["prefix"] = 3] = "prefix";
    })(MatchKind || (MatchKind = {}));
    function getDefaultCompilerOptions() {
        // Set "ES5" target by default for language service
        return {
            target: 1 /* ES5 */,
            module: 0 /* None */
        };
    }
    ts.getDefaultCompilerOptions = getDefaultCompilerOptions;
    function compareDataObjects(dst, src) {
        for (var e in dst) {
            if (typeof dst[e] === "object") {
                if (!compareDataObjects(dst[e], src[e]))
                    return false;
            }
            else if (typeof dst[e] !== "function") {
                if (dst[e] !== src[e])
                    return false;
            }
        }
        return true;
    }
    ts.compareDataObjects = compareDataObjects;
    var OperationCanceledException = (function () {
        function OperationCanceledException() {
        }
        return OperationCanceledException;
    })();
    ts.OperationCanceledException = OperationCanceledException;
    var CancellationTokenObject = (function () {
        function CancellationTokenObject(cancellationToken) {
            this.cancellationToken = cancellationToken;
        }
        CancellationTokenObject.prototype.isCancellationRequested = function () {
            return this.cancellationToken && this.cancellationToken.isCancellationRequested();
        };
        CancellationTokenObject.prototype.throwIfCancellationRequested = function () {
            if (this.isCancellationRequested()) {
                throw new OperationCanceledException();
            }
        };
        CancellationTokenObject.None = new CancellationTokenObject(null);
        return CancellationTokenObject;
    })();
    // Cache host information about scrip Should be refreshed 
    // at each language service public entry point, since we don't know when 
    // set of scripts handled by the host changes.
    var HostCache = (function () {
        function HostCache(host) {
            this.host = host;
            // script id => script index
            this.filenameToEntry = {};
            var filenames = host.getScriptFileNames();
            for (var i = 0, n = filenames.length; i < n; i++) {
                var filename = filenames[i];
                this.filenameToEntry[TypeScript.switchToForwardSlashes(filename)] = {
                    filename: filename,
                    version: host.getScriptVersion(filename),
                    isOpen: host.getScriptIsOpen(filename)
                };
            }
            this._compilationSettings = host.getCompilationSettings() || getDefaultCompilerOptions();
        }
        HostCache.prototype.compilationSettings = function () {
            return this._compilationSettings;
        };
        HostCache.prototype.getEntry = function (filename) {
            filename = TypeScript.switchToForwardSlashes(filename);
            return ts.lookUp(this.filenameToEntry, filename);
        };
        HostCache.prototype.contains = function (filename) {
            return !!this.getEntry(filename);
        };
        HostCache.prototype.getHostfilename = function (filename) {
            var hostCacheEntry = this.getEntry(filename);
            if (hostCacheEntry) {
                return hostCacheEntry.filename;
            }
            return filename;
        };
        HostCache.prototype.getFilenames = function () {
            var _this = this;
            var fileNames = [];
            ts.forEachKey(this.filenameToEntry, function (key) {
                if (ts.hasProperty(_this.filenameToEntry, key))
                    fileNames.push(key);
            });
            return fileNames;
        };
        HostCache.prototype.getVersion = function (filename) {
            return this.getEntry(filename).version;
        };
        HostCache.prototype.isOpen = function (filename) {
            return this.getEntry(filename).isOpen;
        };
        HostCache.prototype.getScriptSnapshot = function (filename) {
            var file = this.getEntry(filename);
            if (!file.sourceText) {
                file.sourceText = this.host.getScriptSnapshot(file.filename);
            }
            return file.sourceText;
        };
        HostCache.prototype.getChangeRange = function (filename, lastKnownVersion, oldScriptSnapshot) {
            var currentVersion = this.getVersion(filename);
            if (lastKnownVersion === currentVersion) {
                return TypeScript.TextChangeRange.unchanged; // "No changes"
            }
            var scriptSnapshot = this.getScriptSnapshot(filename);
            return scriptSnapshot.getChangeRange(oldScriptSnapshot);
        };
        return HostCache;
    })();
    var SyntaxTreeCache = (function () {
        function SyntaxTreeCache(host) {
            this.host = host;
            // For our syntactic only features, we also keep a cache of the syntax tree for the 
            // currently edited file.  
            this.currentFilename = "";
            this.currentFileVersion = null;
            this.currentSourceFile = null;
            this.currentFileSyntaxTree = null;
            this.hostCache = new HostCache(host);
        }
        SyntaxTreeCache.prototype.initialize = function (filename) {
            // ensure that both source file and syntax tree are either initialized or not initialized
            ts.Debug.assert(!!this.currentFileSyntaxTree === !!this.currentSourceFile);
            this.hostCache = new HostCache(this.host);
            var version = this.hostCache.getVersion(filename);
            var syntaxTree = null;
            var sourceFile;
            if (this.currentFileSyntaxTree === null || this.currentFilename !== filename) {
                var scriptSnapshot = this.hostCache.getScriptSnapshot(filename);
                syntaxTree = this.createSyntaxTree(filename, scriptSnapshot);
                sourceFile = createSourceFileFromScriptSnapshot(filename, scriptSnapshot, getDefaultCompilerOptions(), version, true);
                fixupParentReferences(sourceFile);
            }
            else if (this.currentFileVersion !== version) {
                var scriptSnapshot = this.hostCache.getScriptSnapshot(filename);
                syntaxTree = this.updateSyntaxTree(filename, scriptSnapshot, this.currentSourceFile.getScriptSnapshot(), this.currentFileSyntaxTree, this.currentFileVersion);
                var editRange = this.hostCache.getChangeRange(filename, this.currentFileVersion, this.currentSourceFile.getScriptSnapshot());
                sourceFile = !editRange ? createSourceFileFromScriptSnapshot(filename, scriptSnapshot, getDefaultCompilerOptions(), version, true) : this.currentSourceFile.update(scriptSnapshot, version, true, editRange);
                fixupParentReferences(sourceFile);
            }
            if (syntaxTree !== null) {
                ts.Debug.assert(sourceFile);
                // All done, ensure state is up to date
                this.currentFileVersion = version;
                this.currentFilename = filename;
                this.currentFileSyntaxTree = syntaxTree;
                this.currentSourceFile = sourceFile;
            }
            function fixupParentReferences(sourceFile) {
                // normally parent references are set during binding.
                // however here SourceFile data is used only for syntactic features so running the whole binding process is an overhead.
                // walk over the nodes and set parent references
                var parent = sourceFile;
                function walk(n) {
                    n.parent = parent;
                    var saveParent = parent;
                    parent = n;
                    ts.forEachChild(n, walk);
                    parent = saveParent;
                }
                ts.forEachChild(sourceFile, walk);
            }
        };
        SyntaxTreeCache.prototype.getCurrentFileSyntaxTree = function (filename) {
            this.initialize(filename);
            return this.currentFileSyntaxTree;
        };
        SyntaxTreeCache.prototype.getCurrentSourceFile = function (filename) {
            this.initialize(filename);
            return this.currentSourceFile;
        };
        SyntaxTreeCache.prototype.getCurrentScriptSnapshot = function (filename) {
            // update currentFileScriptSnapshot as a part of 'getCurrentFileSyntaxTree' call
            this.getCurrentFileSyntaxTree(filename);
            return this.getCurrentSourceFile(filename).getScriptSnapshot();
        };
        SyntaxTreeCache.prototype.createSyntaxTree = function (filename, scriptSnapshot) {
            var text = TypeScript.SimpleText.fromScriptSnapshot(scriptSnapshot);
            // For the purposes of features that use this syntax tree, we can just use the default
            // compilation settings.  The features only use the syntax (and not the diagnostics),
            // and the syntax isn't affected by the compilation settings.
            var syntaxTree = TypeScript.Parser.parse(filename, text, getDefaultCompilerOptions().target, TypeScript.isDTSFile(filename));
            return syntaxTree;
        };
        SyntaxTreeCache.prototype.updateSyntaxTree = function (filename, scriptSnapshot, previousScriptSnapshot, previousSyntaxTree, previousFileVersion) {
            var editRange = this.hostCache.getChangeRange(filename, previousFileVersion, previousScriptSnapshot);
            // Debug.assert(newLength >= 0);
            // The host considers the entire buffer changed.  So parse a completely new tree.
            if (editRange === null) {
                return this.createSyntaxTree(filename, scriptSnapshot);
            }
            var nextSyntaxTree = TypeScript.IncrementalParser.parse(previousSyntaxTree, editRange, TypeScript.SimpleText.fromScriptSnapshot(scriptSnapshot));
            this.ensureInvariants(filename, editRange, nextSyntaxTree, previousScriptSnapshot, scriptSnapshot);
            return nextSyntaxTree;
        };
        SyntaxTreeCache.prototype.ensureInvariants = function (filename, editRange, incrementalTree, oldScriptSnapshot, newScriptSnapshot) {
            // First, verify that the edit range and the script snapshots make sense.
            // If this fires, then the edit range is completely bogus.  Somehow the lengths of the
            // old snapshot, the change range and the new snapshot aren't in sync.  This is very
            // bad.
            var expectedNewLength = oldScriptSnapshot.getLength() - editRange.span().length() + editRange.newLength();
            var actualNewLength = newScriptSnapshot.getLength();
            function provideMoreDebugInfo() {
                var debugInformation = ["expected length:", expectedNewLength, "and actual length:", actualNewLength, "are not equal\r\n"];
                var oldSpan = editRange.span();
                function prettyPrintString(s) {
                    return '"' + s.replace(/\r/g, '\\r').replace(/\n/g, '\\n') + '"';
                }
                debugInformation.push('Edit range (old text) (start: ' + oldSpan.start() + ', end: ' + oldSpan.end() + ') \r\n');
                debugInformation.push('Old text edit range contents: ' + prettyPrintString(oldScriptSnapshot.getText(oldSpan.start(), oldSpan.end())));
                var newSpan = editRange.newSpan();
                debugInformation.push('Edit range (new text) (start: ' + newSpan.start() + ', end: ' + newSpan.end() + ') \r\n');
                debugInformation.push('New text edit range contents: ' + prettyPrintString(newScriptSnapshot.getText(newSpan.start(), newSpan.end())));
                return debugInformation.join(' ');
            }
            ts.Debug.assert(expectedNewLength === actualNewLength, "Expected length is different from actual!", provideMoreDebugInfo);
            if (ts.Debug.shouldAssert(3 /* VeryAggressive */)) {
                // If this fires, the text change range is bogus.  It says the change starts at point 
                // 'X', but we can see a text difference *before* that point.
                var oldPrefixText = oldScriptSnapshot.getText(0, editRange.span().start());
                var newPrefixText = newScriptSnapshot.getText(0, editRange.span().start());
                ts.Debug.assert(oldPrefixText === newPrefixText, 'Expected equal prefix texts!');
                // If this fires, the text change range is bogus.  It says the change goes only up to
                // point 'X', but we can see a text difference *after* that point.
                var oldSuffixText = oldScriptSnapshot.getText(editRange.span().end(), oldScriptSnapshot.getLength());
                var newSuffixText = newScriptSnapshot.getText(editRange.newSpan().end(), newScriptSnapshot.getLength());
                ts.Debug.assert(oldSuffixText === newSuffixText, 'Expected equal suffix texts!');
                // Ok, text change range and script snapshots look ok.  Let's verify that our 
                // incremental parsing worked properly.
                //var normalTree = this.createSyntaxTree(filename, newScriptSnapshot);
                //Debug.assert(normalTree.structuralEquals(incrementalTree), 'Expected equal incremental and normal trees');
                // Ok, the trees looked good.  So at least our incremental parser agrees with the 
                // normal parser.  Now, verify that the incremental tree matches the contents of the 
                // script snapshot.
                var incrementalTreeText = TypeScript.fullText(incrementalTree.sourceUnit());
                var actualSnapshotText = newScriptSnapshot.getText(0, newScriptSnapshot.getLength());
                ts.Debug.assert(incrementalTreeText === actualSnapshotText, 'Expected full texts to be equal');
            }
        };
        return SyntaxTreeCache;
    })();
    function createSourceFileFromScriptSnapshot(filename, scriptSnapshot, settings, version, isOpen) {
        return SourceFileObject.createSourceFileObject(filename, scriptSnapshot, settings.target, version, isOpen);
    }
    function createDocumentRegistry() {
        var buckets = {};
        function getKeyFromCompilationSettings(settings) {
            return "_" + ts.ScriptTarget[settings.target]; //  + "|" + settings.propagateEnumConstantoString()
        }
        function getBucketForCompilationSettings(settings, createIfMissing) {
            var key = getKeyFromCompilationSettings(settings);
            var bucket = ts.lookUp(buckets, key);
            if (!bucket && createIfMissing) {
                buckets[key] = bucket = {};
            }
            return bucket;
        }
        function reportStats() {
            var bucketInfoArray = Object.keys(buckets).filter(function (name) { return name && name.charAt(0) === '_'; }).map(function (name) {
                var entries = ts.lookUp(buckets, name);
                var sourceFiles = [];
                for (var i in entries) {
                    var entry = entries[i];
                    sourceFiles.push({
                        name: i,
                        refCount: entry.refCount,
                        references: entry.owners.slice(0)
                    });
                }
                sourceFiles.sort(function (x, y) { return y.refCount - x.refCount; });
                return {
                    bucket: name,
                    sourceFiles: sourceFiles
                };
            });
            return JSON.stringify(bucketInfoArray, null, 2);
        }
        function acquireDocument(filename, compilationSettings, scriptSnapshot, version, isOpen) {
            var bucket = getBucketForCompilationSettings(compilationSettings, true);
            var entry = ts.lookUp(bucket, filename);
            if (!entry) {
                var sourceFile = createSourceFileFromScriptSnapshot(filename, scriptSnapshot, compilationSettings, version, isOpen);
                bucket[filename] = entry = {
                    sourceFile: sourceFile,
                    refCount: 0,
                    owners: []
                };
            }
            entry.refCount++;
            return entry.sourceFile;
        }
        function updateDocument(sourceFile, filename, compilationSettings, scriptSnapshot, version, isOpen, textChangeRange) {
            var bucket = getBucketForCompilationSettings(compilationSettings, false);
            ts.Debug.assert(bucket);
            var entry = ts.lookUp(bucket, filename);
            ts.Debug.assert(entry);
            if (entry.sourceFile.isOpen === isOpen && entry.sourceFile.version === version) {
                return entry.sourceFile;
            }
            entry.sourceFile = entry.sourceFile.update(scriptSnapshot, version, isOpen, textChangeRange);
            return entry.sourceFile;
        }
        function releaseDocument(filename, compilationSettings) {
            var bucket = getBucketForCompilationSettings(compilationSettings, false);
            ts.Debug.assert(bucket);
            var entry = ts.lookUp(bucket, filename);
            entry.refCount--;
            ts.Debug.assert(entry.refCount >= 0);
            if (entry.refCount === 0) {
                delete bucket[filename];
            }
        }
        return {
            acquireDocument: acquireDocument,
            updateDocument: updateDocument,
            releaseDocument: releaseDocument,
            reportStats: reportStats
        };
    }
    ts.createDocumentRegistry = createDocumentRegistry;
    /// Helpers
    function getTargetLabel(referenceNode, labelName) {
        while (referenceNode) {
            if (referenceNode.kind === 164 /* LabeledStatement */ && referenceNode.label.text === labelName) {
                return referenceNode.label;
            }
            referenceNode = referenceNode.parent;
        }
        return undefined;
    }
    function isJumpStatementTarget(node) {
        return node.kind === 59 /* Identifier */ && (node.parent.kind === 158 /* BreakStatement */ || node.parent.kind === 157 /* ContinueStatement */) && node.parent.label === node;
    }
    function isLabelOfLabeledStatement(node) {
        return node.kind === 59 /* Identifier */ && node.parent.kind === 164 /* LabeledStatement */ && node.parent.label === node;
    }
    /**
     * Whether or not a 'node' is preceded by a label of the given string.
     * Note: 'node' cannot be a SourceFile.
     */
    function isLabeledBy(node, labelName) {
        for (var owner = node.parent; owner.kind === 164 /* LabeledStatement */; owner = owner.parent) {
            if (owner.label.text === labelName) {
                return true;
            }
        }
        return false;
    }
    function isLabelName(node) {
        return isLabelOfLabeledStatement(node) || isJumpStatementTarget(node);
    }
    function isCallExpressionTarget(node) {
        if (node.parent.kind === 135 /* PropertyAccess */ && node.parent.right === node)
            node = node.parent;
        return node.parent.kind === 137 /* CallExpression */ && node.parent.func === node;
    }
    function isNewExpressionTarget(node) {
        if (node.parent.kind === 135 /* PropertyAccess */ && node.parent.right === node)
            node = node.parent;
        return node.parent.kind === 138 /* NewExpression */ && node.parent.func === node;
    }
    function isNameOfFunctionDeclaration(node) {
        return node.kind === 59 /* Identifier */ && ts.isAnyFunction(node.parent) && node.parent.name === node;
    }
    /// Returns true if node is a name of an object literal property, e.g. "a" in x = { "a": 1 }
    function isNameOfPropertyAssignment(node) {
        return (node.kind === 59 /* Identifier */ || node.kind === 7 /* StringLiteral */ || node.kind === 6 /* NumericLiteral */) && node.parent.kind === 134 /* PropertyAssignment */ && node.parent.name === node;
    }
    function isLiteralNameOfPropertyDeclarationOrIndexAccess(node) {
        if (node.kind === 7 /* StringLiteral */ || node.kind === 6 /* NumericLiteral */) {
            switch (node.parent.kind) {
                case 119 /* Property */:
                case 134 /* PropertyAssignment */:
                case 181 /* EnumMember */:
                case 120 /* Method */:
                case 122 /* GetAccessor */:
                case 123 /* SetAccessor */:
                case 177 /* ModuleDeclaration */:
                    return node.parent.name === node;
                case 136 /* IndexedAccess */:
                    return node.parent.index === node;
            }
        }
        return false;
    }
    function isNameOfExternalModuleImportOrDeclaration(node) {
        return node.kind === 7 /* StringLiteral */ && ((node.parent.kind === 177 /* ModuleDeclaration */ && node.parent.name === node) || (node.parent.kind === 179 /* ImportDeclaration */ && node.parent.externalModuleName === node));
    }
    var SearchMeaning;
    (function (SearchMeaning) {
        SearchMeaning[SearchMeaning["None"] = 0x0] = "None";
        SearchMeaning[SearchMeaning["Value"] = 0x1] = "Value";
        SearchMeaning[SearchMeaning["Type"] = 0x2] = "Type";
        SearchMeaning[SearchMeaning["Namespace"] = 0x4] = "Namespace";
    })(SearchMeaning || (SearchMeaning = {}));
    var BreakContinueSearchType;
    (function (BreakContinueSearchType) {
        BreakContinueSearchType[BreakContinueSearchType["None"] = 0x0] = "None";
        BreakContinueSearchType[BreakContinueSearchType["Unlabeled"] = 0x1] = "Unlabeled";
        BreakContinueSearchType[BreakContinueSearchType["Labeled"] = 0x2] = "Labeled";
        BreakContinueSearchType[BreakContinueSearchType["All"] = BreakContinueSearchType.Unlabeled | BreakContinueSearchType.Labeled] = "All";
    })(BreakContinueSearchType || (BreakContinueSearchType = {}));
    // A cache of completion entries for keywords, these do not change between sessions
    var keywordCompletions = [];
    for (var i = ts.SyntaxKind.FirstKeyword; i <= ts.SyntaxKind.LastKeyword; i++) {
        keywordCompletions.push({
            name: ts.tokenToString(i),
            kind: ScriptElementKind.keyword,
            kindModifiers: ScriptElementKindModifier.none
        });
    }
    function createLanguageService(host, documentRegistry) {
        var syntaxTreeCache = new SyntaxTreeCache(host);
        var formattingRulesProvider;
        var hostCache; // A cache of all the information about the files on the host side.
        var program;
        // this checker is used to answer all LS questions except errors 
        var typeInfoResolver;
        // the sole purpose of this checker is to return semantic diagnostics
        // creation is deferred - use getFullTypeCheckChecker to get instance
        var fullTypeCheckChecker_doNotAccessDirectly;
        var useCaseSensitivefilenames = false;
        var sourceFilesByName = {};
        var documentRegistry = documentRegistry;
        var cancellationToken = new CancellationTokenObject(host.getCancellationToken());
        var activeCompletionSession; // The current active completion session, used to get the completion entry details
        var writer = undefined;
        // Check if the localized messages json is set, otherwise query the host for it
        if (!TypeScript.LocalizedDiagnosticMessages) {
            TypeScript.LocalizedDiagnosticMessages = host.getLocalizedDiagnosticMessages();
        }
        function getSourceFile(filename) {
            return ts.lookUp(sourceFilesByName, filename);
        }
        function getFullTypeCheckChecker() {
            return fullTypeCheckChecker_doNotAccessDirectly || (fullTypeCheckChecker_doNotAccessDirectly = program.getTypeChecker(true));
        }
        function createCompilerHost() {
            return {
                getSourceFile: function (filename, languageVersion) {
                    var sourceFile = getSourceFile(filename);
                    return sourceFile && sourceFile.getSourceFile();
                },
                getCancellationToken: function () { return cancellationToken; },
                getCanonicalFileName: function (filename) { return useCaseSensitivefilenames ? filename : filename.toLowerCase(); },
                useCaseSensitiveFileNames: function () { return useCaseSensitivefilenames; },
                getNewLine: function () { return "\r\n"; },
                getDefaultLibFilename: function () {
                    return host.getDefaultLibFilename();
                },
                writeFile: function (filename, data, writeByteOrderMark) {
                    writer(filename, data, writeByteOrderMark);
                },
                getCurrentDirectory: function () {
                    return host.getCurrentDirectory();
                }
            };
        }
        function sourceFileUpToDate(sourceFile) {
            return sourceFile && sourceFile.version === hostCache.getVersion(sourceFile.filename) && sourceFile.isOpen === hostCache.isOpen(sourceFile.filename);
        }
        function programUpToDate() {
            // If we haven't create a program yet, then it is not up-to-date
            if (!program) {
                return false;
            }
            // If number of files in the program do not match, it is not up-to-date
            var hostFilenames = hostCache.getFilenames();
            if (program.getSourceFiles().length !== hostFilenames.length) {
                return false;
            }
            for (var i = 0, n = hostFilenames.length; i < n; i++) {
                if (!sourceFileUpToDate(program.getSourceFile(hostFilenames[i]))) {
                    return false;
                }
            }
            // If the compilation settings do no match, then the program is not up-to-date
            return compareDataObjects(program.getCompilerOptions(), hostCache.compilationSettings());
        }
        function synchronizeHostData() {
            // Reset the cache at start of every refresh
            hostCache = new HostCache(host);
            // If the program is already up-to-date, we can reuse it
            if (programUpToDate()) {
                return;
            }
            var compilationSettings = hostCache.compilationSettings();
            // Now, remove any files from the compiler that are no longer in the host.
            var oldProgram = program;
            if (oldProgram) {
                var oldSettings = program.getCompilerOptions();
                // If the language version changed, then that affects what types of things we parse. So
                // we have to dump all syntax trees.
                // TODO: handle propagateEnumConstants
                // TODO: is module still needed
                var settingsChangeAffectsSyntax = oldSettings.target !== compilationSettings.target || oldSettings.module !== compilationSettings.module;
                var changesInCompilationSettingsAffectSyntax = oldSettings && compilationSettings && !compareDataObjects(oldSettings, compilationSettings) && settingsChangeAffectsSyntax;
                var oldSourceFiles = program.getSourceFiles();
                for (var i = 0, n = oldSourceFiles.length; i < n; i++) {
                    cancellationToken.throwIfCancellationRequested();
                    var filename = oldSourceFiles[i].filename;
                    if (!hostCache.contains(filename) || changesInCompilationSettingsAffectSyntax) {
                        documentRegistry.releaseDocument(filename, oldSettings);
                        delete sourceFilesByName[filename];
                    }
                }
            }
            // Now, for every file the host knows about, either add the file (if the compiler
            // doesn't know about it.).  Or notify the compiler about any changes (if it does
            // know about it.)
            var hostfilenames = hostCache.getFilenames();
            for (var i = 0, n = hostfilenames.length; i < n; i++) {
                var filename = hostfilenames[i];
                var version = hostCache.getVersion(filename);
                var isOpen = hostCache.isOpen(filename);
                var scriptSnapshot = hostCache.getScriptSnapshot(filename);
                var sourceFile = getSourceFile(filename);
                if (sourceFile) {
                    //
                    // If the sourceFile is the same, assume no update
                    //
                    if (sourceFileUpToDate(sourceFile)) {
                        continue;
                    }
                    // Only perform incremental parsing on open files that are being edited.  If a file was
                    // open, but is now closed, we want to re-parse entirely so we don't have any tokens that
                    // are holding onto expensive script snapshot instances on the host.  Similarly, if a 
                    // file was closed, then we always want to re-parse.  This is so our tree doesn't keep 
                    // the old buffer alive that represented the file on disk (as the host has moved to a 
                    // new text buffer).
                    var textChangeRange = null;
                    if (sourceFile.isOpen && isOpen) {
                        textChangeRange = hostCache.getChangeRange(filename, sourceFile.version, sourceFile.getScriptSnapshot());
                    }
                    sourceFile = documentRegistry.updateDocument(sourceFile, filename, compilationSettings, scriptSnapshot, version, isOpen, textChangeRange);
                }
                else {
                    sourceFile = documentRegistry.acquireDocument(filename, compilationSettings, scriptSnapshot, version, isOpen);
                }
                // Remember the new sourceFile
                sourceFilesByName[filename] = sourceFile;
            }
            // Now create a new compiler
            program = ts.createProgram(hostfilenames, compilationSettings, createCompilerHost());
            typeInfoResolver = program.getTypeChecker(false);
            fullTypeCheckChecker_doNotAccessDirectly = undefined;
        }
        /// Clean up any semantic caches that are not needed. 
        /// The host can call this method if it wants to jettison unused memory.
        /// We will just dump the typeChecker and recreate a new one. this should have the effect of destroying all the semantic caches.
        function cleanupSemanticCache() {
            if (program) {
                typeInfoResolver = program.getTypeChecker(false);
                fullTypeCheckChecker_doNotAccessDirectly = undefined;
            }
        }
        function dispose() {
            if (program) {
                ts.forEach(program.getSourceFiles(), function (f) {
                    documentRegistry.releaseDocument(f.filename, program.getCompilerOptions());
                });
            }
        }
        /// Diagnostics
        function getSyntacticDiagnostics(filename) {
            synchronizeHostData();
            filename = TypeScript.switchToForwardSlashes(filename);
            return program.getDiagnostics(getSourceFile(filename).getSourceFile());
        }
        // getSemanticDiagnostiscs return array of Diagnostics. If '-d' is not enabled, only report semantic errors
        // If '-d' enabled, report both semantic and emitter errors 
        function getSemanticDiagnostics(filename) {
            synchronizeHostData();
            filename = TypeScript.switchToForwardSlashes(filename);
            var compilerOptions = program.getCompilerOptions();
            var checker = getFullTypeCheckChecker();
            var targetSourceFile = getSourceFile(filename);
            // Only perform the action per file regardless of '-out' flag as LanguageServiceHost is expected to call this function per file.
            // Therefore only get diagnostics for given file.
            var allDiagnostics = checker.getDiagnostics(targetSourceFile);
            if (compilerOptions.declaration) {
                // If '-d' is enabled, check for emitter error. One example of emitter error is export class implements non-export interface
                // Get emitter-diagnostics requires calling TypeChecker.emitFiles so we have to define CompilerHost.writer which does nothing because emitFiles function has side effects defined by CompilerHost.writer
                var savedWriter = writer;
                writer = function (filename, data, writeByteOrderMark) {
                };
                allDiagnostics = allDiagnostics.concat(checker.emitFiles(targetSourceFile).errors);
                writer = savedWriter;
            }
            return allDiagnostics;
        }
        function getCompilerOptionsDiagnostics() {
            synchronizeHostData();
            return program.getGlobalDiagnostics();
        }
        /// Completion
        function getValidCompletionEntryDisplayName(displayName, target) {
            if (displayName && displayName.length > 0) {
                var firstCharCode = displayName.charCodeAt(0);
                if (displayName && displayName.length >= 2 && firstCharCode === displayName.charCodeAt(displayName.length - 1) && (firstCharCode === 39 /* singleQuote */ || firstCharCode === 34 /* doubleQuote */)) {
                    // If the user entered name for the symbol was quoted, removing the quotes is not enough, as the name could be an
                    // invalid identifer name. We need to check if whatever was inside the quotes is actually a valid identifier name.
                    displayName = displayName.substring(1, displayName.length - 1);
                }
                var isValid = ts.isIdentifierStart(displayName.charCodeAt(0), target);
                for (var i = 1, n = displayName.length; isValid && i < n; i++) {
                    isValid = ts.isIdentifierPart(displayName.charCodeAt(i), target);
                }
                if (isValid) {
                    return displayName;
                }
            }
            return undefined;
        }
        function createCompletionEntry(symbol) {
            // Try to get a valid display name for this symbol, if we could not find one, then ignore it. 
            // We would like to only show things that can be added after a dot, so for instance numeric properties can
            // not be accessed with a dot (a.1 <- invalid)
            var displayName = getValidCompletionEntryDisplayName(symbol.getName(), program.getCompilerOptions().target);
            if (!displayName) {
                return undefined;
            }
            return {
                name: displayName,
                kind: getSymbolKind(symbol),
                kindModifiers: getSymbolModifiers(symbol)
            };
        }
        function getCompletionsAtPosition(filename, position, isMemberCompletion) {
            function getCompletionEntriesFromSymbols(symbols, session) {
                ts.forEach(symbols, function (symbol) {
                    var entry = createCompletionEntry(symbol);
                    if (entry && !ts.lookUp(session.symbols, entry.name)) {
                        session.entries.push(entry);
                        session.symbols[entry.name] = symbol;
                    }
                });
            }
            function isCompletionListBlocker(sourceUnit, position) {
                // We shouldn't be getting a position that is outside the file because
                // isEntirelyInsideComment can't handle when the position is out of bounds, 
                // callers should be fixed, however we should be resilient to bad inputs
                // so we return true (this position is a blocker for getting completions)
                if (position < 0 || position > TypeScript.fullWidth(sourceUnit)) {
                    return true;
                }
                // This method uses Fidelity completely. Some information can be reached using the AST, but not everything.
                return TypeScript.Syntax.isEntirelyInsideComment(sourceUnit, position) || TypeScript.Syntax.isEntirelyInStringOrRegularExpressionLiteral(sourceUnit, position) || isIdentifierDefinitionLocation(sourceUnit, position) || isRightOfIllegalDot(sourceUnit, position);
            }
            function getContainingObjectLiteralApplicableForCompletion(sourceUnit, position) {
                // The locations in an object literal expression that are applicable for completion are property name definition locations.
                var previousToken = getNonIdentifierCompleteTokenOnLeft(sourceUnit, position);
                if (previousToken) {
                    var parent = previousToken.parent;
                    switch (previousToken.kind()) {
                        case 70 /* OpenBraceToken */:
                        case 79 /* CommaToken */:
                            if (parent && parent.kind() === 2 /* SeparatedList */) {
                                parent = parent.parent;
                            }
                            if (parent && parent.kind() === 216 /* ObjectLiteralExpression */) {
                                return parent;
                            }
                            break;
                    }
                }
                return undefined;
            }
            function isIdentifierDefinitionLocation(sourceUnit, position) {
                var positionedToken = getNonIdentifierCompleteTokenOnLeft(sourceUnit, position);
                if (positionedToken) {
                    var containingNodeKind = TypeScript.Syntax.containingNode(positionedToken) && TypeScript.Syntax.containingNode(positionedToken).kind();
                    switch (positionedToken.kind()) {
                        case 79 /* CommaToken */:
                            return containingNodeKind === 228 /* ParameterList */ || containingNodeKind === 225 /* VariableDeclaration */ || containingNodeKind === 133 /* EnumDeclaration */;
                        case 72 /* OpenParenToken */:
                            return containingNodeKind === 228 /* ParameterList */ || containingNodeKind === 237 /* CatchClause */;
                        case 70 /* OpenBraceToken */:
                            return containingNodeKind === 133 /* EnumDeclaration */;
                        case 57 /* PublicKeyword */:
                        case 55 /* PrivateKeyword */:
                        case 58 /* StaticKeyword */:
                        case 77 /* DotDotDotToken */:
                            return containingNodeKind === 243 /* Parameter */;
                        case 44 /* ClassKeyword */:
                        case 65 /* ModuleKeyword */:
                        case 46 /* EnumKeyword */:
                        case 52 /* InterfaceKeyword */:
                        case 27 /* FunctionKeyword */:
                        case 40 /* VarKeyword */:
                        case 64 /* GetKeyword */:
                        case 68 /* SetKeyword */:
                            return true;
                    }
                    switch (positionedToken.text()) {
                        case "class":
                        case "interface":
                        case "enum":
                        case "module":
                            return true;
                    }
                }
                return false;
            }
            function getNonIdentifierCompleteTokenOnLeft(sourceUnit, position) {
                var positionedToken = TypeScript.Syntax.findCompleteTokenOnLeft(sourceUnit, position, true);
                if (positionedToken && position === TypeScript.end(positionedToken) && positionedToken.kind() == 10 /* EndOfFileToken */) {
                    // EndOfFile token is not interesting, get the one before it
                    positionedToken = TypeScript.previousToken(positionedToken, true);
                }
                if (positionedToken && position === TypeScript.end(positionedToken) && positionedToken.kind() === 11 /* IdentifierName */) {
                    // The caret is at the end of an identifier, the decision to provide completion depends on the previous token
                    positionedToken = TypeScript.previousToken(positionedToken, true);
                }
                return positionedToken;
            }
            function isRightOfIllegalDot(sourceUnit, position) {
                var positionedToken = getNonIdentifierCompleteTokenOnLeft(sourceUnit, position);
                if (positionedToken) {
                    switch (positionedToken.kind()) {
                        case 76 /* DotToken */:
                            var leftOfDotPositionedToken = TypeScript.previousToken(positionedToken, true);
                            return leftOfDotPositionedToken && leftOfDotPositionedToken.kind() === 13 /* NumericLiteral */;
                        case 13 /* NumericLiteral */:
                            var text = positionedToken.text();
                            return text.charAt(text.length - 1) === ".";
                    }
                }
                return false;
            }
            function isPunctuation(kind) {
                return (ts.SyntaxKind.FirstPunctuation <= kind && kind <= ts.SyntaxKind.LastPunctuation);
            }
            function isVisibleWithinClassDeclaration(symbol, containingClass) {
                var declaration = symbol.declarations && symbol.declarations[0];
                if (declaration && (declaration.flags & 32 /* Private */)) {
                    var declarationClass = ts.getAncestor(declaration, 174 /* ClassDeclaration */);
                    return containingClass === declarationClass;
                }
                return true;
            }
            function filterContextualMembersList(contextualMemberSymbols, existingMembers) {
                if (!existingMembers || existingMembers.length === 0) {
                    return contextualMemberSymbols;
                }
                var existingMemberNames = {};
                ts.forEach(existingMembers, function (m) {
                    if (m.kind !== 134 /* PropertyAssignment */) {
                        // Ignore omitted expressions for missing members in the object literal
                        return;
                    }
                    if (m.getStart() <= position && position <= m.getEnd()) {
                        // If this is the current item we are editing right now, do not filter it out
                        return;
                    }
                    existingMemberNames[m.name.text] = true;
                });
                var filteredMembers = [];
                ts.forEach(contextualMemberSymbols, function (s) {
                    if (!existingMemberNames[s.name]) {
                        filteredMembers.push(s);
                    }
                });
                return filteredMembers;
            }
            synchronizeHostData();
            filename = TypeScript.switchToForwardSlashes(filename);
            var sourceFile = getSourceFile(filename);
            var sourceUnit = sourceFile.getSourceUnit();
            if (isCompletionListBlocker(sourceFile.getSyntaxTree().sourceUnit(), position)) {
                host.log("Returning an empty list because completion was blocked.");
                return null;
            }
            var node = TypeScript.ASTHelpers.getAstAtPosition(sourceUnit, position, true, true);
            if (node && node.kind() === 11 /* IdentifierName */ && TypeScript.start(node) === TypeScript.end(node)) {
                // Ignore missing name nodes
                node = node.parent;
            }
            var isRightOfDot = false;
            if (node && node.kind() === 213 /* MemberAccessExpression */ && TypeScript.end(node.expression) < position) {
                isRightOfDot = true;
                node = node.expression;
            }
            else if (node && node.kind() === 121 /* QualifiedName */ && TypeScript.end(node.left) < position) {
                isRightOfDot = true;
                node = node.left;
            }
            else if (node && node.parent && node.kind() === 11 /* IdentifierName */ && node.parent.kind() === 213 /* MemberAccessExpression */ && node.parent.name === node) {
                isRightOfDot = true;
                node = node.parent.expression;
            }
            else if (node && node.parent && node.kind() === 11 /* IdentifierName */ && node.parent.kind() === 121 /* QualifiedName */ && node.parent.right === node) {
                isRightOfDot = true;
                node = node.parent.left;
            }
            // TODO: this is a hack for now, we need a proper walking mechanism to verify that we have the correct node
            var mappedNode = getNodeAtPosition(sourceFile, TypeScript.end(node) - 1);
            if (isPunctuation(mappedNode.kind)) {
                mappedNode = mappedNode.parent;
            }
            ts.Debug.assert(mappedNode, "Could not map a Fidelity node to an AST node");
            // Get the completions
            activeCompletionSession = {
                filename: filename,
                position: position,
                entries: [],
                symbols: {},
                location: mappedNode,
                typeChecker: typeInfoResolver
            };
            // Right of dot member completion list
            if (isRightOfDot) {
                var symbols = [];
                var containingClass = ts.getAncestor(mappedNode, 174 /* ClassDeclaration */);
                isMemberCompletion = true;
                if (mappedNode.kind === 59 /* Identifier */ || mappedNode.kind === 116 /* QualifiedName */ || mappedNode.kind === 135 /* PropertyAccess */) {
                    var symbol = typeInfoResolver.getSymbolInfo(mappedNode);
                    if (symbol && symbol.flags & ts.SymbolFlags.HasExports) {
                        // Extract module or enum members
                        ts.forEachValue(symbol.exports, function (symbol) {
                            if (isVisibleWithinClassDeclaration(symbol, containingClass)) {
                                symbols.push(symbol);
                            }
                        });
                    }
                }
                var type = typeInfoResolver.getTypeOfNode(mappedNode);
                var apparentType = type && typeInfoResolver.getApparentType(type);
                if (apparentType) {
                    // Filter private properties
                    ts.forEach(apparentType.getApparentProperties(), function (symbol) {
                        if (isVisibleWithinClassDeclaration(symbol, containingClass)) {
                            symbols.push(symbol);
                        }
                    });
                }
                getCompletionEntriesFromSymbols(symbols, activeCompletionSession);
            }
            else {
                var containingObjectLiteral = getContainingObjectLiteralApplicableForCompletion(sourceFile.getSyntaxTree().sourceUnit(), position);
                // Object literal expression, look up possible property names from contextual type
                if (containingObjectLiteral) {
                    var objectLiteral = (mappedNode.kind === 133 /* ObjectLiteral */ ? mappedNode : ts.getAncestor(mappedNode, 133 /* ObjectLiteral */));
                    ts.Debug.assert(objectLiteral);
                    isMemberCompletion = true;
                    var contextualType = typeInfoResolver.getContextualType(objectLiteral);
                    if (!contextualType) {
                        return undefined;
                    }
                    var contextualTypeMembers = typeInfoResolver.getPropertiesOfType(contextualType);
                    if (contextualTypeMembers && contextualTypeMembers.length > 0) {
                        // Add filtered items to the completion list
                        var filteredMembers = filterContextualMembersList(contextualTypeMembers, objectLiteral.properties);
                        getCompletionEntriesFromSymbols(filteredMembers, activeCompletionSession);
                    }
                }
                else {
                    isMemberCompletion = false;
                    /// TODO filter meaning based on the current context
                    var symbolMeanings = ts.SymbolFlags.Type | ts.SymbolFlags.Value | ts.SymbolFlags.Namespace;
                    var symbols = typeInfoResolver.getSymbolsInScope(mappedNode, symbolMeanings);
                    getCompletionEntriesFromSymbols(symbols, activeCompletionSession);
                }
            }
            // Add keywords if this is not a member completion list
            if (!isMemberCompletion) {
                Array.prototype.push.apply(activeCompletionSession.entries, keywordCompletions);
            }
            return {
                isMemberCompletion: isMemberCompletion,
                entries: activeCompletionSession.entries
            };
        }
        function getCompletionEntryDetails(filename, position, entryName) {
            // Note: No need to call synchronizeHostData, as we have captured all the data we need
            //       in the getCompletionsAtPosition earlier
            filename = TypeScript.switchToForwardSlashes(filename);
            var session = activeCompletionSession;
            // Ensure that the current active completion session is still valid for this request
            if (!session || session.filename !== filename || session.position !== position) {
                return undefined;
            }
            var symbol = ts.lookUp(activeCompletionSession.symbols, entryName);
            if (symbol) {
                var type = session.typeChecker.getTypeOfSymbol(symbol);
                ts.Debug.assert(type, "Could not find type for symbol");
                var completionEntry = createCompletionEntry(symbol);
                return {
                    name: entryName,
                    kind: completionEntry.kind,
                    kindModifiers: completionEntry.kindModifiers,
                    type: session.typeChecker.typeToString(type, session.location),
                    fullSymbolName: typeInfoResolver.symbolToString(symbol, session.location),
                    docComment: ""
                };
            }
            else {
                // No symbol, it is a keyword
                return {
                    name: entryName,
                    kind: ScriptElementKind.keyword,
                    kindModifiers: ScriptElementKindModifier.none,
                    type: undefined,
                    fullSymbolName: entryName,
                    docComment: undefined
                };
            }
        }
        /** Get the token whose text contains the position, or the containing node. */
        function getNodeAtPosition(sourceFile, position) {
            var current = sourceFile;
            outer: while (true) {
                for (var i = 0, n = current.getChildCount(); i < n; i++) {
                    var child = current.getChildAt(i);
                    if (child.getStart() <= position && position < child.getEnd()) {
                        current = child;
                        continue outer;
                    }
                }
                return current;
            }
        }
        /** Get a token that contains the position. This is guaranteed to return a token, the position can be in the
          * leading trivia or within the token text.
          */
        function getTokenAtPosition(sourceFile, position) {
            var current = sourceFile;
            outer: while (true) {
                for (var i = 0, n = current.getChildCount(); i < n; i++) {
                    var child = current.getChildAt(i);
                    if (child.getFullStart() <= position && position < child.getEnd()) {
                        current = child;
                        continue outer;
                    }
                }
                return current;
            }
        }
        function getContainerNode(node) {
            while (true) {
                node = node.parent;
                if (!node) {
                    return node;
                }
                switch (node.kind) {
                    case 182 /* SourceFile */:
                    case 120 /* Method */:
                    case 172 /* FunctionDeclaration */:
                    case 141 /* FunctionExpression */:
                    case 122 /* GetAccessor */:
                    case 123 /* SetAccessor */:
                    case 174 /* ClassDeclaration */:
                    case 175 /* InterfaceDeclaration */:
                    case 176 /* EnumDeclaration */:
                    case 177 /* ModuleDeclaration */:
                        return node;
                }
            }
        }
        function getSymbolKind(symbol) {
            var flags = typeInfoResolver.getRootSymbol(symbol).getFlags();
            if (flags & ts.SymbolFlags.Module)
                return ScriptElementKind.moduleElement;
            if (flags & 16 /* Class */)
                return ScriptElementKind.classElement;
            if (flags & 32 /* Interface */)
                return ScriptElementKind.interfaceElement;
            if (flags & 64 /* Enum */)
                return ScriptElementKind.enumElement;
            if (flags & 1 /* Variable */)
                return ScriptElementKind.variableElement;
            if (flags & 8 /* Function */)
                return ScriptElementKind.functionElement;
            if (flags & 8192 /* GetAccessor */)
                return ScriptElementKind.memberGetAccessorElement;
            if (flags & 16384 /* SetAccessor */)
                return ScriptElementKind.memberSetAccessorElement;
            if (flags & 2048 /* Method */)
                return ScriptElementKind.memberFunctionElement;
            if (flags & 2 /* Property */)
                return ScriptElementKind.memberVariableElement;
            if (flags & 131072 /* IndexSignature */)
                return ScriptElementKind.indexSignatureElement;
            if (flags & 65536 /* ConstructSignature */)
                return ScriptElementKind.constructSignatureElement;
            if (flags & 32768 /* CallSignature */)
                return ScriptElementKind.callSignatureElement;
            if (flags & 4096 /* Constructor */)
                return ScriptElementKind.constructorImplementationElement;
            if (flags & 262144 /* TypeParameter */)
                return ScriptElementKind.typeParameterElement;
            if (flags & 4 /* EnumMember */)
                return ScriptElementKind.variableElement;
            return ScriptElementKind.unknown;
        }
        function getTypeKind(type) {
            var flags = type.getFlags();
            if (flags & 128 /* Enum */)
                return ScriptElementKind.enumElement;
            if (flags & 1024 /* Class */)
                return ScriptElementKind.classElement;
            if (flags & 2048 /* Interface */)
                return ScriptElementKind.interfaceElement;
            if (flags & 512 /* TypeParameter */)
                return ScriptElementKind.typeParameterElement;
            if (flags & ts.TypeFlags.Intrinsic)
                return ScriptElementKind.primitiveType;
            if (flags & 256 /* StringLiteral */)
                return ScriptElementKind.primitiveType;
            return ScriptElementKind.unknown;
        }
        function getNodeKind(node) {
            switch (node.kind) {
                case 177 /* ModuleDeclaration */:
                    return ScriptElementKind.moduleElement;
                case 174 /* ClassDeclaration */:
                    return ScriptElementKind.classElement;
                case 175 /* InterfaceDeclaration */:
                    return ScriptElementKind.interfaceElement;
                case 176 /* EnumDeclaration */:
                    return ScriptElementKind.enumElement;
                case 171 /* VariableDeclaration */:
                    return ScriptElementKind.variableElement;
                case 172 /* FunctionDeclaration */:
                    return ScriptElementKind.functionElement;
                case 122 /* GetAccessor */:
                    return ScriptElementKind.memberGetAccessorElement;
                case 123 /* SetAccessor */:
                    return ScriptElementKind.memberSetAccessorElement;
                case 120 /* Method */:
                    return ScriptElementKind.memberFunctionElement;
                case 119 /* Property */:
                    return ScriptElementKind.memberVariableElement;
                case 126 /* IndexSignature */:
                    return ScriptElementKind.indexSignatureElement;
                case 125 /* ConstructSignature */:
                    return ScriptElementKind.constructSignatureElement;
                case 124 /* CallSignature */:
                    return ScriptElementKind.callSignatureElement;
                case 121 /* Constructor */:
                    return ScriptElementKind.constructorImplementationElement;
                case 117 /* TypeParameter */:
                    return ScriptElementKind.typeParameterElement;
                case 181 /* EnumMember */:
                    return ScriptElementKind.variableElement;
                case 118 /* Parameter */:
                    return (node.flags & ts.NodeFlags.AccessibilityModifier) ? ScriptElementKind.memberVariableElement : ScriptElementKind.parameterElement;
                    return ScriptElementKind.unknown;
            }
        }
        function getSymbolModifiers(symbol) {
            return symbol && symbol.declarations && symbol.declarations.length > 0 ? getNodeModifiers(symbol.declarations[0]) : ScriptElementKindModifier.none;
        }
        function getNodeModifiers(node) {
            var flags = node.flags;
            var result = [];
            if (flags & 32 /* Private */)
                result.push(ScriptElementKindModifier.privateMemberModifier);
            if (flags & 16 /* Public */)
                result.push(ScriptElementKindModifier.publicMemberModifier);
            if (flags & 128 /* Static */)
                result.push(ScriptElementKindModifier.staticModifier);
            if (flags & 1 /* Export */)
                result.push(ScriptElementKindModifier.exportedModifier);
            if (ts.isInAmbientContext(node))
                result.push(ScriptElementKindModifier.ambientModifier);
            return result.length > 0 ? result.join(',') : ScriptElementKindModifier.none;
        }
        function getQuickInfoAtPosition(fileName, position) {
            synchronizeHostData();
            fileName = TypeScript.switchToForwardSlashes(fileName);
            var sourceFile = getSourceFile(fileName);
            var node = getNodeAtPosition(sourceFile, position);
            if (!node) {
                return undefined;
            }
            var symbol = typeInfoResolver.getSymbolInfo(node);
            if (!symbol) {
                return undefined;
            }
            var documentation = symbol.getDocumentationComment();
            var documentationParts = documentation === "" ? [] : [new ts.SymbolDisplayPart(documentation, 20 /* text */, null)];
            // Having all this logic here is pretty unclean.  Consider moving to the roslyn model
            // where all symbol display logic is encapsulated into visitors and options.
            var totalParts = [];
            if (symbol.flags & 16 /* Class */) {
                totalParts.push(new ts.SymbolDisplayPart("class", 5 /* keyword */, undefined));
                totalParts.push(new ts.SymbolDisplayPart(" ", 18 /* space */, undefined));
                totalParts.push.apply(totalParts, typeInfoResolver.symbolToDisplayParts(symbol, sourceFile));
            }
            else if (symbol.flags & 32 /* Interface */) {
                totalParts.push(new ts.SymbolDisplayPart("interface", 5 /* keyword */, undefined));
                totalParts.push(new ts.SymbolDisplayPart(" ", 18 /* space */, undefined));
                totalParts.push.apply(totalParts, typeInfoResolver.symbolToDisplayParts(symbol, sourceFile));
            }
            else if (symbol.flags & 64 /* Enum */) {
                totalParts.push(new ts.SymbolDisplayPart("enum", 5 /* keyword */, undefined));
                totalParts.push(new ts.SymbolDisplayPart(" ", 18 /* space */, undefined));
                totalParts.push.apply(totalParts, typeInfoResolver.symbolToDisplayParts(symbol, sourceFile));
            }
            else if (symbol.flags & ts.SymbolFlags.Module) {
                totalParts.push(new ts.SymbolDisplayPart("module", 5 /* keyword */, undefined));
                totalParts.push(new ts.SymbolDisplayPart(" ", 18 /* space */, undefined));
                totalParts.push.apply(totalParts, typeInfoResolver.symbolToDisplayParts(symbol, sourceFile));
            }
            else if (symbol.flags & 262144 /* TypeParameter */) {
                totalParts.push(new ts.SymbolDisplayPart("(", 17 /* punctuation */, undefined));
                totalParts.push(new ts.SymbolDisplayPart("type parameter", 20 /* text */, undefined));
                totalParts.push(new ts.SymbolDisplayPart(")", 17 /* punctuation */, undefined));
                totalParts.push(new ts.SymbolDisplayPart(" ", 18 /* space */, undefined));
                totalParts.push.apply(totalParts, typeInfoResolver.symbolToDisplayParts(symbol));
            }
            else {
                totalParts.push(new ts.SymbolDisplayPart("(", 17 /* punctuation */, undefined));
                var text;
                if (symbol.flags & 2 /* Property */) {
                    text = "property";
                }
                else if (symbol.flags & 4 /* EnumMember */) {
                    text = "enum member";
                }
                else if (symbol.flags & 8 /* Function */) {
                    text = "function";
                }
                else if (symbol.flags & 1 /* Variable */) {
                    text = "variable";
                }
                else if (symbol.flags & 2048 /* Method */) {
                    text = "method";
                }
                if (!text) {
                    return undefined;
                }
                totalParts.push(new ts.SymbolDisplayPart(text, 20 /* text */, undefined));
                totalParts.push(new ts.SymbolDisplayPart(")", 17 /* punctuation */, undefined));
                totalParts.push(new ts.SymbolDisplayPart(" ", 18 /* space */, undefined));
                totalParts.push.apply(totalParts, typeInfoResolver.symbolToDisplayParts(symbol, getContainerNode(node)));
                var type = typeInfoResolver.getTypeOfSymbol(symbol);
                if (symbol.flags & 2 /* Property */ || symbol.flags & 1 /* Variable */) {
                    if (type) {
                        totalParts.push(new ts.SymbolDisplayPart(":", 17 /* punctuation */, undefined));
                        totalParts.push(new ts.SymbolDisplayPart(" ", 18 /* space */, undefined));
                        totalParts.push.apply(totalParts, typeInfoResolver.typeToDisplayParts(type, getContainerNode(node)));
                    }
                }
                else if (symbol.flags & 8 /* Function */ || symbol.flags & 2048 /* Method */) {
                    if (type) {
                        totalParts.push.apply(totalParts, typeInfoResolver.typeToDisplayParts(type, getContainerNode(node)));
                    }
                }
                else if (symbol.flags & 4 /* EnumMember */) {
                    var declaration = symbol.declarations[0];
                    if (declaration.kind === 181 /* EnumMember */) {
                        var constantValue = typeInfoResolver.getEnumMemberValue(declaration);
                        if (constantValue !== undefined) {
                            totalParts.push(new ts.SymbolDisplayPart(" ", 18 /* space */, undefined));
                            totalParts.push(new ts.SymbolDisplayPart("=", 14 /* operator */, undefined));
                            totalParts.push(new ts.SymbolDisplayPart(" ", 18 /* space */, undefined));
                            totalParts.push(new ts.SymbolDisplayPart(constantValue.toString(), 8 /* numericLiteral */, undefined));
                        }
                    }
                }
            }
            return new QuickInfo(getSymbolKind(symbol), getSymbolModifiers(symbol), new TypeScript.TextSpan(node.getStart(), node.getWidth()), totalParts, documentationParts);
        }
        function getTypeAtPosition(fileName, position) {
            synchronizeHostData();
            fileName = TypeScript.switchToForwardSlashes(fileName);
            var sourceFile = getSourceFile(fileName);
            var node = getNodeAtPosition(sourceFile, position);
            if (!node) {
                return undefined;
            }
            var symbol = typeInfoResolver.getSymbolInfo(node);
            var type = symbol && typeInfoResolver.getTypeOfSymbol(symbol);
            if (type) {
                return new TypeInfo(new TypeScript.MemberNameString(typeInfoResolver.typeToString(type)), "", typeInfoResolver.symbolToString(symbol, getContainerNode(node)), getSymbolKind(symbol), TypeScript.TextSpan.fromBounds(node.pos, node.end));
            }
            return undefined;
        }
        /// Goto definition
        function getDefinitionAtPosition(filename, position) {
            function getDefinitionInfo(node, symbolKind, symbolName, containerName) {
                return new DefinitionInfo(node.getSourceFile().filename, TypeScript.TextSpan.fromBounds(node.getStart(), node.getEnd()), symbolKind, symbolName, undefined, containerName);
            }
            function tryAddSignature(signatureDeclarations, selectConstructors, symbolKind, symbolName, containerName, result) {
                var declarations = [];
                var definition;
                ts.forEach(signatureDeclarations, function (d) {
                    if ((selectConstructors && d.kind === 121 /* Constructor */) || (!selectConstructors && (d.kind === 172 /* FunctionDeclaration */ || d.kind === 120 /* Method */))) {
                        declarations.push(d);
                        if (d.body)
                            definition = d;
                    }
                });
                if (definition) {
                    result.push(getDefinitionInfo(definition, symbolKind, symbolName, containerName));
                    return true;
                }
                else if (declarations.length) {
                    result.push(getDefinitionInfo(declarations[declarations.length - 1], symbolKind, symbolName, containerName));
                    return true;
                }
                return false;
            }
            function tryAddConstructSignature(symbol, location, symbolKind, symbolName, containerName, result) {
                // Applicable only if we are in a new expression, or we are on a constructor declaration
                // and in either case the symbol has a construct signature definition, i.e. class
                if (isNewExpressionTarget(location) || location.kind === 107 /* ConstructorKeyword */) {
                    if (symbol.flags & 16 /* Class */) {
                        var classDeclaration = symbol.getDeclarations()[0];
                        ts.Debug.assert(classDeclaration && classDeclaration.kind === 174 /* ClassDeclaration */);
                        return tryAddSignature(classDeclaration.members, true, symbolKind, symbolName, containerName, result);
                    }
                }
                return false;
            }
            function tryAddCallSignature(symbol, location, symbolKind, symbolName, containerName, result) {
                if (isCallExpressionTarget(location) || isNewExpressionTarget(location) || isNameOfFunctionDeclaration(location)) {
                    return tryAddSignature(symbol.declarations, false, symbolKind, symbolName, containerName, result);
                }
                return false;
            }
            synchronizeHostData();
            filename = TypeScript.switchToForwardSlashes(filename);
            var sourceFile = getSourceFile(filename);
            var node = getNodeAtPosition(sourceFile, position);
            if (!node) {
                return undefined;
            }
            // Labels
            if (isJumpStatementTarget(node)) {
                var labelName = node.text;
                var label = getTargetLabel(node.parent, node.text);
                return label ? [getDefinitionInfo(label, ScriptElementKind.label, labelName, undefined)] : undefined;
            }
            /// Triple slash reference comments
            var comment = ts.forEach(sourceFile.referencedFiles, function (r) { return (r.pos <= position && position < r.end) ? r : undefined; });
            if (comment) {
                var targetFilename = ts.normalizePath(ts.combinePaths(ts.getDirectoryPath(filename), comment.filename));
                if (program.getSourceFile(targetFilename)) {
                    return [new DefinitionInfo(targetFilename, TypeScript.TextSpan.fromBounds(0, 0), ScriptElementKind.scriptElement, comment.filename, undefined, undefined)];
                }
                return undefined;
            }
            var symbol = typeInfoResolver.getSymbolInfo(node);
            // Could not find a symbol e.g. node is string or number keyword,
            // or the symbol was an internal symbol and does not have a declaration e.g. undefined symbol
            if (!symbol || !(symbol.getDeclarations())) {
                return undefined;
            }
            var result = [];
            var declarations = symbol.getDeclarations();
            var symbolName = typeInfoResolver.symbolToString(symbol, node);
            var symbolKind = getSymbolKind(symbol);
            var containerSymbol = symbol.parent;
            var containerName = containerSymbol ? typeInfoResolver.symbolToString(containerSymbol, node) : "";
            var containerKind = containerSymbol ? getSymbolKind(symbol) : "";
            if (!tryAddConstructSignature(symbol, node, symbolKind, symbolName, containerName, result) && !tryAddCallSignature(symbol, node, symbolKind, symbolName, containerName, result)) {
                // Just add all the declarations. 
                ts.forEach(declarations, function (declaration) {
                    result.push(getDefinitionInfo(declaration, symbolKind, symbolName, containerName));
                });
            }
            return result;
        }
        /// References and Occurances
        function getOccurrencesAtPosition(filename, position) {
            synchronizeHostData();
            filename = TypeScript.switchToForwardSlashes(filename);
            var sourceFile = getSourceFile(filename);
            var node = getNodeAtPosition(sourceFile, position);
            if (!node) {
                return undefined;
            }
            if (node.kind === 59 /* Identifier */ || node.kind === 87 /* ThisKeyword */ || node.kind === 85 /* SuperKeyword */ || isLiteralNameOfPropertyDeclarationOrIndexAccess(node) || isNameOfExternalModuleImportOrDeclaration(node)) {
                return getReferencesForNode(node, [sourceFile]);
            }
            switch (node.kind) {
                case 78 /* IfKeyword */:
                case 70 /* ElseKeyword */:
                    if (hasKind(node.parent, 152 /* IfStatement */)) {
                        return getIfElseOccurrences(node.parent);
                    }
                    break;
                case 84 /* ReturnKeyword */:
                    if (hasKind(node.parent, 159 /* ReturnStatement */)) {
                        return getReturnOccurrences(node.parent);
                    }
                    break;
                case 90 /* TryKeyword */:
                case 62 /* CatchKeyword */:
                case 75 /* FinallyKeyword */:
                    if (hasKind(parent(parent(node)), 166 /* TryStatement */)) {
                        return getTryCatchFinallyOccurrences(node.parent.parent);
                    }
                    break;
                case 86 /* SwitchKeyword */:
                    if (hasKind(node.parent, 161 /* SwitchStatement */)) {
                        return getSwitchCaseDefaultOccurrences(node.parent);
                    }
                    break;
                case 61 /* CaseKeyword */:
                case 67 /* DefaultKeyword */:
                    if (hasKind(parent(parent(node)), 161 /* SwitchStatement */)) {
                        return getSwitchCaseDefaultOccurrences(node.parent.parent);
                    }
                    break;
                case 60 /* BreakKeyword */:
                case 65 /* ContinueKeyword */:
                    if (hasKind(node.parent, 158 /* BreakStatement */) || hasKind(node.parent, 157 /* ContinueStatement */)) {
                        return getBreakOrContinueStatementOccurences(node.parent);
                    }
                    break;
                case 76 /* ForKeyword */:
                    if (hasKind(node.parent, 155 /* ForStatement */) || hasKind(node.parent, 156 /* ForInStatement */)) {
                        return getLoopBreakContinueOccurrences(node.parent);
                    }
                    break;
                case 94 /* WhileKeyword */:
                case 69 /* DoKeyword */:
                    if (hasKind(node.parent, 154 /* WhileStatement */) || hasKind(node.parent, 153 /* DoStatement */)) {
                        return getLoopBreakContinueOccurrences(node.parent);
                    }
                    break;
                case 107 /* ConstructorKeyword */:
                    if (hasKind(node.parent, 121 /* Constructor */)) {
                        return getConstructorOccurrences(node.parent);
                    }
                    break;
            }
            return undefined;
            function getIfElseOccurrences(ifStatement) {
                var keywords = [];
                while (hasKind(ifStatement.parent, 152 /* IfStatement */) && ifStatement.parent.elseStatement === ifStatement) {
                    ifStatement = ifStatement.parent;
                }
                while (ifStatement) {
                    var children = ifStatement.getChildren();
                    pushKeywordIf(keywords, children[0], 78 /* IfKeyword */);
                    for (var i = children.length - 1; i >= 0; i--) {
                        if (pushKeywordIf(keywords, children[i], 70 /* ElseKeyword */)) {
                            break;
                        }
                    }
                    if (!hasKind(ifStatement.elseStatement, 152 /* IfStatement */)) {
                        break;
                    }
                    ifStatement = ifStatement.elseStatement;
                }
                var result = [];
                for (var i = 0; i < keywords.length; i++) {
                    if (keywords[i].kind === 70 /* ElseKeyword */ && i < keywords.length - 1) {
                        var elseKeyword = keywords[i];
                        var ifKeyword = keywords[i + 1]; // this *should* always be an 'if' keyword.
                        var shouldHighlightNextKeyword = true;
                        for (var j = ifKeyword.getStart() - 1; j >= elseKeyword.end; j--) {
                            if (!ts.isWhiteSpace(sourceFile.text.charCodeAt(j))) {
                                shouldHighlightNextKeyword = false;
                                break;
                            }
                        }
                        if (shouldHighlightNextKeyword) {
                            result.push(new ReferenceEntry(filename, TypeScript.TextSpan.fromBounds(elseKeyword.getStart(), ifKeyword.end), false));
                            i++; // skip the next keyword
                            continue;
                        }
                    }
                    // Ordinary case: just highlight the keyword.
                    result.push(getReferenceEntryFromNode(keywords[i]));
                }
                return result;
            }
            function getReturnOccurrences(returnStatement) {
                var func = ts.getContainingFunction(returnStatement);
                // If we didn't find a containing function with a block body, bail out.
                if (!(func && hasKind(func.body, 173 /* FunctionBlock */))) {
                    return undefined;
                }
                var keywords = [];
                ts.forEachReturnStatement(func.body, function (returnStatement) {
                    pushKeywordIf(keywords, returnStatement.getFirstToken(), 84 /* ReturnKeyword */);
                });
                return ts.map(keywords, getReferenceEntryFromNode);
            }
            function getTryCatchFinallyOccurrences(tryStatement) {
                var keywords = [];
                pushKeywordIf(keywords, tryStatement.getFirstToken(), 90 /* TryKeyword */);
                if (tryStatement.catchBlock) {
                    pushKeywordIf(keywords, tryStatement.catchBlock.getFirstToken(), 62 /* CatchKeyword */);
                }
                if (tryStatement.finallyBlock) {
                    pushKeywordIf(keywords, tryStatement.finallyBlock.getFirstToken(), 75 /* FinallyKeyword */);
                }
                return ts.map(keywords, getReferenceEntryFromNode);
            }
            function getLoopBreakContinueOccurrences(loopNode) {
                var keywords = [];
                if (pushKeywordIf(keywords, loopNode.getFirstToken(), 76 /* ForKeyword */, 94 /* WhileKeyword */, 69 /* DoKeyword */)) {
                    // If we succeeded and got a do-while loop, then start looking for a 'while' keyword.
                    if (loopNode.kind === 153 /* DoStatement */) {
                        var loopTokens = loopNode.getChildren();
                        for (var i = loopTokens.length - 1; i >= 0; i--) {
                            if (pushKeywordIf(keywords, loopTokens[i], 94 /* WhileKeyword */)) {
                                break;
                            }
                        }
                    }
                }
                var breaksAndContinues = aggregateAllBreakAndContinueStatements(loopNode.statement);
                ts.forEach(breaksAndContinues, function (statement) {
                    if (ownsBreakOrContinueStatement(loopNode, statement)) {
                        pushKeywordIf(keywords, statement.getFirstToken(), 60 /* BreakKeyword */, 65 /* ContinueKeyword */);
                    }
                });
                return ts.map(keywords, getReferenceEntryFromNode);
            }
            function getSwitchCaseDefaultOccurrences(switchStatement) {
                var keywords = [];
                pushKeywordIf(keywords, switchStatement.getFirstToken(), 86 /* SwitchKeyword */);
                // Types of break statements we can grab on to.
                var breakSearchType = BreakContinueSearchType.All;
                // Go through each clause in the switch statement, collecting the 'case'/'default' keywords.
                ts.forEach(switchStatement.clauses, function (clause) {
                    pushKeywordIf(keywords, clause.getFirstToken(), 61 /* CaseKeyword */, 67 /* DefaultKeyword */);
                    var breaksAndContinues = aggregateAllBreakAndContinueStatements(clause);
                    ts.forEach(breaksAndContinues, function (statement) {
                        if (ownsBreakOrContinueStatement(switchStatement, statement)) {
                            pushKeywordIf(keywords, statement.getFirstToken(), 60 /* BreakKeyword */);
                        }
                    });
                });
                return ts.map(keywords, getReferenceEntryFromNode);
            }
            function getBreakOrContinueStatementOccurences(breakOrContinueStatement) {
                var owner = getBreakOrContinueOwner(breakOrContinueStatement);
                if (owner) {
                    switch (owner.kind) {
                        case 155 /* ForStatement */:
                        case 156 /* ForInStatement */:
                        case 153 /* DoStatement */:
                        case 154 /* WhileStatement */:
                            return getLoopBreakContinueOccurrences(owner);
                        case 161 /* SwitchStatement */:
                            return getSwitchCaseDefaultOccurrences(owner);
                    }
                }
                return undefined;
            }
            function aggregateAllBreakAndContinueStatements(node) {
                var statementAccumulator = [];
                aggregate(node);
                return statementAccumulator;
                function aggregate(node) {
                    if (node.kind === 158 /* BreakStatement */ || node.kind === 157 /* ContinueStatement */) {
                        statementAccumulator.push(node);
                    }
                    else if (!ts.isAnyFunction(node)) {
                        ts.forEachChild(node, aggregate);
                    }
                }
                ;
            }
            function ownsBreakOrContinueStatement(owner, statement) {
                var actualOwner = getBreakOrContinueOwner(statement);
                return actualOwner && actualOwner === owner;
            }
            function getBreakOrContinueOwner(statement) {
                for (var node = statement.parent; node; node = node.parent) {
                    switch (node.kind) {
                        case 161 /* SwitchStatement */:
                            if (statement.kind === 157 /* ContinueStatement */) {
                                continue;
                            }
                        case 155 /* ForStatement */:
                        case 156 /* ForInStatement */:
                        case 154 /* WhileStatement */:
                        case 153 /* DoStatement */:
                            if (!statement.label || isLabeledBy(node, statement.label.text)) {
                                return node;
                            }
                            break;
                        default:
                            // Don't cross function boundaries.
                            if (ts.isAnyFunction(node)) {
                                return undefined;
                            }
                            break;
                    }
                }
                return undefined;
            }
            function getConstructorOccurrences(constructorDeclaration) {
                var declarations = constructorDeclaration.symbol.getDeclarations();
                var keywords = [];
                ts.forEach(declarations, function (declaration) {
                    ts.forEach(declaration.getChildren(), function (token) {
                        return pushKeywordIf(keywords, token, 107 /* ConstructorKeyword */);
                    });
                });
                return ts.map(keywords, getReferenceEntryFromNode);
            }
            // returns true if 'node' is defined and has a matching 'kind'.
            function hasKind(node, kind) {
                return node !== undefined && node.kind === kind;
            }
            // Null-propagating 'parent' function.
            function parent(node) {
                return node && node.parent;
            }
            function pushKeywordIf(keywordList, token) {
                var expected = [];
                for (var _i = 2; _i < arguments.length; _i++) {
                    expected[_i - 2] = arguments[_i];
                }
                if (token && ts.contains(expected, token.kind)) {
                    keywordList.push(token);
                    return true;
                }
                return false;
            }
        }
        function getReferencesAtPosition(filename, position) {
            synchronizeHostData();
            filename = TypeScript.switchToForwardSlashes(filename);
            var sourceFile = getSourceFile(filename);
            var node = getNodeAtPosition(sourceFile, position);
            if (!node) {
                return undefined;
            }
            if (node.kind !== 59 /* Identifier */ && !isLiteralNameOfPropertyDeclarationOrIndexAccess(node) && !isNameOfExternalModuleImportOrDeclaration(node)) {
                return undefined;
            }
            return getReferencesForNode(node, program.getSourceFiles());
        }
        function getReferencesForNode(node, sourceFiles) {
            // Labels
            if (isLabelName(node)) {
                if (isJumpStatementTarget(node)) {
                    var labelDefinition = getTargetLabel(node.parent, node.text);
                    // if we have a label definition, look within its statement for references, if not, then
                    // the label is undefined, just return a set of one for the current node.
                    return labelDefinition ? getLabelReferencesInNode(labelDefinition.parent, labelDefinition) : [getReferenceEntryFromNode(node)];
                }
                else {
                    // it is a label definition and not a target, search within the parent labeledStatement
                    return getLabelReferencesInNode(node.parent, node);
                }
            }
            if (node.kind === 87 /* ThisKeyword */) {
                return getReferencesForThisKeyword(node, sourceFiles);
            }
            if (node.kind === 85 /* SuperKeyword */) {
                return getReferencesForSuperKeyword(node);
            }
            var symbol = typeInfoResolver.getSymbolInfo(node);
            // Could not find a symbol e.g. unknown identifier
            if (!symbol) {
                // Even if we did not find a symbol, we have an identifier, so there is at least
                // one reference that we know of. return that instead of undefined.
                return [getReferenceEntryFromNode(node)];
            }
            // the symbol was an internal symbol and does not have a declaration e.g.undefined symbol
            if (!symbol.getDeclarations()) {
                return undefined;
            }
            var result;
            // Compute the meaning from the location and the symbol it references
            var searchMeaning = getIntersectingMeaningFromDeclarations(getMeaningFromLocation(node), symbol.getDeclarations());
            // Get the text to search for, we need to normalize it as external module names will have quote
            var symbolName = getNormalizedSymbolName(symbol);
            // Get syntactic diagnostics
            var scope = getSymbolScope(symbol);
            if (scope) {
                result = [];
                getReferencesInNode(scope, symbol, symbolName, node, searchMeaning, result);
            }
            else {
                ts.forEach(sourceFiles, function (sourceFile) {
                    cancellationToken.throwIfCancellationRequested();
                    if (ts.lookUp(sourceFile.identifiers, symbolName)) {
                        result = result || [];
                        getReferencesInNode(sourceFile, symbol, symbolName, node, searchMeaning, result);
                    }
                });
            }
            return result;
            function getNormalizedSymbolName(symbol) {
                // Special case for function expressions, whose names are solely local to their bodies.
                var functionExpression = ts.getDeclarationOfKind(symbol, 141 /* FunctionExpression */);
                if (functionExpression && functionExpression.name) {
                    var name = functionExpression.name.text;
                }
                else {
                    var name = symbol.name;
                }
                var length = name.length;
                if (length >= 2 && name.charCodeAt(0) === 34 /* doubleQuote */ && name.charCodeAt(length - 1) === 34 /* doubleQuote */) {
                    return name.substring(1, length - 1);
                }
                ;
                return name;
            }
            function getSymbolScope(symbol) {
                // If this is private property or method, the scope is the containing class
                if (symbol.getFlags() && (2 /* Property */ | 2048 /* Method */)) {
                    var privateDeclaration = ts.forEach(symbol.getDeclarations(), function (d) { return (d.flags & 32 /* Private */) ? d : undefined; });
                    if (privateDeclaration) {
                        return privateDeclaration.parent;
                    }
                }
                // if this symbol is visible from its parent container, e.g. exported, then bail out
                if (symbol.parent) {
                    return undefined;
                }
                var scope = undefined;
                var declarations = symbol.getDeclarations();
                for (var i = 0, n = declarations.length; i < n; i++) {
                    var container = getContainerNode(declarations[i]);
                    if (scope && scope !== container) {
                        // Different declarations have different containers, bail out
                        return undefined;
                    }
                    if (container.kind === 182 /* SourceFile */ && !ts.isExternalModule(container)) {
                        // This is a global variable and not an external module, any declaration defined
                        // within this scope is visible outside the file
                        return undefined;
                    }
                    // The search scope is the container node
                    scope = container;
                }
                return scope;
            }
            function getPossibleSymbolReferencePositions(sourceFile, symbolName, start, end) {
                var positions = [];
                /// TODO: Cache symbol existence for files to save text search
                // Also, need to make this work for unicode escapes.
                // Be resilient in the face of a symbol with no name or zero length name
                if (!symbolName || !symbolName.length) {
                    return positions;
                }
                var text = sourceFile.text;
                var sourceLength = text.length;
                var symbolNameLength = symbolName.length;
                var position = text.indexOf(symbolName, start);
                while (position >= 0) {
                    cancellationToken.throwIfCancellationRequested();
                    // If we are past the end, stop looking
                    if (position > end)
                        break;
                    // We found a match.  Make sure it's not part of a larger word (i.e. the char 
                    // before and after it have to be a non-identifier char).
                    var endPosition = position + symbolNameLength;
                    if ((position === 0 || !ts.isIdentifierPart(text.charCodeAt(position - 1), 1 /* ES5 */)) && (endPosition === sourceLength || !ts.isIdentifierPart(text.charCodeAt(endPosition), 1 /* ES5 */))) {
                        // Found a real match.  Keep searching.  
                        positions.push(position);
                    }
                    position = text.indexOf(symbolName, position + symbolNameLength + 1);
                }
                return positions;
            }
            function getLabelReferencesInNode(container, targetLabel) {
                var result = [];
                var sourceFile = container.getSourceFile();
                var labelName = targetLabel.text;
                var possiblePositions = getPossibleSymbolReferencePositions(sourceFile, labelName, container.getStart(), container.getEnd());
                ts.forEach(possiblePositions, function (position) {
                    cancellationToken.throwIfCancellationRequested();
                    var node = getNodeAtPosition(sourceFile, position);
                    if (!node || node.getWidth() !== labelName.length) {
                        return;
                    }
                    // Only pick labels that are either the target label, or have a target that is the target label
                    if (node === targetLabel || (isJumpStatementTarget(node) && getTargetLabel(node, labelName) === targetLabel)) {
                        result.push(getReferenceEntryFromNode(node));
                    }
                });
                return result;
            }
            function isValidReferencePosition(node, searchSymbolName) {
                if (node) {
                    switch (node.kind) {
                        case 59 /* Identifier */:
                            return node.getWidth() === searchSymbolName.length;
                        case 7 /* StringLiteral */:
                            if (isLiteralNameOfPropertyDeclarationOrIndexAccess(node) || isNameOfExternalModuleImportOrDeclaration(node)) {
                                // For string literals we have two additional chars for the quotes
                                return node.getWidth() === searchSymbolName.length + 2;
                            }
                            break;
                        case 6 /* NumericLiteral */:
                            if (isLiteralNameOfPropertyDeclarationOrIndexAccess(node)) {
                                return node.getWidth() === searchSymbolName.length;
                            }
                            break;
                    }
                }
                return false;
            }
            /** Search within node "container" for references for a search value, where the search value is defined as a
              * tuple of(searchSymbol, searchText, searchLocation, and searchMeaning).
              * searchLocation: a node where the search value
              */
            function getReferencesInNode(container, searchSymbol, searchText, searchLocation, searchMeaning, result) {
                var sourceFile = container.getSourceFile();
                var possiblePositions = getPossibleSymbolReferencePositions(sourceFile, searchText, container.getStart(), container.getEnd());
                if (possiblePositions.length) {
                    // Build the set of symbols to search for, initially it has only the current symbol
                    var searchSymbols = populateSearchSymbolSet(searchSymbol, searchLocation);
                    ts.forEach(possiblePositions, function (position) {
                        cancellationToken.throwIfCancellationRequested();
                        var referenceLocation = getNodeAtPosition(sourceFile, position);
                        if (!isValidReferencePosition(referenceLocation, searchText)) {
                            return;
                        }
                        if (!(getMeaningFromLocation(referenceLocation) & searchMeaning)) {
                            return;
                        }
                        var referenceSymbol = typeInfoResolver.getSymbolInfo(referenceLocation);
                        // Could not find a symbol e.g. node is string or number keyword,
                        // or the symbol was an internal symbol and does not have a declaration e.g. undefined symbol
                        if (!referenceSymbol || !(referenceSymbol.getDeclarations())) {
                            return;
                        }
                        if (isRelatableToSearchSet(searchSymbols, referenceSymbol, referenceLocation)) {
                            result.push(getReferenceEntryFromNode(referenceLocation));
                        }
                    });
                }
            }
            function getReferencesForSuperKeyword(superKeyword) {
                var searchSpaceNode = ts.getSuperContainer(superKeyword);
                if (!searchSpaceNode) {
                    return undefined;
                }
                // Whether 'super' occurs in a static context within a class.
                var staticFlag = 128 /* Static */;
                switch (searchSpaceNode.kind) {
                    case 119 /* Property */:
                    case 120 /* Method */:
                    case 121 /* Constructor */:
                    case 122 /* GetAccessor */:
                    case 123 /* SetAccessor */:
                        staticFlag &= searchSpaceNode.flags;
                        searchSpaceNode = searchSpaceNode.parent; // re-assign to be the owning class
                        break;
                    default:
                        return undefined;
                }
                var result = [];
                var sourceFile = searchSpaceNode.getSourceFile();
                var possiblePositions = getPossibleSymbolReferencePositions(sourceFile, "super", searchSpaceNode.getStart(), searchSpaceNode.getEnd());
                ts.forEach(possiblePositions, function (position) {
                    cancellationToken.throwIfCancellationRequested();
                    var node = getNodeAtPosition(sourceFile, position);
                    if (!node || node.kind !== 85 /* SuperKeyword */) {
                        return;
                    }
                    var container = ts.getSuperContainer(node);
                    // If we have a 'super' container, we must have an enclosing class.
                    // Now make sure the owning class is the same as the search-space
                    // and has the same static qualifier as the original 'super's owner.
                    if (container && (128 /* Static */ & container.flags) === staticFlag && container.parent.symbol === searchSpaceNode.symbol) {
                        result.push(getReferenceEntryFromNode(node));
                    }
                });
                return result;
            }
            function getReferencesForThisKeyword(thisOrSuperKeyword, sourceFiles) {
                var searchSpaceNode = ts.getThisContainer(thisOrSuperKeyword, false);
                // Whether 'this' occurs in a static context within a class.
                var staticFlag = 128 /* Static */;
                switch (searchSpaceNode.kind) {
                    case 119 /* Property */:
                    case 120 /* Method */:
                    case 121 /* Constructor */:
                    case 122 /* GetAccessor */:
                    case 123 /* SetAccessor */:
                        staticFlag &= searchSpaceNode.flags;
                        searchSpaceNode = searchSpaceNode.parent; // re-assign to be the owning class
                        break;
                    case 182 /* SourceFile */:
                        if (ts.isExternalModule(searchSpaceNode)) {
                            return undefined;
                        }
                    case 172 /* FunctionDeclaration */:
                    case 141 /* FunctionExpression */:
                        break;
                    default:
                        return undefined;
                }
                var result = [];
                if (searchSpaceNode.kind === 182 /* SourceFile */) {
                    ts.forEach(sourceFiles, function (sourceFile) {
                        var possiblePositions = getPossibleSymbolReferencePositions(sourceFile, "this", sourceFile.getStart(), sourceFile.getEnd());
                        getThisReferencesInFile(sourceFile, sourceFile, possiblePositions, result);
                    });
                }
                else {
                    var sourceFile = searchSpaceNode.getSourceFile();
                    var possiblePositions = getPossibleSymbolReferencePositions(sourceFile, "this", searchSpaceNode.getStart(), searchSpaceNode.getEnd());
                    getThisReferencesInFile(sourceFile, searchSpaceNode, possiblePositions, result);
                }
                return result;
                function getThisReferencesInFile(sourceFile, searchSpaceNode, possiblePositions, result) {
                    ts.forEach(possiblePositions, function (position) {
                        cancellationToken.throwIfCancellationRequested();
                        var node = getNodeAtPosition(sourceFile, position);
                        if (!node || node.kind !== 87 /* ThisKeyword */) {
                            return;
                        }
                        var container = ts.getThisContainer(node, false);
                        switch (searchSpaceNode.kind) {
                            case 141 /* FunctionExpression */:
                            case 172 /* FunctionDeclaration */:
                                if (searchSpaceNode.symbol === container.symbol) {
                                    result.push(getReferenceEntryFromNode(node));
                                }
                                break;
                            case 174 /* ClassDeclaration */:
                                // Make sure the container belongs to the same class
                                // and has the appropriate static modifier from the original container.
                                if (container.parent && searchSpaceNode.symbol === container.parent.symbol && (container.flags & 128 /* Static */) === staticFlag) {
                                    result.push(getReferenceEntryFromNode(node));
                                }
                                break;
                            case 182 /* SourceFile */:
                                if (container.kind === 182 /* SourceFile */ && !ts.isExternalModule(container)) {
                                    result.push(getReferenceEntryFromNode(node));
                                }
                                break;
                        }
                    });
                }
            }
            function populateSearchSymbolSet(symbol, location) {
                // The search set contains at least the current symbol
                var result = [symbol];
                // If the symbol is an instantiation from a another symbol (e.g. widened symbol) , add the root the list
                var rootSymbol = typeInfoResolver.getRootSymbol(symbol);
                if (rootSymbol && rootSymbol !== symbol) {
                    result.push(rootSymbol);
                }
                // If the location is in a context sensitive location (i.e. in an object literal) try
                // to get a contextual type for it, and add the property symbol from the contextual
                // type to the search set
                if (isNameOfPropertyAssignment(location)) {
                    var symbolFromContextualType = getPropertySymbolFromContextualType(location);
                    if (symbolFromContextualType)
                        result.push(typeInfoResolver.getRootSymbol(symbolFromContextualType));
                }
                // Add symbol of properties/methods of the same name in base classes and implemented interfaces definitions
                if (symbol.parent && symbol.parent.flags & (16 /* Class */ | 32 /* Interface */)) {
                    getPropertySymbolsFromBaseTypes(symbol.parent, symbol.getName(), result);
                }
                return result;
            }
            function getPropertySymbolsFromBaseTypes(symbol, propertyName, result) {
                if (symbol.flags & (16 /* Class */ | 32 /* Interface */)) {
                    ts.forEach(symbol.getDeclarations(), function (declaration) {
                        if (declaration.kind === 174 /* ClassDeclaration */) {
                            getPropertySymbolFromTypeReference(declaration.baseType);
                            ts.forEach(declaration.implementedTypes, getPropertySymbolFromTypeReference);
                        }
                        else if (declaration.kind === 175 /* InterfaceDeclaration */) {
                            ts.forEach(declaration.baseTypes, getPropertySymbolFromTypeReference);
                        }
                    });
                }
                return;
                function getPropertySymbolFromTypeReference(typeReference) {
                    if (typeReference) {
                        // TODO: move to getTypeOfNode instead
                        var typeReferenceSymbol = typeInfoResolver.getSymbolInfo(typeReference.typeName);
                        if (typeReferenceSymbol) {
                            var propertySymbol = typeReferenceSymbol.members[propertyName];
                            if (propertySymbol)
                                result.push(typeReferenceSymbol.members[propertyName]);
                            // Visit the typeReference as well to see if it directly or indirectly use that property
                            getPropertySymbolsFromBaseTypes(typeReferenceSymbol, propertyName, result);
                        }
                    }
                }
            }
            function isRelatableToSearchSet(searchSymbols, referenceSymbol, referenceLocation) {
                // Unwrap symbols to get to the root (e.g. transient symbols as a result of widening)
                var referenceSymbolTarget = typeInfoResolver.getRootSymbol(referenceSymbol);
                // if it is in the list, then we are done
                if (searchSymbols.indexOf(referenceSymbolTarget) >= 0) {
                    return true;
                }
                // If the reference location is in an object literal, try to get the contextual type for the 
                // object literal, lookup the property symbol in the contextual type, and use this symbol to
                // compare to our searchSymbol
                if (isNameOfPropertyAssignment(referenceLocation)) {
                    var symbolFromContextualType = getPropertySymbolFromContextualType(referenceLocation);
                    if (symbolFromContextualType && searchSymbols.indexOf(typeInfoResolver.getRootSymbol(symbolFromContextualType)) >= 0) {
                        return true;
                    }
                }
                // Finally, try all properties with the same name in any type the containing type extend or implemented, and 
                // see if any is in the list
                if (referenceSymbol.parent && referenceSymbol.parent.flags & (16 /* Class */ | 32 /* Interface */)) {
                    var result = [];
                    getPropertySymbolsFromBaseTypes(referenceSymbol.parent, referenceSymbol.getName(), result);
                    return ts.forEach(result, function (s) { return searchSymbols.indexOf(s) >= 0; });
                }
                return false;
            }
            function getPropertySymbolFromContextualType(node) {
                if (isNameOfPropertyAssignment(node)) {
                    var objectLiteral = node.parent.parent;
                    var contextualType = typeInfoResolver.getContextualType(objectLiteral);
                    if (contextualType) {
                        return typeInfoResolver.getPropertyOfType(contextualType, node.text);
                    }
                }
                return undefined;
            }
            function getMeaningFromDeclaration(node) {
                switch (node.kind) {
                    case 118 /* Parameter */:
                    case 171 /* VariableDeclaration */:
                    case 119 /* Property */:
                    case 134 /* PropertyAssignment */:
                    case 181 /* EnumMember */:
                    case 120 /* Method */:
                    case 121 /* Constructor */:
                    case 122 /* GetAccessor */:
                    case 123 /* SetAccessor */:
                    case 172 /* FunctionDeclaration */:
                    case 141 /* FunctionExpression */:
                    case 142 /* ArrowFunction */:
                    case 168 /* CatchBlock */:
                        return 1 /* Value */;
                    case 117 /* TypeParameter */:
                    case 175 /* InterfaceDeclaration */:
                    case 129 /* TypeLiteral */:
                        return 2 /* Type */;
                    case 174 /* ClassDeclaration */:
                    case 176 /* EnumDeclaration */:
                        return 1 /* Value */ | 2 /* Type */;
                    case 177 /* ModuleDeclaration */:
                        if (node.name.kind === 7 /* StringLiteral */) {
                            return 4 /* Namespace */ | 1 /* Value */;
                        }
                        else if (ts.isInstantiated(node)) {
                            return 4 /* Namespace */ | 1 /* Value */;
                        }
                        else {
                            return 4 /* Namespace */;
                        }
                        break;
                    case 179 /* ImportDeclaration */:
                        return 1 /* Value */ | 2 /* Type */ | 4 /* Namespace */;
                }
                ts.Debug.fail("Unknown declaration type");
            }
            function isTypeReference(node) {
                if (node.parent.kind === 116 /* QualifiedName */ && node.parent.right === node)
                    node = node.parent;
                return node.parent.kind === 127 /* TypeReference */;
            }
            function isNamespaceReference(node) {
                var root = node;
                var isLastClause = true;
                if (root.parent.kind === 116 /* QualifiedName */) {
                    while (root.parent && root.parent.kind === 116 /* QualifiedName */)
                        root = root.parent;
                    isLastClause = root.right === node;
                }
                return root.parent.kind === 127 /* TypeReference */ && !isLastClause;
            }
            function isInRightSideOfImport(node) {
                while (node.parent.kind === 116 /* QualifiedName */) {
                    node = node.parent;
                }
                return node.parent.kind === 179 /* ImportDeclaration */ && node.parent.entityName === node;
            }
            function getMeaningFromRightHandSideOfImport(node) {
                ts.Debug.assert(node.kind === 59 /* Identifier */);
                //     import a = |b|; // Namespace
                //     import a = |b.c|; // Value, type, namespace
                //     import a = |b.c|.d; // Namespace
                if (node.parent.kind === 116 /* QualifiedName */ && node.parent.right === node && node.parent.parent.kind === 179 /* ImportDeclaration */) {
                    return 1 /* Value */ | 2 /* Type */ | 4 /* Namespace */;
                }
                return 4 /* Namespace */;
            }
            function getMeaningFromLocation(node) {
                if (node.parent.kind === 180 /* ExportAssignment */) {
                    return 1 /* Value */ | 2 /* Type */ | 4 /* Namespace */;
                }
                else if (isInRightSideOfImport(node)) {
                    return getMeaningFromRightHandSideOfImport(node);
                }
                else if (ts.isDeclarationOrFunctionExpressionOrCatchVariableName(node)) {
                    return getMeaningFromDeclaration(node.parent);
                }
                else if (isTypeReference(node)) {
                    return 2 /* Type */;
                }
                else if (isNamespaceReference(node)) {
                    return 4 /* Namespace */;
                }
                else {
                    return 1 /* Value */;
                }
            }
            /** Given an initial searchMeaning, extracted from a location, widen the search scope based on the declarations
              * of the corresponding symbol. e.g. if we are searching for "Foo" in value position, but "Foo" references a class
              * then we need to widen the search to include type positions as well.
              * On the contrary, if we are searching for "Bar" in type position and we trace bar to an interface, and an uninstantiated
              * module, we want to keep the search limited to only types, as the two declarations (interface and uninstantiated module)
              * do not intersect in any of the three spaces.
              */
            function getIntersectingMeaningFromDeclarations(meaning, declarations) {
                if (declarations) {
                    do {
                        // The result is order-sensitive, for instance if initialMeaning === Namespace, and declarations = [class, instantiated module]
                        // we need to consider both as they initialMeaning intersects with the module in the namespace space, and the module
                        // intersects with the class in the value space.
                        // To achieve that we will keep iterating until the result stabilizes.
                        // Remember the last meaning
                        var lastIterationMeaning = meaning;
                        for (var i = 0, n = declarations.length; i < n; i++) {
                            var declarationMeaning = getMeaningFromDeclaration(declarations[i]);
                            if (declarationMeaning & meaning) {
                                meaning |= declarationMeaning;
                            }
                        }
                    } while (meaning !== lastIterationMeaning);
                }
                return meaning;
            }
        }
        function getReferenceEntryFromNode(node) {
            var start = node.getStart();
            var end = node.getEnd();
            if (node.kind === 7 /* StringLiteral */) {
                start += 1;
                end -= 1;
            }
            return new ReferenceEntry(node.getSourceFile().filename, TypeScript.TextSpan.fromBounds(start, end), isWriteAccess(node));
        }
        /** A node is considered a writeAccess iff it is a name of a declaration or a target of an assignment */
        function isWriteAccess(node) {
            if (node.kind === 59 /* Identifier */ && ts.isDeclarationOrFunctionExpressionOrCatchVariableName(node)) {
                return true;
            }
            var parent = node.parent;
            if (parent) {
                if (parent.kind === 144 /* PostfixOperator */ || parent.kind === 143 /* PrefixOperator */) {
                    return true;
                }
                else if (parent.kind === 145 /* BinaryExpression */ && parent.left === node) {
                    var operator = parent.operator;
                    return ts.SyntaxKind.FirstAssignment <= operator && operator <= ts.SyntaxKind.LastAssignment;
                }
            }
            return false;
        }
        /// NavigateTo
        function getNavigateToItems(searchValue) {
            synchronizeHostData();
            // Split search value in terms array
            var terms = searchValue.split(" ");
            // default NavigateTo approach: if search term contains only lower-case chars - use case-insensitive search, otherwise switch to case-sensitive version
            var searchTerms = ts.map(terms, function (t) { return ({ caseSensitive: hasAnyUpperCaseCharacter(t), term: t }); });
            var items = [];
            // Search the declarations in all files and output matched NavigateToItem into array of NavigateToItem[] 
            ts.forEach(program.getSourceFiles(), function (sourceFile) {
                cancellationToken.throwIfCancellationRequested();
                var filename = sourceFile.filename;
                var declarations = sourceFile.getNamedDeclarations();
                for (var i = 0, n = declarations.length; i < n; i++) {
                    var declaration = declarations[i];
                    var name = declaration.name.text;
                    var matchKind = getMatchKind(searchTerms, name);
                    if (matchKind !== 0 /* none */) {
                        var container = getContainerNode(declaration);
                        items.push({
                            name: name,
                            kind: getNodeKind(declaration),
                            kindModifiers: getNodeModifiers(declaration),
                            matchKind: MatchKind[matchKind],
                            fileName: filename,
                            textSpan: TypeScript.TextSpan.fromBounds(declaration.getStart(), declaration.getEnd()),
                            containerName: container.name ? container.name.text : "",
                            containerKind: container.name ? getNodeKind(container) : ""
                        });
                    }
                }
            });
            return items;
            function hasAnyUpperCaseCharacter(s) {
                for (var i = 0, n = s.length; i < n; i++) {
                    var c = s.charCodeAt(i);
                    if ((65 /* A */ <= c && c <= 90 /* Z */) || (c >= 127 /* maxAsciiCharacter */ && s.charAt(i).toLocaleLowerCase() !== s.charAt(i))) {
                        return true;
                    }
                }
                return false;
            }
            function getMatchKind(searchTerms, name) {
                var matchKind = 0 /* none */;
                if (name) {
                    for (var j = 0, n = searchTerms.length; j < n; j++) {
                        var searchTerm = searchTerms[j];
                        var nameToSearch = searchTerm.caseSensitive ? name : name.toLocaleLowerCase();
                        // in case of case-insensitive search searchTerm.term will already be lower-cased
                        var index = nameToSearch.indexOf(searchTerm.term);
                        if (index < 0) {
                            // Didn't match.
                            return 0 /* none */;
                        }
                        var termKind = 2 /* substring */;
                        if (index === 0) {
                            // here we know that match occur at the beginning of the string.
                            // if search term and declName has the same length - we have an exact match, otherwise declName have longer length and this will be prefix match
                            termKind = name.length === searchTerm.term.length ? 1 /* exact */ : 3 /* prefix */;
                        }
                        // Update our match kind if we don't have one, or if this match is better.
                        if (matchKind === 0 /* none */ || termKind < matchKind) {
                            matchKind = termKind;
                        }
                    }
                }
                return matchKind;
            }
        }
        function containErrors(diagnostics) {
            return ts.forEach(diagnostics, function (diagnostic) { return diagnostic.category === 1 /* Error */; });
        }
        function getEmitOutput(filename) {
            synchronizeHostData();
            filename = TypeScript.switchToForwardSlashes(filename);
            var compilerOptions = program.getCompilerOptions();
            var targetSourceFile = program.getSourceFile(filename); // Current selected file to be output
            var emitToSingleFile = ts.shouldEmitToOwnFile(targetSourceFile, compilerOptions);
            var emitDeclaration = compilerOptions.declaration;
            var emitOutput = {
                outputFiles: [],
                emitOutputStatus: undefined
            };
            function getEmitOutputWriter(filename, data, writeByteOrderMark) {
                emitOutput.outputFiles.push({
                    name: filename,
                    writeByteOrderMark: writeByteOrderMark,
                    text: data
                });
            }
            // Initialize writer for CompilerHost.writeFile
            writer = getEmitOutputWriter;
            var syntacticDiagnostics = [];
            var containSyntacticErrors = false;
            if (emitToSingleFile) {
                // Check only the file we want to emit
                containSyntacticErrors = containErrors(program.getDiagnostics(targetSourceFile));
            }
            else {
                // Check the syntactic of only sourceFiles that will get emitted into single output
                // Terminate the process immediately if we encounter a syntax error from one of the sourceFiles
                containSyntacticErrors = ts.forEach(program.getSourceFiles(), function (sourceFile) {
                    if (!ts.isExternalModuleOrDeclarationFile(sourceFile)) {
                        // If emit to a single file then we will check all files that do not have external module
                        return containErrors(program.getDiagnostics(sourceFile));
                    }
                    return false;
                });
            }
            if (containSyntacticErrors) {
                // If there is a syntax error, terminate the process and report outputStatus
                emitOutput.emitOutputStatus = 1 /* AllOutputGenerationSkipped */;
                // Reset writer back to undefined to make sure that we produce an error message
                // if CompilerHost.writeFile is called when we are not in getEmitOutput
                writer = undefined;
                return emitOutput;
            }
            // Perform semantic and force a type check before emit to ensure that all symbols are updated
            // EmitFiles will report if there is an error from TypeChecker and Emitter
            // Depend whether we will have to emit into a single file or not either emit only selected file in the project, emit all files into a single file
            var emitFilesResult = emitToSingleFile ? getFullTypeCheckChecker().emitFiles(targetSourceFile) : getFullTypeCheckChecker().emitFiles();
            emitOutput.emitOutputStatus = emitFilesResult.emitResultStatus;
            // Reset writer back to undefined to make sure that we produce an error message if CompilerHost.writeFile method is called when we are not in getEmitOutput
            writer = undefined;
            return emitOutput;
        }
        /// Syntactic features
        function getSyntaxTree(filename) {
            filename = TypeScript.switchToForwardSlashes(filename);
            return syntaxTreeCache.getCurrentFileSyntaxTree(filename);
        }
        function getCurrentSourceFile(filename) {
            filename = TypeScript.switchToForwardSlashes(filename);
            var currentSourceFile = syntaxTreeCache.getCurrentSourceFile(filename);
            return currentSourceFile;
        }
        function getNameOrDottedNameSpan(filename, startPos, endPos) {
            function getTypeInfoEligiblePath(filename, position, isConstructorValidPosition) {
                var sourceUnit = syntaxTreeCache.getCurrentFileSyntaxTree(filename).sourceUnit();
                var ast = TypeScript.ASTHelpers.getAstAtPosition(sourceUnit, position, false, true);
                if (ast === null) {
                    return null;
                }
                if (ast.kind() === 228 /* ParameterList */ && ast.parent.kind() === 143 /* CallSignature */ && ast.parent.parent.kind() === 138 /* ConstructorDeclaration */) {
                    ast = ast.parent.parent;
                }
                switch (ast.kind()) {
                    default:
                        return null;
                    case 138 /* ConstructorDeclaration */:
                        var constructorAST = ast;
                        if (!isConstructorValidPosition || !(position >= TypeScript.start(constructorAST) && position <= TypeScript.start(constructorAST) + "constructor".length)) {
                            return null;
                        }
                        else {
                            return ast;
                        }
                    case 130 /* FunctionDeclaration */:
                        return null;
                    case 213 /* MemberAccessExpression */:
                    case 121 /* QualifiedName */:
                    case 50 /* SuperKeyword */:
                    case 14 /* StringLiteral */:
                    case 35 /* ThisKeyword */:
                    case 11 /* IdentifierName */:
                        return ast;
                }
            }
            filename = TypeScript.switchToForwardSlashes(filename);
            var node = getTypeInfoEligiblePath(filename, startPos, false);
            if (!node)
                return null;
            while (node) {
                if (TypeScript.ASTHelpers.isNameOfMemberAccessExpression(node) || TypeScript.ASTHelpers.isRightSideOfQualifiedName(node)) {
                    node = node.parent;
                }
                else {
                    break;
                }
            }
            return TypeScript.TextSpan.fromBounds(TypeScript.start(node), TypeScript.end(node));
        }
        function getBreakpointStatementAtPosition(filename, position) {
            // doesn't use compiler - no need to synchronize with host
            filename = TypeScript.switchToForwardSlashes(filename);
            var syntaxtree = getSyntaxTree(filename);
            return TypeScript.Services.Breakpoints.getBreakpointLocation(syntaxtree, position);
        }
        function getNavigationBarItems(filename) {
            filename = TypeScript.switchToForwardSlashes(filename);
            var syntaxTree = getSyntaxTree(filename);
            return new TypeScript.Services.NavigationBarItemGetter().getItems(syntaxTree.sourceUnit());
        }
        function getSemanticClassifications(fileName, span) {
            synchronizeHostData();
            fileName = TypeScript.switchToForwardSlashes(fileName);
            var sourceFile = getSourceFile(fileName);
            var result = [];
            processNode(sourceFile);
            return result;
            function classifySymbol(symbol) {
                var flags = symbol.getFlags();
                if (flags & 16 /* Class */) {
                    return ClassificationTypeNames.className;
                }
                else if (flags & 64 /* Enum */) {
                    return ClassificationTypeNames.enumName;
                }
                else if (flags & 32 /* Interface */) {
                    return ClassificationTypeNames.interfaceName;
                }
                else if (flags & ts.SymbolFlags.Module) {
                    return ClassificationTypeNames.moduleName;
                }
                else if (flags & 262144 /* TypeParameter */) {
                    return ClassificationTypeNames.typeParameterName;
                }
            }
            function processNode(node) {
                // Only walk into nodes that intersect the requested span.
                if (node && span.intersectsWith(node.getStart(), node.getWidth())) {
                    if (node.kind === 59 /* Identifier */ && node.getWidth() > 0) {
                        var symbol = typeInfoResolver.getSymbolInfo(node);
                        if (symbol) {
                            var type = classifySymbol(symbol);
                            if (type) {
                                result.push(new ClassifiedSpan(new TypeScript.TextSpan(node.getStart(), node.getWidth()), type));
                            }
                        }
                    }
                    ts.forEachChild(node, processNode);
                }
            }
        }
        function getSyntacticClassifications(fileName, span) {
            // doesn't use compiler - no need to synchronize with host
            fileName = TypeScript.switchToForwardSlashes(fileName);
            var sourceFile = getCurrentSourceFile(fileName);
            var result = [];
            processElement(sourceFile.getSourceUnit());
            return result;
            function classifyTrivia(trivia) {
                if (trivia.isComment() && span.intersectsWith(trivia.fullStart(), trivia.fullWidth())) {
                    result.push(new ClassifiedSpan(new TypeScript.TextSpan(trivia.fullStart(), trivia.fullWidth()), ClassificationTypeNames.comment));
                }
            }
            function classifyTriviaList(trivia) {
                for (var i = 0, n = trivia.count(); i < n; i++) {
                    classifyTrivia(trivia.syntaxTriviaAt(i));
                }
            }
            function classifyToken(token) {
                if (token.hasLeadingComment()) {
                    classifyTriviaList(token.leadingTrivia());
                }
                if (TypeScript.width(token) > 0) {
                    var type = classifyTokenType(token);
                    if (type) {
                        result.push(new ClassifiedSpan(new TypeScript.TextSpan(TypeScript.start(token), TypeScript.width(token)), type));
                    }
                }
                if (token.hasTrailingComment()) {
                    classifyTriviaList(token.trailingTrivia());
                }
            }
            function classifyTokenType(token) {
                var tokenKind = token.kind();
                if (TypeScript.SyntaxFacts.isAnyKeyword(token.kind())) {
                    return ClassificationTypeNames.keyword;
                }
                // Special case < and >  If they appear in a generic context they are punctation,
                // not operators.
                if (tokenKind === 80 /* LessThanToken */ || tokenKind === 81 /* GreaterThanToken */) {
                    var tokenParentKind = token.parent.kind();
                    if (tokenParentKind === 229 /* TypeArgumentList */ || tokenParentKind === 230 /* TypeParameterList */) {
                        return ClassificationTypeNames.punctuation;
                    }
                }
                if (TypeScript.SyntaxFacts.isBinaryExpressionOperatorToken(tokenKind) || TypeScript.SyntaxFacts.isPrefixUnaryExpressionOperatorToken(tokenKind)) {
                    return ClassificationTypeNames.operator;
                }
                else if (TypeScript.SyntaxFacts.isAnyPunctuation(tokenKind)) {
                    return ClassificationTypeNames.punctuation;
                }
                else if (tokenKind === 13 /* NumericLiteral */) {
                    return ClassificationTypeNames.numericLiteral;
                }
                else if (tokenKind === 14 /* StringLiteral */) {
                    return ClassificationTypeNames.stringLiteral;
                }
                else if (tokenKind === 12 /* RegularExpressionLiteral */) {
                    // TODO: we shoudl get another classification type for these literals.
                    return ClassificationTypeNames.stringLiteral;
                }
                else if (tokenKind === 11 /* IdentifierName */) {
                    var current = token;
                    var parent = token.parent;
                    while (parent.kind() === 121 /* QualifiedName */) {
                        current = parent;
                        parent = parent.parent;
                    }
                    switch (parent.kind()) {
                        case 241 /* SimplePropertyAssignment */:
                            if (parent.propertyName === token) {
                                return ClassificationTypeNames.identifier;
                            }
                            return;
                        case 132 /* ClassDeclaration */:
                            if (parent.identifier === token) {
                                return ClassificationTypeNames.className;
                            }
                            return;
                        case 239 /* TypeParameter */:
                            if (parent.identifier === token) {
                                return ClassificationTypeNames.typeParameterName;
                            }
                            return;
                        case 129 /* InterfaceDeclaration */:
                            if (parent.identifier === token) {
                                return ClassificationTypeNames.interfaceName;
                            }
                            return;
                        case 133 /* EnumDeclaration */:
                            if (parent.identifier === token) {
                                return ClassificationTypeNames.enumName;
                            }
                            return;
                        case 131 /* ModuleDeclaration */:
                            if (parent.name === current) {
                                return ClassificationTypeNames.moduleName;
                            }
                            return;
                        default:
                            return ClassificationTypeNames.text;
                    }
                }
            }
            function processElement(element) {
                // Ignore nodes that don't intersect the original span to classify.
                if (!TypeScript.isShared(element) && span.intersectsWith(TypeScript.fullStart(element), TypeScript.fullWidth(element))) {
                    for (var i = 0, n = TypeScript.childCount(element); i < n; i++) {
                        var child = TypeScript.childAt(element, i);
                        if (child) {
                            if (TypeScript.isToken(child)) {
                                classifyToken(child);
                            }
                            else {
                                // Recurse into our child nodes.
                                processElement(child);
                            }
                        }
                    }
                }
            }
        }
        function getOutliningSpans(filename) {
            // doesn't use compiler - no need to synchronize with host
            filename = TypeScript.switchToForwardSlashes(filename);
            var sourceFile = getCurrentSourceFile(filename);
            return ts.OutliningElementsCollector.collectElements(sourceFile);
        }
        function getBraceMatchingAtPosition(filename, position) {
            var sourceFile = getCurrentSourceFile(filename);
            var result = [];
            var token = getTokenAtPosition(sourceFile, position);
            if (token.getStart(sourceFile) === position) {
                var matchKind = getMatchingTokenKind(token);
                // Ensure that there is a corresponding token to match ours.
                if (matchKind) {
                    var parentElement = token.parent;
                    var childNodes = parentElement.getChildren(sourceFile);
                    for (var i = 0, n = childNodes.length; i < n; i++) {
                        var current = childNodes[i];
                        if (current.kind === matchKind) {
                            var range1 = new TypeScript.TextSpan(token.getStart(sourceFile), token.getWidth(sourceFile));
                            var range2 = new TypeScript.TextSpan(current.getStart(sourceFile), current.getWidth(sourceFile));
                            // We want to order the braces when we return the result.
                            if (range1.start() < range2.start()) {
                                result.push(range1, range2);
                            }
                            else {
                                result.push(range2, range1);
                            }
                            break;
                        }
                    }
                }
            }
            return result;
            function getMatchingTokenKind(token) {
                switch (token.kind) {
                    case 9 /* OpenBraceToken */:
                        return 10 /* CloseBraceToken */;
                    case 11 /* OpenParenToken */:
                        return 12 /* CloseParenToken */;
                    case 13 /* OpenBracketToken */:
                        return 14 /* CloseBracketToken */;
                    case 19 /* LessThanToken */:
                        return 20 /* GreaterThanToken */;
                    case 10 /* CloseBraceToken */:
                        return 9 /* OpenBraceToken */;
                    case 12 /* CloseParenToken */:
                        return 11 /* OpenParenToken */;
                    case 14 /* CloseBracketToken */:
                        return 13 /* OpenBracketToken */;
                    case 20 /* GreaterThanToken */:
                        return 19 /* LessThanToken */;
                }
                return undefined;
            }
        }
        function getIndentationAtPosition(filename, position, editorOptions) {
            filename = TypeScript.switchToForwardSlashes(filename);
            var sourceFile = getCurrentSourceFile(filename);
            var options = new TypeScript.FormattingOptions(!editorOptions.ConvertTabsToSpaces, editorOptions.TabSize, editorOptions.IndentSize, editorOptions.NewLineCharacter);
            return ts.formatting.SmartIndenter.getIndentation(position, sourceFile, options);
        }
        function getFormattingManager(filename, options) {
            // Ensure rules are initialized and up to date wrt to formatting options
            if (formattingRulesProvider == null) {
                formattingRulesProvider = new TypeScript.Services.Formatting.RulesProvider(host);
            }
            formattingRulesProvider.ensureUpToDate(options);
            // Get the Syntax Tree
            var syntaxTree = getSyntaxTree(filename);
            // Convert IScriptSnapshot to ITextSnapshot
            var scriptSnapshot = syntaxTreeCache.getCurrentScriptSnapshot(filename);
            var scriptText = TypeScript.SimpleText.fromScriptSnapshot(scriptSnapshot);
            var textSnapshot = new TypeScript.Services.Formatting.TextSnapshot(scriptText);
            var manager = new TypeScript.Services.Formatting.FormattingManager(syntaxTree, textSnapshot, formattingRulesProvider, options);
            return manager;
        }
        function getFormattingEditsForRange(fileName, start, end, options) {
            fileName = TypeScript.switchToForwardSlashes(fileName);
            var manager = getFormattingManager(fileName, options);
            return manager.formatSelection(start, end);
        }
        function getFormattingEditsForDocument(fileName, options) {
            fileName = TypeScript.switchToForwardSlashes(fileName);
            var manager = getFormattingManager(fileName, options);
            return manager.formatDocument();
        }
        function getFormattingEditsAfterKeystroke(fileName, position, key, options) {
            fileName = TypeScript.switchToForwardSlashes(fileName);
            var manager = getFormattingManager(fileName, options);
            if (key === "}") {
                return manager.formatOnClosingCurlyBrace(position);
            }
            else if (key === ";") {
                return manager.formatOnSemicolon(position);
            }
            else if (key === "\n") {
                return manager.formatOnEnter(position);
            }
            return [];
        }
        function getTodoComments(filename, descriptors) {
            filename = TypeScript.switchToForwardSlashes(filename);
            var sourceFile = getCurrentSourceFile(filename);
            cancellationToken.throwIfCancellationRequested();
            var fileContents = sourceFile.text;
            cancellationToken.throwIfCancellationRequested();
            var result = [];
            if (descriptors.length > 0) {
                var regExp = getTodoCommentsRegExp();
                var matchArray;
                while (matchArray = regExp.exec(fileContents)) {
                    cancellationToken.throwIfCancellationRequested();
                    // If we got a match, here is what the match array will look like.  Say the source text is:
                    //
                    //      "    // hack   1"
                    //
                    // The result array with the regexp:    will be:
                    //
                    //      ["// hack   1", "// ", "hack   1", undefined, "hack"]
                    //
                    // Here are the relevant capture groups:
                    //  0) The full match for the entire regexp.
                    //  1) The preamble to the message portion.
                    //  2) The message portion.
                    //  3...N) The descriptor that was matched - by index.  'undefined' for each 
                    //         descriptor that didn't match.  an actual value if it did match.
                    //
                    //  i.e. 'undefined' in position 3 above means TODO(jason) didn't match.
                    //       "hack"      in position 4 means HACK did match.
                    var firstDescriptorCaptureIndex = 3;
                    ts.Debug.assert(matchArray.length === descriptors.length + firstDescriptorCaptureIndex);
                    var preamble = matchArray[1];
                    var matchPosition = matchArray.index + preamble.length;
                    // OK, we have found a match in the file.  This is only an acceptable match if
                    // it is contained within a comment.
                    var token = getTokenAtPosition(sourceFile, matchPosition);
                    if (token.getStart() <= matchPosition && matchPosition < token.getEnd()) {
                        continue;
                    }
                    // Looks to be within the trivia. See if we can find the comment containing it.
                    if (!getContainingComment(ts.getTrailingCommentRanges(fileContents, token.getFullStart()), matchPosition) && !getContainingComment(ts.getLeadingCommentRanges(fileContents, token.getFullStart()), matchPosition)) {
                        continue;
                    }
                    var descriptor = undefined;
                    for (var i = 0, n = descriptors.length; i < n; i++) {
                        if (matchArray[i + firstDescriptorCaptureIndex]) {
                            descriptor = descriptors[i];
                        }
                    }
                    ts.Debug.assert(descriptor);
                    // We don't want to match something like 'TODOBY', so we make sure a non 
                    // letter/digit follows the match.
                    if (isLetterOrDigit(fileContents.charCodeAt(matchPosition + descriptor.text.length))) {
                        continue;
                    }
                    var message = matchArray[2];
                    result.push(new TodoComment(descriptor, message, matchPosition));
                }
            }
            return result;
            function escapeRegExp(str) {
                return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
            }
            function getTodoCommentsRegExp() {
                // NOTE: ?:  means 'non-capture group'.  It allows us to have groups without having to
                // filter them out later in the final result array.
                // TODO comments can appear in one of the following forms:
                //
                //  1)      // TODO     or  /////////// TODO
                //
                //  2)      /* TODO     or  /********** TODO
                //
                //  3)      /*
                //           *   TODO
                //           */
                //
                // The following three regexps are used to match the start of the text up to the TODO
                // comment portion.
                var singleLineCommentStart = /(?:\/\/+\s*)/.source;
                var multiLineCommentStart = /(?:\/\*+\s*)/.source;
                var anyNumberOfSpacesAndAsterixesAtStartOfLine = /(?:^(?:\s|\*)*)/.source;
                // Match any of the above three TODO comment start regexps.
                // Note that the outermost group *is* a capture group.  We want to capture the preamble
                // so that we can determine the starting position of the TODO comment match.
                var preamble = "(" + anyNumberOfSpacesAndAsterixesAtStartOfLine + "|" + singleLineCommentStart + "|" + multiLineCommentStart + ")";
                // Takes the descriptors and forms a regexp that matches them as if they were literals.
                // For example, if the descriptors are "TODO(jason)" and "HACK", then this will be:
                //
                //      (?:(TODO\(jason\))|(HACK))
                //
                // Note that the outermost group is *not* a capture group, but the innermost groups
                // *are* capture groups.  By capturing the inner literals we can determine after 
                // matching which descriptor we are dealing with.
                var literals = "(?:" + ts.map(descriptors, function (d) { return "(" + escapeRegExp(d.text) + ")"; }).join("|") + ")";
                // After matching a descriptor literal, the following regexp matches the rest of the 
                // text up to the end of the line (or */).
                var endOfLineOrEndOfComment = /(?:$|\*\/)/.source;
                var messageRemainder = /(?:.*?)/.source;
                // This is the portion of the match we'll return as part of the TODO comment result. We
                // match the literal portion up to the end of the line or end of comment.
                var messagePortion = "(" + literals + messageRemainder + ")";
                var regExpString = preamble + messagePortion + endOfLineOrEndOfComment;
                // The final regexp will look like this:
                // /((?:\/\/+\s*)|(?:\/\*+\s*)|(?:^(?:\s|\*)*))((?:(TODO\(jason\))|(HACK))(?:.*?))(?:$|\*\/)/gim
                // The flags of the regexp are important here.
                //  'g' is so that we are doing a global search and can find matches several times
                //  in the input.
                //
                //  'i' is for case insensitivity (We do this to match C# TODO comment code).
                //
                //  'm' is so we can find matches in a multi-line input.
                return new RegExp(regExpString, "gim");
            }
            function getContainingComment(comments, position) {
                if (comments) {
                    for (var i = 0, n = comments.length; i < n; i++) {
                        var comment = comments[i];
                        if (comment.pos <= position && position < comment.end) {
                            return comment;
                        }
                    }
                }
                return undefined;
            }
            function isLetterOrDigit(char) {
                return (char >= 97 /* a */ && char <= 122 /* z */) || (char >= 65 /* A */ && char <= 90 /* Z */) || (char >= 48 /* _0 */ && char <= 57 /* _9 */);
            }
        }
        function getRenameInfo(fileName, position) {
            synchronizeHostData();
            fileName = TypeScript.switchToForwardSlashes(fileName);
            var sourceFile = getSourceFile(fileName);
            var node = getNodeAtPosition(sourceFile, position);
            // Can only rename an identifier.
            if (node && node.kind === 59 /* Identifier */) {
                var symbol = typeInfoResolver.getSymbolInfo(node);
                // Only allow a symbol to be renamed if it actually has at least one declaration.
                if (symbol && symbol.getDeclarations() && symbol.getDeclarations().length > 0) {
                    var kind = getSymbolKind(symbol);
                    if (kind) {
                        return RenameInfo.Create(symbol.name, typeInfoResolver.getFullyQualifiedName(symbol), kind, getSymbolModifiers(symbol), new TypeScript.TextSpan(node.getStart(), node.getWidth()));
                    }
                }
            }
            return RenameInfo.CreateError(ts.getLocaleSpecificMessage(ts.Diagnostics.You_cannot_rename_this_element.key));
        }
        return {
            dispose: dispose,
            cleanupSemanticCache: cleanupSemanticCache,
            getSyntacticDiagnostics: getSyntacticDiagnostics,
            getSemanticDiagnostics: getSemanticDiagnostics,
            getCompilerOptionsDiagnostics: getCompilerOptionsDiagnostics,
            getSyntacticClassifications: getSyntacticClassifications,
            getSemanticClassifications: getSemanticClassifications,
            getCompletionsAtPosition: getCompletionsAtPosition,
            getCompletionEntryDetails: getCompletionEntryDetails,
            getTypeAtPosition: getTypeAtPosition,
            getQuickInfoAtPosition: getQuickInfoAtPosition,
            getSignatureHelpItems: function (filename, position) { return null; },
            getSignatureHelpCurrentArgumentState: function (fileName, position, applicableSpanStart) { return null; },
            getDefinitionAtPosition: getDefinitionAtPosition,
            getReferencesAtPosition: getReferencesAtPosition,
            getOccurrencesAtPosition: getOccurrencesAtPosition,
            getImplementorsAtPosition: function (filename, position) { return []; },
            getNameOrDottedNameSpan: getNameOrDottedNameSpan,
            getBreakpointStatementAtPosition: getBreakpointStatementAtPosition,
            getNavigateToItems: getNavigateToItems,
            getRenameInfo: getRenameInfo,
            getNavigationBarItems: getNavigationBarItems,
            getOutliningSpans: getOutliningSpans,
            getTodoComments: getTodoComments,
            getBraceMatchingAtPosition: getBraceMatchingAtPosition,
            getIndentationAtPosition: getIndentationAtPosition,
            getFormattingEditsForRange: getFormattingEditsForRange,
            getFormattingEditsForDocument: getFormattingEditsForDocument,
            getFormattingEditsAfterKeystroke: getFormattingEditsAfterKeystroke,
            getEmitOutput: getEmitOutput
        };
    }
    ts.createLanguageService = createLanguageService;
    /// Classifier
    function createClassifier(host) {
        var scanner;
        var noRegexTable;
        /// We do not have a full parser support to know when we should parse a regex or not
        /// If we consider every slash token to be a regex, we could be missing cases like "1/2/3", where
        /// we have a series of divide operator. this list allows us to be more accurate by ruling out 
        /// locations where a regexp cannot exist.
        if (!noRegexTable) {
            noRegexTable = [];
            noRegexTable[59 /* Identifier */] = true;
            noRegexTable[7 /* StringLiteral */] = true;
            noRegexTable[6 /* NumericLiteral */] = true;
            noRegexTable[8 /* RegularExpressionLiteral */] = true;
            noRegexTable[87 /* ThisKeyword */] = true;
            noRegexTable[33 /* PlusPlusToken */] = true;
            noRegexTable[34 /* MinusMinusToken */] = true;
            noRegexTable[12 /* CloseParenToken */] = true;
            noRegexTable[14 /* CloseBracketToken */] = true;
            noRegexTable[10 /* CloseBraceToken */] = true;
            noRegexTable[89 /* TrueKeyword */] = true;
            noRegexTable[74 /* FalseKeyword */] = true;
        }
        function getClassificationsForLine(text, lexState) {
            var offset = 0;
            var lastTokenOrCommentEnd = 0;
            var lastToken = 0 /* Unknown */;
            var inUnterminatedMultiLineComment = false;
            switch (lexState) {
                case 3 /* InDoubleQuoteStringLiteral */:
                    text = '"\\\n' + text;
                    offset = 3;
                    break;
                case 2 /* InSingleQuoteStringLiteral */:
                    text = "'\\\n" + text;
                    offset = 3;
                    break;
                case 1 /* InMultiLineCommentTrivia */:
                    text = "/*\n" + text;
                    offset = 3;
                    break;
            }
            var result = {
                finalLexState: 0 /* Start */,
                entries: []
            };
            scanner = ts.createScanner(1 /* ES5 */, true, text, onError, processComment);
            var token = 0 /* Unknown */;
            do {
                token = scanner.scan();
                if ((token === 31 /* SlashToken */ || token === 51 /* SlashEqualsToken */) && !noRegexTable[lastToken]) {
                    if (scanner.reScanSlashToken() === 8 /* RegularExpressionLiteral */) {
                        token = 8 /* RegularExpressionLiteral */;
                    }
                }
                else if (lastToken === 15 /* DotToken */) {
                    token = 59 /* Identifier */;
                }
                lastToken = token;
                processToken();
            } while (token !== 1 /* EndOfFileToken */);
            return result;
            function onError(message) {
                inUnterminatedMultiLineComment = message.key === ts.Diagnostics.Asterisk_Slash_expected.key;
            }
            function processComment(start, end) {
                // add Leading white spaces
                addLeadingWhiteSpace(start, end);
                // add the comment
                addResult(end - start, 3 /* Comment */);
            }
            function processToken() {
                var start = scanner.getTokenPos();
                var end = scanner.getTextPos();
                // add Leading white spaces
                addLeadingWhiteSpace(start, end);
                // add the token
                addResult(end - start, classFromKind(token));
                if (end >= text.length) {
                    // We're at the end.
                    if (inUnterminatedMultiLineComment) {
                        result.finalLexState = 1 /* InMultiLineCommentTrivia */;
                    }
                    else if (token === 7 /* StringLiteral */) {
                        var tokenText = scanner.getTokenText();
                        if (tokenText.length > 0 && tokenText.charCodeAt(tokenText.length - 1) === 92 /* backslash */) {
                            var quoteChar = tokenText.charCodeAt(0);
                            result.finalLexState = quoteChar === 34 /* doubleQuote */ ? 3 /* InDoubleQuoteStringLiteral */ : 2 /* InSingleQuoteStringLiteral */;
                        }
                    }
                }
            }
            function addLeadingWhiteSpace(start, end) {
                if (start > lastTokenOrCommentEnd) {
                    addResult(start - lastTokenOrCommentEnd, 4 /* Whitespace */);
                }
                // Remember the end of the last token
                lastTokenOrCommentEnd = end;
            }
            function addResult(length, classification) {
                if (length > 0) {
                    // If this is the first classification we're adding to the list, then remove any 
                    // offset we have if we were continuing a construct from the previous line.
                    if (result.entries.length === 0) {
                        length -= offset;
                    }
                    result.entries.push({ length: length, classification: classification });
                }
            }
        }
        function isBinaryExpressionOperatorToken(token) {
            switch (token) {
                case 30 /* AsteriskToken */:
                case 31 /* SlashToken */:
                case 32 /* PercentToken */:
                case 28 /* PlusToken */:
                case 29 /* MinusToken */:
                case 35 /* LessThanLessThanToken */:
                case 36 /* GreaterThanGreaterThanToken */:
                case 37 /* GreaterThanGreaterThanGreaterThanToken */:
                case 19 /* LessThanToken */:
                case 20 /* GreaterThanToken */:
                case 21 /* LessThanEqualsToken */:
                case 22 /* GreaterThanEqualsToken */:
                case 81 /* InstanceOfKeyword */:
                case 80 /* InKeyword */:
                case 23 /* EqualsEqualsToken */:
                case 24 /* ExclamationEqualsToken */:
                case 25 /* EqualsEqualsEqualsToken */:
                case 26 /* ExclamationEqualsEqualsToken */:
                case 38 /* AmpersandToken */:
                case 40 /* CaretToken */:
                case 39 /* BarToken */:
                case 43 /* AmpersandAmpersandToken */:
                case 44 /* BarBarToken */:
                case 57 /* BarEqualsToken */:
                case 56 /* AmpersandEqualsToken */:
                case 58 /* CaretEqualsToken */:
                case 53 /* LessThanLessThanEqualsToken */:
                case 54 /* GreaterThanGreaterThanEqualsToken */:
                case 55 /* GreaterThanGreaterThanGreaterThanEqualsToken */:
                case 48 /* PlusEqualsToken */:
                case 49 /* MinusEqualsToken */:
                case 50 /* AsteriskEqualsToken */:
                case 51 /* SlashEqualsToken */:
                case 52 /* PercentEqualsToken */:
                case 47 /* EqualsToken */:
                case 18 /* CommaToken */:
                    return true;
                default:
                    return false;
            }
        }
        function isPrefixUnaryExpressionOperatorToken(token) {
            switch (token) {
                case 28 /* PlusToken */:
                case 29 /* MinusToken */:
                case 42 /* TildeToken */:
                case 41 /* ExclamationToken */:
                case 33 /* PlusPlusToken */:
                case 34 /* MinusMinusToken */:
                    return true;
                default:
                    return false;
            }
        }
        function isKeyword(token) {
            return token >= ts.SyntaxKind.FirstKeyword && token <= ts.SyntaxKind.LastKeyword;
        }
        function classFromKind(token) {
            if (isKeyword(token)) {
                return 1 /* Keyword */;
            }
            else if (isBinaryExpressionOperatorToken(token) || isPrefixUnaryExpressionOperatorToken(token)) {
                return 2 /* Operator */;
            }
            else if (token >= ts.SyntaxKind.FirstPunctuation && token <= ts.SyntaxKind.LastPunctuation) {
                return 0 /* Punctuation */;
            }
            switch (token) {
                case 6 /* NumericLiteral */:
                    return 6 /* NumberLiteral */;
                case 7 /* StringLiteral */:
                    return 7 /* StringLiteral */;
                case 8 /* RegularExpressionLiteral */:
                    return 8 /* RegExpLiteral */;
                case 59 /* Identifier */:
                default:
                    return 5 /* Identifier */;
            }
        }
        return {
            getClassificationsForLine: getClassificationsForLine
        };
    }
    ts.createClassifier = createClassifier;
    function initializeServices() {
        ts.objectAllocator = {
            getNodeConstructor: function (kind) {
                function Node() {
                }
                var proto = kind === 182 /* SourceFile */ ? new SourceFileObject() : new NodeObject();
                proto.kind = kind;
                proto.pos = 0;
                proto.end = 0;
                proto.flags = 0;
                proto.parent = undefined;
                Node.prototype = proto;
                return Node;
            },
            getSymbolConstructor: function () { return SymbolObject; },
            getTypeConstructor: function () { return TypeObject; },
            getSignatureConstructor: function () { return SignatureObject; }
        };
    }
    initializeServices();
})(ts || (ts = {}));
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
var TypeScript;
(function (TypeScript) {
    function isNoDefaultLibMatch(comment) {
        var isNoDefaultLibRegex = /^(\/\/\/\s*<reference\s+no-default-lib=)('|")(.+?)\2\s*\/>/gim;
        return isNoDefaultLibRegex.exec(comment);
    }
    TypeScript.tripleSlashReferenceRegExp = /^(\/\/\/\s*<reference\s+path=)('|")(.+?)\2\s*(static=('|")(.+?)\5\s*)*\/>/;
    function getFileReferenceFromReferencePath(fileName, text, position, comment, diagnostics) {
        // First, just see if they've written: /// <reference\s+
        // If so, then we'll consider this a reference directive and we'll report errors if it's
        // malformed.  Otherwise, we'll completely ignore this.
        var lineMap = text.lineMap();
        var simpleReferenceRegEx = /^\/\/\/\s*<reference\s+/gim;
        if (simpleReferenceRegEx.exec(comment)) {
            var isNoDefaultLib = isNoDefaultLibMatch(comment);
            if (!isNoDefaultLib) {
                var fullReferenceRegEx = TypeScript.tripleSlashReferenceRegExp;
                var fullReference = fullReferenceRegEx.exec(comment);
                if (!fullReference) {
                    // It matched the start of a reference directive, but wasn't well formed.  Report
                    // an appropriate error to the user.
                    diagnostics.push(new TypeScript.Diagnostic(fileName, lineMap, position, comment.length, TypeScript.DiagnosticCode.Invalid_reference_directive_syntax));
                }
                else {
                    var path = TypeScript.normalizePath(fullReference[3]);
                    var adjustedPath = TypeScript.normalizePath(path);
                    var isResident = fullReference.length >= 7 && fullReference[6] === "true";
                    return {
                        line: 0,
                        character: 0,
                        position: 0,
                        length: 0,
                        path: TypeScript.switchToForwardSlashes(adjustedPath),
                        isResident: isResident
                    };
                }
            }
        }
        return null;
    }
    var reportDiagnostic = function () {
    };
    function processImports(text, scanner, token, importedFiles) {
        var lineChar = { line: -1, character: -1 };
        var lineMap = text.lineMap();
        var start = new Date().getTime();
        while (token.kind() !== 10 /* EndOfFileToken */) {
            if (token.kind() === 49 /* ImportKeyword */) {
                var importToken = token;
                token = scanner.scan(false);
                if (TypeScript.SyntaxFacts.isIdentifierNameOrAnyKeyword(token)) {
                    token = scanner.scan(false);
                    if (token.kind() === 107 /* EqualsToken */) {
                        token = scanner.scan(false);
                        if (token.kind() === 65 /* ModuleKeyword */ || token.kind() === 66 /* RequireKeyword */) {
                            token = scanner.scan(false);
                            if (token.kind() === 72 /* OpenParenToken */) {
                                token = scanner.scan(false);
                                lineMap.fillLineAndCharacterFromPosition(TypeScript.start(importToken, text), lineChar);
                                if (token.kind() === 14 /* StringLiteral */) {
                                    var ref = {
                                        line: lineChar.line,
                                        character: lineChar.character,
                                        position: TypeScript.start(token, text),
                                        length: TypeScript.width(token),
                                        path: TypeScript.stripStartAndEndQuotes(TypeScript.switchToForwardSlashes(token.text())),
                                        isResident: false
                                    };
                                    importedFiles.push(ref);
                                }
                            }
                        }
                    }
                }
            }
            token = scanner.scan(false);
        }
        var totalTime = new Date().getTime() - start;
        //TypeScript.fileResolutionScanImportsTime += totalTime;
    }
    function processTripleSlashDirectives(fileName, text, firstToken) {
        var leadingTrivia = firstToken.leadingTrivia(text);
        var position = 0;
        var lineChar = { line: -1, character: -1 };
        var noDefaultLib = false;
        var diagnostics = [];
        var referencedFiles = [];
        var lineMap = text.lineMap();
        for (var i = 0, n = leadingTrivia.count(); i < n; i++) {
            var trivia = leadingTrivia.syntaxTriviaAt(i);
            if (trivia.kind() === 7 /* SingleLineCommentTrivia */) {
                var triviaText = trivia.fullText();
                var referencedCode = getFileReferenceFromReferencePath(fileName, text, position, triviaText, diagnostics);
                if (referencedCode) {
                    lineMap.fillLineAndCharacterFromPosition(position, lineChar);
                    referencedCode.position = position;
                    referencedCode.length = trivia.fullWidth();
                    referencedCode.line = lineChar.line;
                    referencedCode.character = lineChar.character;
                    referencedFiles.push(referencedCode);
                }
                // is it a lib file?
                var isNoDefaultLib = isNoDefaultLibMatch(triviaText);
                if (isNoDefaultLib) {
                    noDefaultLib = isNoDefaultLib[3] === "true";
                }
            }
            position += trivia.fullWidth();
        }
        return { noDefaultLib: noDefaultLib, diagnostics: diagnostics, referencedFiles: referencedFiles };
    }
    function preProcessFile(fileName, sourceText, readImportFiles) {
        if (readImportFiles === void 0) { readImportFiles = true; }
        var text = TypeScript.SimpleText.fromScriptSnapshot(sourceText);
        var scanner = TypeScript.Scanner.createScanner(1 /* ES5 */, text, reportDiagnostic);
        var firstToken = scanner.scan(false);
        // only search out dynamic mods
        // if you find a dynamic mod, ignore every other mod inside, until you balance rcurlies
        // var position
        var importedFiles = [];
        if (readImportFiles) {
            processImports(text, scanner, firstToken, importedFiles);
        }
        var properties = processTripleSlashDirectives(fileName, text, firstToken);
        return { referencedFiles: properties.referencedFiles, importedFiles: importedFiles, isLibFile: properties.noDefaultLib, diagnostics: properties.diagnostics };
    }
    TypeScript.preProcessFile = preProcessFile;
    function getReferencedFiles(fileName, sourceText) {
        return preProcessFile(fileName, sourceText, false).referencedFiles;
    }
    TypeScript.getReferencedFiles = getReferencedFiles;
})(TypeScript || (TypeScript = {})); // Tools
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
/// <reference path='services.ts' />
/// <reference path='compiler\pathUtils.ts' />
/// <reference path='compiler\precompile.ts' />
var debugObjectHost = this;
var ts;
(function (ts) {
    /// TODO: delete this, it is only needed until the VS interface is updated
    (function (LanguageVersion) {
        LanguageVersion[LanguageVersion["EcmaScript3"] = 0] = "EcmaScript3";
        LanguageVersion[LanguageVersion["EcmaScript5"] = 1] = "EcmaScript5";
    })(ts.LanguageVersion || (ts.LanguageVersion = {}));
    var LanguageVersion = ts.LanguageVersion;
    (function (ModuleGenTarget) {
        ModuleGenTarget[ModuleGenTarget["Unspecified"] = 0] = "Unspecified";
        ModuleGenTarget[ModuleGenTarget["Synchronous"] = 1] = "Synchronous";
        ModuleGenTarget[ModuleGenTarget["Asynchronous"] = 2] = "Asynchronous";
    })(ts.ModuleGenTarget || (ts.ModuleGenTarget = {}));
    var ModuleGenTarget = ts.ModuleGenTarget;
    function languageVersionToScriptTarget(languageVersion) {
        if (typeof languageVersion === "undefined")
            return undefined;
        switch (languageVersion) {
            case 0 /* EcmaScript3 */:
                return 0 /* ES3 */;
            case 1 /* EcmaScript5 */:
                return 1 /* ES5 */;
            default:
                throw Error("unsupported LanguageVersion value: " + languageVersion);
        }
    }
    function moduleGenTargetToModuleKind(moduleGenTarget) {
        if (typeof moduleGenTarget === "undefined")
            return undefined;
        switch (moduleGenTarget) {
            case 2 /* Asynchronous */:
                return 2 /* AMD */;
            case 1 /* Synchronous */:
                return 1 /* CommonJS */;
            case 0 /* Unspecified */:
                return 0 /* None */;
            default:
                throw Error("unsupported ModuleGenTarget value: " + moduleGenTarget);
        }
    }
    function scriptTargetTolanguageVersion(scriptTarget) {
        if (typeof scriptTarget === "undefined")
            return undefined;
        switch (scriptTarget) {
            case 0 /* ES3 */:
                return 0 /* EcmaScript3 */;
            case 1 /* ES5 */:
                return 1 /* EcmaScript5 */;
            default:
                throw Error("unsupported ScriptTarget value: " + scriptTarget);
        }
    }
    function moduleKindToModuleGenTarget(moduleKind) {
        if (typeof moduleKind === "undefined")
            return undefined;
        switch (moduleKind) {
            case 2 /* AMD */:
                return 2 /* Asynchronous */;
            case 1 /* CommonJS */:
                return 1 /* Synchronous */;
            case 0 /* None */:
                return 0 /* Unspecified */;
            default:
                throw Error("unsupported ModuleKind value: " + moduleKind);
        }
    }
    function compilationSettingsToCompilerOptions(settings) {
        // TODO: we should not be converting, but use options all the way
        var options = {};
        //options.propagateEnumConstants = settings.propagateEnumConstants;
        options.removeComments = settings.removeComments;
        options.noResolve = settings.noResolve;
        options.noImplicitAny = settings.noImplicitAny;
        options.noLib = settings.noLib;
        options.target = languageVersionToScriptTarget(settings.codeGenTarget);
        options.module = moduleGenTargetToModuleKind(settings.moduleGenTarget);
        options.out = settings.outFileOption;
        options.outDir = settings.outDirOption;
        options.sourceMap = settings.mapSourceFiles;
        options.mapRoot = settings.mapRoot;
        options.sourceRoot = settings.sourceRoot;
        options.declaration = settings.generateDeclarationFiles;
        //options.useCaseSensitiveFileResolution = settings.useCaseSensitiveFileResolution;
        options.codepage = settings.codepage;
        options.emitBOM = settings.emitBOM;
        return options;
    }
    function compilerOptionsToCompilationSettings(options) {
        var settings = {};
        //options.propagateEnumConstants = settings.propagateEnumConstants;
        settings.removeComments = options.removeComments;
        settings.noResolve = options.noResolve;
        settings.noImplicitAny = options.noImplicitAny;
        settings.noLib = options.noLib;
        settings.codeGenTarget = scriptTargetTolanguageVersion(options.target);
        settings.moduleGenTarget = moduleKindToModuleGenTarget(options.module);
        settings.outFileOption = options.out;
        settings.outDirOption = options.outDir;
        settings.mapSourceFiles = options.sourceMap;
        settings.mapRoot = options.mapRoot;
        settings.sourceRoot = options.sourceRoot;
        settings.generateDeclarationFiles = options.declaration;
        // settings.useCaseSensitiveFileResolution = options.useCaseSensitiveFileResolution;
        settings.codepage = options.codepage;
        settings.emitBOM = options.emitBOM;
        return settings;
    }
    function logInternalError(logger, err) {
        logger.log("*INTERNAL ERROR* - Exception in typescript services: " + err.message);
    }
    var ScriptSnapshotShimAdapter = (function () {
        function ScriptSnapshotShimAdapter(scriptSnapshotShim) {
            this.scriptSnapshotShim = scriptSnapshotShim;
            this.lineStartPositions = null;
        }
        ScriptSnapshotShimAdapter.prototype.getText = function (start, end) {
            return this.scriptSnapshotShim.getText(start, end);
        };
        ScriptSnapshotShimAdapter.prototype.getLength = function () {
            return this.scriptSnapshotShim.getLength();
        };
        ScriptSnapshotShimAdapter.prototype.getLineStartPositions = function () {
            if (this.lineStartPositions == null) {
                this.lineStartPositions = JSON.parse(this.scriptSnapshotShim.getLineStartPositions());
            }
            return this.lineStartPositions;
        };
        ScriptSnapshotShimAdapter.prototype.getChangeRange = function (oldSnapshot) {
            var oldSnapshotShim = oldSnapshot;
            var encoded = this.scriptSnapshotShim.getChangeRange(oldSnapshotShim.scriptSnapshotShim);
            if (encoded == null) {
                return null;
            }
            var decoded = JSON.parse(encoded);
            return new TypeScript.TextChangeRange(new TypeScript.TextSpan(decoded.span.start, decoded.span.length), decoded.newLength);
        };
        return ScriptSnapshotShimAdapter;
    })();
    var LanguageServiceShimHostAdapter = (function () {
        function LanguageServiceShimHostAdapter(shimHost) {
            this.shimHost = shimHost;
        }
        LanguageServiceShimHostAdapter.prototype.log = function (s) {
            this.shimHost.log(s);
        };
        LanguageServiceShimHostAdapter.prototype.getCompilationSettings = function () {
            var settingsJson = this.shimHost.getCompilationSettings();
            if (settingsJson == null || settingsJson == "") {
                throw Error("LanguageServiceShimHostAdapter.getCompilationSettings: empty compilationSettings");
                return null;
            }
            var options = compilationSettingsToCompilerOptions(JSON.parse(settingsJson));
            /// TODO: this should be pushed into VS.
            /// We can not ask the LS instance to resolve, as this will lead to asking the host about files it does not know about,
            /// something it is not designed to handle. for now make sure we never get a "noresolve == false".
            /// This value should not matter, as the host runs resolution logic independently
            options.noResolve = true;
            return options;
        };
        LanguageServiceShimHostAdapter.prototype.getScriptFileNames = function () {
            var encoded = this.shimHost.getScriptFileNames();
            return JSON.parse(encoded);
        };
        LanguageServiceShimHostAdapter.prototype.getScriptSnapshot = function (fileName) {
            return new ScriptSnapshotShimAdapter(this.shimHost.getScriptSnapshot(fileName));
        };
        LanguageServiceShimHostAdapter.prototype.getScriptVersion = function (fileName) {
            return this.shimHost.getScriptVersion(fileName);
        };
        LanguageServiceShimHostAdapter.prototype.getScriptIsOpen = function (fileName) {
            return this.shimHost.getScriptIsOpen(fileName);
        };
        LanguageServiceShimHostAdapter.prototype.getLocalizedDiagnosticMessages = function () {
            var diagnosticMessagesJson = this.shimHost.getLocalizedDiagnosticMessages();
            if (diagnosticMessagesJson == null || diagnosticMessagesJson == "") {
                return null;
            }
            try {
                return JSON.parse(diagnosticMessagesJson);
            }
            catch (e) {
                this.log(e.description || "diagnosticMessages.generated.json has invalid JSON format");
                return null;
            }
        };
        LanguageServiceShimHostAdapter.prototype.getCancellationToken = function () {
            return this.shimHost.getCancellationToken();
        };
        LanguageServiceShimHostAdapter.prototype.getDefaultLibFilename = function () {
            return this.shimHost.getDefaultLibFilename();
        };
        LanguageServiceShimHostAdapter.prototype.getCurrentDirectory = function () {
            return this.shimHost.getCurrentDirectory();
        };
        return LanguageServiceShimHostAdapter;
    })();
    ts.LanguageServiceShimHostAdapter = LanguageServiceShimHostAdapter;
    function simpleForwardCall(logger, actionDescription, action) {
        logger.log(actionDescription);
        var start = Date.now();
        var result = action();
        var end = Date.now();
        logger.log(actionDescription + " completed in " + (end - start) + " msec");
        if (typeof (result) === "string") {
            var str = result;
            if (str.length > 128) {
                str = str.substring(0, 128) + "...";
            }
            logger.log("  result.length=" + str.length + ", result='" + JSON.stringify(str) + "'");
        }
        return result;
    }
    function forwardJSONCall(logger, actionDescription, action) {
        try {
            var result = simpleForwardCall(logger, actionDescription, action);
            return JSON.stringify({ result: result });
        }
        catch (err) {
            if (err instanceof ts.OperationCanceledException) {
                return JSON.stringify({ canceled: true });
            }
            logInternalError(logger, err);
            err.description = actionDescription;
            return JSON.stringify({ error: err });
        }
    }
    var ShimBase = (function () {
        function ShimBase(factory) {
            this.factory = factory;
            factory.registerShim(this);
        }
        ShimBase.prototype.dispose = function (dummy) {
            this.factory.unregisterShim(this);
        };
        return ShimBase;
    })();
    var LanguageServiceShimObject = (function (_super) {
        __extends(LanguageServiceShimObject, _super);
        function LanguageServiceShimObject(factory, host, languageService) {
            _super.call(this, factory);
            this.host = host;
            this.languageService = languageService;
            this.logger = this.host;
        }
        LanguageServiceShimObject.prototype.forwardJSONCall = function (actionDescription, action) {
            return forwardJSONCall(this.logger, actionDescription, action);
        };
        // DISPOSE
        // Ensure (almost) deterministic release of internal Javascript resources when
        // some external native objects holds onto us (e.g. Com/Interop).
        LanguageServiceShimObject.prototype.dispose = function (dummy) {
            this.logger.log("dispose()");
            this.languageService.dispose();
            this.languageService = null;
            // force a GC
            if (debugObjectHost && debugObjectHost.CollectGarbage) {
                debugObjectHost.CollectGarbage();
                this.logger.log("CollectGarbage()");
            }
            this.logger = null;
            _super.prototype.dispose.call(this, dummy);
        };
        // REFRESH
        // Update the list of scripts known to the compiler
        LanguageServiceShimObject.prototype.refresh = function (throwOnError) {
            this.forwardJSONCall("refresh(" + throwOnError + ")", function () {
                return null;
            });
        };
        LanguageServiceShimObject.prototype.cleanupSemanticCache = function () {
            var _this = this;
            this.forwardJSONCall("cleanupSemanticCache()", function () {
                _this.languageService.cleanupSemanticCache();
                return null;
            });
        };
        LanguageServiceShimObject.realizeDiagnostic = function (diagnostic) {
            return {
                message: diagnostic.messageText,
                start: diagnostic.start,
                length: diagnostic.length,
                /// TODO: no need for the tolowerCase call
                category: ts.DiagnosticCategory[diagnostic.category].toLowerCase()
            };
        };
        LanguageServiceShimObject.prototype.realizeDiagnosticWithFileName = function (diagnostic) {
            return {
                fileName: diagnostic.file.filename,
                message: diagnostic.messageText,
                start: diagnostic.start,
                length: diagnostic.length,
                /// TODO: no need for the tolowerCase call
                category: ts.DiagnosticCategory[diagnostic.category].toLowerCase()
            };
        };
        LanguageServiceShimObject.prototype.getSyntacticClassifications = function (fileName, start, length) {
            var _this = this;
            return this.forwardJSONCall("getSyntacticClassifications('" + fileName + "', " + start + ", " + length + ")", function () {
                var classifications = _this.languageService.getSyntacticClassifications(fileName, new TypeScript.TextSpan(start, length));
                return classifications;
            });
        };
        LanguageServiceShimObject.prototype.getSemanticClassifications = function (fileName, start, length) {
            var _this = this;
            return this.forwardJSONCall("getSemanticClassifications('" + fileName + "', " + start + ", " + length + ")", function () {
                var classifications = _this.languageService.getSemanticClassifications(fileName, new TypeScript.TextSpan(start, length));
                return classifications;
            });
        };
        LanguageServiceShimObject.prototype.getSyntacticDiagnostics = function (fileName) {
            var _this = this;
            return this.forwardJSONCall("getSyntacticDiagnostics('" + fileName + "')", function () {
                var errors = _this.languageService.getSyntacticDiagnostics(fileName);
                return errors.map(LanguageServiceShimObject.realizeDiagnostic);
            });
        };
        LanguageServiceShimObject.prototype.getSemanticDiagnostics = function (fileName) {
            var _this = this;
            return this.forwardJSONCall("getSemanticDiagnostics('" + fileName + "')", function () {
                var errors = _this.languageService.getSemanticDiagnostics(fileName);
                return errors.map(LanguageServiceShimObject.realizeDiagnostic);
            });
        };
        LanguageServiceShimObject.prototype.getCompilerOptionsDiagnostics = function () {
            var _this = this;
            return this.forwardJSONCall("getCompilerOptionsDiagnostics()", function () {
                var errors = _this.languageService.getCompilerOptionsDiagnostics();
                return errors.map(function (d) { return _this.realizeDiagnosticWithFileName(d); });
            });
        };
        /// QUICKINFO
        /// Computes a string representation of the type at the requested position
        /// in the active file.
        LanguageServiceShimObject.prototype.getQuickInfoAtPosition = function (fileName, position) {
            var _this = this;
            return this.forwardJSONCall("getQuickInfoAtPosition('" + fileName + "', " + position + ")", function () {
                var quickInfo = _this.languageService.getQuickInfoAtPosition(fileName, position);
                return quickInfo;
            });
        };
        LanguageServiceShimObject.prototype.getTypeAtPosition = function (fileName, position) {
            var _this = this;
            return this.forwardJSONCall("getTypeAtPosition('" + fileName + "', " + position + ")", function () {
                var typeInfo = _this.languageService.getTypeAtPosition(fileName, position);
                return typeInfo;
            });
        };
        /// NAMEORDOTTEDNAMESPAN
        /// Computes span information of the name or dotted name at the requested position
        // in the active file.
        LanguageServiceShimObject.prototype.getNameOrDottedNameSpan = function (fileName, startPos, endPos) {
            var _this = this;
            return this.forwardJSONCall("getNameOrDottedNameSpan('" + fileName + "', " + startPos + ", " + endPos + ")", function () {
                var spanInfo = _this.languageService.getNameOrDottedNameSpan(fileName, startPos, endPos);
                return spanInfo;
            });
        };
        /// STATEMENTSPAN
        /// Computes span information of statement at the requested position in the active file.
        LanguageServiceShimObject.prototype.getBreakpointStatementAtPosition = function (fileName, position) {
            var _this = this;
            return this.forwardJSONCall("getBreakpointStatementAtPosition('" + fileName + "', " + position + ")", function () {
                var spanInfo = _this.languageService.getBreakpointStatementAtPosition(fileName, position);
                return spanInfo;
            });
        };
        /// SIGNATUREHELP
        LanguageServiceShimObject.prototype.getSignatureHelpItems = function (fileName, position) {
            var _this = this;
            return this.forwardJSONCall("getSignatureHelpItems('" + fileName + "', " + position + ")", function () {
                var signatureInfo = _this.languageService.getSignatureHelpItems(fileName, position);
                return signatureInfo;
            });
        };
        LanguageServiceShimObject.prototype.getSignatureHelpCurrentArgumentState = function (fileName, position, applicableSpanStart) {
            var _this = this;
            return this.forwardJSONCall("getSignatureHelpCurrentArgumentState('" + fileName + "', " + position + ", " + applicableSpanStart + ")", function () {
                var signatureInfo = _this.languageService.getSignatureHelpItems(fileName, position);
                return signatureInfo;
            });
        };
        /// GOTO DEFINITION
        /// Computes the definition location and file for the symbol
        /// at the requested position.
        LanguageServiceShimObject.prototype.getDefinitionAtPosition = function (fileName, position) {
            var _this = this;
            return this.forwardJSONCall("getDefinitionAtPosition('" + fileName + "', " + position + ")", function () {
                return _this.languageService.getDefinitionAtPosition(fileName, position);
            });
        };
        LanguageServiceShimObject.prototype.getRenameInfo = function (fileName, position) {
            var _this = this;
            return this.forwardJSONCall("getRenameInfo('" + fileName + "', " + position + ")", function () {
                return _this.languageService.getRenameInfo(fileName, position);
            });
        };
        /// GET BRACE MATCHING
        LanguageServiceShimObject.prototype.getBraceMatchingAtPosition = function (fileName, position) {
            var _this = this;
            return this.forwardJSONCall("getBraceMatchingAtPosition('" + fileName + "', " + position + ")", function () {
                var textRanges = _this.languageService.getBraceMatchingAtPosition(fileName, position);
                return textRanges;
            });
        };
        /// GET SMART INDENT
        LanguageServiceShimObject.prototype.getIndentationAtPosition = function (fileName, position, options /*Services.EditorOptions*/) {
            var _this = this;
            return this.forwardJSONCall("getIndentationAtPosition('" + fileName + "', " + position + ")", function () {
                var localOptions = JSON.parse(options);
                return _this.languageService.getIndentationAtPosition(fileName, position, localOptions);
            });
        };
        /// GET REFERENCES
        ///  Return references to a symbol at the requested position.
        ///  References are separated by "\n".
        ///  Each reference is a "fileindex min lim" sub-string.
        LanguageServiceShimObject.prototype.getReferencesAtPosition = function (fileName, position) {
            var _this = this;
            return this.forwardJSONCall("getReferencesAtPosition('" + fileName + "', " + position + ")", function () {
                return _this.languageService.getReferencesAtPosition(fileName, position);
            });
        };
        LanguageServiceShimObject.prototype.getOccurrencesAtPosition = function (fileName, position) {
            var _this = this;
            return this.forwardJSONCall("getOccurrencesAtPosition('" + fileName + "', " + position + ")", function () {
                return _this.languageService.getOccurrencesAtPosition(fileName, position);
            });
        };
        /// GET IMPLEMENTORS
        LanguageServiceShimObject.prototype.getImplementorsAtPosition = function (fileName, position) {
            var _this = this;
            return this.forwardJSONCall("getImplementorsAtPosition('" + fileName + "', " + position + ")", function () {
                return _this.languageService.getImplementorsAtPosition(fileName, position);
            });
        };
        /// COMPLETION LISTS
        /// Get a string based representation of the completions
        /// to provide at the given source position and providing a member completion
        /// list if requested.
        LanguageServiceShimObject.prototype.getCompletionsAtPosition = function (fileName, position, isMemberCompletion) {
            var _this = this;
            return this.forwardJSONCall("getCompletionsAtPosition('" + fileName + "', " + position + ", " + isMemberCompletion + ")", function () {
                var completion = _this.languageService.getCompletionsAtPosition(fileName, position, isMemberCompletion);
                return completion;
            });
        };
        /// Get a string based representation of a completion list entry details
        LanguageServiceShimObject.prototype.getCompletionEntryDetails = function (fileName, position, entryName) {
            var _this = this;
            return this.forwardJSONCall("getCompletionEntryDetails('" + fileName + "', " + position + ", " + entryName + ")", function () {
                var details = _this.languageService.getCompletionEntryDetails(fileName, position, entryName);
                return details;
            });
        };
        LanguageServiceShimObject.prototype.getFormattingEditsForRange = function (fileName, start, end, options /*Services.FormatCodeOptions*/) {
            var _this = this;
            return this.forwardJSONCall("getFormattingEditsForRange('" + fileName + "', " + start + ", " + end + ")", function () {
                var localOptions = JSON.parse(options);
                var edits = _this.languageService.getFormattingEditsForRange(fileName, start, end, localOptions);
                return edits;
            });
        };
        LanguageServiceShimObject.prototype.getFormattingEditsForDocument = function (fileName, options /*Services.FormatCodeOptions*/) {
            var _this = this;
            return this.forwardJSONCall("getFormattingEditsForDocument('" + fileName + "')", function () {
                var localOptions = JSON.parse(options);
                var edits = _this.languageService.getFormattingEditsForDocument(fileName, localOptions);
                return edits;
            });
        };
        LanguageServiceShimObject.prototype.getFormattingEditsAfterKeystroke = function (fileName, position, key, options /*Services.FormatCodeOptions*/) {
            var _this = this;
            return this.forwardJSONCall("getFormattingEditsAfterKeystroke('" + fileName + "', " + position + ", '" + key + "')", function () {
                var localOptions = JSON.parse(options);
                var edits = _this.languageService.getFormattingEditsAfterKeystroke(fileName, position, key, localOptions);
                return edits;
            });
        };
        /// NAVIGATE TO
        ///  Return a list of symbols that are interesting to navigate to
        LanguageServiceShimObject.prototype.getNavigateToItems = function (searchValue) {
            var _this = this;
            return this.forwardJSONCall("getNavigateToItems('" + searchValue + "')", function () {
                var items = _this.languageService.getNavigateToItems(searchValue);
                return items;
            });
        };
        LanguageServiceShimObject.prototype.getNavigationBarItems = function (fileName) {
            var _this = this;
            return this.forwardJSONCall("getNavigationBarItems('" + fileName + "')", function () {
                var items = _this.languageService.getNavigationBarItems(fileName);
                return items;
            });
        };
        LanguageServiceShimObject.prototype.getOutliningSpans = function (fileName) {
            var _this = this;
            return this.forwardJSONCall("getOutliningSpans('" + fileName + "')", function () {
                var items = _this.languageService.getOutliningSpans(fileName);
                return items;
            });
        };
        LanguageServiceShimObject.prototype.getTodoComments = function (fileName, descriptors) {
            var _this = this;
            return this.forwardJSONCall("getTodoComments('" + fileName + "')", function () {
                var items = _this.languageService.getTodoComments(fileName, JSON.parse(descriptors));
                return items;
            });
        };
        /// Emit
        LanguageServiceShimObject.prototype.getEmitOutput = function (fileName) {
            var _this = this;
            return this.forwardJSONCall("getEmitOutput('" + fileName + "')", function () {
                var output = _this.languageService.getEmitOutput(fileName);
                return output;
            });
        };
        return LanguageServiceShimObject;
    })(ShimBase);
    var ClassifierShimObject = (function (_super) {
        __extends(ClassifierShimObject, _super);
        function ClassifierShimObject(factory, logger) {
            _super.call(this, factory);
            this.logger = logger;
            this.classifier = ts.createClassifier(this.logger);
        }
        /// COLORIZATION
        ClassifierShimObject.prototype.getClassificationsForLine = function (text, lexState) {
            var classification = this.classifier.getClassificationsForLine(text, lexState);
            var items = classification.entries;
            var result = "";
            for (var i = 0; i < items.length; i++) {
                result += items[i].length + "\n";
                result += items[i].classification + "\n";
            }
            result += classification.finalLexState;
            return result;
        };
        return ClassifierShimObject;
    })(ShimBase);
    var CoreServicesShimObject = (function (_super) {
        __extends(CoreServicesShimObject, _super);
        function CoreServicesShimObject(factory, logger) {
            _super.call(this, factory);
            this.logger = logger;
        }
        CoreServicesShimObject.prototype.forwardJSONCall = function (actionDescription, action) {
            return forwardJSONCall(this.logger, actionDescription, action);
        };
        ///
        /// getPreProcessedFileInfo
        ///
        CoreServicesShimObject.prototype.getPreProcessedFileInfo = function (fileName, sourceText) {
            return this.forwardJSONCall("getPreProcessedFileInfo('" + fileName + "')", function () {
                var result = TypeScript.preProcessFile(fileName, sourceText);
                return result;
            });
        };
        ///
        /// getDefaultCompilationSettings
        ///
        CoreServicesShimObject.prototype.getDefaultCompilationSettings = function () {
            return this.forwardJSONCall("getDefaultCompilationSettings()", function () {
                return compilerOptionsToCompilationSettings(ts.getDefaultCompilerOptions());
            });
        };
        return CoreServicesShimObject;
    })(ShimBase);
    var TypeScriptServicesFactory = (function () {
        function TypeScriptServicesFactory() {
            this._shims = [];
            this.documentRegistry = ts.createDocumentRegistry();
        }
        TypeScriptServicesFactory.prototype.createLanguageServiceShim = function (host) {
            try {
                var hostAdapter = new LanguageServiceShimHostAdapter(host);
                var languageService = ts.createLanguageService(hostAdapter, this.documentRegistry);
                return new LanguageServiceShimObject(this, host, languageService);
            }
            catch (err) {
                logInternalError(host, err);
                throw err;
            }
        };
        TypeScriptServicesFactory.prototype.createClassifierShim = function (logger) {
            try {
                return new ClassifierShimObject(this, logger);
            }
            catch (err) {
                logInternalError(logger, err);
                throw err;
            }
        };
        TypeScriptServicesFactory.prototype.createCoreServicesShim = function (logger) {
            try {
                return new CoreServicesShimObject(this, logger);
            }
            catch (err) {
                logInternalError(logger, err);
                throw err;
            }
        };
        TypeScriptServicesFactory.prototype.close = function () {
            // Forget all the registered shims
            this._shims = [];
            this.documentRegistry = ts.createDocumentRegistry();
        };
        TypeScriptServicesFactory.prototype.registerShim = function (shim) {
            this._shims.push(shim);
        };
        TypeScriptServicesFactory.prototype.unregisterShim = function (shim) {
            for (var i = 0, n = this._shims.length; i < n; i++) {
                if (this._shims[i] === shim) {
                    delete this._shims[i];
                    return;
                }
            }
            throw TypeScript.Errors.invalidOperation();
        };
        return TypeScriptServicesFactory;
    })();
    ts.TypeScriptServicesFactory = TypeScriptServicesFactory;
})(ts || (ts = {}));
/// TODO: this is used by VS, clean this up on both sides of the interface
var TypeScript;
(function (TypeScript) {
    var Services;
    (function (Services) {
        Services.TypeScriptServicesFactory = ts.TypeScriptServicesFactory;
    })(Services = TypeScript.Services || (TypeScript.Services = {}));
})(TypeScript || (TypeScript = {}));
